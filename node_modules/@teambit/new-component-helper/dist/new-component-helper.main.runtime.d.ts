import { Component } from '@teambit/component';
import { ComponentID } from '@teambit/component-id';
import { Harmony } from '@teambit/harmony';
import { PathLinuxRelative } from '@teambit/legacy/dist/utils/path';
import { Workspace } from '@teambit/workspace';
export declare class NewComponentHelperMain {
    private workspace;
    private harmony;
    constructor(workspace: Workspace, harmony: Harmony);
    /**
     * when creating/forking a component, the user provides the new name and optionally the scope/namespace.
     * from this user input, create a ComponentID.
     */
    getNewComponentId(name: string, namespace?: string, scope?: string): ComponentID;
    /**
     * when creating/forking a component, the user may or may not provide a path.
     * if not provided, generate the path based on the component-id.
     * the component will be written to that path.
     */
    getNewComponentPath(componentId: ComponentID, pathFromUser?: string): PathLinuxRelative;
    writeAndAddNewComp(comp: Component, targetId: ComponentID, options?: {
        path?: string;
        scope?: string;
    }, config?: {
        [aspectName: string]: any;
    }): Promise<void>;
    private throwForExistingPath;
    getConfigFromExistingToNewComponent(comp: Component): Promise<{}>;
    static slots: never[];
    static dependencies: import("@teambit/harmony").Aspect[];
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static provider([workspace]: [Workspace], config: any, _: any, harmony: Harmony): Promise<NewComponentHelperMain>;
}
export interface CloneConfig {
    readonly shouldPreserveConfigForClonedComponent?: boolean;
}
