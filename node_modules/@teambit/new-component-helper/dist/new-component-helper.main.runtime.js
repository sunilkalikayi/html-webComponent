"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NewComponentHelperMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");
  _legacyBitId = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _composeComponentPath() {
  const data = require("@teambit/legacy/dist/utils/bit/compose-component-path");
  _composeComponentPath = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@teambit/legacy/dist/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _componentId() {
  const data = require("@teambit/component-id");
  _componentId = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _newComponentHelper() {
  const data = require("./new-component-helper.aspect");
  _newComponentHelper = function () {
    return data;
  };
  return data;
}
class NewComponentHelperMain {
  constructor(workspace, harmony) {
    this.workspace = workspace;
    this.harmony = harmony;
  }
  /**
   * when creating/forking a component, the user provides the new name and optionally the scope/namespace.
   * from this user input, create a ComponentID.
   */
  getNewComponentId(name, namespace, scope) {
    scope = scope || this.workspace.defaultScope;
    if (!(0, _legacyBitId().isValidScopeName)(scope)) {
      throw new (_legacyBitId().InvalidScopeName)(scope);
    }
    if (!scope) throw new (_bitError().BitError)(`failed finding defaultScope`);
    const fullComponentName = namespace ? `${namespace}/${name}` : name;
    return _componentId().ComponentID.fromObject({
      name: fullComponentName
    }, scope);
  }

  /**
   * when creating/forking a component, the user may or may not provide a path.
   * if not provided, generate the path based on the component-id.
   * the component will be written to that path.
   */
  getNewComponentPath(componentId, pathFromUser) {
    if (pathFromUser) return pathFromUser;
    return (0, _composeComponentPath().composeComponentPath)(componentId._legacy.changeScope(componentId.scope), this.workspace.defaultDirectory);
  }
  async writeAndAddNewComp(comp, targetId, options, config) {
    const targetPath = this.getNewComponentPath(targetId, options === null || options === void 0 ? void 0 : options.path);
    await this.throwForExistingPath(targetPath);
    await this.workspace.write(comp, targetPath);
    try {
      await this.workspace.track({
        rootDir: targetPath,
        componentName: targetId.fullName,
        mainFile: comp.state._consumer.mainFile,
        defaultScope: options === null || options === void 0 ? void 0 : options.scope,
        config
      });
    } catch (err) {
      await _fsExtra().default.remove(targetPath);
      throw err;
    }
    await this.workspace.bitMap.write();
    this.workspace.clearCache();
    // this takes care of compiling the component as well
    await this.workspace.triggerOnComponentAdd(targetId);
  }
  async throwForExistingPath(targetPath) {
    try {
      const stat = await _fsExtra().default.stat(targetPath);
      if (!stat.isDirectory()) {
        throw new (_bitError().BitError)(`unable to create component at "${targetPath}", this path already exists`);
      }
      const isEmpty = await (0, _utils().isDirEmpty)(targetPath);
      if (!isEmpty) {
        throw new (_bitError().BitError)(`unable to create component at "${targetPath}", this directory is not empty`);
      }
    } catch (err) {
      if (err.code === 'ENOENT') {
        return;
      }
      throw err;
    }
  }
  async getConfigFromExistingToNewComponent(comp) {
    const aspectIds = comp.state.aspects.entries.map(e => e.id.toString());
    await this.workspace.loadAspects(aspectIds, undefined, 'new-component-helper.getConfigFromExistingToNewComponent');
    const fromExisting = {};
    comp.state.aspects.entries.forEach(entry => {
      if (!entry.config) return;
      const aspectId = entry.id.toString();
      const aspect = this.harmony.get(aspectId);
      if (!aspect) throw new Error(`error: unable to get "${aspectId}" aspect from Harmony`);
      if ('shouldPreserveConfigForClonedComponent' in aspect && aspect.shouldPreserveConfigForClonedComponent === false) {
        return;
      }
      fromExisting[aspectId] = entry.config;
    });
    return fromExisting;
  }
  static async provider([workspace], config, _, harmony) {
    return new NewComponentHelperMain(workspace, harmony);
  }
}
exports.NewComponentHelperMain = NewComponentHelperMain;
(0, _defineProperty2().default)(NewComponentHelperMain, "slots", []);
(0, _defineProperty2().default)(NewComponentHelperMain, "dependencies", [_workspace().default]);
(0, _defineProperty2().default)(NewComponentHelperMain, "runtime", _cli().MainRuntime);
_newComponentHelper().NewComponentHelperAspect.addRuntime(NewComponentHelperMain);

//# sourceMappingURL=new-component-helper.main.runtime.js.map