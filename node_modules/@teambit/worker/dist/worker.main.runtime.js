"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkerMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _pkg() {
  const data = require("@teambit/pkg");
  _pkg = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _worker() {
  const data = require("./worker.aspect");
  _worker = function () {
    return data;
  };
  return data;
}
function _harmonyWorker() {
  const data = require("./harmony-worker");
  _harmonyWorker = function () {
    return data;
  };
  return data;
}
class WorkerMain {
  constructor(workerSlot, componentAspect, pkg, workerNameSlot) {
    this.workerSlot = workerSlot;
    this.componentAspect = componentAspect;
    this.pkg = pkg;
    this.workerNameSlot = workerNameSlot;
  }
  listWorkers() {
    return this.workerSlot.values();
  }

  /**
   * create a new worker.
   */
  async declareWorker(name, path) {
    this.workerNameSlot.register(name);
    const maybeAspectId = this.workerNameSlot.toArray().find(([, workerName]) => {
      return workerName === name;
    });
    if (!maybeAspectId) throw new Error(`could not create a worker ${name}`);
    // const scriptPath = path || await this.resolveWorkerScript(name, aspectId);
    const scriptPath = path;
    const systemWorker = new (_harmonyWorker().HarmonyWorker)(name, scriptPath);
    this.workerSlot.register(systemWorker);
    return systemWorker;
  }
  async resolveWorkerScript(name, aspectId) {
    const host = this.componentAspect.getHost();
    const id = await host.resolveComponentId(aspectId);
    const component = await host.get(id);
    if (!component) throw new Error(`[worker] could not resolve component for aspect ID: ${aspectId}`);
    const packageName = this.pkg.getPackageName(component);
    // const workerFile = component.state.filesystem.files.find((file) => file.relative.includes(`${name}.worker`));
    // if (!workerFile) throw new Error(`[worker] aspect declaring a worker must contain a ${name}.worker. file`);
    return require.resolve((0, _path().join)(packageName, 'dist', `${name}.worker.js`));
  }
  getWorker(id) {
    return this.workerSlot.get(id);
  }
  static async provider([componentAspect, pkg], config, [workerSlot, workerNameSlot]) {
    return new WorkerMain(workerSlot, componentAspect, pkg, workerNameSlot);
  }
}
exports.WorkerMain = WorkerMain;
(0, _defineProperty2().default)(WorkerMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(WorkerMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(WorkerMain, "dependencies", [_component().ComponentAspect, _pkg().PkgAspect]);
_worker().WorkerAspect.addRuntime(WorkerMain);

//# sourceMappingURL=worker.main.runtime.js.map