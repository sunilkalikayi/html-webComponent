"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompileCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _prettyTime() {
  const data = _interopRequireDefault(require("pretty-time"));
  _prettyTime = function () {
    return data;
  };
  return data;
}
function _outputFormatter() {
  const data = require("./output-formatter");
  _outputFormatter = function () {
    return data;
  };
  return data;
}
function _types() {
  const data = require("./types");
  _types = function () {
    return data;
  };
  return data;
}
function _compiler() {
  const data = require("./compiler.aspect");
  _compiler = function () {
    return data;
  };
  return data;
}
function _events() {
  const data = require("./events");
  _events = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class CompileCmd {
  constructor(compile, logger, pubsub) {
    this.compile = compile;
    this.logger = logger;
    this.pubsub = pubsub;
    (0, _defineProperty2().default)(this, "componentsStatus", []);
    (0, _defineProperty2().default)(this, "name", 'compile [component-names...]');
    (0, _defineProperty2().default)(this, "description", 'compile components in the workspace');
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'component-names...',
      description: 'a list of component names or component IDs (defaults to all components)'
    }]);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "options", [['c', 'changed', 'compile only new and modified components'], ['v', 'verbose', 'show more data, such as, dist paths'], ['j', 'json', 'return the compile results in json format'], ['d', 'delete-dist-dir', 'delete existing dist folder before writing new compiled files']]);
  }
  async report([components = []], compilerOptions) {
    const startTimestamp = process.hrtime();
    this.logger.setStatusLine('Compiling your components, hold tight.');
    this.pubsub.sub(_compiler().CompilerAspect.id, this.onComponentCompilationDone.bind(this));
    let outputString = '';
    await this.compile.compileComponents(components, _objectSpread(_objectSpread({}, compilerOptions), {}, {
      initiator: _types().CompilationInitiator.CmdReport
    }));
    const compileTimeLength = process.hrtime(startTimestamp);
    outputString += '\n';
    outputString += `  ${_chalk().default.underline('STATUS')}\t${_chalk().default.underline('COMPONENT ID')}\n`;
    outputString += (0, _outputFormatter().formatCompileResults)(this.componentsStatus, !!compilerOptions.verbose);
    outputString += '\n';
    outputString += this.getStatusLine(this.componentsStatus, compileTimeLength);
    this.logger.clearStatusLine();
    return {
      data: outputString,
      code: this.getExitCode(this.componentsStatus)
    };
  }
  async json([components], compilerOptions) {
    compilerOptions.deleteDistDir = true;
    // @ts-ignore
    const compileResults = await this.compile.compileComponents(components, _objectSpread(_objectSpread({}, compilerOptions), {}, {
      initiator: _types().CompilationInitiator.CmdJson
    }));
    return {
      data: compileResults,
      // @todo: fix the code once compile is ready.
      code: 0
    };
  }
  failedComponents(componentsStatus) {
    return componentsStatus.filter(component => component.errors.length);
  }
  getSummaryIcon(componentsStatus) {
    switch (this.failedComponents(componentsStatus).length) {
      case 0:
        return _chalk().default.green('✔');
      case componentsStatus.length:
        return _chalk().default.red('✗');
      default:
        return _chalk().default.yellow('⍻');
    }
  }
  getExitCode(componentsStatus) {
    return this.failedComponents(componentsStatus).length ? 1 : 0;
  }
  getStatusLine(componentsStatus, compileTimeLength) {
    const numberOfComponents = componentsStatus.length;
    const numberOfFailingComponents = this.failedComponents(componentsStatus).length;
    const numberOfSuccessfulComponents = componentsStatus.filter(component => !component.errors.length).length;
    const icon = this.getSummaryIcon(componentsStatus);
    const summaryLine = numberOfFailingComponents ? `${icon} ${numberOfFailingComponents}/${numberOfComponents} components failed to compile.` : `${icon} ${numberOfSuccessfulComponents}/${numberOfComponents} components compiled successfully.`;
    return `${summaryLine}\nFinished. (${(0, _prettyTime().default)(compileTimeLength)})`;
  }
  onComponentCompilationDone(event) {
    if (event.type === _events().ComponentCompilationOnDoneEvent.TYPE) {
      this.componentsStatus.push(event.data);
    }
  }
}
exports.CompileCmd = CompileCmd;

//# sourceMappingURL=compiler.cmd.js.map