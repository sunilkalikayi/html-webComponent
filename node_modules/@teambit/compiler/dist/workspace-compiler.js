"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkspaceCompiler = exports.ComponentCompiler = void 0;
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _sources() {
  const data = require("@teambit/legacy/dist/consumer/component/sources");
  _sources = function () {
    return data;
  };
  return data;
}
function _dataToPersist() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/sources/data-to-persist"));
  _dataToPersist = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/bit/component-id-to-package-name"));
  _componentIdToPackageName = function () {
    return data;
  };
  return data;
}
function _removePath() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/sources/remove-path"));
  _removePath = function () {
    return data;
  };
  return data;
}
function _compiler() {
  const data = require("./compiler.aspect");
  _compiler = function () {
    return data;
  };
  return data;
}
function _events() {
  const data = require("./events");
  _events = function () {
    return data;
  };
  return data;
}
function _types() {
  const data = require("./types");
  _types = function () {
    return data;
  };
  return data;
}
/* eslint-disable max-classes-per-file */

class ComponentCompiler {
  constructor(pubsub, workspace, component, compilerInstance, compilerId, logger, dependencyResolver, dists = [], compileErrors = []) {
    this.pubsub = pubsub;
    this.workspace = workspace;
    this.component = component;
    this.compilerInstance = compilerInstance;
    this.compilerId = compilerId;
    this.logger = logger;
    this.dependencyResolver = dependencyResolver;
    this.dists = dists;
    this.compileErrors = compileErrors;
  }
  async compile(noThrow = true, options) {
    var _options$deleteDistDi;
    let dataToPersist;
    const deleteDistDir = (_options$deleteDistDi = options.deleteDistDir) !== null && _options$deleteDistDi !== void 0 ? _options$deleteDistDi : this.compilerInstance.deleteDistDir;
    // delete dist folder before transpilation (because some compilers (like ngPackagr) can generate files there during the compilation process)
    if (deleteDistDir) {
      dataToPersist = new (_dataToPersist().default)();
      for (const distDir of await this.distDirs()) {
        dataToPersist.removePath(new (_removePath().default)(distDir));
      }
      dataToPersist.addBasePath(this.workspace.path);
      await dataToPersist.persistAllToFS();
    }
    const compilers = this.compilerInstance.compilers ? this.compilerInstance.compilers : [this.compilerInstance];
    const canTranspileFile = compilers.find(c => c.transpileFile);
    const canTranspileComponent = compilers.find(c => c.transpileComponent);
    if (canTranspileFile) {
      await Promise.all(this.component.filesystem.files.map(file => this.compileOneFile(file, options.initiator)));
    }
    if (canTranspileComponent) {
      await this.compileAllFiles(this.component, options.initiator);
    }
    if (!canTranspileFile && !canTranspileComponent) {
      throw new Error(`compiler ${this.compilerId.toString()} doesn't implement either "transpileFile" or "transpileComponent" methods`);
    }
    this.throwOnCompileErrors(noThrow);

    // writing the dists with `component.setDists(dists); component.dists.writeDists` is tricky
    // as it uses other base-paths and doesn't respect the new node-modules base path.
    dataToPersist = new (_dataToPersist().default)();
    dataToPersist.addManyFiles(this.dists);
    dataToPersist.addBasePath(this.workspace.path);
    await dataToPersist.persistAllToFS();
    const buildResults = this.dists.map(distFile => distFile.path);
    if (this.component.state._consumer.compiler) _loader().default.succeed();
    this.pubsub.pub(_compiler().CompilerAspect.id, new (_events().ComponentCompilationOnDoneEvent)(this.compileErrors, this.component, buildResults));
    return {
      component: this.component.id.toString(),
      buildResults
    };
  }
  throwOnCompileErrors(noThrow = true) {
    if (this.compileErrors.length) {
      this.compileErrors.forEach(errorItem => {
        this.logger.error(`compilation error at ${errorItem.path}`, errorItem.error);
      });
      const formatError = errorItem => `${errorItem.path}\n${errorItem.error}`;
      const err = new Error(`compilation failed. see the following errors from the compiler
${this.compileErrors.map(formatError).join('\n')}`);
      this.pubsub.pub(_compiler().CompilerAspect.id, new (_events().CompilerErrorEvent)(err));
      if (!noThrow) {
        throw err;
      }
      this.logger.console(err.message);
    }
  }
  async distDirs() {
    var _this$compilerInstanc, _this$compilerInstanc2;
    const packageName = (0, _componentIdToPackageName().default)(this.component.state._consumer);
    const packageDir = _path().default.join('node_modules', packageName);
    const distDirName = ((_this$compilerInstanc = (_this$compilerInstanc2 = this.compilerInstance).getDistDir) === null || _this$compilerInstanc === void 0 ? void 0 : _this$compilerInstanc.call(_this$compilerInstanc2)) || _constants().DEFAULT_DIST_DIRNAME;
    const injectedDirs = await this.getInjectedDirs(packageName);
    return [packageDir, ...injectedDirs].map(dist => _path().default.join(dist, distDirName));
  }
  async getInjectedDirs(packageName) {
    const relativeCompDir = this.workspace.componentDir(this.component.id, undefined, {
      relative: true
    });
    return this.dependencyResolver.getInjectedDirs(this.workspace.path, relativeCompDir, packageName);
  }
  get componentDir() {
    return this.workspace.componentDir(this.component.id);
  }
  async compileOneFile(file, initiator) {
    const options = {
      componentDir: this.componentDir,
      filePath: file.relative,
      initiator
    };
    const isFileSupported = this.compilerInstance.isFileSupported(file.path);
    let compileResults;
    if (isFileSupported) {
      try {
        var _this$compilerInstanc3, _this$compilerInstanc4;
        compileResults = (_this$compilerInstanc3 = (_this$compilerInstanc4 = this.compilerInstance).transpileFile) === null || _this$compilerInstanc3 === void 0 ? void 0 : _this$compilerInstanc3.call(_this$compilerInstanc4, file.contents.toString(), options);
      } catch (error) {
        this.compileErrors.push({
          path: file.path,
          error
        });
        return;
      }
    }
    for (const base of await this.distDirs()) {
      if (isFileSupported && compileResults) {
        this.dists.push(...compileResults.map(result => new (_sources().Dist)({
          base,
          path: _path().default.join(base, result.outputPath),
          contents: Buffer.from(result.outputText)
        })));
      } else if (this.compilerInstance.shouldCopyNonSupportedFiles) {
        // compiler doesn't support this file type. copy the file as is to the dist dir.
        this.dists.push(new (_sources().Dist)({
          base,
          path: _path().default.join(base, file.relative),
          contents: file.contents
        }));
      }
    }
  }
  async compileAllFiles(component, initiator) {
    const filesToCompile = [];
    for (const base of await this.distDirs()) {
      component.filesystem.files.forEach(file => {
        const isFileSupported = this.compilerInstance.isFileSupported(file.path);
        if (isFileSupported) {
          filesToCompile.push(file);
        } else if (this.compilerInstance.shouldCopyNonSupportedFiles) {
          // compiler doesn't support this file type. copy the file as is to the dist dir.
          this.dists.push(new (_sources().Dist)({
            base,
            path: _path().default.join(base, file.relative),
            contents: file.contents
          }));
        }
      });
    }
    if (filesToCompile.length) {
      try {
        var _this$compilerInstanc5, _this$compilerInstanc6;
        await ((_this$compilerInstanc5 = (_this$compilerInstanc6 = this.compilerInstance).transpileComponent) === null || _this$compilerInstanc5 === void 0 ? void 0 : _this$compilerInstanc5.call(_this$compilerInstanc6, {
          component,
          componentDir: this.componentDir,
          outputDir: this.workspace.getComponentPackagePath(component),
          initiator
        }));
      } catch (error) {
        this.compileErrors.push({
          path: this.componentDir,
          error
        });
      }
    }
  }
}
exports.ComponentCompiler = ComponentCompiler;
class WorkspaceCompiler {
  constructor(workspace, envs, pubsub, aspectLoader, ui, logger, dependencyResolver) {
    this.workspace = workspace;
    this.envs = envs;
    this.pubsub = pubsub;
    this.aspectLoader = aspectLoader;
    this.ui = ui;
    this.logger = logger;
    this.dependencyResolver = dependencyResolver;
    if (this.workspace) {
      this.workspace.registerOnComponentChange(this.onComponentChange.bind(this));
      this.workspace.registerOnComponentAdd(this.onComponentChange.bind(this));
      this.workspace.registerOnPreWatch(this.onPreWatch.bind(this));
      this.ui.registerPreStart(this.onPreStart.bind(this));
    }
    if (this.aspectLoader) {
      this.aspectLoader.registerOnAspectLoadErrorSlot(this.onAspectLoadFail.bind(this));
    }
  }
  async onPreStart(preStartOpts) {
    if (preStartOpts.skipCompilation) {
      return;
    }
    await this.compileComponents([], {
      changed: true,
      verbose: false,
      deleteDistDir: false,
      initiator: _types().CompilationInitiator.PreStart
    });
  }
  async onAspectLoadFail(err, id) {
    if (err.code && err.code === 'MODULE_NOT_FOUND' && this.workspace) {
      await this.compileComponents([id.toString()], {
        initiator: _types().CompilationInitiator.AspectLoadFail
      }, true);
      return true;
    }
    return false;
  }
  async onComponentChange(component, files, initiator) {
    const buildResults = await this.compileComponents([component.id.toString()], {
      initiator: initiator || _types().CompilationInitiator.ComponentChanged
    }, true);
    return {
      results: buildResults,
      toString() {
        var _buildResults$, _buildResults$$buildR;
        return `${(_buildResults$ = buildResults[0]) === null || _buildResults$ === void 0 ? void 0 : (_buildResults$$buildR = _buildResults$.buildResults) === null || _buildResults$$buildR === void 0 ? void 0 : _buildResults$$buildR.join('\n\t')}`;
      }
    };
  }
  async onPreWatch(components, watchOpts) {
    if (watchOpts.preCompile) {
      const start = Date.now();
      this.logger.console(`compiling ${components.length} components`);
      await this.compileComponents(components.map(c => c.id._legacy), {
        initiator: _types().CompilationInitiator.PreWatch
      });
      const end = Date.now() - start;
      this.logger.consoleSuccess(`compiled ${components.length} components successfully (${end / 1000} sec)`);
    }
  }
  async compileComponents(componentsIds,
  // when empty, it compiles new+modified (unless options.all is set),
  options, noThrow) {
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    const componentIds = await this.getIdsToCompile(componentsIds, options.changed);
    const components = await this.workspace.getMany(componentIds);
    const componentsCompilers = [];
    components.forEach(c => {
      var _environment$getCompi, _c$state$_consumer$co;
      const environment = this.envs.getEnv(c).env;
      const compilerInstance = (_environment$getCompi = environment.getCompiler) === null || _environment$getCompi === void 0 ? void 0 : _environment$getCompi.call(environment);
      // if there is no componentDir (e.g. author that added files, not dir), then we can't write the dists
      // inside the component dir.
      if (compilerInstance && (_c$state$_consumer$co = c.state._consumer.componentMap) !== null && _c$state$_consumer$co !== void 0 && _c$state$_consumer$co.getComponentDir()) {
        const compilerName = compilerInstance.constructor.name || 'compiler';
        componentsCompilers.push(new ComponentCompiler(this.pubsub, this.workspace, c, compilerInstance, compilerName, this.logger, this.dependencyResolver));
      }
    });
    const resultOnWorkspace = await (0, _pMapSeries().default)(componentsCompilers, componentCompiler => componentCompiler.compile(noThrow, options));
    return resultOnWorkspace;
  }
  async getIdsToCompile(componentsIds, changed = false) {
    if (componentsIds.length) {
      return this.workspace.resolveMultipleComponentIds(componentsIds);
    }
    if (changed) {
      return this.workspace.getNewAndModifiedIds();
    }
    return this.workspace.getAllComponentIds();
  }
}
exports.WorkspaceCompiler = WorkspaceCompiler;

//# sourceMappingURL=workspace-compiler.js.map