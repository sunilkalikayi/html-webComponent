"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CompilerMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _aspectLoader() {
  const data = _interopRequireDefault(require("@teambit/aspect-loader"));
  _aspectLoader = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("@teambit/builder");
  _builder = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _componentIssues() {
  const data = require("@teambit/component-issues");
  _componentIssues = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = require("@teambit/envs");
  _envs = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _manyComponentsWriter() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/many-components-writer"));
  _manyComponentsWriter = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _generator() {
  const data = require("@teambit/generator");
  _generator = function () {
    return data;
  };
  return data;
}
function _pubsub() {
  const data = require("@teambit/pubsub");
  _pubsub = function () {
    return data;
  };
  return data;
}
function _ui() {
  const data = _interopRequireDefault(require("@teambit/ui"));
  _ui = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = require("@teambit/workspace");
  _workspace = function () {
    return data;
  };
  return data;
}
function _compiler() {
  const data = require("./compiler.aspect");
  _compiler = function () {
    return data;
  };
  return data;
}
function _compiler2() {
  const data = require("./compiler.cmd");
  _compiler2 = function () {
    return data;
  };
  return data;
}
function _compiler3() {
  const data = require("./compiler.service");
  _compiler3 = function () {
    return data;
  };
  return data;
}
function _compiler4() {
  const data = require("./compiler.task");
  _compiler4 = function () {
    return data;
  };
  return data;
}
function _distArtifact() {
  const data = require("./dist-artifact");
  _distArtifact = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _types() {
  const data = require("./types");
  _types = function () {
    return data;
  };
  return data;
}
function _workspaceCompiler() {
  const data = require("./workspace-compiler");
  _workspaceCompiler = function () {
    return data;
  };
  return data;
}
function _compiler5() {
  const data = require("./templates/compiler");
  _compiler5 = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class CompilerMain {
  constructor(pubsub, workspaceCompiler, envs, builder, workspace, dependencyResolver) {
    this.pubsub = pubsub;
    this.workspaceCompiler = workspaceCompiler;
    this.envs = envs;
    this.builder = builder;
    this.workspace = workspace;
    this.dependencyResolver = dependencyResolver;
  }

  /**
   * Run compilation on `bit new` and when new components are imported
   */
  compileOnWorkspace(componentsIds = [],
  // when empty, it compiles all
  options = {
    initiator: _types().CompilationInitiator.ComponentAdded
  }) {
    return this.workspaceCompiler.compileComponents(componentsIds, options);
  }
  /**
   * API to create a new compiler task, it facilitates the usage of multiple compilers.
   * with this method you can create any number of compilers and add them to the buildPipeline.
   */
  createTask(name, compiler) {
    return new (_compiler4().CompilerTask)(_compiler().CompilerAspect.id, name, compiler, this.dependencyResolver);
  }

  /**
   * find the compiler configured on the workspace and ask for the dist path.
   */
  getDistPathBySrcPath(component, srcPath) {
    var _environment$getCompi;
    const environment = this.envs.getEnv(component).env;
    const compilerInstance = (_environment$getCompi = environment.getCompiler) === null || _environment$getCompi === void 0 ? void 0 : _environment$getCompi.call(environment);
    if (!compilerInstance) return null;
    return compilerInstance.getDistPathBySrcPath(srcPath);
  }

  /**
   * find the compiler configured on the workspace and ask for the dist folder path.
   */
  getRelativeDistFolder(component) {
    var _environment$getCompi2;
    const environment = this.envs.getOrCalculateEnv(component).env;
    const compilerInstance = (_environment$getCompi2 = environment.getCompiler) === null || _environment$getCompi2 === void 0 ? void 0 : _environment$getCompi2.call(environment);
    if (!compilerInstance || !compilerInstance.getDistDir) return _constants().DEFAULT_DIST_DIRNAME;
    return compilerInstance.getDistDir();
  }

  /**
   * Check if the dist folder (in the component package under node_modules) exist
   * @param component
   * @returns
   */
  isDistDirExists(component) {
    const packageDir = this.workspace.getComponentPackagePath(component);
    const distDir = this.getRelativeDistFolder(component);
    const pathToCheck = path().join(packageDir, distDir);
    return _fsExtra().default.existsSync(pathToCheck);
  }
  async getDistsFiles(component) {
    const artifacts = await this.builder.getArtifactsVinylByAspect(component, _compiler().CompilerAspect.id);
    if (!artifacts.length) throw new (_exceptions().DistArtifactNotFound)(component.id);
    return new (_distArtifact().DistArtifact)(artifacts);
  }
  async addMissingDistsIssue(component) {
    const exist = this.isDistDirExists(component);
    if (!exist) {
      component.state.issues.getOrCreate(_componentIssues().IssuesClasses.MissingDists).data = true;
    }
    // we don't want to add any data to the compiler aspect, only to add issues on the component
    return undefined;
  }
  static async provider([cli, workspace, envs, loggerMain, pubsub, aspectLoader, builder, ui, generator, dependencyResolver]) {
    const logger = loggerMain.createLogger(_compiler().CompilerAspect.id);
    const workspaceCompiler = new (_workspaceCompiler().WorkspaceCompiler)(workspace, envs, pubsub, aspectLoader, ui, logger, dependencyResolver);
    envs.registerService(new (_compiler3().CompilerService)());
    const compilerMain = new CompilerMain(pubsub, workspaceCompiler, envs, builder, workspace, dependencyResolver);
    cli.register(new (_compiler2().CompileCmd)(workspaceCompiler, logger, pubsub));
    if (workspace) {
      workspace.onComponentLoad(compilerMain.addMissingDistsIssue.bind(compilerMain));
    }
    generator.registerComponentTemplate([_compiler5().compilerTemplate]);
    _manyComponentsWriter().default.externalCompiler = compilerMain.compileOnWorkspace.bind(compilerMain);
    return compilerMain;
  }
}
exports.CompilerMain = CompilerMain;
(0, _defineProperty2().default)(CompilerMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(CompilerMain, "dependencies", [_cli().CLIAspect, _workspace().WorkspaceAspect, _envs().EnvsAspect, _logger().LoggerAspect, _pubsub().PubsubAspect, _aspectLoader().default, _builder().BuilderAspect, _ui().default, _generator().GeneratorAspect, _dependencyResolver().DependencyResolverAspect]);
_compiler().CompilerAspect.addRuntime(CompilerMain);
var _default = CompilerMain;
exports.default = _default;

//# sourceMappingURL=compiler.main.runtime.js.map