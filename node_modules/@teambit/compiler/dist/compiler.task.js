"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompilerTask = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _toolboxFs() {
  const data = require("@teambit/toolbox.fs.hard-link-directory");
  _toolboxFs = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
/**
 * compiler build task. Allows to compile components during component build.
 */
class CompilerTask {
  constructor(aspectId, name, compilerInstance, dependencyResolver) {
    this.aspectId = aspectId;
    this.name = name;
    this.compilerInstance = compilerInstance;
    this.dependencyResolver = dependencyResolver;
    (0, _defineProperty2().default)(this, "description", 'compile components');
    if (compilerInstance.artifactName) {
      this.description += ` for artifact ${compilerInstance.artifactName}`;
    }
  }
  async preBuild(context) {
    await Promise.all(context.capsuleNetwork.seedersCapsules.map(capsule => this.copyNonSupportedFiles(capsule, this.compilerInstance)));
    if (!this.compilerInstance.preBuild) return;
    await this.compilerInstance.preBuild(context);
  }
  async execute(context) {
    const buildResults = await this.compilerInstance.build(context);
    await this._hardLinkBuildArtifactsOnCapsules(context);
    return buildResults;
  }

  /**
   * This function hard links the compiled artifacts to the `node_modules` of other component capsules.
   * For instance, if we have a `button` component that is a dependency of the `card` component,
   * then the `dist` folder of the `button` component will be copied to `<card_capsule>/node_modules/button/dist`.
   */
  async _hardLinkBuildArtifactsOnCapsules(context) {
    await Promise.all(context.capsuleNetwork.seedersCapsules.map(async capsule => {
      const relCompDir = _path().default.relative(context.capsuleNetwork.capsulesRootDir, capsule.path).replace(/\\/g, '/');
      const injectedDirs = await this.dependencyResolver.getInjectedDirs(context.capsuleNetwork.capsulesRootDir, relCompDir, this.dependencyResolver.getPackageName(capsule.component));
      return (0, _toolboxFs().hardLinkDirectory)(capsule.path, injectedDirs.map(injectedDir => _path().default.join(context.capsuleNetwork.capsulesRootDir, injectedDir)));
    }));
  }
  async postBuild(context, tasksResults) {
    if (!this.compilerInstance.postBuild) return;
    await this.compilerInstance.postBuild(context, tasksResults);
  }
  async copyNonSupportedFiles(capsule, compiler) {
    if (!compiler.shouldCopyNonSupportedFiles) {
      return;
    }
    const component = capsule.component;
    await Promise.all(component.filesystem.files.map(async file => {
      if (compiler.isFileSupported(file.path)) return;
      const content = file.contents;
      await _fsExtra().default.outputFile(_path().default.join(capsule.path, compiler.distDir, file.relative), content);
    }));
  }
}
exports.CompilerTask = CompilerTask;

//# sourceMappingURL=compiler.task.js.map