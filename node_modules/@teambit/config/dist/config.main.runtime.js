"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConfigMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _consumer() {
  const data = require("@teambit/legacy/dist/consumer");
  _consumer = function () {
    return data;
  };
  return data;
}
function _workspaceConfig() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/config/workspace-config"));
  _workspaceConfig = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _workspaceConfig2() {
  const data = require("./workspace-config");
  _workspaceConfig2 = function () {
    return data;
  };
  return data;
}
function _config() {
  const data = require("./config.aspect");
  _config = function () {
    return data;
  };
  return data;
}
class ConfigMain {
  constructor(workspaceConfig, scopeConfig) {
    this.workspaceConfig = workspaceConfig;
    this.scopeConfig = scopeConfig;
  }
  get type() {
    if (this.workspaceConfig) {
      return 'workspace';
    }
    return 'scope';
  }
  get path() {
    var _this$config;
    return (_this$config = this.config) === null || _this$config === void 0 ? void 0 : _this$config.path;
  }
  get config() {
    if (this.workspaceConfig) {
      return this.workspaceConfig;
    }
    return this.scopeConfig;
  }

  /**
   * Ensure the given directory has a workspace config
   * Load if existing and create new if not
   *
   * @static
   * @param {PathOsBasedAbsolute} dirPath
   * @param {WorkspaceConfigFileProps} [workspaceConfigProps={} as any]
   * @returns {Promise<WorkspaceConfig>}
   * @memberof WorkspaceConfig
   */
  static async ensureWorkspace(dirPath, workspaceConfigProps = {}) {
    const workspaceConfig = await _workspaceConfig2().WorkspaceConfig.ensure(dirPath, workspaceConfigProps);
    return new ConfigMain(workspaceConfig);
  }
  get extensions() {
    var _this$config2;
    return (_this$config2 = this.config) === null || _this$config2 === void 0 ? void 0 : _this$config2.extensions;
  }
  extension(extensionId, ignoreVersion) {
    var _this$config3;
    return (_this$config3 = this.config) === null || _this$config3 === void 0 ? void 0 : _this$config3.extension(extensionId, ignoreVersion);
  }
  setExtension(extensionId, config, options) {
    var _this$config4;
    (_this$config4 = this.config) === null || _this$config4 === void 0 ? void 0 : _this$config4.setExtension(extensionId, config, options);
  }
  getHarmonyConfigObject() {
    const config = {};
    if (!this.extensions) return config;
    this.extensions.forEach(extension => {
      config[extension.stringId] = extension.config;
    });
    return config;
  }
  static async provider() {
    _workspaceConfig().default.registerOnWorkspaceConfigIsExist(onLegacyWorkspaceConfigIsExist());
    _workspaceConfig().default.registerOnWorkspaceConfigEnsuring(onLegacyWorkspaceEnsure());
    const consumerInfo = await (0, _consumer().getConsumerInfo)(process.cwd());
    let configMain;
    const configDirPath = (consumerInfo === null || consumerInfo === void 0 ? void 0 : consumerInfo.path) || process.cwd();
    const workspaceConfig = await _workspaceConfig2().WorkspaceConfig.loadIfExist(configDirPath);
    if (workspaceConfig) {
      configMain = new ConfigMain(workspaceConfig, undefined);
    } else {
      // TODO: try load scope config here
      configMain = {};
    }
    _workspaceConfig().default.registerOnWorkspaceConfigLoading(onLegacyWorkspaceLoad(configMain));
    _workspaceConfig().default.registerOnWorkspaceConfigReset((dirPath, resetHard) => _workspaceConfig2().WorkspaceConfig.reset(dirPath, resetHard));
    return configMain;
  }
}
exports.ConfigMain = ConfigMain;
(0, _defineProperty2().default)(ConfigMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(ConfigMain, "slots", []);
(0, _defineProperty2().default)(ConfigMain, "dependencies", [_cli().CLIAspect]);
(0, _defineProperty2().default)(ConfigMain, "config", {});
_config().ConfigAspect.addRuntime(ConfigMain);
function onLegacyWorkspaceConfigIsExist() {
  return async dirPath => {
    return _workspaceConfig2().WorkspaceConfig.isExist(dirPath);
  };
}
function onLegacyWorkspaceLoad(config) {
  return async dirPath => {
    if (config !== null && config !== void 0 && config.workspaceConfig && config.path && _path().default.normalize(dirPath) === _path().default.dirname(config.path)) {
      return config.config.toLegacy();
    }
    const newConfig = await _workspaceConfig2().WorkspaceConfig.loadIfExist(dirPath);
    if (newConfig) {
      return newConfig.toLegacy();
    }
    return undefined;
  };
}
function onLegacyWorkspaceEnsure() {
  const func = async (dirPath, standAlone, legacyWorkspaceConfigProps) => {
    let workspaceConfigProps;
    if (legacyWorkspaceConfigProps) {
      workspaceConfigProps = (0, _workspaceConfig2().transformLegacyPropsToExtensions)(legacyWorkspaceConfigProps);
    }
    const config = await ConfigMain.ensureWorkspace(dirPath, workspaceConfigProps);
    const workspaceConfig = config.config;
    return workspaceConfig.toLegacy();
  };
  return func;
}

//# sourceMappingURL=config.main.runtime.js.map