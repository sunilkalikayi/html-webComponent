"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkspaceConfig = void 0;
exports.getWorkspaceConfigTemplateParsed = getWorkspaceConfigTemplateParsed;
exports.stringifyWorkspaceConfig = stringifyWorkspaceConfig;
exports.transformLegacyPropsToExtensions = transformLegacyPropsToExtensions;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _analytics() {
  const data = require("@teambit/legacy/dist/analytics/analytics");
  _analytics = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _sources() {
  const data = require("@teambit/legacy/dist/consumer/component/sources");
  _sources = function () {
    return data;
  };
  return data;
}
function _dataToPersist() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/sources/data-to-persist"));
  _dataToPersist = function () {
    return data;
  };
  return data;
}
function _config() {
  const data = require("@teambit/legacy/dist/consumer/config");
  _config = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/config/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _workspaceConfig() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/config/workspace-config"));
  _workspaceConfig = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _commentJson() {
  const data = require("comment-json");
  _commentJson = function () {
    return data;
  };
  return data;
}
function fs() {
  const data = _interopRequireWildcard(require("fs-extra"));
  fs = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _exceptions2() {
  const data = require("./exceptions");
  _exceptions2 = function () {
    return data;
  };
  return data;
}
function _configDirNotDefined() {
  const data = require("./exceptions/config-dir-not-defined");
  _configDirNotDefined = function () {
    return data;
  };
  return data;
}
function _invalidConfigFile() {
  const data = _interopRequireDefault(require("./exceptions/invalid-config-file"));
  _invalidConfigFile = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const INTERNAL_CONFIG_PROPS = ['$schema', '$schemaVersion'];
class WorkspaceConfig {
  constructor(data, legacyConfig) {
    this.data = data;
    this.legacyConfig = legacyConfig;
    (0, _defineProperty2().default)(this, "raw", void 0);
    (0, _defineProperty2().default)(this, "_path", void 0);
    (0, _defineProperty2().default)(this, "_extensions", void 0);
    (0, _defineProperty2().default)(this, "_legacyProps", void 0);
    (0, _defineProperty2().default)(this, "isLegacy", void 0);
    this.isLegacy = Boolean(legacyConfig);
    const isHarmony = !this.isLegacy;
    _logger().default.debug(`workspace-config, isLegacy: ${this.isLegacy}`);
    _analytics().Analytics.setExtraData('is_harmony', isHarmony);
    this.raw = data;
    this.loadExtensions();
  }
  get path() {
    var _this$legacyConfig;
    return this._path || ((_this$legacyConfig = this.legacyConfig) === null || _this$legacyConfig === void 0 ? void 0 : _this$legacyConfig.path) || '';
  }
  set path(configPath) {
    this._path = configPath;
  }
  get extensions() {
    return this._extensions;
  }
  loadExtensions() {
    const withoutInternalConfig = (0, _lodash().omit)(this.raw, INTERNAL_CONFIG_PROPS);
    this._extensions = _config().ExtensionDataList.fromConfigObject(withoutInternalConfig);
  }
  extension(extensionId, ignoreVersion) {
    const existing = this.extensions.findExtension(extensionId, ignoreVersion);
    return existing === null || existing === void 0 ? void 0 : existing.config;
  }
  setExtension(extensionId, config, options) {
    const existing = this.extension(extensionId, options.ignoreVersion);
    if (existing) {
      if (options.mergeIntoExisting) {
        config = _objectSpread(_objectSpread({}, existing), config);
      } else if (!options.overrideExisting) {
        throw new (_exceptions2().ExtensionAlreadyConfigured)(extensionId);
      }
    }
    this.raw[extensionId] = config;
    this.loadExtensions();
  }
  renameExtensionInRaw(oldExtId, newExtId) {
    if (this.raw[oldExtId]) {
      this.raw[newExtId] = this.raw[oldExtId];
      delete this.raw[oldExtId];
      return true;
    }
    return false;
  }

  /**
   * Create an instance of the WorkspaceConfig by an instance of the legacy config
   *
   * @static
   * @param {*} legacyConfig
   * @returns
   * @memberof WorkspaceConfig
   */
  static fromLegacyConfig(legacyConfig) {
    return new WorkspaceConfig(undefined, legacyConfig);
  }

  /**
   * Create an instance of the WorkspaceConfig by data
   *
   * @static
   * @param {WorkspaceConfigFileProps} data
   * @returns
   * @memberof WorkspaceConfig
   */
  static fromObject(data) {
    return new WorkspaceConfig(data, undefined);
  }

  /**
   * Create an instance of the WorkspaceConfig by the workspace config template and override values
   *
   * @static
   * @param {WorkspaceConfigFileProps} data values to override in the default template
   * @returns
   * @memberof WorkspaceConfig
   */
  static async create(props, dirPath) {
    const template = await getWorkspaceConfigTemplateParsed();
    // TODO: replace this assign with some kind of deepAssign that keeps the comments
    // right now the comments above the internal props are overrides after the assign
    const merged = (0, _commentJson().assign)(template, props);
    const instance = new WorkspaceConfig(merged, undefined);
    if (dirPath) {
      instance.path = WorkspaceConfig.composeWorkspaceJsoncPath(dirPath);
    }
    return instance;
  }

  /**
   * Ensure the given directory has a workspace config
   * Load if existing and create new if not
   *
   * @static
   * @param {PathOsBasedAbsolute} dirPath
   * @param {WorkspaceConfigFileProps} [workspaceConfigProps={} as any]
   * @returns {Promise<WorkspaceConfig>}
   * @memberof WorkspaceConfig
   */
  static async ensure(dirPath, workspaceConfigProps = {}) {
    try {
      let workspaceConfig = await this.loadIfExist(dirPath);
      if (workspaceConfig) {
        return workspaceConfig;
      }
      workspaceConfig = await this.create(workspaceConfigProps, dirPath);
      return workspaceConfig;
    } catch (err) {
      if (err instanceof _exceptions().InvalidBitJson || err instanceof _invalidConfigFile().default) {
        const workspaceConfig = this.create(workspaceConfigProps, dirPath);
        return workspaceConfig;
      }
      throw err;
    }
  }

  /**
   * A function that register to the legacy ensure function in order to transform old props structure
   * to the new one
   * @param dirPath
   * @param standAlone
   * @param legacyWorkspaceConfigProps
   */
  static async onLegacyEnsure(dirPath, standAlone, legacyWorkspaceConfigProps = {}) {
    const newProps = transformLegacyPropsToExtensions(legacyWorkspaceConfigProps);
    // TODO: gilad move to constants file
    newProps.$schemaVersion = '1.0.0';
    return WorkspaceConfig.ensure(dirPath, newProps);
  }
  static async reset(dirPath, resetHard) {
    const workspaceJsoncPath = WorkspaceConfig.composeWorkspaceJsoncPath(dirPath);
    if (resetHard && workspaceJsoncPath) {
      _logger().default.info(`deleting the consumer workspace.jsonc file at ${workspaceJsoncPath}`);
      await fs().remove(workspaceJsoncPath);
    }
  }

  /**
   * Get the path of the bit.jsonc file by a containing folder
   *
   * @static
   * @param {PathOsBased} dirPath containing dir of the bit.jsonc file
   * @returns {PathOsBased}
   * @memberof WorkspaceConfig
   */
  static composeWorkspaceJsoncPath(dirPath) {
    return path().join(dirPath, _constants().WORKSPACE_JSONC);
  }
  static async pathHasWorkspaceJsonc(dirPath) {
    const isExist = await fs().pathExists(WorkspaceConfig.composeWorkspaceJsoncPath(dirPath));
    return isExist;
  }

  /**
   * Check if the given dir has workspace config (new or legacy)
   * @param dirPath
   */
  static async isExist(dirPath) {
    const jsoncExist = await WorkspaceConfig.pathHasWorkspaceJsonc(dirPath);
    if (jsoncExist) {
      return true;
    }
    return _workspaceConfig().default._isExist(dirPath);
  }

  /**
   * Load the workspace configuration if it's exist
   *
   * @static
   * @param {PathOsBased} dirPath
   * @returns {(Promise<WorkspaceConfig | undefined>)}
   * @memberof WorkspaceConfig
   */
  static async loadIfExist(dirPath) {
    const jsoncExist = await WorkspaceConfig.pathHasWorkspaceJsonc(dirPath);
    if (jsoncExist) {
      const jsoncPath = WorkspaceConfig.composeWorkspaceJsoncPath(dirPath);
      const instance = await WorkspaceConfig._loadFromWorkspaceJsonc(jsoncPath);
      instance.path = jsoncPath;
      return instance;
    }
    const legacyConfig = await _workspaceConfig().default._loadIfExist(dirPath);
    if (legacyConfig) {
      return WorkspaceConfig.fromLegacyConfig(legacyConfig);
    }
    return undefined;
  }
  static async _loadFromWorkspaceJsonc(workspaceJsoncPath) {
    const contentBuffer = await fs().readFile(workspaceJsoncPath);
    let parsed;
    try {
      parsed = (0, _commentJson().parse)(contentBuffer.toString());
    } catch (e) {
      throw new (_invalidConfigFile().default)(workspaceJsoncPath);
    }
    return WorkspaceConfig.fromObject(parsed);
  }
  async write({
    dir
  } = {}) {
    var _this$legacyConfig2;
    const getCalculatedDir = () => {
      if (dir) return dir;
      if (this._path) return path().dirname(this._path);
      throw new (_configDirNotDefined().ConfigDirNotDefined)();
    };
    const calculatedDir = getCalculatedDir();
    if (this.data) {
      const files = await this.toVinyl(calculatedDir);
      const dataToPersist = new (_dataToPersist().default)();
      if (files) {
        dataToPersist.addManyFiles(files);
        return dataToPersist.persistAllToFS();
      }
    }
    await ((_this$legacyConfig2 = this.legacyConfig) === null || _this$legacyConfig2 === void 0 ? void 0 : _this$legacyConfig2.write({
      workspaceDir: calculatedDir
    }));
    return undefined;
  }
  async toVinyl(workspaceDir) {
    var _this$legacyConfig3;
    if (this.data) {
      const jsonStr = (0, _commentJson().stringify)(this.data, undefined, 2);
      const base = workspaceDir;
      const fullPath = workspaceDir ? WorkspaceConfig.composeWorkspaceJsoncPath(workspaceDir) : this.path;
      const jsonFile = new (_sources().AbstractVinyl)({
        base,
        path: fullPath,
        contents: Buffer.from(jsonStr)
      });
      return [jsonFile];
    }
    return (_this$legacyConfig3 = this.legacyConfig) === null || _this$legacyConfig3 === void 0 ? void 0 : _this$legacyConfig3.toVinyl({
      workspaceDir
    });
  }
  _legacyPlainObject() {
    if (this.legacyConfig) {
      return this.legacyConfig.toPlainObject();
    }
    return undefined;
  }
  toLegacy() {
    var _this$extension, _this$legacyConfig4, _this$extension2, _this$extension3, _this$extension4, _this$extension5, _this$_legacyProps, _this$_legacyProps2, _this$_legacyProps3, _this$extension6, _this$extension7, _this$legacyConfig5, _this$legacyConfig6, _this$legacyConfig7, _this$legacyConfig8;
    let componentsDefaultDirectory = (_this$extension = this.extension('teambit.workspace/workspace', true)) === null || _this$extension === void 0 ? void 0 : _this$extension.defaultDirectory;
    if (componentsDefaultDirectory && !componentsDefaultDirectory.includes('{name}')) {
      componentsDefaultDirectory = `${componentsDefaultDirectory}/{name}`;
    }
    return {
      lang: ((_this$legacyConfig4 = this.legacyConfig) === null || _this$legacyConfig4 === void 0 ? void 0 : _this$legacyConfig4.lang) || _constants().DEFAULT_LANGUAGE,
      defaultScope: (_this$extension2 = this.extension('teambit.workspace/workspace', true)) === null || _this$extension2 === void 0 ? void 0 : _this$extension2.defaultScope,
      _useWorkspaces: (_this$extension3 = this.extension('teambit.dependencies/dependency-resolver', true)) === null || _this$extension3 === void 0 ? void 0 : _this$extension3.useWorkspaces,
      dependencyResolver: this.extension('teambit.dependencies/dependency-resolver', true),
      packageManager: (_this$extension4 = this.extension('teambit.dependencies/dependency-resolver', true)) === null || _this$extension4 === void 0 ? void 0 : _this$extension4.packageManager,
      _bindingPrefix: (_this$extension5 = this.extension('teambit.workspace/workspace', true)) === null || _this$extension5 === void 0 ? void 0 : _this$extension5.defaultOwner,
      _saveDependenciesAsComponents: (_this$_legacyProps = this._legacyProps) === null || _this$_legacyProps === void 0 ? void 0 : _this$_legacyProps.saveDependenciesAsComponents,
      _dependenciesDirectory: (_this$_legacyProps2 = this._legacyProps) === null || _this$_legacyProps2 === void 0 ? void 0 : _this$_legacyProps2.dependenciesDirectory,
      componentsDefaultDirectory,
      _resolveModules: (_this$_legacyProps3 = this._legacyProps) === null || _this$_legacyProps3 === void 0 ? void 0 : _this$_legacyProps3.resolveModules,
      _manageWorkspaces: (_this$extension6 = this.extension('teambit.dependencies/dependency-resolver', true)) === null || _this$extension6 === void 0 ? void 0 : _this$extension6.manageWorkspaces,
      defaultOwner: (_this$extension7 = this.extension('teambit.workspace/workspace', true)) === null || _this$extension7 === void 0 ? void 0 : _this$extension7.defaultOwner,
      extensions: this.extensions.toConfigObject(),
      // @ts-ignore
      path: this.path,
      isLegacy: this.isLegacy,
      write: ({
        workspaceDir
      }) => this.write.call(this, {
        dir: workspaceDir
      }),
      toVinyl: this.toVinyl.bind(this),
      componentsConfig: this.legacyConfig ? (_this$legacyConfig5 = this.legacyConfig) === null || _this$legacyConfig5 === void 0 ? void 0 : _this$legacyConfig5.overrides : undefined,
      getComponentConfig: this.legacyConfig ? (_this$legacyConfig6 = this.legacyConfig) === null || _this$legacyConfig6 === void 0 ? void 0 : _this$legacyConfig6.overrides.getOverrideComponentData.bind((_this$legacyConfig7 = this.legacyConfig) === null || _this$legacyConfig7 === void 0 ? void 0 : _this$legacyConfig7.overrides) : () => undefined,
      _legacyPlainObject: this.legacyConfig ? (_this$legacyConfig8 = this.legacyConfig) === null || _this$legacyConfig8 === void 0 ? void 0 : _this$legacyConfig8.toPlainObject.bind(this.legacyConfig) : () => undefined
    };
  }
}
exports.WorkspaceConfig = WorkspaceConfig;
function transformLegacyPropsToExtensions(legacyConfig) {
  var _legacyConfig$overrid;
  // TODO: move to utils
  const removeUndefined = obj => {
    // const res = omit(mapObjIndexed((val) => val === undefined))(obj);
    // return res;
    Object.entries(obj).forEach(e => {
      if (e[1] === undefined) delete obj[e[0]];
    });
    return obj;
  };
  const workspace = removeUndefined({
    defaultScope: legacyConfig.defaultScope,
    defaultDirectory: legacyConfig.componentsDefaultDirectory,
    defaultOwner: legacyConfig.bindingPrefix
  });
  const dependencyResolver = removeUndefined({
    packageManager: legacyConfig.packageManager,
    // strictPeerDependencies: false,
    extraArgs: legacyConfig.packageManagerArgs,
    packageManagerProcessOptions: legacyConfig.packageManagerProcessOptions,
    manageWorkspaces: legacyConfig.manageWorkspaces,
    useWorkspaces: legacyConfig.useWorkspaces
  });
  const variants = (_legacyConfig$overrid = legacyConfig.overrides) === null || _legacyConfig$overrid === void 0 ? void 0 : _legacyConfig$overrid.overrides;
  const data = {};
  if (workspace && !(0, _lodash().isEmpty)(workspace)) {
    data['teambit.workspace/workspace'] = workspace;
  }
  if (dependencyResolver && !(0, _lodash().isEmpty)(dependencyResolver)) {
    data['teambit.dependencies/dependency-resolver'] = dependencyResolver;
  }
  // TODO: add variants here once we have a way to pass the deps overrides and general key vals for package.json to
  // TODO: new extensions (via dependency-resolver extension and pkg extensions)
  // TODO: transform legacy props to new one once dependency-resolver extension and pkg extensions are ready
  if (variants && !(0, _lodash().isEmpty)(variants)) {
    data['teambit.workspace/variants'] = variants;
  }
  // @ts-ignore
  return data;
}
async function getWorkspaceConfigTemplateParsed() {
  let fileContent;
  try {
    fileContent = await fs().readFile(path().join(__dirname, 'workspace-template.jsonc'));
  } catch (err) {
    if (err.code !== 'ENOENT') throw err;
    // when the extension is compiled by tsc, it doesn't copy .jsonc files into the dists, grab it from src
    fileContent = await fs().readFile(path().join(__dirname, '..', 'workspace-template.jsonc'));
  }
  return (0, _commentJson().parse)(fileContent.toString());
}
function stringifyWorkspaceConfig(workspaceConfig) {
  return (0, _commentJson().stringify)(workspaceConfig, undefined, 2);
}

//# sourceMappingURL=workspace-config.js.map