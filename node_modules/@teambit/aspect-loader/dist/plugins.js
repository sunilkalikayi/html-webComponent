"use strict";

require("core-js/modules/es.array.flat-map.js");
require("core-js/modules/es.array.unscopables.flat-map.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Plugins = void 0;
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _plugin() {
  const data = require("./plugin");
  _plugin = function () {
    return data;
  };
  return data;
}
class Plugins {
  constructor(component, plugins) {
    this.component = component;
    this.plugins = plugins;
  }

  // computeDependencies(runtime: string): Aspect[] {
  //   const inRuntime = this.getByRuntime(runtime);
  //   return inRuntime.flatMap((plugin) => {
  //     return plugin.def.dependencies;
  //   });
  // }

  getByRuntime(runtime) {
    return this.plugins.filter(plugin => {
      return plugin.supportsRuntime(runtime);
    });
  }
  async load(runtime) {
    const plugins = this.getByRuntime(runtime);
    const aspect = _harmony().Aspect.create({
      id: this.component.id.toString()
    });
    aspect.addRuntime({
      provider: async () => {
        plugins.forEach(plugin => {
          plugin.register(aspect);
        });
      },
      runtime,
      // dependencies: this.computeDependencies(runtime)
      dependencies: []
    });
    return aspect;
  }
  has() {
    return Boolean(this.plugins.length);
  }
  static from(component, defs, resolvePath) {
    const plugins = defs.flatMap(pluginDef => {
      const files = typeof pluginDef.pattern === 'string' ? component.filesystem.byGlob([pluginDef.pattern]) : component.filesystem.byRegex(pluginDef.pattern);
      return files.map(file => {
        return new (_plugin().Plugin)(pluginDef, resolvePath ? resolvePath(file.relative) : file.path);
      });
    });
    return new Plugins(component, plugins);
  }
}
exports.Plugins = Plugins;

//# sourceMappingURL=plugins.js.map