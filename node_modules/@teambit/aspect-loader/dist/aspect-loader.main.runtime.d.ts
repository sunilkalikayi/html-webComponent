import { ExtensionManifest, Harmony, Aspect, SlotRegistry } from '@teambit/harmony';
import type { LoggerMain } from '@teambit/logger';
import { ComponentID, Component } from '@teambit/component';
import { Logger } from '@teambit/logger';
import { RequireableComponent } from '@teambit/harmony.modules.requireable-component';
import { EnvsMain } from '@teambit/envs';
import { AspectDefinition, AspectDefinitionProps } from './aspect-definition';
import { PluginDefinition } from './plugin-definition';
import { Plugins } from './plugins';
export declare type PluginDefinitionSlot = SlotRegistry<PluginDefinition[]>;
export declare type AspectDescriptor = {
    /**
     * name of the extension.
     */
    id: string;
    /**
     * icon of the extension.
     */
    icon?: string;
};
export declare type AspectResolver = (component: Component) => Promise<ResolvedAspect>;
export declare type ResolvedAspect = {
    aspectPath: string;
    runtimePath: string | null;
};
declare type OnAspectLoadError = (err: Error, id: ComponentID) => Promise<boolean>;
export declare type OnAspectLoadErrorSlot = SlotRegistry<OnAspectLoadError>;
export declare type OnLoadRequireableExtension = (requireableExtension: RequireableComponent, manifest: ExtensionManifest | Aspect) => Promise<ExtensionManifest | Aspect>;
/**
 * A slot which run during loading the requirable extension (after first manifest calculation)
 */
export declare type OnLoadRequireableExtensionSlot = SlotRegistry<OnLoadRequireableExtension>;
export declare type MainAspect = {
    /**
     * path to the main aspect.
     */
    path: string;
    /**
     * version of the aspect.
     */
    version: string | undefined;
    /**
     * package name of the aspect
     */
    packageName: string | undefined;
    /**
     * reference to aspect manifest.
     */
    aspect: Aspect;
    /**
     * The name of the aspect (without the scope prefix)
     */
    name: string;
    /**
     * The name of the aspect
     */
    id: string;
};
export declare class AspectLoaderMain {
    private logger;
    private envs;
    private harmony;
    private onAspectLoadErrorSlot;
    private onLoadRequireableExtensionSlot;
    private pluginSlot;
    constructor(logger: Logger, envs: EnvsMain, harmony: Harmony, onAspectLoadErrorSlot: OnAspectLoadErrorSlot, onLoadRequireableExtensionSlot: OnLoadRequireableExtensionSlot, pluginSlot: PluginDefinitionSlot);
    private getCompiler;
    registerOnAspectLoadErrorSlot(onAspectLoadError: OnAspectLoadError): void;
    registerOnLoadRequireableExtensionSlot(onLoadRequireableExtension: OnLoadRequireableExtension): void;
    /**
     * returns whether the aspect-load issue has been fixed.
     */
    triggerOnAspectLoadError(err: Error, component: Component): Promise<boolean>;
    getRuntimePath(component: Component, modulePath: string, runtime: string): Promise<string | null>;
    isAspectLoaded(id: string): unknown;
    getDescriptor(id: string): AspectDescriptor;
    getNotLoadedConfiguredExtensions(): string[];
    loadDefinition(props: AspectDefinitionProps): AspectDefinition;
    private _coreAspects;
    get coreAspects(): Aspect[];
    isCoreAspect(id: string): boolean;
    setCoreAspects(aspects: Aspect[]): this;
    getCoreAspectIds(): string[];
    /**
     * Get all the core envs ids which is still register in the bit manifest as core aspect
     */
    getCoreEnvsIds(): string[];
    isCoreEnv(id: string): boolean;
    private _reserved;
    getUserAspects(): string[];
    getCoreAspectDefs(runtimeName?: string): Promise<AspectDefinition[]>;
    resolveAspects(components: Component[], resolver: AspectResolver): Promise<AspectDefinition[]>;
    private _mainAspect;
    get mainAspect(): MainAspect;
    setMainAspect(mainAspect: MainAspect): this;
    private failedLoadAspect;
    get failedAspects(): string[];
    resetFailedLoadAspects(): void;
    private addFailure;
    cloneManifest(manifest: any): any;
    /**
     * run "require" of the component code to get the manifest
     */
    doRequire(requireableExtension: RequireableComponent): Promise<ExtensionManifest | Aspect>;
    /**
     * in case the extension failed to load, prefer to throw an error, unless `throwOnError` param
     * passed as `false`.
     * there are cases when throwing an error blocks the user from doing anything else. for example,
     * when a user develops an extension and deletes the node-modules, the extension on the workspace
     * cannot be loaded anymore until "bit compile" is running. however, if this function throws an
     * error, it'll throw for "bit compile" as well, which blocks the user.
     * for the CI, it is important to throw an error because errors on console can be ignored.
     * for now, when loading the extension from the workspace the throwOnError is passed as false.
     * when loading from the scope (CI) it should be true.
     *
     * the console printing here is done directly by "console.error" and not by the logger. the reason
     * is that the logger.console only prints when the loader started (which, btw, happens after
     * entering this function, so it can't work) and here we want it to be printed regardless of the
     * rules of starting the loader. e.g. if by mistake the CI got it as throwOnError=false, it's ok
     * to break the output by the console.error.
     *
     * @todo: this is not the final word however about throwing/non throwing errors here.
     * in some cases, such as "bit tag", it's better not to tag if an extension changes the model.
     */
    loadRequireableExtensions(requireableExtensions: RequireableComponent[], throwOnError?: boolean): Promise<void>;
    getManifestsFromRequireableExtensions(requireableExtensions: RequireableComponent[], throwOnError?: boolean): Promise<Array<ExtensionManifest | Aspect>>;
    handleExtensionLoadingError(error: Error, idStr: string, throwOnError: boolean): void;
    runOnLoadRequireableExtensionSubscribers(requireableExtension: RequireableComponent, manifest: ExtensionManifest | Aspect): Promise<ExtensionManifest | Aspect>;
    getPluginDefs(): PluginDefinition[];
    getPlugins(component: Component, componentPath: string): Plugins;
    isAspect(manifest: any): boolean;
    isValidAspect(manifest: any): boolean;
    isAspectComponent(component: Component): boolean;
    /**
     * get or create a global scope, import the non-core aspects, load bit from that scope, create
     * capsules for the aspects and load them from the capsules.
     */
    loadAspectsFromGlobalScope(aspectIds: string[]): Promise<{
        components: Component[];
        globalScopeHarmony: Harmony;
    }>;
    private prepareManifests;
    /**
     * register a plugin.
     */
    registerPlugins(pluginDefs: PluginDefinition[]): void;
    loadExtensionsByManifests(extensionsManifests: Array<ExtensionManifest | Aspect>, throwOnError?: boolean, seeders?: string[]): Promise<void>;
    private generateManifestGraph;
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: Aspect[];
    static slots: (((registerFn: () => string) => SlotRegistry<OnAspectLoadError>) | ((registerFn: () => string) => SlotRegistry<OnLoadRequireableExtension>) | ((registerFn: () => string) => SlotRegistry<PluginDefinition[]>))[];
    static provider([loggerExt, envs]: [LoggerMain, EnvsMain], config: any, [onAspectLoadErrorSlot, onLoadRequireableExtensionSlot, pluginSlot]: [
        OnAspectLoadErrorSlot,
        OnLoadRequireableExtensionSlot,
        PluginDefinitionSlot
    ], harmony: Harmony): Promise<AspectLoaderMain>;
}
export default AspectLoaderMain;
