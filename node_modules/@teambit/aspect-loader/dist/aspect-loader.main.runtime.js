"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.AspectLoaderMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _graph() {
  const data = require("@teambit/graph.cleargraph");
  _graph = function () {
    return data;
  };
  return data;
}
function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");
  _legacyBitId = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/scope/scope"));
  _scope = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _compilationModules() {
  const data = require("@teambit/compilation.modules.babel-compiler");
  _compilationModules = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = require("@teambit/envs");
  _envs = function () {
    return data;
  };
  return data;
}
function _bit() {
  const data = require("@teambit/bit");
  _bit = function () {
    return data;
  };
  return data;
}
function _scope2() {
  const data = require("@teambit/scope");
  _scope2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _aspectDefinition() {
  const data = require("./aspect-definition");
  _aspectDefinition = function () {
    return data;
  };
  return data;
}
function _aspectLoader() {
  const data = require("./aspect-loader.aspect");
  _aspectLoader = function () {
    return data;
  };
  return data;
}
function _constants2() {
  const data = require("./constants");
  _constants2 = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _coreAspects() {
  const data = require("./core-aspects");
  _coreAspects = function () {
    return data;
  };
  return data;
}
function _plugins() {
  const data = require("./plugins");
  _plugins = function () {
    return data;
  };
  return data;
}
class AspectLoaderMain {
  constructor(logger, envs, harmony, onAspectLoadErrorSlot, onLoadRequireableExtensionSlot, pluginSlot) {
    this.logger = logger;
    this.envs = envs;
    this.harmony = harmony;
    this.onAspectLoadErrorSlot = onAspectLoadErrorSlot;
    this.onLoadRequireableExtensionSlot = onLoadRequireableExtensionSlot;
    this.pluginSlot = pluginSlot;
    (0, _defineProperty2().default)(this, "_coreAspects", []);
    (0, _defineProperty2().default)(this, "_reserved", ['teambit.harmony/bit', 'teambit.harmony/config']);
    (0, _defineProperty2().default)(this, "_mainAspect", void 0);
    (0, _defineProperty2().default)(this, "failedLoadAspect", []);
  }
  getCompiler(component) {
    var _this$envs$getEnv;
    const env = (_this$envs$getEnv = this.envs.getEnv(component)) === null || _this$envs$getEnv === void 0 ? void 0 : _this$envs$getEnv.env;
    return env === null || env === void 0 ? void 0 : env.getCompiler();
  }
  registerOnAspectLoadErrorSlot(onAspectLoadError) {
    this.onAspectLoadErrorSlot.register(onAspectLoadError);
  }
  registerOnLoadRequireableExtensionSlot(onLoadRequireableExtension) {
    this.onLoadRequireableExtensionSlot.register(onLoadRequireableExtension);
  }

  /**
   * returns whether the aspect-load issue has been fixed.
   */
  async triggerOnAspectLoadError(err, component) {
    const entries = this.onAspectLoadErrorSlot.toArray(); // e.g. [ [ 'teambit.bit/compiler', [Function: bound onAspectLoadError] ] ]
    let isFixed = false;
    await (0, _pMapSeries().default)(entries, async ([, onAspectFailFunc]) => {
      const result = await onAspectFailFunc(err, component.id);
      if (result) isFixed = true;
    });
    return isFixed;
  }
  async getRuntimePath(component, modulePath, runtime) {
    const runtimeFile = component.filesystem.files.find(file => {
      return file.relative.includes(`.${runtime}.runtime`);
    });

    // @david we should add a compiler api for this.
    if (!runtimeFile) return null;
    try {
      const compiler = this.getCompiler(component);
      if (!compiler) {
        return (0, _path().join)(modulePath, runtimeFile.relative);
      }
      const dist = compiler.getDistPathBySrcPath(runtimeFile.relative);
      return (0, _path().join)(modulePath, dist);
    } catch (e) {
      this.logger.info(`got an error during get runtime path, probably the env is not loaded yet ${e}`);
      // TODO: we are manually adding the dist here and replace the file name to handle case when
      // we load aspects from scope, and their env in the same iteration, but we get into the aspect before its
      // env, so it's env doesn't exist yet
      // we should make sure to first load the env correctly before loading the aspect
      const distPath = (0, _path().join)(modulePath, _constants().DEFAULT_DIST_DIRNAME, (0, _compilationModules().replaceFileExtToJs)(runtimeFile.relative));
      return distPath;
    }
  }
  isAspectLoaded(id) {
    if (this.failedAspects.includes(id)) return true;
    try {
      return this.harmony.get(id);
    } catch (err) {
      return false;
    }
  }
  getDescriptor(id) {
    const instance = this.harmony.get(id);
    const iconFn = instance.icon;
    const icon = iconFn ? iconFn.apply(instance) : undefined;
    return {
      id,
      icon
    };
  }
  getNotLoadedConfiguredExtensions() {
    const configuredAspects = Array.from(this.harmony.config.raw.keys());
    const loadedExtensions = this.harmony.extensionsIds;
    const extensionsToLoad = (0, _lodash().difference)(configuredAspects, loadedExtensions);
    return extensionsToLoad;
  }
  loadDefinition(props) {
    return _aspectDefinition().AspectDefinition.from(props);
  }
  get coreAspects() {
    return this._coreAspects;
  }
  isCoreAspect(id) {
    const ids = this.getCoreAspectIds();
    return ids.includes(id);
  }
  setCoreAspects(aspects) {
    this._coreAspects = aspects;
    return this;
  }
  getCoreAspectIds() {
    const ids = this.coreAspects.map(aspect => aspect.id);
    return ids.concat(this._reserved);
  }

  /**
   * Get all the core envs ids which is still register in the bit manifest as core aspect
   */
  getCoreEnvsIds() {
    const envsIds = this.envs.getCoreEnvsIds();
    const allIds = this.getCoreAspectIds();
    return (0, _lodash().intersection)(allIds, envsIds);
  }
  isCoreEnv(id) {
    const ids = this.getCoreEnvsIds();
    return ids.includes(id);
  }
  getUserAspects() {
    const coreAspectIds = this.getCoreAspectIds();
    return (0, _lodash().difference)(this.harmony.extensionsIds, coreAspectIds);
  }
  async getCoreAspectDefs(runtimeName) {
    const defs = await Promise.all(this.coreAspects.map(async aspect => {
      const id = aspect.id;
      const rawDef = await (0, _coreAspects().getAspectDef)(id, runtimeName);
      return this.loadDefinition(rawDef);
    }));
    return defs.filter(def => def.runtimePath);
  }
  async resolveAspects(components, resolver) {
    const promises = components.map(async component => {
      const resolvedAspect = await resolver(component);
      return new (_aspectDefinition().AspectDefinition)(resolvedAspect.aspectPath, resolvedAspect.runtimePath, component);
    });
    const aspectDefs = await Promise.all(promises);
    // return aspectDefs.filter((def) => def.runtimePath);
    return aspectDefs;
  }
  get mainAspect() {
    return this._mainAspect;
  }
  setMainAspect(mainAspect) {
    this._mainAspect = mainAspect;
    return this;
  }
  get failedAspects() {
    return this.failedLoadAspect;
  }
  resetFailedLoadAspects() {
    this.failedLoadAspect = [];
  }
  addFailure(id) {
    if (this.failedAspects.includes(id)) return;
    this.failedLoadAspect.push(id);
  }
  cloneManifest(manifest) {
    const cloned = Object.assign(Object.create(Object.getPrototypeOf(manifest)), manifest);
    cloned.provider = manifest.provider;
    cloned.addRuntime = manifest.addRuntime;
    cloned.getRuntime = manifest.getRuntime;
    return cloned;
  }

  /**
   * run "require" of the component code to get the manifest
   */
  async doRequire(requireableExtension) {
    const idStr = requireableExtension.component.id.toString();
    const aspect = await requireableExtension.require();
    const manifest = aspect.default || aspect;
    manifest.id = idStr;
    // It's important to clone deep the manifest here to prevent mutate dependencies of other manifests as they point to the same location in memory
    const cloned = this.cloneManifest(manifest);
    const newManifest = await this.runOnLoadRequireableExtensionSubscribers(requireableExtension, cloned);
    return newManifest;
  }

  /**
   * in case the extension failed to load, prefer to throw an error, unless `throwOnError` param
   * passed as `false`.
   * there are cases when throwing an error blocks the user from doing anything else. for example,
   * when a user develops an extension and deletes the node-modules, the extension on the workspace
   * cannot be loaded anymore until "bit compile" is running. however, if this function throws an
   * error, it'll throw for "bit compile" as well, which blocks the user.
   * for the CI, it is important to throw an error because errors on console can be ignored.
   * for now, when loading the extension from the workspace the throwOnError is passed as false.
   * when loading from the scope (CI) it should be true.
   *
   * the console printing here is done directly by "console.error" and not by the logger. the reason
   * is that the logger.console only prints when the loader started (which, btw, happens after
   * entering this function, so it can't work) and here we want it to be printed regardless of the
   * rules of starting the loader. e.g. if by mistake the CI got it as throwOnError=false, it's ok
   * to break the output by the console.error.
   *
   * @todo: this is not the final word however about throwing/non throwing errors here.
   * in some cases, such as "bit tag", it's better not to tag if an extension changes the model.
   */
  async loadRequireableExtensions(requireableExtensions, throwOnError = false) {
    const manifests = await this.getManifestsFromRequireableExtensions(requireableExtensions, throwOnError);
    return this.loadExtensionsByManifests(manifests, throwOnError);
  }
  async getManifestsFromRequireableExtensions(requireableExtensions, throwOnError = false) {
    const manifestsP = (0, _pMapSeries().default)(requireableExtensions, async requireableExtension => {
      if (!requireableExtensions) return undefined;
      const idStr = requireableExtension.component.id.toString();
      try {
        return await this.doRequire(requireableExtension);
      } catch (firstErr) {
        this.addFailure(idStr);
        this.logger.warn(`failed loading an aspect "${idStr}", will try to fix and reload`, firstErr);
        const isFixed = await this.triggerOnAspectLoadError(firstErr, requireableExtension.component);
        let errAfterReLoad;
        if (isFixed) {
          this.logger.info(`the loading issue might be fixed now, re-loading ${idStr}`);
          try {
            return await this.doRequire(requireableExtension);
          } catch (err) {
            this.logger.warn(`re-load of the aspect "${idStr}" failed as well`, err);
            errAfterReLoad = err;
          }
        }
        const error = errAfterReLoad || firstErr;
        this.handleExtensionLoadingError(error, idStr, throwOnError);
      }
      return undefined;
    });
    const manifests = await manifestsP;

    // Remove empty manifests as a result of loading issue
    return (0, _lodash().compact)(manifests);
  }
  handleExtensionLoadingError(error, idStr, throwOnError) {
    const errorMsg = error.message.split('\n')[0]; // show only the first line if the error is long (e.g. happens with MODULE_NOT_FOUND errors)
    const msg = (0, _constants2().UNABLE_TO_LOAD_EXTENSION)(idStr, errorMsg);
    if (throwOnError) {
      // @ts-ignore
      this.logger.console(error);
      throw new (_exceptions().CannotLoadExtension)(idStr, error);
    }
    this.logger.error(msg, error);
    if (this.logger.isLoaderStarted) {
      this.logger.consoleFailure(msg);
    } else {
      this.logger.console(msg);
    }
  }
  async runOnLoadRequireableExtensionSubscribers(requireableExtension, manifest) {
    let updatedManifest = manifest;
    const entries = this.onLoadRequireableExtensionSlot.toArray();
    await (0, _pMapSeries().default)(entries, async ([, onLoadRequireableExtensionFunc]) => {
      updatedManifest = await onLoadRequireableExtensionFunc(requireableExtension, updatedManifest);
    });
    return updatedManifest;
  }
  getPluginDefs() {
    return (0, _lodash().flatten)(this.pluginSlot.values());
  }
  getPlugins(component, componentPath) {
    const defs = this.getPluginDefs();
    return _plugins().Plugins.from(component, defs, relativePath => {
      const compiler = this.getCompiler(component);
      if (!compiler) {
        return (0, _path().join)(componentPath, relativePath);
      }
      const dist = compiler.getDistPathBySrcPath(relativePath);
      return (0, _path().join)(componentPath, dist);
    });
  }
  isAspect(manifest) {
    return !!(manifest.addRuntime && manifest.getRuntime);
  }
  isValidAspect(manifest) {
    return this.isAspect(manifest) || manifest.provider;
  }
  isAspectComponent(component) {
    return this.envs.isUsingAspectEnv(component);
  }

  /**
   * get or create a global scope, import the non-core aspects, load bit from that scope, create
   * capsules for the aspects and load them from the capsules.
   */
  async loadAspectsFromGlobalScope(aspectIds) {
    const globalScope = await _scope().default.ensure(_constants().GLOBAL_SCOPE, 'global-scope');
    await globalScope.ensureDir();
    const globalScopeHarmony = await (0, _bit().loadBit)(globalScope.path);
    const scope = globalScopeHarmony.get(_scope2().ScopeAspect.id);
    const aspectLoader = globalScopeHarmony.get(_aspectLoader().AspectLoaderAspect.id);
    // @todo: Gilad make this work
    // const ids = await scope.resolveMultipleComponentIds(aspectIds);
    const ids = aspectIds.map(id => _component().ComponentID.fromLegacy(_legacyBitId().BitId.parse(id, true)));
    const hasVersions = ids.every(id => id.hasVersion());
    const useCache = hasVersions; // if all components has versions, try to use the cached aspects
    const components = await scope.import(ids, {
      useCache,
      throwIfNotExist: true
    });

    // don't use `await scope.loadAspectsFromCapsules(components, true);`
    // it won't work for globalScope because `this !== scope.aspectLoader` (this instance
    // is not the same as the aspectLoader instance Scope has)
    const resolvedAspects = await scope.getResolvedAspects(components);
    try {
      await aspectLoader.loadRequireableExtensions(resolvedAspects, true);
    } catch (err) {
      if ((err === null || err === void 0 ? void 0 : err.error.code) === 'MODULE_NOT_FOUND') {
        const resolvedAspectsAgain = await scope.getResolvedAspects(components, {
          skipIfExists: false
        });
        await aspectLoader.loadRequireableExtensions(resolvedAspectsAgain, true);
      } else {
        throw err;
      }
    }
    return {
      components,
      globalScopeHarmony
    };
  }
  prepareManifests(manifests) {
    return manifests.map(manifest => {
      if (this.isAspect(manifest)) return manifest;
      manifest.runtime = _cli().MainRuntime;
      if (!manifest.id) throw new Error('manifest must have static id');
      const aspect = _harmony().Aspect.create({
        id: manifest.id
      });
      aspect.addRuntime(manifest);
      return aspect;
    });
  }

  /**
   * register a plugin.
   */
  registerPlugins(pluginDefs) {
    this.pluginSlot.register(pluginDefs);
  }
  async loadExtensionsByManifests(extensionsManifests, throwOnError = true, seeders = []) {
    try {
      const manifests = extensionsManifests.filter(manifest => {
        const isValid = this.isValidAspect(manifest);
        if (!isValid) this.logger.warn(`${manifest.id} is invalid. please make sure the extension is valid.`);
        return isValid;
      });
      const preparedManifests = this.prepareManifests(manifests);
      // don't let harmony load all aspects. if seeders were sent, find their manifests, check for their static
      // dependencies, and load only them.
      const getOnlyDeclaredDependenciesManifests = () => {
        if (!seeders.length || seeders.length === preparedManifests.length) {
          return preparedManifests;
        }
        const manifestGraph = this.generateManifestGraph(preparedManifests);
        const nodes = seeders.map(seeder => manifestGraph.successors(seeder)).flat();
        const seederNodes = (0, _lodash().compact)(seeders.map(seeder => manifestGraph.node(seeder)));
        const allNodes = [...nodes, ...seederNodes];
        const nodesUniq = (0, _lodash().uniqBy)(allNodes, 'id');
        return nodesUniq.map(n => n.attr);
      };
      const relevantManifests = getOnlyDeclaredDependenciesManifests();
      // @ts-ignore TODO: fix this
      await this.harmony.load(relevantManifests);
    } catch (e) {
      const ids = extensionsManifests.map(manifest => manifest.id || 'unknown');
      // TODO: improve texts
      const errorMsg = e.message.split('\n')[0];
      const warning = (0, _constants2().UNABLE_TO_LOAD_EXTENSION_FROM_LIST)(ids, errorMsg);
      this.logger.error(warning, e);
      if (this.logger.isLoaderStarted) {
        this.logger.consoleFailure(warning);
      } else {
        this.logger.console(warning);
        this.logger.console(e);
      }
      if (throwOnError) {
        throw e;
      }
    }
  }
  generateManifestGraph(manifests) {
    const graph = new (_graph().Graph)();
    manifests.forEach(manifest => graph.setNode(new (_graph().Node)(manifest.id, manifest)));
    manifests.forEach(manifest => {
      var _manifest$getRuntime, _manifest$getRuntime$;
      const deps = (_manifest$getRuntime = manifest.getRuntime(_cli().MainRuntime)) === null || _manifest$getRuntime === void 0 ? void 0 : (_manifest$getRuntime$ = _manifest$getRuntime.dependencies) === null || _manifest$getRuntime$ === void 0 ? void 0 : _manifest$getRuntime$.map(dep => dep.id);
      deps === null || deps === void 0 ? void 0 : deps.forEach(dep => {
        if (graph.node(dep)) {
          graph.setEdge(new (_graph().Edge)(manifest.id, dep, 'dep'));
        }
      });
    });
    return graph;
  }
  static async provider([loggerExt, envs], config, [onAspectLoadErrorSlot, onLoadRequireableExtensionSlot, pluginSlot], harmony) {
    const logger = loggerExt.createLogger(_aspectLoader().AspectLoaderAspect.id);
    const aspectLoader = new AspectLoaderMain(logger, envs, harmony, onAspectLoadErrorSlot, onLoadRequireableExtensionSlot, pluginSlot);
    return aspectLoader;
  }
}
exports.AspectLoaderMain = AspectLoaderMain;
(0, _defineProperty2().default)(AspectLoaderMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(AspectLoaderMain, "dependencies", [_logger().LoggerAspect, _envs().EnvsAspect]);
(0, _defineProperty2().default)(AspectLoaderMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType()]);
_aspectLoader().AspectLoaderAspect.addRuntime(AspectLoaderMain);
var _default = AspectLoaderMain;
exports.default = _default;

//# sourceMappingURL=aspect-loader.main.runtime.js.map