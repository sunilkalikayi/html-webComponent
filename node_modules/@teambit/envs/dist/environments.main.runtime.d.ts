import { CLIMain } from '@teambit/cli';
import { Component, ComponentMain, ComponentID, AspectData } from '@teambit/component';
import { GraphqlMain } from '@teambit/graphql';
import { Harmony, SlotRegistry } from '@teambit/harmony';
import { Logger, LoggerMain } from '@teambit/logger';
import { ExtensionDataList } from '@teambit/legacy/dist/consumer/config/extension-data';
import { BitId } from '@teambit/legacy-bit-id';
import { EnvService } from './services';
import { Environment } from './environment';
import { Runtime } from './runtime';
import { EnvDefinition } from './env-definition';
import { EnvServiceList } from './env-service-list';
export declare type EnvsRegistry = SlotRegistry<Environment>;
export declare type EnvsConfig = {
    env: string;
    options: EnvOptions;
};
export declare type EnvOptions = {};
export declare type EnvTransformer = (env: Environment) => Environment;
export declare type ServiceSlot = SlotRegistry<Array<EnvService<any>>>;
export declare type Descriptor = {
    id: string;
    icon: string;
    services?: [];
};
export declare const DEFAULT_ENV = "teambit.harmony/node";
export declare class EnvsMain {
    /**
     * environments extension configuration.
     */
    readonly config: EnvsConfig;
    /**
     * harmony context.
     */
    private context;
    /**
     * slot for allowing extensions to register new environment.
     */
    private envSlot;
    private logger;
    private serviceSlot;
    private componentMain;
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    private alreadyShownWarning;
    /**
     * icon of the extension.
     */
    icon(): string;
    constructor(
    /**
     * environments extension configuration.
     */
    config: EnvsConfig, 
    /**
     * harmony context.
     */
    context: Harmony, 
    /**
     * slot for allowing extensions to register new environment.
     */
    envSlot: EnvsRegistry, logger: Logger, serviceSlot: ServiceSlot, componentMain: ComponentMain);
    /**
     * creates a new runtime environments for a set of components.
     */
    createEnvironment(components: Component[]): Promise<Runtime>;
    /**
     * get the configured default env.
     */
    getDefaultEnv(): EnvDefinition;
    getCoreEnvsIds(): string[];
    /**
     * compose a new environment from a list of environment transformers.
     */
    compose(targetEnv: Environment, envTransformers: EnvTransformer[]): Environment;
    /**
     * create an env transformer which overrides specific env properties.
     */
    override(propsToOverride: Environment): EnvTransformer;
    /**
     * compose two environments into one.
     */
    merge<T extends Environment, S extends Environment>(targetEnv: Environment, sourceEnv: Environment): T & S;
    getEnvData(component: Component): AspectData;
    /**
     * Return the id of the env as configured in the envs data (without version by default)
     * The reason it's not contain version by default is that we want to take the version from the aspect defined on the component itself
     * As this version is stay up to date during tagging the env along with the component
     * @param component
     * @param ignoreVersion
     */
    private getEnvIdFromEnvsData;
    /**
     * get the env id of the given component.
     */
    getEnvId(component: Component): string;
    isUsingCoreEnv(component: Component): boolean;
    isCoreEnv(envId: string): boolean;
    /**
     * get the env of the given component.
     * In case you are asking for the env during on load you should use calculateEnv instead
     */
    getEnv(component: Component): EnvDefinition;
    /**
     * get the env component of the given component.
     */
    getEnvComponent(component: Component): Promise<Component>;
    /**
     * get the env component by the env id.
     */
    getEnvComponentByEnvId(envId: string, requesting: string): Promise<Component>;
    /**
     * get the env of the given component.
     * This will try to use the regular getEnv but fallback to the calculate env (in case you are using it during on load)
     * This is safe to be used on onLoad as well
     */
    getOrCalculateEnv(component: Component): EnvDefinition;
    /**
     * get an environment Descriptor.
     */
    getDescriptor(component: Component): Descriptor | null;
    resolveEnv(component: Component, id: string): ComponentID | undefined;
    /**
     * This used to calculate the actual env during the component load.
     * Do not use it to get the env (use getEnv instead)
     * This should be used only during on load
     */
    calculateEnv(component: Component): EnvDefinition;
    /**
     * an env can be configured on a component in two ways:
     * 1) explicitly inside "teambit.envs/envs". `{ "teambit.envs/envs": { "env": "my-env" } }`
     * 2) the env aspect is set on the variant as any other aspect, e.g. `{ "my-env": {} }`
     *
     * this method returns #1 if exists, otherwise, #2.
     */
    getAllEnvsConfiguredOnComponent(component: Component): EnvDefinition[];
    /**
     * whether a component has an env configured (either by variant or .bitmap).
     */
    hasEnvConfigured(component: Component): boolean;
    getAllRegisteredEnvs(): string[];
    /**
     * an env can be configured on a component in two ways:
     * 1) explicitly inside "teambit.envs/envs". `{ "teambit.envs/envs": { "env": "my-env" } }`
     * 2) the env aspect is set on the variant as any other aspect, e.g. `{ "my-env": {} }`
     *
     * this method returns only #1
     */
    getEnvFromEnvsConfig(component: Component): EnvDefinition | undefined;
    /**
     * an env can be configured on a component in two ways:
     * 1) explicitly inside "teambit.envs/envs". `{ "teambit.envs/envs": { "env": "my-env" } }`
     * 2) the env aspect is set on the variant as any other aspect, e.g. `{ "my-env": {} }`
     *
     * this method returns only #2
     */
    getEnvsNotFromEnvsConfig(component: Component): EnvDefinition[];
    /**
     * @deprecated DO NOT USE THIS METHOD ANYMORE!!! (PLEASE USE .calculateEnv() instead!)
     */
    calculateEnvFromExtensions(extensions: ExtensionDataList): EnvDefinition;
    private getEnvIdFromEnvsConfig;
    getEnvDefinitionById(id: ComponentID): EnvDefinition | undefined;
    getEnvDefinitionByLegacyId(id: BitId): Promise<EnvDefinition | undefined>;
    private getEnvDefinitionByStringId;
    getEnvFromComponent(envComponent: Component): EnvDefinition | undefined;
    /**
     * Return the env definition of teambit.envs/env
     */
    getEnvsEnvDefinition(): EnvDefinition;
    private printWarningIfFirstTime;
    /**
     * determines whether an env is registered.
     */
    isEnvRegistered(id: string): boolean;
    isUsingAspectEnv(component: Component): boolean;
    isUsingEnvEnv(component: Component): boolean;
    /**
     * Check if the given component is an env component.
     * @param component
     * @returns
     */
    isEnv(component: Component): boolean;
    /**
     * register a new environment service.
     */
    registerService(...envServices: EnvService<any>[]): this;
    /**
     * get list of services enabled on an env.
     */
    getServices(env: EnvDefinition): EnvServiceList;
    implements(env: EnvDefinition, service: EnvService<any>): boolean;
    /**
     * register an environment.
     */
    registerEnv(env: Environment): void;
    private createRuntime;
    private aggregateByDefs;
    private getEnvAspectDef;
    private throwForDuplicateComponents;
    static slots: (((registerFn: () => string) => SlotRegistry<Environment>) | ((registerFn: () => string) => SlotRegistry<EnvService<any, {}, {}>>))[];
    static dependencies: import("@teambit/harmony").Aspect[];
    static provider([graphql, loggerAspect, component, cli]: [GraphqlMain, LoggerMain, ComponentMain, CLIMain], config: EnvsConfig, [envSlot, serviceSlot]: [EnvsRegistry, ServiceSlot], context: Harmony): Promise<EnvsMain>;
}
