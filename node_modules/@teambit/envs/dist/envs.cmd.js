"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ListEnvsCmd = exports.GetEnvCmd = exports.EnvsCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _react() {
  const data = _interopRequireDefault(require("react"));
  _react = function () {
    return data;
  };
  return data;
}
function _ink() {
  const data = require("ink");
  _ink = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _cliTable() {
  const data = require("@teambit/cli-table");
  _cliTable = function () {
    return data;
  };
  return data;
}
function _envOverview() {
  const data = require("./components/env-overview");
  _envOverview = function () {
    return data;
  };
  return data;
}
// eslint-disable-next-line max-classes-per-file

class ListEnvsCmd {
  constructor(envs, componentAspect) {
    this.envs = envs;
    this.componentAspect = componentAspect;
    (0, _defineProperty2().default)(this, "name", 'list');
    (0, _defineProperty2().default)(this, "description", 'list all envs available in the workspace');
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "group", 'development');
  }
  async report() {
    const allEnvs = this.envs.getAllRegisteredEnvs().join('\n');
    const title = _chalk().default.green('the following envs are available in the workspace:');
    return `${title}\n${allEnvs}`;
  }
}
exports.ListEnvsCmd = ListEnvsCmd;
class GetEnvCmd {
  constructor(envs, componentAspect) {
    this.envs = envs;
    this.componentAspect = componentAspect;
    (0, _defineProperty2().default)(this, "name", 'get <component-name>');
    (0, _defineProperty2().default)(this, "description", "show information about a component's env");
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'component-name',
      description: "the 'component name' or 'component id' of the component its env you'd like to inspect"
    }]);
    (0, _defineProperty2().default)(this, "examples", void 0);
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "group", 'development');
  }
  async showEnv(id, host) {
    const component = await host.get(await host.resolveComponentId(id));
    if (!component) throw new Error(`component for env ${id} was not found`);
    const env = this.envs.getEnv(component);
    const envRuntime = await this.envs.createEnvironment([component]);
    const envExecutionContext = envRuntime.getEnvExecutionContext();
    const services = this.envs.getServices(env);
    const allP = services.services.map(async ([serviceId, service]) => {
      if (service.render) return /*#__PURE__*/_react().default.createElement(_ink().Text, null, /*#__PURE__*/_react().default.createElement(_ink().Text, {
        bold: true,
        underline: true,
        color: "cyan"
      }, serviceId), /*#__PURE__*/_react().default.createElement(_ink().Newline, null), /*#__PURE__*/_react().default.createElement(_ink().Newline, null), await service.render(env, envExecutionContext));
      return /*#__PURE__*/_react().default.createElement(_ink().Text, {
        key: serviceId
      }, /*#__PURE__*/_react().default.createElement(_ink().Text, {
        bold: true,
        underline: true
      }, serviceId));
    });
    const all = await Promise.all(allP);
    return /*#__PURE__*/_react().default.createElement(_ink().Text, null, /*#__PURE__*/_react().default.createElement(_envOverview().EnvOverview, {
      envDef: env
    }), all.map(item => item));
  }
  async render([name]) {
    const host = this.componentAspect.getHost();
    // TODO: think what to do re this line with gilad.
    if (!host) throw new Error('error: workspace not found');
    return this.showEnv(name, host);
  }
}
exports.GetEnvCmd = GetEnvCmd;
class EnvsCmd {
  constructor(envs, componentAspect) {
    this.envs = envs;
    this.componentAspect = componentAspect;
    (0, _defineProperty2().default)(this, "name", 'envs');
    (0, _defineProperty2().default)(this, "alias", 'env');
    (0, _defineProperty2().default)(this, "description", 'list all components maintained by the workspace and their corresponding envs');
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "commands", []);
  }
  async render() {
    const host = this.componentAspect.getHost();
    // TODO: think what to do re this line with gilad.
    if (!host) throw new Error('error: workspace not found');
    const components = await host.list();
    // TODO: refactor to a react table
    return /*#__PURE__*/_react().default.createElement(_ink().Text, null, this.getTable(components));
  }
  getTable(components) {
    const tableData = components.map(component => {
      const envId = this.envs.getEnvId(component);
      return {
        component: component.id.toString(),
        env: envId
      };
    });
    const header = [{
      value: 'component'
    }, {
      value: 'env'
    }];
    const table = _cliTable().CLITable.fromObject(header, tableData);
    table.sort();
    return table.render();
  }
}
exports.EnvsCmd = EnvsCmd;

//# sourceMappingURL=envs.cmd.js.map