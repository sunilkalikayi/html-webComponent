"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnvsMain = exports.DEFAULT_ENV = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = require("@teambit/graphql");
  _graphql = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _findDuplications() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/array/find-duplications"));
  _findDuplications = function () {
    return data;
  };
  return data;
}
function _environments() {
  const data = require("./environments.aspect");
  _environments = function () {
    return data;
  };
  return data;
}
function _environments2() {
  const data = require("./environments.graphql");
  _environments2 = function () {
    return data;
  };
  return data;
}
function _runtime() {
  const data = require("./runtime");
  _runtime = function () {
    return data;
  };
  return data;
}
function _envDefinition() {
  const data = require("./env-definition");
  _envDefinition = function () {
    return data;
  };
  return data;
}
function _envServiceList() {
  const data = require("./env-service-list");
  _envServiceList = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = require("./envs.cmd");
  _envs = function () {
    return data;
  };
  return data;
}
function _env() {
  const data = require("./env.fragment");
  _env = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
const DEFAULT_ENV = 'teambit.harmony/node';
exports.DEFAULT_ENV = DEFAULT_ENV;
class EnvsMain {
  /**
   * icon of the extension.
   */
  icon() {
    return `<svg width="50" height="50" xmlns="http://www.w3.org/2000/svg">
      <circle cx="25" cy="25" r="20"/>
    </svg>`;
  }
  constructor(
  /**
   * environments extension configuration.
   */
  config,
  /**
   * harmony context.
   */
  context,
  /**
   * slot for allowing extensions to register new environment.
   */
  envSlot, logger, serviceSlot, componentMain) {
    this.config = config;
    this.context = context;
    this.envSlot = envSlot;
    this.logger = logger;
    this.serviceSlot = serviceSlot;
    this.componentMain = componentMain;
    (0, _defineProperty2().default)(this, "alreadyShownWarning", {});
  }

  /**
   * creates a new runtime environments for a set of components.
   */
  async createEnvironment(components) {
    return this.createRuntime(components);
  }

  /**
   * get the configured default env.
   */
  getDefaultEnv() {
    const defaultEnv = this.envSlot.get(DEFAULT_ENV);
    if (!defaultEnv) throw new Error('default env must be set.');
    return new (_envDefinition().EnvDefinition)(DEFAULT_ENV, defaultEnv);
  }
  getCoreEnvsIds() {
    return ['teambit.harmony/aspect', 'teambit.react/react', 'teambit.harmony/node', 'teambit.react/react-native', 'teambit.html/html', 'teambit.mdx/mdx', 'teambit.envs/env', 'teambit.mdx/readme'];
  }

  /**
   * compose a new environment from a list of environment transformers.
   */
  compose(targetEnv, envTransformers) {
    const a = envTransformers.reduce((acc, transformer) => {
      acc = transformer(acc);
      return acc;
    }, targetEnv);
    return a;
  }

  /**
   * create an env transformer which overrides specific env properties.
   */
  override(propsToOverride) {
    return env => {
      return this.merge(propsToOverride, env);
    };
  }

  /**
   * compose two environments into one.
   */
  merge(targetEnv, sourceEnv) {
    const allNames = new Set();
    const keys = ['icon', 'name', 'description'];
    for (let o = sourceEnv; o !== Object.prototype; o = Object.getPrototypeOf(o)) {
      for (const name of Object.getOwnPropertyNames(o)) {
        allNames.add(name);
      }
    }
    allNames.forEach(key => {
      const fn = sourceEnv[key];
      if (targetEnv[key]) return;
      if (keys.includes(key)) targetEnv[key] = fn;
      if (!fn || !fn.bind) {
        return;
      }
      targetEnv[key] = fn.bind(sourceEnv);
    });
    return targetEnv;
  }
  getEnvData(component) {
    let envsData = component.state.aspects.get(_environments().EnvsAspect.id);
    if (!envsData) {
      // TODO: remove this once we re-export old components used to store the data here
      envsData = component.state.aspects.get('teambit.workspace/workspace');
    }
    if (!envsData) throw new Error(`env was not configured on component ${component.id.toString()}`);
    return envsData.data;
  }

  /**
   * Return the id of the env as configured in the envs data (without version by default)
   * The reason it's not contain version by default is that we want to take the version from the aspect defined on the component itself
   * As this version is stay up to date during tagging the env along with the component
   * @param component
   * @param ignoreVersion
   */
  getEnvIdFromEnvsData(component, ignoreVersion = true) {
    const envsData = this.getEnvData(component);
    if (!envsData) return undefined;
    const rawEnvId = envsData.id;
    if (!rawEnvId) return undefined;
    if (!ignoreVersion) return rawEnvId;
    const envIdWithoutVersion = _component().ComponentID.fromString(rawEnvId).toStringWithoutVersion();
    return envIdWithoutVersion;
  }

  /**
   * get the env id of the given component.
   */
  getEnvId(component) {
    const envIdFromEnvData = this.getEnvIdFromEnvsData(component);
    if (!envIdFromEnvData) {
      // This should never happen
      throw new Error(`no env found for ${component.id.toString()}`);
    }
    const withVersion = this.resolveEnv(component, envIdFromEnvData);
    const withVersionMatch = this.envSlot.toArray().find(([envId]) => {
      return (withVersion === null || withVersion === void 0 ? void 0 : withVersion.toString()) === envId;
    });
    const withVersionMatchId = withVersionMatch === null || withVersionMatch === void 0 ? void 0 : withVersionMatch[0];
    if (withVersionMatchId) return withVersionMatchId;

    // Handle core envs
    const exactMatch = this.envSlot.toArray().find(([envId]) => {
      return envIdFromEnvData === envId;
    });
    const exactMatchId = exactMatch === null || exactMatch === void 0 ? void 0 : exactMatch[0];
    if (exactMatchId) return exactMatchId;
    if (!withVersion) throw new (_exceptions().EnvNotConfiguredForComponent)(envIdFromEnvData, component.id.toString());
    return withVersion.toString();
  }
  isUsingCoreEnv(component) {
    const envId = this.getEnvId(component);
    return this.isCoreEnv(envId);
  }
  isCoreEnv(envId) {
    return this.getCoreEnvsIds().includes(envId);
  }

  /**
   * get the env of the given component.
   * In case you are asking for the env during on load you should use calculateEnv instead
   */
  getEnv(component) {
    const id = this.getEnvId(component);
    const envDef = this.getEnvDefinitionByStringId(id);
    if (envDef) {
      return envDef;
    }
    // Do not allow a non existing env
    throw new (_exceptions().EnvNotFound)(id, component.id.toString());
  }

  /**
   * get the env component of the given component.
   */
  async getEnvComponent(component) {
    const envId = this.getEnvId(component);
    return this.getEnvComponentByEnvId(envId, component.id.toString());
  }

  /**
   * get the env component by the env id.
   */
  async getEnvComponentByEnvId(envId, requesting) {
    const host = this.componentMain.getHost();
    const newId = await host.resolveComponentId(envId);
    const envComponent = await host.get(newId);
    if (!envComponent) {
      throw new (_bitError().BitError)(`can't load env. env id is ${envId} used by component ${requesting}`);
    }
    return envComponent;
  }

  /**
   * get the env of the given component.
   * This will try to use the regular getEnv but fallback to the calculate env (in case you are using it during on load)
   * This is safe to be used on onLoad as well
   */
  getOrCalculateEnv(component) {
    try {
      return this.getEnv(component);
    } catch (err) {
      return this.calculateEnv(component);
    }
  }

  /**
   * get an environment Descriptor.
   */
  getDescriptor(component) {
    const envsData = this.getEnvData(component);
    return {
      id: envsData.id,
      icon: envsData.icon,
      services: envsData.services
    };
  }
  resolveEnv(component, id) {
    const matchedEntry = component.state.aspects.entries.find(aspectEntry => {
      return id === aspectEntry.id.toString() || id === aspectEntry.id.toString({
        ignoreVersion: true
      });
    });
    return matchedEntry === null || matchedEntry === void 0 ? void 0 : matchedEntry.id;
  }

  /**
   * This used to calculate the actual env during the component load.
   * Do not use it to get the env (use getEnv instead)
   * This should be used only during on load
   */
  calculateEnv(component) {
    // Search first for env configured via envs aspect itself
    const envIdFromEnvsConfig = this.getEnvIdFromEnvsConfig(component);
    let envIdFromEnvsConfigWithoutVersion;
    if (envIdFromEnvsConfig) {
      envIdFromEnvsConfigWithoutVersion = _component().ComponentID.fromString(envIdFromEnvsConfig).toStringWithoutVersion();
      const envDef = this.getEnvDefinitionByStringId(envIdFromEnvsConfigWithoutVersion);
      if (envDef) {
        return envDef;
      }
    }

    // in some cases we have the id configured in the teambit.envs/envs but without the version
    // in such cases we won't find it in the slot
    // we search in the component aspect list a matching aspect which is match the id from the teambit.envs/envs
    if (envIdFromEnvsConfigWithoutVersion) {
      const matchedEntry = component.state.aspects.entries.find(aspectEntry => {
        return envIdFromEnvsConfigWithoutVersion === aspectEntry.id.toString() || envIdFromEnvsConfigWithoutVersion === aspectEntry.id.toString({
          ignoreVersion: true
        });
      });
      if (matchedEntry) {
        // during the tag process, the version in the aspect-entry-id is changed and is not the
        // same as it was when it registered to the slot.
        const envDef = this.getEnvDefinitionById(matchedEntry.id);
        if (envDef) {
          return envDef;
        }
        // Do not allow a non existing env
        this.printWarningIfFirstTime(matchedEntry.id.toString(), `environment with ID: ${matchedEntry.id.toString()} configured on component ${component.id.toString()} was not found`);
      }
      // Do not allow configure teambit.envs/envs on the component without configure the env aspect itself
      const errMsg = new (_exceptions().EnvNotConfiguredForComponent)(envIdFromEnvsConfig, component.id.toString()).message;
      this.printWarningIfFirstTime(envIdFromEnvsConfig, errMsg);
    }

    // in case there is no config in teambit.envs/envs search the aspects for the first env that registered as env
    let envDefFromList;
    component.state.aspects.entries.find(aspectEntry => {
      const envDef = this.getEnvDefinitionById(aspectEntry.id);
      if (envDef) {
        envDefFromList = envDef;
      }
      return !!envDef;
    });
    if (envDefFromList) {
      return envDefFromList;
    }
    return this.getDefaultEnv();
  }

  /**
   * an env can be configured on a component in two ways:
   * 1) explicitly inside "teambit.envs/envs". `{ "teambit.envs/envs": { "env": "my-env" } }`
   * 2) the env aspect is set on the variant as any other aspect, e.g. `{ "my-env": {} }`
   *
   * this method returns #1 if exists, otherwise, #2.
   */
  getAllEnvsConfiguredOnComponent(component) {
    // if a component has "envs" config, use it and ignore other components that are set up
    // in this components which happen to be envs.
    const envDef = this.getEnvFromEnvsConfig(component);
    if (envDef) {
      return [envDef];
    }
    return this.getEnvsNotFromEnvsConfig(component);
  }

  /**
   * whether a component has an env configured (either by variant or .bitmap).
   */
  hasEnvConfigured(component) {
    return Boolean(this.getAllEnvsConfiguredOnComponent(component).length);
  }
  getAllRegisteredEnvs() {
    return this.envSlot.toArray().map(envData => envData[0]);
  }

  /**
   * an env can be configured on a component in two ways:
   * 1) explicitly inside "teambit.envs/envs". `{ "teambit.envs/envs": { "env": "my-env" } }`
   * 2) the env aspect is set on the variant as any other aspect, e.g. `{ "my-env": {} }`
   *
   * this method returns only #1
   */
  getEnvFromEnvsConfig(component) {
    const envIdFromEnvsConfig = this.getEnvIdFromEnvsConfig(component);
    if (!envIdFromEnvsConfig) {
      return undefined;
    }
    const envIdFromEnvsConfigWithoutVersion = _component().ComponentID.fromString(envIdFromEnvsConfig).toStringWithoutVersion();
    const envDef = this.getEnvDefinitionByStringId(envIdFromEnvsConfigWithoutVersion);
    return envDef;
  }

  /**
   * an env can be configured on a component in two ways:
   * 1) explicitly inside "teambit.envs/envs". `{ "teambit.envs/envs": { "env": "my-env" } }`
   * 2) the env aspect is set on the variant as any other aspect, e.g. `{ "my-env": {} }`
   *
   * this method returns only #2
   */
  getEnvsNotFromEnvsConfig(component) {
    return component.state.aspects.entries.reduce((acc, aspectEntry) => {
      const envDef = this.getEnvDefinitionById(aspectEntry.id);
      if (envDef) acc.push(envDef);
      return acc;
    }, []);
  }

  /**
   * @deprecated DO NOT USE THIS METHOD ANYMORE!!! (PLEASE USE .calculateEnv() instead!)
   */
  calculateEnvFromExtensions(extensions) {
    // Search first for env configured via envs aspect itself
    const envsAspect = extensions.findCoreExtension(_environments().EnvsAspect.id);
    const envIdFromEnvsConfig = envsAspect === null || envsAspect === void 0 ? void 0 : envsAspect.config.env;
    let envIdFromEnvsConfigWithoutVersion;
    if (envIdFromEnvsConfig) {
      envIdFromEnvsConfigWithoutVersion = _component().ComponentID.fromString(envIdFromEnvsConfig).toStringWithoutVersion();
      const envDef = this.getEnvDefinitionByStringId(envIdFromEnvsConfigWithoutVersion);
      if (envDef) {
        return envDef;
      }
    }
    const getEnvDefinitionByLegacyExtension = extension => {
      const envDef = extension.newExtensionId ? this.getEnvDefinitionById(extension.newExtensionId) : this.getEnvDefinitionByStringId(extension.stringId);
      return envDef;
    };

    // in some cases we have the id configured in the teambit.envs/envs but without the version
    // in such cases we won't find it in the slot
    // we search in the component aspect list a matching aspect which is match the id from the teambit.envs/envs
    if (envIdFromEnvsConfigWithoutVersion) {
      const matchedEntry = extensions.find(extension => {
        if (extension.newExtensionId) {
          return envIdFromEnvsConfigWithoutVersion === extension.newExtensionId.toString() || envIdFromEnvsConfigWithoutVersion === extension.newExtensionId.toString({
            ignoreVersion: true
          });
        }
        return envIdFromEnvsConfigWithoutVersion === extension.stringId;
      });
      if (matchedEntry) {
        // during the tag process, the version in the aspect-entry-id is changed and is not the
        // same as it was when it registered to the slot.
        const envDef = getEnvDefinitionByLegacyExtension(matchedEntry);
        if (envDef) {
          return envDef;
        }
        // Do not allow a non existing env
        this.printWarningIfFirstTime(matchedEntry.id.toString(), `environment with ID: ${matchedEntry.id.toString()} was not found`);
      }
      // Do not allow configure teambit.envs/envs on the component without configure the env aspect itself
      const errMsg = new (_exceptions().EnvNotConfiguredForComponent)(envIdFromEnvsConfig).message;
      this.printWarningIfFirstTime(envIdFromEnvsConfig, errMsg);
    }

    // in case there is no config in teambit.envs/envs search the aspects for the first env that registered as env
    let envDefFromList;
    extensions.find(extension => {
      const envDef = getEnvDefinitionByLegacyExtension(extension);
      if (envDef) {
        envDefFromList = envDef;
      }
      return !!envDef;
    });
    if (envDefFromList) {
      return envDefFromList;
    }
    return this.getDefaultEnv();
  }
  getEnvIdFromEnvsConfig(component) {
    const envsAspect = component.state.aspects.get(_environments().EnvsAspect.id);
    return envsAspect === null || envsAspect === void 0 ? void 0 : envsAspect.config.env;
  }
  getEnvDefinitionById(id) {
    const envDef = this.getEnvDefinitionByStringId(id.toString()) || this.getEnvDefinitionByStringId(id.toString({
      ignoreVersion: true
    }));
    return envDef;
  }
  async getEnvDefinitionByLegacyId(id) {
    const host = this.componentMain.getHost();
    const newId = await host.resolveComponentId(id);
    return this.getEnvDefinitionById(newId);
  }
  getEnvDefinitionByStringId(envId) {
    const env = this.envSlot.get(envId);
    if (env) {
      return new (_envDefinition().EnvDefinition)(envId, env);
    }
    return undefined;
  }
  getEnvFromComponent(envComponent) {
    const env = this.getEnvDefinitionById(envComponent.id);
    return env;
  }

  /**
   * Return the env definition of teambit.envs/env
   */
  getEnvsEnvDefinition() {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.getEnvDefinitionByStringId('teambit.envs/env');
  }
  printWarningIfFirstTime(envId, message) {
    if (!this.alreadyShownWarning[envId]) {
      this.alreadyShownWarning[envId] = true;
      this.logger.consoleWarning(message);
    }
  }

  /**
   * determines whether an env is registered.
   */
  isEnvRegistered(id) {
    return Boolean(this.envSlot.get(id));
  }
  isUsingAspectEnv(component) {
    const data = this.getEnvData(component);
    if (!data) return false;
    return data.type === 'aspect';
  }
  isUsingEnvEnv(component) {
    const data = this.getEnvData(component);
    if (!data) return false;
    return data.type === 'env';
  }

  /**
   * Check if the given component is an env component.
   * @param component
   * @returns
   */
  isEnv(component) {
    return this.isUsingEnvEnv(component) || this.isEnvRegistered(component.id.toString());
  }

  /**
   * register a new environment service.
   */
  registerService(...envServices) {
    this.serviceSlot.register(envServices);
    return this;
  }

  /**
   * get list of services enabled on an env.
   */
  getServices(env) {
    const allServices = this.serviceSlot.toArray();
    const services = [];
    allServices.forEach(([id, currentServices]) => {
      currentServices.forEach(service => {
        if (this.implements(env, service)) {
          services.push([id, service]);
        }
      });
    });
    return new (_envServiceList().EnvServiceList)(env, services);
  }
  implements(env, service) {
    // TODO: remove this after refactoring everything and remove getDescriptor from being optional.
    if (!service.getDescriptor) return false;
    return !!service.getDescriptor(env);
  }

  /**
   * register an environment.
   */
  registerEnv(env) {
    return this.envSlot.register(env);
  }

  // refactor here
  async createRuntime(components) {
    return new (_runtime().Runtime)(await this.aggregateByDefs(components), this.logger);
  }

  // :TODO can be refactored to few utilities who will make repeating this very easy.
  async aggregateByDefs(components) {
    this.throwForDuplicateComponents(components);
    const envsMap = {};
    components.forEach(component => {
      const envDef = this.getEnv(component);
      const envId = envDef.id;
      const env = envDef.env;
      // handle config as well when aggregating envs.
      if (envsMap[envId]) envsMap[envId].components.push(component);else envsMap[envId] = {
        components: [component],
        env
      };
    });
    return Promise.all(Object.keys(envsMap).map(async key => {
      const envAspectDef = await this.getEnvAspectDef(key);
      return new (_runtime().EnvRuntime)(key, envsMap[key].env, envsMap[key].components, envAspectDef);
    }));
  }
  async getEnvAspectDef(envId) {
    const host = this.componentMain.getHost();
    const id = await host.resolveComponentId(envId);
    const def = (await host.resolveAspects(_cli().MainRuntime.name, [id], {
      requestedOnly: true
    }))[0];
    return def;
  }
  throwForDuplicateComponents(components) {
    const idsStr = components.map(c => c.id.toString());
    const duplications = (0, _findDuplications().default)(idsStr);
    if (duplications.length) {
      throw new Error(`found duplicated components: ${duplications.join(', ')}`);
    }
  }
  static async provider([graphql, loggerAspect, component, cli], config, [envSlot, serviceSlot], context) {
    const logger = loggerAspect.createLogger(_environments().EnvsAspect.id);
    const envs = new EnvsMain(config, context, envSlot, logger, serviceSlot, component);
    component.registerShowFragments([new (_env().EnvFragment)(envs)]);
    const envsCmd = new (_envs().EnvsCmd)(envs, component);
    envsCmd.commands = [new (_envs().ListEnvsCmd)(envs, component), new (_envs().GetEnvCmd)(envs, component)];
    cli.register(envsCmd);
    graphql.register((0, _environments2().environmentsSchema)(envs));
    return envs;
  }
}
exports.EnvsMain = EnvsMain;
(0, _defineProperty2().default)(EnvsMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(EnvsMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(EnvsMain, "dependencies", [_graphql().GraphqlAspect, _logger().LoggerAspect, _component().ComponentAspect, _cli().CLIAspect]);
_environments().EnvsAspect.addRuntime(EnvsMain);

//# sourceMappingURL=environments.main.runtime.js.map