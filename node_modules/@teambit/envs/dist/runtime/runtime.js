"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Runtime = void 0;
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("../exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _context() {
  const data = require("../context");
  _context = function () {
    return data;
  };
  return data;
}
function _envsExecutionResult() {
  const data = require("./envs-execution-result");
  _envsExecutionResult = function () {
    return data;
  };
  return data;
}
class Runtime {
  constructor(
  /**
   * runtime instances of the environments.
   */
  runtimeEnvs, logger) {
    this.runtimeEnvs = runtimeEnvs;
    this.logger = logger;
  }

  /**
   * execute a service on a specific env.
   */
  runEnv(envRuntimeId, service, options) {
    const envRuntime = this.runtimeEnvs.find(runtime => {
      const id = _component().ComponentID.fromString(runtime.id);
      const withoutVersion = id._legacy.toStringWithoutVersion();
      return withoutVersion === envRuntimeId;
    });
    if (!envRuntime) throw new (_exceptions().EnvNotFoundInRuntime)(envRuntimeId);
    return this.run(service, options, [envRuntime]);
  }

  /**
   * execute a service once for all environments.
   */
  async runOnce(service, options) {
    if (!service.runOnce) throw new Error('a service must implement `runOnce()` in order to be executed');
    const envsExecutionContext = this.getEnvExecutionContext();
    const serviceResult = await service.runOnce(envsExecutionContext, options);
    return serviceResult;
  }
  getEnvExecutionContext() {
    const envsExecutionContext = this.runtimeEnvs.map(env => new (_context().ExecutionContext)(this, env));
    return envsExecutionContext;
  }

  /**
   * execute a service on each one of the environments.
   */
  async run(
  /**
   * environment service to execute.
   */
  service,
  /**
   * options to proxy to the service upon execution.
   */
  options, runtimes) {
    if (!service.run) throw new Error('a service must implement `run()` in order to be executed');
    const errors = [];
    const contexts = await (0, _pMapSeries().default)(runtimes || this.runtimeEnvs, async env => {
      try {
        // @ts-ignore
        const serviceResult = await service.run(new (_context().ExecutionContext)(this, env), options);
        return {
          env,
          data: serviceResult
        };
      } catch (err) {
        this.logger.error(err.message, err);
        this.logger.consoleFailure(`service "${service.name}" of env "${env.id}" has failed. error: ${err.message}`);
        errors.push(err);
        return {
          env,
          error: err
        };
      }
    });
    return new (_envsExecutionResult().EnvsExecutionResult)(contexts);
  }
}
exports.Runtime = Runtime;

//# sourceMappingURL=runtime.js.map