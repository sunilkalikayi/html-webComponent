"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AspectMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _aspectLoader() {
  const data = require("@teambit/aspect-loader");
  _aspectLoader = function () {
    return data;
  };
  return data;
}
function _mergeDeepLeft() {
  const data = _interopRequireDefault(require("ramda/src/mergeDeepLeft"));
  _mergeDeepLeft = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("@teambit/builder");
  _builder = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = require("@teambit/envs");
  _envs = function () {
    return data;
  };
  return data;
}
function _react() {
  const data = require("@teambit/react");
  _react = function () {
    return data;
  };
  return data;
}
function _generator() {
  const data = require("@teambit/generator");
  _generator = function () {
    return data;
  };
  return data;
}
function _babel() {
  const data = require("@teambit/babel");
  _babel = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _compiler() {
  const data = require("@teambit/compiler");
  _compiler = function () {
    return data;
  };
  return data;
}
function _aspect() {
  const data = require("./aspect.aspect");
  _aspect = function () {
    return data;
  };
  return data;
}
function _aspect2() {
  const data = require("./aspect.env");
  _aspect2 = function () {
    return data;
  };
  return data;
}
function _coreExporter() {
  const data = require("./core-exporter.task");
  _coreExporter = function () {
    return data;
  };
  return data;
}
function _aspect3() {
  const data = require("./templates/aspect");
  _aspect3 = function () {
    return data;
  };
  return data;
}
function _babelConfig() {
  const data = require("./babel/babel-config");
  _babelConfig = function () {
    return data;
  };
  return data;
}
function _aspect4() {
  const data = require("./aspect.cmd");
  _aspect4 = function () {
    return data;
  };
  return data;
}
const tsconfig = require('./typescript/tsconfig.json');
class AspectMain {
  constructor(aspectEnv, envs, workspace) {
    this.aspectEnv = aspectEnv;
    this.envs = envs;
    this.workspace = workspace;
  }

  /**
   * compose your own aspect environment.
   */
  compose(transformers = [], targetEnv = {}) {
    return this.envs.compose(this.envs.merge(targetEnv, this.aspectEnv), transformers);
  }
  async listAspectsOfComponent(pattern) {
    const getIds = async () => {
      if (!pattern) return this.workspace.listIds();
      return this.workspace.idsByPattern(pattern);
    };
    const componentIds = await getIds();
    const results = {};
    await Promise.all(componentIds.map(async id => {
      const aspectSources = await this.getAspectNamesForComponent(id);
      results[id.toString()] = aspectSources;
    }));
    return results;
  }
  get babelConfig() {
    return _babelConfig().babelConfig;
  }
  async getAspectNamesForComponent(id) {
    const componentFromScope = await this.workspace.scope.get(id);
    const {
      beforeMerge
    } = await this.workspace.componentExtensions(id, componentFromScope);
    const aspectSources = [];
    beforeMerge.forEach(source => {
      source.extensions.forEach(ext => {
        var _ext$extensionId;
        const aspectName = ext.name || ((_ext$extensionId = ext.extensionId) === null || _ext$extensionId === void 0 ? void 0 : _ext$extensionId.toString()) || '<no-name>';
        const alreadySaved = aspectSources.find(_ => _.aspectName === aspectName);
        if (alreadySaved) return;
        aspectSources.push({
          aspectName,
          source: source.origin,
          level: this.getLevelBySourceOrigin(source.origin)
        });
      });
    });
    return aspectSources;
  }
  getLevelBySourceOrigin(origin) {
    switch (origin) {
      case 'BitmapFile':
      case 'ComponentJsonFile':
      case 'ModelSpecific':
        return 'component';
      default:
        return 'workspace';
    }
  }
  async setAspectsToComponents(pattern, aspectId, config = {}, options = {}) {
    const componentIds = await this.workspace.idsByPattern(pattern);
    await Promise.all(componentIds.map(async componentId => {
      await this.workspace.addSpecificComponentConfig(componentId, aspectId, config, options.merge);
    }));
    await this.workspace.bitMap.write();
    return componentIds;
  }
  async unsetAspectsFromComponents(pattern, aspectId) {
    const componentIds = await this.workspace.idsByPattern(pattern);
    await Promise.all(componentIds.map(async componentId => {
      await this.workspace.removeSpecificComponentConfig(componentId, aspectId, true);
    }));
    await this.workspace.bitMap.write();
    return componentIds;
  }

  /**
   * returns all aspects info of a component, include the config and the data.
   */
  async getAspectsOfComponent(id) {
    if (typeof id === 'string') {
      id = await this.workspace.resolveComponentId(id);
    }
    const component = await this.workspace.get(id);
    return component.state.aspects;
  }

  /**
   * helps debugging why/how an aspect was set to a component
   */
  async getAspectsOfComponentForDebugging(id) {
    if (typeof id === 'string') {
      id = await this.workspace.resolveComponentId(id);
    }
    const componentFromScope = await this.workspace.scope.get(id);
    const {
      extensions,
      beforeMerge
    } = await this.workspace.componentExtensions(id, componentFromScope);
    const component = await this.workspace.get(id);
    return {
      aspects: component.state.aspects,
      extensions,
      beforeMerge
    };
  }
  async updateAspectsToComponents(aspectId, pattern) {
    let aspectCompId = await this.workspace.resolveComponentId(aspectId);
    if (!aspectCompId.hasVersion()) {
      try {
        const fromRemote = await this.workspace.scope.getRemoteComponent(aspectCompId);
        aspectCompId = aspectCompId.changeVersion(fromRemote.id.version);
      } catch (err) {
        throw new (_bitError().BitError)(`unable to find ${aspectId} in the remote. if this is a local aspect, please provide a version with your aspect (${aspectId}) to update to`);
      }
    }
    const allCompIds = pattern ? await this.workspace.idsByPattern(pattern) : await this.workspace.listIds();
    const allComps = await this.workspace.getMany(allCompIds);
    const alreadyUpToDate = [];
    const updatedComponentIds = await Promise.all(allComps.map(async comp => {
      const aspect = comp.state.aspects.get(aspectCompId.toStringWithoutVersion());
      if (!aspect) return undefined;
      if (aspect.id.version === aspectCompId.version) {
        // nothing to update
        alreadyUpToDate.push(comp.id);
        return undefined;
      }
      // don't mark with minus if not exist in .bitmap. it's not needed. when the component is loaded, the
      // merge-operation of the aspects removes duplicate aspect-id with different versions.
      await this.workspace.removeSpecificComponentConfig(comp.id, aspect.id.toString(), false);
      await this.workspace.addSpecificComponentConfig(comp.id, aspectCompId.toString(), aspect.config);
      return comp.id;
    }));
    await this.workspace.bitMap.write();
    return {
      updated: (0, _lodash().compact)(updatedComponentIds),
      alreadyUpToDate
    };
  }

  /**
   * override the dependency configuration of the component environment.
   */
  overrideDependencies(dependencyPolicy) {
    return this.envs.override({
      getDependencies: async () => {
        const reactDeps = await this.aspectEnv.getDependencies();
        return (0, _mergeDeepLeft().default)(dependencyPolicy, reactDeps);
      }
    });
  }
  static async provider([react, envs, builder, aspectLoader, compiler, babel, generator, workspace, cli]) {
    const babelCompiler = babel.createCompiler({
      babelTransformOptions: _babelConfig().babelConfig,
      distDir: 'dist',
      distGlobPatterns: [`dist/**`, `!dist/**/*.d.ts`, `!dist/tsconfig.tsbuildinfo`]
    });
    const compilerOverride = envs.override({
      getCompiler: () => {
        return babelCompiler;
      }
    });
    const transformer = config => {
      config.mergeTsConfig(tsconfig).setArtifactName('declaration').setDistGlobPatterns([`dist/**/*.d.ts`]).setShouldCopyNonSupportedFiles(false);
      return config;
    };
    const tsCompiler = react.env.getCjsCompilerTask([transformer]);
    const compilerTasksOverride = react.overrideCompilerTasks([compiler.createTask('BabelCompiler', babelCompiler), tsCompiler]);
    const aspectEnv = react.compose([compilerOverride, compilerTasksOverride], new (_aspect2().AspectEnv)(react.reactEnv, aspectLoader));
    const coreExporterTask = new (_coreExporter().CoreExporterTask)(aspectEnv, aspectLoader);
    if (!__dirname.includes('@teambit/bit')) {
      builder.registerBuildTasks([coreExporterTask]);
    }
    envs.registerEnv(aspectEnv);
    generator.registerComponentTemplate([_aspect3().aspectTemplate]);
    const aspectMain = new AspectMain(aspectEnv, envs, workspace);
    const aspectCmd = new (_aspect4().AspectCmd)();
    aspectCmd.commands = [new (_aspect4().ListAspectCmd)(aspectMain), new (_aspect4().GetAspectCmd)(aspectMain), new (_aspect4().SetAspectCmd)(aspectMain), new (_aspect4().UnsetAspectCmd)(aspectMain), new (_aspect4().UpdateAspectCmd)(aspectMain)];
    cli.register(aspectCmd);
    return aspectMain;
  }
}
exports.AspectMain = AspectMain;
(0, _defineProperty2().default)(AspectMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(AspectMain, "dependencies", [_react().ReactAspect, _envs().EnvsAspect, _builder().BuilderAspect, _aspectLoader().AspectLoaderAspect, _compiler().CompilerAspect, _babel().BabelAspect, _generator().GeneratorAspect, _workspace().default, _cli().CLIAspect]);
_aspect().AspectAspect.addRuntime(AspectMain);

//# sourceMappingURL=aspect.main.runtime.js.map