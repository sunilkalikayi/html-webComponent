"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UpdateAspectCmd = exports.UnsetAspectCmd = exports.SetAspectCmd = exports.ListAspectCmd = exports.GetAspectCmd = exports.AspectCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cliTable() {
  const data = require("@teambit/cli-table");
  _cliTable = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
// eslint-disable-next-line max-classes-per-file

class ListAspectCmd {
  constructor(aspect) {
    this.aspect = aspect;
    (0, _defineProperty2().default)(this, "name", 'list [pattern]');
    (0, _defineProperty2().default)(this, "description", 'list all aspects configured on component(s)');
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'pattern',
      description: 'component name, component id, or component pattern. use component pattern to select multiple components. \nuse comma to separate patterns and "!" to exclude. e.g. "ui/**, !ui/button"\nwrap the pattern with quotes'
    }]);
    (0, _defineProperty2().default)(this, "options", [['d', 'debug', 'show the origins were the aspects were taken from']]);
    (0, _defineProperty2().default)(this, "group", 'development');
  }
  async report([name], {
    debug
  }) {
    const listAspectsResults = await this.aspect.listAspectsOfComponent(name);
    const rows = Object.keys(listAspectsResults).map(componentId => {
      const longestAspectName = Math.max(...listAspectsResults[componentId].map(_ => _.aspectName.length));
      const aspects = listAspectsResults[componentId].map(aspectSource => {
        const origin = debug ? ` (origin: ${aspectSource.source})` : '';
        const aspectName = aspectSource.aspectName.padEnd(longestAspectName);
        return `${aspectName} (level: ${aspectSource.level})${origin}`;
      }).join('\n');
      return [componentId, aspects];
    });
    const table = new (_cliTable().CLITable)([], rows);
    return table.render();
  }
}
exports.ListAspectCmd = ListAspectCmd;
class SetAspectCmd {
  constructor(aspect) {
    this.aspect = aspect;
    (0, _defineProperty2().default)(this, "name", 'set <pattern> <aspect-id> [config]');
    (0, _defineProperty2().default)(this, "description", 'set components with an aspect to extend their development tools, metadata and (possibly) artifacts');
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'pattern',
      description: 'the components to extend. use component name, component id, or component pattern. use component pattern to select multiple components. use comma to separate patterns and "!" to exclude. e.g. "ui/**, !ui/button". wrap the pattern with quotes'
    }, {
      name: 'aspect-id',
      description: "the aspect's component id"
    }, {
      name: 'config',
      description: `the aspect config. enter the config as a stringified JSON (e.g. '{"foo":"bar"}' ). when no config is provided, an aspect is set with an empty config ({}).`
    }]);
    (0, _defineProperty2().default)(this, "options", [['m', 'merge', 'merge with an existing config if exits. (by default, it replaces the config)']]);
    (0, _defineProperty2().default)(this, "group", 'development');
  }
  async report([pattern, aspectId, config], options) {
    const configParsed = config ? JSON.parse(config) : {};
    const results = await this.aspect.setAspectsToComponents(pattern, aspectId, configParsed, options);
    if (!results.length) return _chalk().default.yellow(`unable to find any matching for ${_chalk().default.bold(pattern)} pattern`);
    return _chalk().default.green(`the following component(s) have been successfully updated:\n${results.join('\n')}`);
  }
}
exports.SetAspectCmd = SetAspectCmd;
class UpdateAspectCmd {
  constructor(aspect) {
    this.aspect = aspect;
    (0, _defineProperty2().default)(this, "name", 'update <aspect-id> [pattern]');
    (0, _defineProperty2().default)(this, "description", 'update a version of an aspect');
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'aspect-id',
      description: "the aspect's component id. optionally, add a version (id@version), otherwise, it finds the latest version on the remote"
    }, {
      name: 'pattern',
      description: 'the components to update (defaults to all components). use component name, component id, or component pattern. use component pattern to select multiple components. use comma to separate patterns and "!" to exclude. e.g. "ui/**, !ui/button". wrap the pattern with quotes'
    }]);
    (0, _defineProperty2().default)(this, "examples", [{
      cmd: "update scope.org/aspect '**/ui/**'",
      description: 'update "ui" components that use scope.org/aspect to use its latest version'
    }, {
      cmd: 'bit aspect update scope.org/aspect@2.0.0',
      description: 'update all components that use scope.org/aspect to version 2.0.0 (of this aspect).'
    }]);
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "group", 'development');
  }
  async report([aspectId, pattern]) {
    const {
      updated,
      alreadyUpToDate
    } = await this.aspect.updateAspectsToComponents(aspectId, pattern);
    if (updated.length) {
      return _chalk().default.green(`the following component(s) have been successfully updated:\n${updated.join('\n')}`);
    }
    if (alreadyUpToDate.length) {
      return _chalk().default.green(`all ${alreadyUpToDate.length} component(s) that use this aspect are already up to date. nothing to update`);
    }
    return _chalk().default.yellow(`unable to find any component that use ${_chalk().default.bold(aspectId)}`);
  }
}
exports.UpdateAspectCmd = UpdateAspectCmd;
class UnsetAspectCmd {
  constructor(aspect) {
    this.aspect = aspect;
    (0, _defineProperty2().default)(this, "name", 'unset <pattern> <aspect-id>');
    (0, _defineProperty2().default)(this, "description", `unset an aspect from component(s).`);
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'pattern',
      description: 'the components to target. use component name, component id, or component pattern. use component pattern to select multiple components. use comma to separate patterns and "!" to exclude. e.g. "ui/**, !ui/button". wrap the pattern with quotes'
    }, {
      name: 'aspect-id',
      description: "the aspect's component id"
    }]);
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "group", 'development');
  }
  async report([pattern, aspectId]) {
    const results = await this.aspect.unsetAspectsFromComponents(pattern, aspectId);
    if (!results.length) return _chalk().default.yellow(`unable to find any matching for ${_chalk().default.bold(pattern)} pattern`);
    return _chalk().default.green(`the following component(s) have been successfully updated:\n${results.join('\n')}`);
  }
}
exports.UnsetAspectCmd = UnsetAspectCmd;
class GetAspectCmd {
  constructor(aspect) {
    this.aspect = aspect;
    (0, _defineProperty2().default)(this, "name", 'get <component-name>');
    (0, _defineProperty2().default)(this, "description", 'list the aspects set on a component, as well as their config and data');
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'component-name',
      description: 'the component name or component id'
    }]);
    (0, _defineProperty2().default)(this, "options", [['d', 'debug', 'show the origins were the aspects were taken from'], ['j', 'json', 'format as json']]);
    (0, _defineProperty2().default)(this, "group", 'development');
  }
  async report([componentName], {
    debug
  }) {
    const extensionsDetailsToString = extensions => extensions.map(e => {
      const {
        name,
        data,
        config,
        extensionId
      } = e.toComponentObject();
      return `${_chalk().default.bold('name:')}   ${name || (extensionId === null || extensionId === void 0 ? void 0 : extensionId.toString())}
${_chalk().default.bold('config:')} ${JSON.stringify(config, undefined, 2)}
${_chalk().default.bold('data:')}   ${JSON.stringify(data, undefined, 2)}
`;
    }).join('\n');
    if (debug) {
      const {
        aspects,
        extensions: mergedExtensions,
        beforeMerge
      } = await this.aspect.getAspectsOfComponentForDebugging(componentName);
      const beforeMergeOutput = beforeMerge.map(({
        origin,
        extensions,
        extraData
      }) => {
        const title = _chalk().default.green.bold(`Origin: ${origin}`);
        const details = extensionsDetailsToString(extensions);
        const moreData = extraData ? `\n${_chalk().default.bold('Extra Data:')} ${JSON.stringify(extraData, undefined, 2)}` : '';
        return `${title}\n${details}${moreData}`;
      }).join('\n\n');
      const afterMergeTitle = _chalk().default.green.bold('After merging the origins above');
      const afterMergeOutput = `${afterMergeTitle}\n${extensionsDetailsToString(mergedExtensions)}`;
      const afterFinalMergeTitle = _chalk().default.green.bold('Final - After merging the origin above and the loaded data');
      const afterFinalMergeOutput = `${afterFinalMergeTitle}\n${extensionsDetailsToString(aspects.toLegacy())}`;
      return `${beforeMergeOutput}\n\n${afterMergeOutput}\n\n\n${afterFinalMergeOutput}`;
    }
    const aspects = await this.aspect.getAspectsOfComponent(componentName);
    const extensionDataList = aspects.toLegacy();
    return extensionsDetailsToString(extensionDataList);
  }
  async json([componentName], {
    debug
  }) {
    const extensionsDetailsToObject = extensions => extensions.reduce((acc, current) => {
      const {
        name,
        data,
        config,
        extensionId
      } = current.toComponentObject();
      const aspectName = name || (extensionId === null || extensionId === void 0 ? void 0 : extensionId.toString()) || '<no-name>';
      acc[aspectName] = {
        name: aspectName,
        config,
        data
      };
      return acc;
    }, {});
    if (debug) {
      const {
        aspects,
        extensions: mergedExtensions,
        beforeMerge
      } = await this.aspect.getAspectsOfComponentForDebugging(componentName);
      const jsonObj = {};
      beforeMerge.forEach(({
        origin,
        extensions,
        extraData
      }) => {
        jsonObj[origin] = {
          extensions: extensionsDetailsToObject(extensions),
          extraData
        };
      });
      jsonObj.AfterMerge = {
        extensions: extensionsDetailsToObject(mergedExtensions)
      };
      jsonObj.FinalAfterMergeIncludeLoad = {
        extensions: extensionsDetailsToObject(aspects.toLegacy())
      };
      return jsonObj;
    }
    const aspects = await this.aspect.getAspectsOfComponent(componentName);
    return extensionsDetailsToObject(aspects.toLegacy());
  }
}
exports.GetAspectCmd = GetAspectCmd;
class AspectCmd {
  constructor() {
    (0, _defineProperty2().default)(this, "name", 'aspect <sub-command>');
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "description", 'EXPERIMENTAL. manage aspects');
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "commands", []);
  }
  async report([unrecognizedSubcommand]) {
    return _chalk().default.red(`"${unrecognizedSubcommand}" is not a subcommand of "aspect", please run "bit aspect --help" to list the subcommands`);
  }
}
exports.AspectCmd = AspectCmd;

//# sourceMappingURL=aspect.cmd.js.map