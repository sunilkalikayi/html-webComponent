import { AspectLoaderMain } from '@teambit/aspect-loader';
import { BuilderMain } from '@teambit/builder';
import { EnvPolicyConfigObject } from '@teambit/dependency-resolver';
import { CLIMain } from '@teambit/cli';
import { Environment, EnvsMain, EnvTransformer } from '@teambit/envs';
import { ReactMain } from '@teambit/react';
import { GeneratorMain } from '@teambit/generator';
import { BabelMain } from '@teambit/babel';
import { ComponentID } from '@teambit/component-id';
import { AspectList } from '@teambit/component';
import { ExtensionsOrigin, Workspace } from '@teambit/workspace';
import { CompilerMain } from '@teambit/compiler';
import { AspectEnv } from './aspect.env';
import { SetAspectOptions } from './aspect.cmd';
export declare type AspectSource = {
    aspectName: string;
    source: string;
    level: string;
};
export declare class AspectMain {
    readonly aspectEnv: AspectEnv;
    private envs;
    private workspace;
    constructor(aspectEnv: AspectEnv, envs: EnvsMain, workspace: Workspace);
    /**
     * compose your own aspect environment.
     */
    compose(transformers?: EnvTransformer[], targetEnv?: Environment): Environment;
    listAspectsOfComponent(pattern?: string): Promise<{
        [component: string]: AspectSource[];
    }>;
    get babelConfig(): {
        presets: (string | (string | {
            targets: {
                node: number;
            };
            useBuiltIns: string;
            corejs: number;
        })[])[];
        plugins: (string | (string | {
            lazy: () => boolean;
        })[] | (string | {
            legacy: boolean;
        })[])[];
        sourceMaps: boolean;
    };
    private getAspectNamesForComponent;
    private getLevelBySourceOrigin;
    setAspectsToComponents(pattern: string, aspectId: string, config?: Record<string, any>, options?: SetAspectOptions): Promise<ComponentID[]>;
    unsetAspectsFromComponents(pattern: string, aspectId: string): Promise<ComponentID[]>;
    /**
     * returns all aspects info of a component, include the config and the data.
     */
    getAspectsOfComponent(id: string | ComponentID): Promise<AspectList>;
    /**
     * helps debugging why/how an aspect was set to a component
     */
    getAspectsOfComponentForDebugging(id: string | ComponentID): Promise<{
        aspects: AspectList;
        extensions: import("@teambit/legacy/dist/consumer/config").ExtensionDataList;
        beforeMerge: {
            extensions: import("@teambit/legacy/dist/consumer/config").ExtensionDataList;
            origin: ExtensionsOrigin;
            extraData: any;
        }[];
    }>;
    updateAspectsToComponents(aspectId: string, pattern?: string): Promise<{
        updated: ComponentID[];
        alreadyUpToDate: ComponentID[];
    }>;
    /**
     * override the dependency configuration of the component environment.
     */
    overrideDependencies(dependencyPolicy: EnvPolicyConfigObject): EnvTransformer;
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: import("@teambit/harmony").Aspect[];
    static provider([react, envs, builder, aspectLoader, compiler, babel, generator, workspace, cli]: [
        ReactMain,
        EnvsMain,
        BuilderMain,
        AspectLoaderMain,
        CompilerMain,
        BabelMain,
        GeneratorMain,
        Workspace,
        CLIMain
    ]): Promise<AspectMain>;
}
