"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DevServerService = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _react() {
  const data = _interopRequireDefault(require("react"));
  _react = function () {
    return data;
  };
  return data;
}
function _ink() {
  const data = require("ink");
  _ink = function () {
    return data;
  };
  return data;
}
function _cliHighlight() {
  const data = _interopRequireDefault(require("cli-highlight"));
  _cliHighlight = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _componentServer() {
  const data = require("./component-server");
  _componentServer = function () {
    return data;
  };
  return data;
}
function _dedupEnvs() {
  const data = require("./dedup-envs");
  _dedupEnvs = function () {
    return data;
  };
  return data;
}
function _getEntry() {
  const data = require("./get-entry");
  _getEntry = function () {
    return data;
  };
  return data;
}
class DevServerService {
  constructor(
  /**
   * browser runtime slot
   */
  pubsub, dependencyResolver,
  /**
   * browser runtime slot
   */
  runtimeSlot) {
    this.pubsub = pubsub;
    this.dependencyResolver = dependencyResolver;
    this.runtimeSlot = runtimeSlot;
    (0, _defineProperty2().default)(this, "name", 'dev server');
  }
  async render(env, context) {
    const descriptor = await this.getDescriptor(env, context);
    return /*#__PURE__*/_react().default.createElement(_ink().Text, {
      key: descriptor === null || descriptor === void 0 ? void 0 : descriptor.id
    }, /*#__PURE__*/_react().default.createElement(_ink().Text, {
      color: "cyan"
    }, "configured dev server: "), /*#__PURE__*/_react().default.createElement(_ink().Text, null, descriptor === null || descriptor === void 0 ? void 0 : descriptor.id, " (", descriptor === null || descriptor === void 0 ? void 0 : descriptor.displayName, " @ ", descriptor === null || descriptor === void 0 ? void 0 : descriptor.version, ")"), /*#__PURE__*/_react().default.createElement(_ink().Newline, null), /*#__PURE__*/_react().default.createElement(_ink().Text, {
      underline: true,
      color: "cyan"
    }, "dev server config:"), /*#__PURE__*/_react().default.createElement(_ink().Newline, null), /*#__PURE__*/_react().default.createElement(_ink().Text, null, (0, _cliHighlight().default)((descriptor === null || descriptor === void 0 ? void 0 : descriptor.config) || '', {
      language: 'javascript',
      ignoreIllegals: true
    })), /*#__PURE__*/_react().default.createElement(_ink().Newline, null));
  }
  async getDescriptor(environment, context) {
    if (!environment.env.getDevServer || !context) return undefined;
    const mergedContext = await this.buildContext(context[0], []);
    const devServer = environment.env.getDevServer(mergedContext);
    return {
      id: devServer.id || '',
      displayName: devServer.displayName || '',
      icon: devServer.icon || '',
      config: devServer.displayConfig ? devServer.displayConfig() : '',
      version: devServer.version ? devServer.version() : '?'
    };
  }

  // async run(context: ExecutionContext): Promise<ComponentServer[]> {
  //   const devServerContext = await this.buildContext(context);
  //   const devServer: DevServer = context.env.getDevServer(devServerContext);
  //   const port = await selectPort();
  //   // TODO: refactor to replace with a component server instance.
  //   return new ComponentServer(this.pubsub, context, port, devServer);
  // }

  async runOnce(contexts, {
    dedicatedEnvDevServers
  }) {
    const groupedEnvs = await (0, _dedupEnvs().dedupEnvs)(contexts, this.dependencyResolver, dedicatedEnvDevServers);
    const servers = await Promise.all(Object.entries(groupedEnvs).map(async ([id, contextList]) => {
      const mainContext = contextList.find(context => context.envDefinition.id === id) || contextList[0];
      const additionalContexts = contextList.filter(context => context.envDefinition.id !== id);
      const devServerContext = await this.buildContext(mainContext, additionalContexts);
      const devServer = await devServerContext.envRuntime.env.getDevServer(devServerContext);
      return new (_componentServer().ComponentServer)(this.pubsub, devServerContext, [3300, 3400], devServer);
    }));
    return servers;
  }
  mergeContext() {}
  getComponentsFromContexts(contexts) {
    return (0, _lodash().flatten)(contexts.map(context => {
      return context.components;
    }));
  }

  /**
   * builds the execution context for the dev server.
   */
  async buildContext(context, additionalContexts = []) {
    var _context$envRuntime$e;
    context.relatedContexts = additionalContexts.map(ctx => ctx.envDefinition.id);
    context.components = context.components.concat(this.getComponentsFromContexts(additionalContexts));
    const peers = await this.dependencyResolver.getPeerDependenciesListFromEnv(context.env);
    const hostRootDir = (_context$envRuntime$e = context.envRuntime.envAspectDefinition) === null || _context$envRuntime$e === void 0 ? void 0 : _context$envRuntime$e.aspectPath;
    return Object.assign(context, {
      entry: await (0, _getEntry().getEntry)(context, this.runtimeSlot),
      // don't start with a leading "/" because it generates errors on Windows
      rootPath: `preview/${context.envRuntime.id}`,
      publicPath: `${_path().sep}public`,
      hostRootDir,
      hostDependencies: peers,
      aliasHostDependencies: true
    });
  }
}
exports.DevServerService = DevServerService;

//# sourceMappingURL=dev-server.service.js.map