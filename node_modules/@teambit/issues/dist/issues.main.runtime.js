"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IssuesMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _componentIssues() {
  const data = require("@teambit/component-issues");
  _componentIssues = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _issuesCmd() {
  const data = require("./issues-cmd");
  _issuesCmd = function () {
    return data;
  };
  return data;
}
function _issues() {
  const data = require("./issues.aspect");
  _issues = function () {
    return data;
  };
  return data;
}
function _nonExistIssueError() {
  const data = require("./non-exist-issue-error");
  _nonExistIssueError = function () {
    return data;
  };
  return data;
}
class IssuesMain {
  constructor(config, addComponentsIssuesSlot) {
    this.config = config;
    this.addComponentsIssuesSlot = addComponentsIssuesSlot;
  }
  getIssuesToIgnoreGlobally() {
    const issuesToIgnore = this.config.ignoreIssues || [];
    this.validateIssueNames(issuesToIgnore);
    return issuesToIgnore;
  }
  getIssuesToIgnorePerComponent(component) {
    var _component$state$aspe;
    const issuesToIgnore = (_component$state$aspe = component.state.aspects.get(_issues().IssuesAspect.id)) === null || _component$state$aspe === void 0 ? void 0 : _component$state$aspe.config.ignoreIssues;
    if (!issuesToIgnore) return [];
    this.validateIssueNames(issuesToIgnore);
    return issuesToIgnore;
  }
  validateIssueNames(issues) {
    const allIssues = this.listIssues().map(issue => issue.name);
    issues.forEach(issue => {
      if (!allIssues.includes(issue)) {
        throw new (_nonExistIssueError().NonExistIssueError)(issue);
      }
    });
  }
  listIssues() {
    const instances = Object.keys(_componentIssues().IssuesClasses).map(issueClass => new (_componentIssues().IssuesClasses[issueClass])());
    const issuesList = new (_componentIssues().IssuesList)(instances);
    const allIssues = issuesList.getAllIssues();
    return allIssues.map(issueInstance => {
      return {
        name: issueInstance.constructor.name,
        description: issueInstance.description,
        solution: issueInstance.solution,
        isTagBlocker: issueInstance.isTagBlocker
      };
    });
  }
  removeIgnoredIssuesFromComponents(components) {
    const issuesToIgnoreGlobally = this.getIssuesToIgnoreGlobally();
    components.forEach(component => {
      const issuesToIgnoreForThisComp = this.getIssuesToIgnorePerComponent(component);
      const issuesToIgnore = [...issuesToIgnoreGlobally, ...issuesToIgnoreForThisComp];
      issuesToIgnore.forEach(issueToIgnore => {
        component.state.issues.delete(_componentIssues().IssuesClasses[issueToIgnore]);
      });
    });
  }

  /**
   * register to this slot in order to add a component-issue in bit-status and bit-snap/tag.
   * your function gets all components in one param and the issuesToIgnore as a second param, you don't need to check
   * for issuesToIgnore. if the issue you added is configured to be ignored, it'll be ignored later in the process.
   * this is useful for optimization, if you don't want to calculate the component issue when it's ignored.
   */
  registerAddComponentsIssues(addComponentsIssues) {
    this.addComponentsIssuesSlot.register(addComponentsIssues);
  }
  async triggerAddComponentIssues(components, issuesToIgnore) {
    const allFunctions = this.addComponentsIssuesSlot.values();
    await (0, _pMapSeries().default)(allFunctions, func => func(components, issuesToIgnore));
  }
  static async provider([cli], config, [addComponentsIssuesSlot]) {
    const issuesMain = new IssuesMain(config, addComponentsIssuesSlot);
    cli.register(new (_issuesCmd().ComponentIssuesCmd)(issuesMain));
    return issuesMain;
  }
}
exports.IssuesMain = IssuesMain;
(0, _defineProperty2().default)(IssuesMain, "slots", [_harmony().Slot.withType()]);
(0, _defineProperty2().default)(IssuesMain, "dependencies", [_cli().CLIAspect]);
(0, _defineProperty2().default)(IssuesMain, "defaultConfig", {
  ignoreIssues: []
});
(0, _defineProperty2().default)(IssuesMain, "runtime", _cli().MainRuntime);
_issues().IssuesAspect.addRuntime(IssuesMain);

//# sourceMappingURL=issues.main.runtime.js.map