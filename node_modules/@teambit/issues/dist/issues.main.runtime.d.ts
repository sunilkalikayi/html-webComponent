import { CLIMain } from '@teambit/cli';
import { Component } from '@teambit/component';
import { SlotRegistry } from '@teambit/harmony';
export declare type IssuesConfig = {
    ignoreIssues: string[];
};
export declare type AddComponentsIssues = (components: Component[], issuesToIgnore: string[]) => Promise<void>;
export declare type AddComponentsIssuesSlot = SlotRegistry<AddComponentsIssues>;
export declare class IssuesMain {
    private config;
    private addComponentsIssuesSlot;
    constructor(config: IssuesConfig, addComponentsIssuesSlot: AddComponentsIssuesSlot);
    getIssuesToIgnoreGlobally(): string[];
    getIssuesToIgnorePerComponent(component: Component): string[];
    private validateIssueNames;
    listIssues(): {
        name: string;
        description: string;
        solution: string;
        isTagBlocker: boolean;
    }[];
    removeIgnoredIssuesFromComponents(components: Component[]): void;
    /**
     * register to this slot in order to add a component-issue in bit-status and bit-snap/tag.
     * your function gets all components in one param and the issuesToIgnore as a second param, you don't need to check
     * for issuesToIgnore. if the issue you added is configured to be ignored, it'll be ignored later in the process.
     * this is useful for optimization, if you don't want to calculate the component issue when it's ignored.
     */
    registerAddComponentsIssues(addComponentsIssues: AddComponentsIssues): void;
    triggerAddComponentIssues(components: Component[], issuesToIgnore: string[]): Promise<void>;
    static slots: ((registerFn: () => string) => SlotRegistry<AddComponentsIssues>)[];
    static dependencies: import("@teambit/harmony").Aspect[];
    static defaultConfig: {
        ignoreIssues: never[];
    };
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static provider([cli]: [CLIMain], config: IssuesConfig, [addComponentsIssuesSlot]: [AddComponentsIssuesSlot]): Promise<IssuesMain>;
}
