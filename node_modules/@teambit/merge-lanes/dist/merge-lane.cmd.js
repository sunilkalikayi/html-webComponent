"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MergeLaneCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _mergeVersion() {
  const data = require("@teambit/legacy/dist/consumer/versions-ops/merge-version");
  _mergeVersion = function () {
    return data;
  };
  return data;
}
function _merging() {
  const data = require("@teambit/merging");
  _merging = function () {
    return data;
  };
  return data;
}
function _featureToggle() {
  const data = require("@teambit/legacy/dist/api/consumer/lib/feature-toggle");
  _featureToggle = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _removeTemplate() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/templates/remove-template"));
  _removeTemplate = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class MergeLaneCmd {
  constructor(mergeLanes) {
    this.mergeLanes = mergeLanes;
    (0, _defineProperty2().default)(this, "name", 'merge <lane> [pattern]');
    (0, _defineProperty2().default)(this, "description", `merge a local or a remote lane`);
    (0, _defineProperty2().default)(this, "extendedDescription", `if the <lane> exists locally, it will be merged from the local lane.
otherwise, it will fetch the lane from the remote and merge it.
in case the <lane> exists locally but you want to merge the remote version of it, use --remote flag.
when the current and the other lanes are diverged in history and the files could be merged with no conflicts,
it will snap-merge these components to complete the merge. use "no-snap" to opt-out, or "tag" to tag instead`);
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'lane',
      description: 'lane-name or lane-id (if not exists locally) to merge to the current lane'
    }, {
      name: 'pattern',
      description: 'EXPERIMENTAL. partially merge the lane with the specified component-pattern'
    }]);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['', 'ours', 'in case of a conflict, override the used version with the current modification'], ['', 'theirs', 'in case of a conflict, override the current modification with the specified version'], ['', 'manual', 'in case of a conflict, leave the files with a conflict state to resolve them manually later'], ['', 'workspace', 'merge only components in a lane that exist in the workspace'], ['', 'no-snap', 'do not auto snap in case the merge completed without conflicts'], ['', 'tag', 'tag all lane components after merging into main (also tag-merge in case of snap-merge)'], ['', 'build', 'in case of snap during the merge, run the build-pipeline (similar to bit snap --build)'], ['m', 'message <message>', 'override the default message for the auto snap'], ['', 'keep-readme', 'skip deleting the lane readme component after merging'], ['', 'no-squash', 'EXPERIMENTAL. relevant for merging lanes into main, which by default squash.'], ['', 'ignore-config-changes', 'allow merging when component are modified due to config changes (such as dependencies) only and not files'], ['', 'verbose', 'show details of components that were not merged legitimately'], ['', 'skip-dependency-installation', 'do not install packages of the imported components'], ['', 'remote', 'relevant when the target-lane locally is differ than the remote and you want the remote'], ['', 'include-deps', 'EXPERIMENTAL. relevant for "--pattern" and "--workspace". merge also dependencies of the given components'], ['', 'resolve-unrelated [merge-strategy]', 'EXPERIMENTAL. relevant when a component on a lane and the component on main has nothing in common. merge-strategy can be "ours" (default) or "theirs"']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "remoteOp", true);
  }
  async report([name, pattern], {
    ours = false,
    theirs = false,
    manual = false,
    build,
    workspace: existingOnWorkspaceOnly = false,
    noSnap = false,
    tag = false,
    message: snapMessage = '',
    keepReadme = false,
    noSquash = false,
    skipDependencyInstallation = false,
    remote = false,
    includeDeps = false,
    resolveUnrelated,
    ignoreConfigChanges,
    verbose = false
  }) {
    build = (0, _featureToggle().isFeatureEnabled)(_featureToggle().BUILD_ON_CI) ? Boolean(build) : true;
    const mergeStrategy = (0, _mergeVersion().getMergeStrategy)(ours, theirs, manual);
    if (noSnap && snapMessage) throw new (_bitError().BitError)('unable to use "noSnap" and "message" flags together');
    if (includeDeps && !pattern && !existingOnWorkspaceOnly) {
      throw new (_bitError().BitError)(`"--include-deps" flag is relevant only for --workspace and --pattern flags`);
    }
    const getResolveUnrelated = () => {
      if (!resolveUnrelated) return undefined;
      if (typeof resolveUnrelated === 'boolean') return 'ours';
      if (resolveUnrelated !== 'ours' && resolveUnrelated !== 'theirs' && resolveUnrelated !== 'manual') {
        throw new Error('--resolve-unrelated must be one of the following: [ours, theirs, manual]');
      }
      return resolveUnrelated;
    };
    if (resolveUnrelated && typeof resolveUnrelated === 'boolean') {
      resolveUnrelated = 'ours';
    }
    const {
      mergeResults,
      deleteResults
    } = await this.mergeLanes.mergeLane(name, {
      build,
      // @ts-ignore
      mergeStrategy,
      existingOnWorkspaceOnly,
      noSnap,
      snapMessage,
      keepReadme,
      noSquash,
      tag,
      pattern,
      skipDependencyInstallation,
      remote,
      resolveUnrelated: getResolveUnrelated(),
      ignoreConfigChanges,
      includeDeps
    });
    const mergeResult = (0, _merging().mergeReport)(_objectSpread(_objectSpread({}, mergeResults), {}, {
      verbose
    }));
    const deleteResult = `${deleteResults.localResult ? (0, _removeTemplate().default)(deleteResults.localResult, false) : ''}${(deleteResults.remoteResult || []).map(item => (0, _removeTemplate().default)(item, true))}${deleteResults.readmeResult && _chalk().default.yellow(deleteResults.readmeResult) || ''}\n`;
    return mergeResult + deleteResult;
  }
}
exports.MergeLaneCmd = MergeLaneCmd;

//# sourceMappingURL=merge-lane.cmd.js.map