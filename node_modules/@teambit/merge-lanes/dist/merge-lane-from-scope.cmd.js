"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MergeLaneFromScopeCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
/**
 * private command. the underscore prefix is intended.
 */
class MergeLaneFromScopeCmd {
  constructor(mergeLanes) {
    this.mergeLanes = mergeLanes;
    (0, _defineProperty2().default)(this, "name", '_merge-lane <lane> [pattern]');
    (0, _defineProperty2().default)(this, "description", `merge a remote lane into main via a bare-scope (not workspace)`);
    (0, _defineProperty2().default)(this, "extendedDescription", `to merge from a workspace, use "bit lane merge" command.
this is intended to use from the UI, which will have a button to merge an existing lane into main.
the lane must be up-to-date with main, otherwise, conflicts might occur which are not handled in this command`);
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'lane',
      description: 'lane-id to merge to main'
    }, {
      name: 'pattern',
      description: 'EXPERIMENTAL. partially merge the lane with the specified component-pattern'
    }]);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['', 'push', 'export the updated objects to the original scopes once done'], ['', 'keep-readme', 'skip deleting the lane readme component after merging'], ['', 'no-squash', 'EXPERIMENTAL. relevant for merging lanes into main, which by default squash.'],
    // ['', 'verbose', 'show details of components that were not merged legitimately'],
    ['', 'include-deps', 'EXPERIMENTAL. relevant for "--pattern". merge also dependencies of the given components']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "remoteOp", true);
  }
  async report([name, pattern], {
    push = false,
    keepReadme = false,
    noSquash = false,
    includeDeps = false
  }) {
    if (includeDeps && !pattern) {
      throw new (_bitError().BitError)(`"--include-deps" flag is relevant only for --pattern flag`);
    }
    const {
      mergedNow,
      mergedPreviously,
      exportedIds
    } = await this.mergeLanes.mergeFromScope(name, {
      push,
      keepReadme,
      noSquash,
      pattern,
      includeDeps
    });
    const mergedTitle = _chalk().default.green(`successfully merged ${mergedNow.length} components from ${name} to main`);
    const mergedOutput = mergedNow.length ? `${mergedTitle}\n${mergedNow.join('\n')}` : '';
    const nonMergedTitle = _chalk().default.bold(`the following ${mergedPreviously.length} components were already merged before, they were left intact`);
    const nonMergedOutput = mergedPreviously.length ? `\n${nonMergedTitle}\n${mergedPreviously.join('\n')}` : '';
    const exportedTitle = _chalk().default.green(`successfully exported ${exportedIds.length} components`);
    const exportedOutput = exportedIds.length ? `\n${exportedTitle}\n${exportedIds.join('\n')}` : '';
    return mergedOutput + nonMergedOutput + exportedOutput;
  }
}
exports.MergeLaneFromScopeCmd = MergeLaneFromScopeCmd;

//# sourceMappingURL=merge-lane-from-scope.cmd.js.map