"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MergeLanesMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _lanes() {
  const data = require("@teambit/lanes");
  _lanes = function () {
    return data;
  };
  return data;
}
function _merging() {
  const data = _interopRequireDefault(require("@teambit/merging"));
  _merging = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = require("@teambit/scope");
  _scope = function () {
    return data;
  };
  return data;
}
function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/scope/component-ops/scope-components-importer"));
  _scopeComponentsImporter = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _repositories() {
  const data = require("@teambit/legacy/dist/scope/repositories");
  _repositories = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _remove() {
  const data = require("@teambit/remove");
  _remove = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _export() {
  const data = require("@teambit/export");
  _export = function () {
    return data;
  };
  return data;
}
function _getDivergeData() {
  const data = require("@teambit/legacy/dist/scope/component-ops/get-diverge-data");
  _getDivergeData = function () {
    return data;
  };
  return data;
}
function _mergeLanes() {
  const data = require("./merge-lanes.aspect");
  _mergeLanes = function () {
    return data;
  };
  return data;
}
function _mergeLane() {
  const data = require("./merge-lane.cmd");
  _mergeLane = function () {
    return data;
  };
  return data;
}
function _mergeLaneFromScope() {
  const data = require("./merge-lane-from-scope.cmd");
  _mergeLaneFromScope = function () {
    return data;
  };
  return data;
}
class MergeLanesMain {
  constructor(workspace, merging, lanes, logger, remove, scope, exporter) {
    this.workspace = workspace;
    this.merging = merging;
    this.lanes = lanes;
    this.logger = logger;
    this.remove = remove;
    this.scope = scope;
    this.exporter = exporter;
  }
  async mergeLane(laneName, options) {
    if (!this.workspace) {
      throw new (_bitError().BitError)(`unable to merge a lane outside of Bit workspace`);
    }
    const consumer = this.workspace.consumer;
    const {
      mergeStrategy,
      noSnap,
      tag,
      snapMessage,
      existingOnWorkspaceOnly,
      build,
      keepReadme,
      noSquash,
      pattern,
      includeDeps,
      skipDependencyInstallation,
      resolveUnrelated,
      ignoreConfigChanges,
      remote
    } = options;
    const currentLaneId = consumer.getCurrentLaneId();
    if (tag && !currentLaneId.isDefault()) {
      throw new (_bitError().BitError)(`--tag only possible when on main. currently checked out to ${currentLaneId.toString()}`);
    }
    const otherLaneId = await consumer.getParsedLaneId(laneName);
    if (otherLaneId.isEqual(currentLaneId)) {
      throw new (_bitError().BitError)(`unable to merge lane "${otherLaneId.toString()}", you're already at this lane. to get updates, simply run "bit checkout head"`);
    }
    const currentLane = currentLaneId.isDefault() ? null : await consumer.scope.loadLane(currentLaneId);
    const isDefaultLane = otherLaneId.isDefault();
    const getOtherLane = async () => {
      if (isDefaultLane) {
        return undefined;
      }
      const lane = await consumer.scope.loadLane(otherLaneId);
      if (remote || !lane) {
        return this.lanes.fetchLaneWithItsComponents(otherLaneId);
      }
      return lane;
    };
    const otherLane = await getOtherLane();
    const getBitIds = async () => {
      if (isDefaultLane) {
        if (!currentLane) throw new Error(`unable to merge ${_laneId().DEFAULT_LANE}, the current lane was not found`);
        return consumer.scope.getDefaultLaneIdsFromLane(currentLane);
      }
      if (!otherLane) throw new Error(`lane must be defined for non-default`);
      return otherLane.toBitIds();
    };
    const bitIds = await getBitIds();
    this.logger.debug(`merging the following bitIds: ${bitIds.toString()}`);
    const otherLaneName = isDefaultLane ? _laneId().DEFAULT_LANE : otherLaneId.toString();
    const getAllComponentsStatus = async () => {
      const tmp = new (_repositories().Tmp)(consumer.scope);
      try {
        const componentsStatus = await Promise.all(bitIds.map(bitId => this.merging.getComponentMergeStatus(bitId, currentLane, otherLaneName, {
          resolveUnrelated,
          ignoreConfigChanges
        })));
        await tmp.clear();
        return componentsStatus;
      } catch (err) {
        await tmp.clear();
        throw err;
      }
    };
    let allComponentsStatus = await getAllComponentsStatus();
    if (pattern) {
      const componentIds = await this.workspace.resolveMultipleComponentIds(bitIds);
      const compIdsFromPattern = this.workspace.scope.filterIdsFromPoolIdsByPattern(pattern, componentIds);
      allComponentsStatus = await filterComponentsStatus(allComponentsStatus, compIdsFromPattern, bitIds, this.workspace, includeDeps, otherLane || undefined);
      bitIds.forEach(bitId => {
        if (!allComponentsStatus.find(c => c.id.isEqualWithoutVersion(bitId))) {
          allComponentsStatus.push({
            id: bitId,
            unmergedLegitimately: true,
            unmergedMessage: `excluded by pattern`
          });
        }
      });
    }
    if (existingOnWorkspaceOnly) {
      const workspaceIds = await this.workspace.listIds();
      const compIdsFromPattern = workspaceIds.filter(id => allComponentsStatus.find(c => c.id.isEqualWithoutVersion(id._legacy)));
      allComponentsStatus = await filterComponentsStatus(allComponentsStatus, compIdsFromPattern, bitIds, this.workspace, includeDeps);
      bitIds.forEach(bitId => {
        if (!allComponentsStatus.find(c => c.id.isEqualWithoutVersion(bitId))) {
          allComponentsStatus.push({
            id: bitId,
            unmergedLegitimately: true,
            unmergedMessage: `not in the workspace`
          });
        }
      });
    }
    throwForFailures();
    if (currentLaneId.isDefault() && !noSquash) {
      squashSnaps(allComponentsStatus, otherLaneId, consumer);
    }
    const mergeResults = await this.merging.mergeSnaps({
      mergeStrategy,
      allComponentsStatus,
      laneId: otherLaneId,
      localLane: currentLane,
      noSnap,
      tag,
      snapMessage,
      build,
      skipDependencyInstallation
    });
    const mergedSuccessfully = !mergeResults.failedComponents || mergeResults.failedComponents.length === 0 || mergeResults.failedComponents.every(failedComponent => failedComponent.unchangedLegitimately);
    let deleteResults = {};
    if (!keepReadme && otherLane && otherLane.readmeComponent && mergedSuccessfully) {
      var _otherLane$readmeComp, _otherLane$readmeComp2;
      const readmeComponentId = otherLane.readmeComponent.id.changeVersion((_otherLane$readmeComp = otherLane.readmeComponent) === null || _otherLane$readmeComp === void 0 ? void 0 : (_otherLane$readmeComp2 = _otherLane$readmeComp.head) === null || _otherLane$readmeComp2 === void 0 ? void 0 : _otherLane$readmeComp2.hash).toString();
      deleteResults = await this.remove.remove({
        componentsPattern: readmeComponentId,
        force: false,
        remote: false,
        track: false,
        deleteFiles: true,
        fromLane: false
      });
    } else if (otherLane && !otherLane.readmeComponent) {
      deleteResults = {
        readmeResult: `\nlane ${otherLane.name} doesn't have a readme component`
      };
    }
    await this.workspace.consumer.onDestroy();
    return {
      mergeResults,
      deleteResults
    };
    function throwForFailures() {
      const failedComponents = allComponentsStatus.filter(c => c.unmergedMessage && !c.unmergedLegitimately);
      if (failedComponents.length) {
        const failureMsgs = failedComponents.map(failedComponent => `${_chalk().default.bold(failedComponent.id.toString())} - ${_chalk().default.red(failedComponent.unmergedMessage)}`).join('\n');
        throw new (_bitError().BitError)(`unable to merge due to the following failures:\n${failureMsgs}`);
      }
    }
  }
  async mergeFromScope(laneName, options) {
    if (this.workspace) throw new (_bitError().BitError)(`unable to run this command from a workspace, please create a new bare-scope and run it from there`);
    const laneId = _laneId().LaneId.parse(laneName);
    const lane = await this.lanes.importLaneObject(laneId);
    const laneIds = lane.toBitIds();
    const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(this.scope.legacyScope);
    await scopeComponentsImporter.importManyDeltaWithoutDeps(laneIds, true, lane, true);
    // get their main as well
    await scopeComponentsImporter.importManyDeltaWithoutDeps(laneIds.toVersionLatest(), true, undefined, true);
    const repo = this.scope.legacyScope.objects;
    // loop through all components, make sure they're all ahead of main (it might not be on main yet).
    // then, change the version object to include an extra parent to point to the main.
    // then, change the component object head to point to this changed version
    const mergedPreviously = [];
    const mergedNow = [];
    const bitObjectsPerComp = await (0, _pMapSeries().default)(laneIds, async id => {
      const modelComponent = await this.scope.legacyScope.getModelComponent(id);
      const versionObj = await modelComponent.loadVersion(id.version, repo);
      const laneHead = modelComponent.getRef(id.version);
      if (!laneHead) throw new Error(`lane head must be defined for ${id.toString()}`);
      const mainHead = modelComponent.head || null;
      if (mainHead !== null && mainHead !== void 0 && mainHead.isEqual(laneHead)) {
        mergedPreviously.push(id);
        return undefined;
      }
      const divergeData = await (0, _getDivergeData().getDivergeData)({
        repo,
        modelComponent,
        remoteHead: laneHead,
        checkedOutLocalHead: mainHead
      });
      const modifiedVersion = squashOneComp(_laneId().DEFAULT_LANE, laneId, id, divergeData, versionObj);
      modelComponent.setHead(laneHead);
      const objects = [modelComponent, modifiedVersion];
      mergedNow.push(id);
      return {
        id,
        objects
      };
    });
    const bitObjects = (0, _lodash().compact)(bitObjectsPerComp).map(b => b.objects);
    await repo.writeObjectsToTheFS(bitObjects.flat());
    let exportedIds = [];
    if (options.push) {
      const ids = (0, _lodash().compact)(bitObjectsPerComp).map(b => b.id);
      const bitIds = _bitId().BitIds.fromArray(ids);
      const {
        exported
      } = await this.exporter.exportMany({
        scope: this.scope.legacyScope,
        ids: bitIds,
        idsWithFutureScope: bitIds,
        allVersions: false
      });
      exportedIds = exported.map(id => id.toString());
    }
    return {
      mergedPreviously: mergedPreviously.map(id => id.toString()),
      mergedNow: mergedNow.map(id => id.toString()),
      exportedIds
    };
  }
  static async provider([lanes, cli, workspace, merging, loggerMain, remove, scope, exporter]) {
    var _lanesCommand$command;
    const logger = loggerMain.createLogger(_mergeLanes().MergeLanesAspect.id);
    const lanesCommand = cli.getCommand('lane');
    const mergeLanesMain = new MergeLanesMain(workspace, merging, lanes, logger, remove, scope, exporter);
    lanesCommand === null || lanesCommand === void 0 ? void 0 : (_lanesCommand$command = lanesCommand.commands) === null || _lanesCommand$command === void 0 ? void 0 : _lanesCommand$command.push(new (_mergeLane().MergeLaneCmd)(mergeLanesMain));
    cli.register(new (_mergeLaneFromScope().MergeLaneFromScopeCmd)(mergeLanesMain));
    return mergeLanesMain;
  }
}
exports.MergeLanesMain = MergeLanesMain;
(0, _defineProperty2().default)(MergeLanesMain, "slots", []);
(0, _defineProperty2().default)(MergeLanesMain, "dependencies", [_lanes().LanesAspect, _cli().CLIAspect, _workspace().default, _merging().default, _logger().LoggerAspect, _remove().RemoveAspect, _scope().ScopeAspect, _export().ExportAspect]);
(0, _defineProperty2().default)(MergeLanesMain, "runtime", _cli().MainRuntime);
async function filterComponentsStatus(allComponentsStatus, compIdsToKeep, allBitIds, workspace, includeDeps = false, lane) {
  const bitIdsFromPattern = _bitId().BitIds.fromArray(compIdsToKeep.map(c => c._legacy));
  const bitIdsNotFromPattern = allBitIds.filter(bitId => !bitIdsFromPattern.hasWithoutVersion(bitId));
  const filteredComponentStatus = [];
  const depsToAdd = [];
  await (0, _pMapSeries().default)(compIdsToKeep, async compId => {
    const fromStatus = allComponentsStatus.find(c => c.id.isEqualWithoutVersion(compId._legacy));
    if (!fromStatus) {
      throw new Error(`filterComponentsStatus: unable to find ${compId.toString()} in component-status`);
    }
    filteredComponentStatus.push(fromStatus);
    if (fromStatus.unmergedMessage) {
      return;
    }
    const {
      divergeData
    } = fromStatus;
    if (!divergeData) {
      throw new Error(`filterComponentsStatus: unable to find divergeData for ${compId.toString()}`);
    }
    const remoteVersions = divergeData.snapsOnRemoteOnly;
    if (!remoteVersions.length) {
      return;
    }
    const modelComponent = await workspace.consumer.scope.getModelComponent(compId._legacy);
    // optimization suggestion: if squash is given, check only the last version.
    await (0, _pMapSeries().default)(remoteVersions, async remoteVersion => {
      const versionObj = await modelComponent.loadVersion(remoteVersion.toString(), workspace.consumer.scope.objects);
      const flattenedDeps = versionObj.getAllFlattenedDependencies();
      const depsNotIncludeInPattern = flattenedDeps.filter(id => bitIdsNotFromPattern.find(bitId => bitId.isEqualWithoutVersion(id)));
      if (!depsNotIncludeInPattern.length) {
        return;
      }
      const depsOnLane = [];
      await Promise.all(depsNotIncludeInPattern.map(async dep => {
        const isOnLane = await workspace.consumer.scope.isIdOnLane(dep, lane);
        if (isOnLane) {
          depsOnLane.push(dep);
        }
      }));
      if (!depsOnLane.length) {
        return;
      }
      if (!includeDeps) {
        throw new (_bitError().BitError)(`unable to merge ${compId.toString()}.
it has (in version ${remoteVersion.toString()}) the following dependencies which were not included in the pattern. consider adding "--include-deps" flag
${depsOnLane.map(d => d.toString()).join('\n')}`);
      }
      depsToAdd.push(...depsOnLane);
    });
  });
  if (depsToAdd.length) {
    const depsUniq = _bitId().BitIds.uniqFromArray(depsToAdd);
    depsUniq.forEach(id => {
      const fromStatus = allComponentsStatus.find(c => c.id.isEqualWithoutVersion(id));
      if (!fromStatus) {
        throw new Error(`filterComponentsStatus: unable to find ${id.toString()} in component-status`);
      }
      filteredComponentStatus.push(fromStatus);
    });
  }
  return filteredComponentStatus;
}
function squashSnaps(allComponentsStatus, otherLaneId, consumer) {
  const currentLaneName = consumer.getCurrentLaneId().name;
  const succeededComponents = allComponentsStatus.filter(c => !c.unmergedMessage);
  succeededComponents.forEach(({
    id,
    divergeData,
    componentFromModel
  }) => {
    if (!divergeData) {
      throw new Error(`unable to squash. divergeData is missing from ${id.toString()}`);
    }
    const modifiedComp = squashOneComp(currentLaneName, otherLaneId, id, divergeData, componentFromModel);
    if (modifiedComp) consumer.scope.objects.add(modifiedComp);
  });
}

/**
 * returns Version object if it was modified. otherwise, returns undefined
 */
function squashOneComp(currentLaneName, otherLaneId, id, divergeData, componentFromModel) {
  if (divergeData.isDiverged()) {
    throw new (_bitError().BitError)(`unable to squash because ${id.toString()} is diverged in history.
consider switching to "${otherLaneId.name}" first, merging "${currentLaneName}", then switching back to "${currentLaneName}" and merging "${otherLaneId.name}"
alternatively, use "--no-squash" flag to keep the entire history of "${otherLaneId.name}"`);
  }
  if (divergeData.isLocalAhead()) {
    // nothing to do. current is ahead, nothing to merge. (it was probably filtered out already as a "failedComponent")
    return undefined;
  }
  if (!divergeData.isRemoteAhead()) {
    // nothing to do. current and remote are the same, nothing to merge. (it was probably filtered out already as a "failedComponent")
    return undefined;
  }
  // remote is ahead and was not diverge.
  const remoteSnaps = divergeData.snapsOnRemoteOnly;
  if (remoteSnaps.length === 0) {
    throw new Error(`remote is ahead but it has no snaps. it's impossible`);
  }
  // no need to check this case. even if it has only one snap ahead, we want to do the "squash", and run "addAsOnlyParent"
  // to make sure it doesn't not have two parents.
  // if (remoteSnaps.length === 1) {
  //   // nothing to squash. it has only one commit.
  //   return;
  // }
  if (!componentFromModel) {
    throw new Error('unable to squash, the componentFromModel is missing');
  }
  const currentParents = componentFromModel.parents;

  // do the squash.
  if (divergeData.commonSnapBeforeDiverge) {
    componentFromModel.addAsOnlyParent(divergeData.commonSnapBeforeDiverge);
  } else {
    // there is no commonSnapBeforeDiverge. the local has no snaps, all are remote, no need for parents. keep only head.
    componentFromModel.parents.forEach(ref => componentFromModel.removeParent(ref));
  }
  componentFromModel.setSquashed({
    previousParents: currentParents,
    laneId: otherLaneId
  });
  return componentFromModel;
}
_mergeLanes().MergeLanesAspect.addRuntime(MergeLanesMain);
var _default = MergeLanesMain;
exports.default = _default;

//# sourceMappingURL=merge-lanes.main.runtime.js.map