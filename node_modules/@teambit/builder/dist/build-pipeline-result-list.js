"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.flat-map.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat-map.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BuildPipelineResultList = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _artifact() {
  const data = require("./artifact");
  _artifact = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * Helper to get the data and artifacts from the TasksResultsList before saving during the tag
 */
class BuildPipelineResultList {
  constructor(tasksResults, components) {
    this.tasksResults = tasksResults;
    this.components = components;
    (0, _defineProperty2().default)(this, "artifactListsMap", void 0);
    this.artifactListsMap = this.getFlattenedArtifactListsMapFromAllTasks();
  }
  getFlattenedArtifactListsMapFromAllTasks() {
    const artifactListsMaps = this.tasksResults.flatMap(t => t.artifacts ? [t.artifacts] : []);
    return _component().ComponentMap.as(this.components, component => {
      const artifacts = [];
      artifactListsMaps.forEach(artifactListMap => {
        const artifactList = artifactListMap.getValueByComponentId(component.id);
        if (artifactList) artifacts.push(...artifactList);
      });
      return _artifact().ArtifactList.fromArray(artifacts);
    });
  }
  getMetadataFromTaskResults(componentId) {
    const compResults = this.tasksResults.reduce((acc, current) => {
      const foundComponent = current.componentsResults.find(c => c.component.id.isEqual(componentId));
      const taskId = current.task.aspectId;
      if (foundComponent && foundComponent.metadata) {
        acc[taskId] = this.mergeDataIfPossible(foundComponent.metadata, acc[taskId], taskId);
      }
      return acc;
    }, {});
    return compResults;
  }
  getPipelineReportOfComponent(componentId) {
    const compResults = this.tasksResults.map(taskResults => {
      const foundComponent = taskResults.componentsResults.find(c => c.component.id.isEqual(componentId));
      if (!foundComponent) return null;
      const pipelineReport = {
        taskId: taskResults.task.aspectId,
        taskName: taskResults.task.name,
        taskDescription: taskResults.task.description,
        errors: foundComponent.errors,
        warnings: foundComponent.warnings,
        startTime: foundComponent.startTime,
        endTime: foundComponent.endTime
      };
      return pipelineReport;
    });
    return (0, _lodash().compact)(compResults);
  }
  getDataOfComponent(componentId) {
    const tasksData = this.getMetadataFromTaskResults(componentId);
    return Object.keys(tasksData).map(taskId => ({
      aspectId: taskId,
      data: tasksData[taskId]
    }));
  }
  getArtifactsDataOfComponent(componentId) {
    var _this$artifactListsMa;
    return (_this$artifactListsMa = this.artifactListsMap.getValueByComponentId(componentId)) === null || _this$artifactListsMa === void 0 ? void 0 : _this$artifactListsMa.toObject();
  }
  mergeDataIfPossible(currentData, existingData, taskId) {
    if (!existingData || (0, _lodash().isEmpty)(existingData)) return currentData;
    // both exist
    if (typeof currentData !== 'object') {
      throw new Error(`task data must be "object", get ${typeof currentData} for ${taskId}`);
    }
    if (Array.isArray(currentData)) {
      throw new Error(`task data must be "object", get Array for ${taskId}`);
    }
    return _objectSpread(_objectSpread({}, currentData), existingData);
  }
}
exports.BuildPipelineResultList = BuildPipelineResultList;

//# sourceMappingURL=build-pipeline-result-list.js.map