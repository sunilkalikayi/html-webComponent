"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.builderSchema = builderSchema;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _graphqlTag() {
  const data = _interopRequireDefault(require("graphql-tag"));
  _graphqlTag = function () {
    return data;
  };
  return data;
}
function _isBinaryPath() {
  const data = _interopRequireDefault(require("is-binary-path"));
  _isBinaryPath = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function builderSchema(builder) {
  return {
    typeDefs: (0, _graphqlTag().default)`
      type TaskReport {
        # for GQL caching - taskId + taskName
        id: String!
        taskId: String!
        taskName: String!
        description: String
        startTime: String
        endTime: String
        errors: [String!]
        warnings: [String!]
        artifact(path: String): Artifact
      }

      type ArtifactFile {
        # for GQL caching - same as the path
        id: String!
        # name of the artifact file
        name: String
        # path of the artifact file
        path: String!
        # artifact file content (only for text files). Use /api/<component-id>/~aspect/builder/<extension-id>/~<path> to fetch binary file data
        content: String
        # REST endpoint to fetch artifact data from. /api/<component-id>/~aspect/builder/<extension-id>/~<pat
        downloadUrl: String
        # Remote storage url to resolve artifact file from
        externalUrl: String
      }

      type Artifact {
        # for GQL caching -  PipelineId + Artifact Name
        id: String!
        # artifact name
        name: String!
        description: String
        storage: String
        generatedBy: String
        files: [ArtifactFile!]!
      }

      extend type Component {
        pipelineReport(taskId: String): [TaskReport!]!
      }
    `,
    resolvers: {
      Component: {
        pipelineReport: async (component, {
          taskId
        }) => {
          const builderData = builder.getBuilderData(component);
          const pipeline = (builderData === null || builderData === void 0 ? void 0 : builderData.pipeline) || [];
          const artifacts = taskId ? builder.getArtifactsByAspect(component, taskId) : builder.getArtifacts(component);
          const artifactsWithVinyl = await Promise.all(artifacts.map(async artifact => {
            const id = artifact.task.aspectId;
            const name = artifact.task.name;
            const artifactFiles = (await builder.getArtifactsVinylByAspectAndTaskName(component, id, name)).map(vinyl => {
              const {
                basename,
                path,
                contents
              } = vinyl || {};
              const isBinary = path && (0, _isBinaryPath().default)(path);
              const content = !isBinary ? contents === null || contents === void 0 ? void 0 : contents.toString('utf-8') : undefined;
              const downloadUrl = encodeURI(builder.getDownloadUrlForArtifact(component.id, artifact.task.aspectId, path));
              const externalUrl = vinyl.url;
              return {
                id: path,
                name: basename,
                path,
                content,
                downloadUrl,
                externalUrl
              };
            });
            const artifactObj = _objectSpread(_objectSpread({}, artifact), {}, {
              files: artifactFiles
            });
            return artifactObj;
          }));
          const result = pipeline.map(task => _objectSpread(_objectSpread({}, task), {}, {
            artifact: artifactsWithVinyl.find(data => data.task.aspectId === task.taskId && data.task.name === task.taskName)
          }));
          return result;
        }
      },
      TaskReport: {
        id: taskReport => `${taskReport.taskId}-${taskReport.taskName}`,
        description: taskReport => taskReport.taskDescription,
        errors: taskReport => {
          var _taskReport$errors;
          return ((_taskReport$errors = taskReport.errors) === null || _taskReport$errors === void 0 ? void 0 : _taskReport$errors.map(e => e.toString())) || [];
        },
        warnings: taskReport => taskReport.warnings || [],
        artifact: async (taskReport, {
          path: pathFilter
        }) => {
          var _taskReport$artifact;
          if (!taskReport.artifact) return undefined;
          return _objectSpread(_objectSpread({
            id: `${taskReport.taskId}-${taskReport.taskName}-${(_taskReport$artifact = taskReport.artifact) === null || _taskReport$artifact === void 0 ? void 0 : _taskReport$artifact.name}`
          }, taskReport.artifact), {}, {
            files: taskReport.artifact.files.filter(file => !pathFilter || file.path === pathFilter)
          });
        }
      }
    }
  };
}

//# sourceMappingURL=builder.graphql.js.map