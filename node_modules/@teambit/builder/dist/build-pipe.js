"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BuildPipe = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _prettyTime() {
  const data = _interopRequireDefault(require("pretty-time"));
  _prettyTime = function () {
    return data;
  };
  return data;
}
function _buildTask() {
  const data = require("./build-task");
  _buildTask = function () {
    return data;
  };
  return data;
}
function _taskResultsList() {
  const data = require("./task-results-list");
  _taskResultsList = function () {
    return data;
  };
  return data;
}
class BuildPipe {
  constructor(
  /**
   * array of services to apply on the components.
   */
  tasksQueue, envsBuildContext, logger, artifactFactory, previousTaskResults) {
    this.tasksQueue = tasksQueue;
    this.envsBuildContext = envsBuildContext;
    this.logger = logger;
    this.artifactFactory = artifactFactory;
    this.previousTaskResults = previousTaskResults;
    (0, _defineProperty2().default)(this, "failedTasks", []);
    (0, _defineProperty2().default)(this, "failedDependencyTask", void 0);
    (0, _defineProperty2().default)(this, "longProcessLogger", void 0);
    (0, _defineProperty2().default)(this, "taskResults", []);
  }
  get allTasksResults() {
    return [...(this.previousTaskResults || []), ...(this.taskResults || [])];
  }

  /**
   * execute a pipeline of build tasks.
   */
  async execute() {
    this.addSignalListener();
    await this.executePreBuild();
    this.longProcessLogger = this.logger.createLongProcessLogger('running tasks', this.tasksQueue.length);
    await (0, _pMapSeries().default)(this.tasksQueue, async ({
      task,
      env
    }) => this.executeTask(task, env));
    this.longProcessLogger.end();
    const tasksResultsList = new (_taskResultsList().TaskResultsList)(this.tasksQueue, this.taskResults);
    await this.executePostBuild(tasksResultsList);
    return tasksResultsList;
  }

  /**
   * for some reason, some tasks (such as typescript compilation) ignore ctrl+C. this fixes it.
   */
  addSignalListener() {
    process.on('SIGTERM', () => {
      process.exit();
    });
    process.on('SIGINT', () => {
      process.exit();
    });
  }
  async executePreBuild() {
    this.logger.setStatusLine('executing pre-build for all tasks');
    await (0, _pMapSeries().default)(this.tasksQueue, async ({
      task,
      env
    }) => {
      if (!task.preBuild) return;
      await task.preBuild(this.getBuildContext(env.id));
    });
    this.logger.consoleSuccess();
  }
  async executeTask(task, env) {
    const taskId = _buildTask().BuildTaskHelper.serializeId(task);
    const taskName = `${taskId}${task.description ? ` (${task.description})` : ''}`;
    this.longProcessLogger.logProgress(`env "${env.id}", task "${taskName}"`);
    this.updateFailedDependencyTask(task);
    if (this.shouldSkipTask(taskId, env.id)) {
      return;
    }
    const startTask = process.hrtime();
    const taskStartTime = Date.now();
    const buildContext = this.getBuildContext(env.id);
    let buildTaskResult;
    try {
      buildTaskResult = await task.execute(buildContext);
    } catch (err) {
      this.logger.consoleFailure(`env: ${env.id}, task "${taskId}" threw an error`);
      throw err;
    }
    const endTime = Date.now();
    const compsWithErrors = buildTaskResult.componentsResults.filter(c => {
      var _c$errors;
      return (_c$errors = c.errors) === null || _c$errors === void 0 ? void 0 : _c$errors.length;
    });
    let artifacts;
    if (compsWithErrors.length) {
      this.logger.consoleFailure(`env: ${env.id}, task "${taskId}" has failed`);
      this.failedTasks.push(task);
    } else {
      const duration = (0, _prettyTime().default)(process.hrtime(startTask));
      this.logger.consoleSuccess(`env "${env.id}", task "${taskName}" has completed successfully in ${duration}`);
      const defs = buildTaskResult.artifacts || [];
      artifacts = this.artifactFactory.generate(buildContext, defs, task);
    }
    const taskResults = {
      task,
      env,
      componentsResults: buildTaskResult.componentsResults,
      artifacts,
      startTime: taskStartTime,
      endTime
    };
    this.taskResults.push(taskResults);
  }
  async executePostBuild(tasksResults) {
    this.logger.setStatusLine('executing post-build for all tasks');
    await (0, _pMapSeries().default)(this.tasksQueue, async ({
      task,
      env
    }) => {
      if (!task.postBuild) return;
      await task.postBuild(this.getBuildContext(env.id), tasksResults);
    });
    this.logger.consoleSuccess();
  }
  updateFailedDependencyTask(task) {
    if (!this.failedDependencyTask && this.failedTasks.length && task.dependencies) {
      task.dependencies.forEach(dependency => {
        const {
          aspectId,
          name
        } = _buildTask().BuildTaskHelper.deserializeIdAllowEmptyName(dependency);
        this.failedDependencyTask = this.failedTasks.find(failedTask => {
          if (name && name !== failedTask.name) return false;
          return aspectId === failedTask.aspectId;
        });
      });
    }
  }
  shouldSkipTask(taskId, envId) {
    if (!this.failedDependencyTask) return false;
    const failedTaskId = _buildTask().BuildTaskHelper.serializeId(this.failedDependencyTask);
    this.logger.consoleWarning(`env: ${envId}, task "${taskId}" has skipped due to "${failedTaskId}" failure`);
    return true;
  }
  getBuildContext(envId) {
    const buildContext = this.envsBuildContext[envId];
    if (!buildContext) throw new Error(`unable to find buildContext for ${envId}`);
    buildContext.previousTasksResults = this.allTasksResults;
    return buildContext;
  }
}
exports.BuildPipe = BuildPipe;

//# sourceMappingURL=build-pipe.js.map