import { ArtifactVinyl } from '@teambit/legacy/dist/consumer/component/sources/artifact';
import { ArtifactObject } from '@teambit/legacy/dist/consumer/component/sources/artifact-files';
import { AspectLoaderMain } from '@teambit/aspect-loader';
import { CLIMain } from '@teambit/cli';
import { Component, ComponentMap, IComponent, ComponentMain, ComponentID } from '@teambit/component';
import { EnvsMain } from '@teambit/envs';
import { GraphqlMain } from '@teambit/graphql';
import { SlotRegistry } from '@teambit/harmony';
import { LoggerMain } from '@teambit/logger';
import { ScopeMain } from '@teambit/scope';
import { Workspace } from '@teambit/workspace';
import { IsolateComponentsOptions, IsolatorMain } from '@teambit/isolator';
import { GeneratorMain } from '@teambit/generator';
import { Artifact, ArtifactList } from './artifact';
import { BuilderService, BuilderServiceOptions } from './builder.service';
import { BuildTask } from './build-task';
import { TaskResults } from './build-pipe';
import { TaskResultsList } from './task-results-list';
import { AspectData, PipelineReport } from './build-pipeline-result-list';
import { Serializable } from './types';
export declare type TaskSlot = SlotRegistry<BuildTask[]>;
export declare type OnTagResults = {
    builderDataMap: ComponentMap<RawBuilderData>;
    pipeResults: TaskResultsList[];
};
export declare type OnTagOpts = {
    disableTagAndSnapPipelines?: boolean;
    throwOnError?: boolean;
    forceDeploy?: boolean;
    skipTests?: boolean;
    isSnap?: boolean;
};
export declare const FILE_PATH_PARAM_DELIM = "~";
/**
 * builder data format for the bit object store
 */
export declare type RawBuilderData = {
    pipeline: PipelineReport[];
    artifacts?: ArtifactObject[];
    aspectsData: AspectData[];
    bitVersion?: string;
};
/**
 * builder data mapped to an ArtifactList instance
 */
export declare type BuilderData = Omit<RawBuilderData, 'artifacts'> & {
    artifacts: ArtifactList<Artifact>;
};
export declare class BuilderMain {
    private envs;
    private workspace;
    private buildService;
    private tagService;
    private snapService;
    private scope;
    private isolator;
    private aspectLoader;
    private componentAspect;
    private buildTaskSlot;
    private tagTaskSlot;
    private snapTaskSlot;
    constructor(envs: EnvsMain, workspace: Workspace, buildService: BuilderService, tagService: BuilderService, snapService: BuilderService, scope: ScopeMain, isolator: IsolatorMain, aspectLoader: AspectLoaderMain, componentAspect: ComponentMain, buildTaskSlot: TaskSlot, tagTaskSlot: TaskSlot, snapTaskSlot: TaskSlot);
    private storeArtifacts;
    private pipelineResultsToBuilderData;
    tagListener(components: Component[], options?: OnTagOpts, isolateOptions?: IsolateComponentsOptions): Promise<OnTagResults>;
    private validateBuilderDataMap;
    getArtifactsVinylByAspect(component: Component, aspectName: string): Promise<ArtifactVinyl[]>;
    getArtifactsVinylByAspectAndName(component: Component, aspectName: string, name: string): Promise<ArtifactVinyl[]>;
    getArtifactsVinylByAspectAndTaskName(component: Component, aspectName: string, name: string): Promise<ArtifactVinyl[]>;
    getArtifactsByName(component: Component, name: string): ArtifactList<Artifact>;
    getArtifactsByAspect(component: Component, aspectName: string): ArtifactList<Artifact>;
    getArtifactsByAspectAndName(component: Component, aspectName: string, name: string): ArtifactList<Artifact>;
    getArtifactsbyAspectAndTaskName(component: Component, aspectName: string, taskName: string): ArtifactList<Artifact>;
    getDataByAspect(component: IComponent, aspectName: string): Serializable | undefined;
    getArtifacts(component: Component): ArtifactList<Artifact>;
    getBuilderData(component: IComponent): BuilderData | undefined;
    /**
     * build given components for release.
     * for each one of the envs it runs a series of tasks.
     * in case of an error in a task, it stops the execution of that env and continue to the next
     * env. at the end, the results contain the data and errors per env.
     */
    build(components: Component[], isolateOptions?: IsolateComponentsOptions, builderOptions?: BuilderServiceOptions): Promise<TaskResultsList>;
    runTagTasks(components: Component[], isolateOptions?: IsolateComponentsOptions, previousTasksResults?: TaskResults[]): Promise<TaskResultsList>;
    runSnapTasks(components: Component[], isolateOptions?: IsolateComponentsOptions, previousTasksResults?: TaskResults[]): Promise<TaskResultsList>;
    listTasks(component: Component): {
        id: ComponentID;
        envId: string;
        buildTasks: string[];
        tagTasks: string[];
        snapTasks: string[];
    };
    /**
     * register a build task to apply on all component build pipelines.
     * build happens on `bit build` and as part of `bit tag --persist`.
     */
    registerBuildTasks(tasks: BuildTask[]): this;
    /**
     * @deprecated use registerTagTasks or registerSnapTasks
     */
    registerDeployTasks(tasks: BuildTask[]): this;
    /**
     * tag tasks that don't get executed on `bit build`, only on `bit tag'.
     * this pipeline is running once the build-pipeline has completed.
     */
    registerTagTasks(tasks: BuildTask[]): this;
    /**
     * tag tasks that don't get executed on `bit build`, only on `bit snap'.
     * this pipeline is running once the build-pipeline has completed.
     */
    registerSnapTasks(tasks: BuildTask[]): this;
    getDownloadUrlForArtifact(componentId: ComponentID, taskId: string, path?: string): string;
    static slots: ((registerFn: () => string) => SlotRegistry<BuildTask>)[];
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: import("@teambit/harmony").Aspect[];
    static provider([cli, envs, workspace, scope, isolator, loggerExt, aspectLoader, graphql, generator, component]: [
        CLIMain,
        EnvsMain,
        Workspace,
        ScopeMain,
        IsolatorMain,
        LoggerMain,
        AspectLoaderMain,
        GraphqlMain,
        GeneratorMain,
        ComponentMain
    ], config: any, [buildTaskSlot, tagTaskSlot, snapTaskSlot]: [TaskSlot, TaskSlot, TaskSlot]): Promise<BuilderMain>;
}
