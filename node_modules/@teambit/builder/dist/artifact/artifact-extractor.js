"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArtifactExtractor = void 0;
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _filenamify() {
  const data = _interopRequireDefault(require("filenamify"));
  _filenamify = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _minimatch() {
  const data = _interopRequireDefault(require("minimatch"));
  _minimatch = function () {
    return data;
  };
  return data;
}
function _artifactFiles() {
  const data = require("@teambit/legacy/dist/consumer/component/sources/artifact-files");
  _artifactFiles = function () {
    return data;
  };
  return data;
}
function _artifactList() {
  const data = require("./artifact-list");
  _artifactList = function () {
    return data;
  };
  return data;
}
function _artifact() {
  const data = require("./artifact");
  _artifact = function () {
    return data;
  };
  return data;
}
class ArtifactExtractor {
  constructor(scope, builder, pattern, options) {
    this.scope = scope;
    this.builder = builder;
    this.pattern = pattern;
    this.options = options;
  }
  async list() {
    const ids = await this.scope.idsByPattern(this.pattern);
    const components = await this.scope.loadMany(ids);
    const artifactListPerId = components.map(component => {
      return {
        id: component.id,
        artifacts: this.builder.getArtifacts(component)
      };
    });
    this.filterByOptions(artifactListPerId);
    await this.saveFilesInFileSystemIfAsked(artifactListPerId);
    return this.artifactsObjectsToExtractorResults(artifactListPerId);
  }
  groupResultsByAspect(extractorResult) {
    return extractorResult.map(result => {
      const artifacts = result.artifacts.reduce((acc, current) => {
        var _current$aspectId;
        (acc[_current$aspectId = current.aspectId] || (acc[_current$aspectId] = [])).push(current);
        return acc;
      }, {});
      return {
        id: result.id,
        artifacts
      };
    });
  }
  async saveFilesInFileSystemIfAsked(artifactListPerId) {
    const outDir = this.options.outDir;
    if (!outDir) {
      return;
    }
    // @todo: optimize this to first import all missing hashes.
    await (0, _pMapSeries().default)(artifactListPerId, async ({
      id,
      artifacts
    }) => {
      const vinyls = await artifacts.getVinylsAndImportIfMissing(id._legacy, this.scope.legacyScope);
      // make sure the component-dir is just one dir. without this, every slash in the component-id will create a new dir.
      const idAsFilename = (0, _filenamify().default)(id.toStringWithoutVersion(), {
        replacement: '_'
      });
      const compPath = _path().default.join(outDir, idAsFilename);
      await Promise.all(vinyls.map(vinyl => _fsExtra().default.outputFile(_path().default.join(compPath, vinyl.path), vinyl.contents)));
    });
  }
  artifactsObjectsToExtractorResults(artifactListPerId) {
    return artifactListPerId.map(({
      id,
      artifacts
    }) => {
      const results = artifacts.map(artifact => {
        return {
          artifactName: artifact.name,
          aspectId: artifact.task.aspectId,
          taskName: artifact.task.name || artifact.generatedBy,
          files: artifact.files.refs.map(ref => ref.relativePath)
        };
      });
      return {
        id,
        artifacts: results
      };
    });
  }
  filterByOptions(artifactListPerId) {
    const {
      aspect,
      task,
      files
    } = this.options;
    let filteredArtifacts = [];
    artifactListPerId.forEach(item => {
      filteredArtifacts = item.artifacts.filter(artifact => {
        if (aspect && aspect !== artifact.task.aspectId) return false;
        if (task && task !== artifact.task.name) return false;
        return true;
      });
      if (files) {
        filteredArtifacts = item.artifacts.map(artifact => {
          const refs = artifact.files.refs.filter(ref => (0, _minimatch().default)(ref.relativePath, files));
          return new (_artifact().Artifact)(artifact.def, new (_artifactFiles().ArtifactFiles)([], [], refs), artifact.task);
        })
        // remove artifacts with no files
        .filter(artifact => !artifact.isEmpty());
      }
      item.artifacts = _artifactList().ArtifactList.fromArray(filteredArtifacts);
    });
  }
}
exports.ArtifactExtractor = ArtifactExtractor;

//# sourceMappingURL=artifact-extractor.js.map