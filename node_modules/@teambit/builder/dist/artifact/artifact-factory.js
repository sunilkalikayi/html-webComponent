"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_CONTEXT = exports.ArtifactFactory = void 0;
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _globby() {
  const data = _interopRequireDefault(require("globby"));
  _globby = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _artifactFiles() {
  const data = require("@teambit/legacy/dist/consumer/component/sources/artifact-files");
  _artifactFiles = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _storage() {
  const data = require("../storage");
  _storage = function () {
    return data;
  };
  return data;
}
function _artifactList() {
  const data = require("./artifact-list");
  _artifactList = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("../exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _fsArtifact() {
  const data = require("./fs-artifact");
  _fsArtifact = function () {
    return data;
  };
  return data;
}
const DEFAULT_CONTEXT = 'component';
exports.DEFAULT_CONTEXT = DEFAULT_CONTEXT;
class ArtifactFactory {
  resolvePaths(root, def) {
    const patternsFlattened = (0, _lodash().flatten)(def.globPatterns);
    const paths = _globby().default.sync(patternsFlattened, {
      cwd: root
    });
    return paths;
  }
  getArtifactContextPath(context, component, def) {
    const artifactContext = this.getArtifactContext(def);
    if (artifactContext === 'component') {
      var _context$capsuleNetwo;
      const capsulePath = (_context$capsuleNetwo = context.capsuleNetwork.graphCapsules.getCapsule(component.id)) === null || _context$capsuleNetwo === void 0 ? void 0 : _context$capsuleNetwo.path;
      if (!capsulePath) throw new (_exceptions().CapsuleNotFound)(component.id);
      return capsulePath;
    }
    return context.capsuleNetwork.capsulesRootDir;
  }
  getArtifactContext(def) {
    return def.context || DEFAULT_CONTEXT;
  }
  createFromComponent(context, component, def, task) {
    const contextPath = this.getArtifactContextPath(context, component, def);
    const rootDir = this.getRootDir(contextPath, def);
    const paths = this.resolvePaths(rootDir, def);
    if (!paths || !paths.length) {
      return undefined;
    }
    return new (_fsArtifact().FsArtifact)(def, new (_artifactFiles().ArtifactFiles)(paths), task, rootDir);
  }
  getStorageResolver(def) {
    return def.storageResolver || new (_storage().DefaultResolver)();
  }
  toComponentMap(context, artifactMap) {
    return _component().ComponentMap.as(context.components, component => {
      const id = component.id.toString();
      const artifacts = artifactMap.filter(([targetId]) => targetId === id).map(([, artifact]) => artifact);
      return _artifactList().ArtifactList.fromArray(artifacts);
    });
  }
  getRootDir(rootDir, def) {
    if (!def.rootDir) return rootDir;
    return (0, _path().join)(rootDir, def.rootDir);
  }

  /**
   * generate artifacts from a build context according to the spec defined in the artifact definitions.
   */
  generate(context, defs, task) {
    const tupleArr = [];
    defs.forEach(def => {
      const artifactContext = this.getArtifactContext(def);
      if (artifactContext === 'env') {
        const capsuleDir = context.capsuleNetwork.capsulesRootDir;
        const rootDir = this.getRootDir(capsuleDir, def);
        const paths = this.resolvePaths(rootDir, def);
        if (paths && paths.length) {
          const artifact = new (_fsArtifact().FsArtifact)(def, new (_artifactFiles().ArtifactFiles)(this.resolvePaths(rootDir, def)), task, rootDir);
          return context.components.forEach(component => {
            tupleArr.push([component.id.toString(), artifact]);
          });
        }
      }
      return context.components.forEach(component => {
        const artifact = this.createFromComponent(context, component, def, task);
        if (artifact) {
          tupleArr.push([component.id.toString(), artifact]);
        }
      });
    });
    return this.toComponentMap(context, tupleArr);
  }
}
exports.ArtifactFactory = ArtifactFactory;

//# sourceMappingURL=artifact-factory.js.map