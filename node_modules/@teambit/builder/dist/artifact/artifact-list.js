"use strict";

require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArtifactList = void 0;
function _artifact() {
  const data = require("./artifact");
  _artifact = function () {
    return data;
  };
  return data;
}
function _storage() {
  const data = require("../storage");
  _storage = function () {
    return data;
  };
  return data;
}
class ArtifactList extends Array {
  byAspectNameAndName(aspectName, name) {
    const filtered = this.filter(artifact => {
      let cond = true;
      if (aspectName) {
        cond = cond && artifact.task.aspectId === aspectName;
      }
      if (name) {
        cond = cond && artifact.name === name;
      }
      return cond;
    });
    return ArtifactList.fromArray(filtered);
  }
  byAspectNameAndTaskName(aspectName, name) {
    const filtered = this.filter(artifact => {
      let cond = true;
      if (aspectName) {
        cond = cond && artifact.task.aspectId === aspectName;
      }
      if (name) {
        cond = cond && artifact.task.name === name;
      }
      return cond;
    });
    return ArtifactList.fromArray(filtered);
  }
  isEmpty() {
    return this.every(artifact => artifact.files.isEmpty());
  }

  /**
   * group artifacts by the storage resolver.
   */
  groupByResolver() {
    const resolverMap = {};
    this.forEach(artifact => {
      const storageResolver = artifact.storageResolver;
      const resolverArray = resolverMap[storageResolver.name];
      if (!resolverArray) {
        resolverMap[storageResolver.name] = [artifact];
        return;
      }
      if (resolverArray.length) {
        resolverMap[storageResolver.name].push(artifact);
      }
    });
    return resolverMap;
  }
  toObject() {
    return this.map(artifact => artifact.toObject());
  }
  groupByTaskId() {
    return this.reduce((acc, artifact) => {
      const taskId = artifact.task.aspectId;
      acc[taskId] = artifact;
      return acc;
    }, {});
  }
  async getVinylsAndImportIfMissing(id, scope) {
    if (this.isEmpty()) return [];
    const vinyls = await Promise.all(this.map(artifact => artifact.files.getVinylsAndImportIfMissing(id, scope)));
    return vinyls.flat();
  }

  /**
   * store all artifacts using the configured storage resolvers.
   */
  async store(component) {
    const byResolvers = this.groupByResolver();
    const promises = Object.keys(byResolvers).map(async key => {
      const artifacts = byResolvers[key];
      if (!artifacts.length) return;
      const storageResolver = artifacts[0].storageResolver;
      const artifactList = ArtifactList.fromArray(artifacts);
      const artifactPromises = artifactList.map(async artifact => {
        return this.storeArtifact(storageResolver, artifact, component);
      });
      await Promise.all(artifactPromises);
    });
    return Promise.all(promises);
  }
  async storeArtifact(storageResolver, artifact, component) {
    // For now we are always storing also using the default resolver
    if (storageResolver.name !== 'default') {
      const defaultResolver = new (_storage().DefaultResolver)();
      await defaultResolver.store(component, artifact);
    }
    // @ts-ignore
    if (storageResolver.store && typeof storageResolver.store === 'function') {
      return this.storeWholeArtifactByResolver(storageResolver, artifact, component);
    }
    return this.storeArtifactFilesByResolver(storageResolver, artifact, component);
  }

  /**
   * Send the entire artifact to the resolver then get back the result for all files from the resolver
   * @param storageResolver
   * @param artifact
   * @param component
   */
  async storeWholeArtifactByResolver(storageResolver, artifact, component) {
    const results = await storageResolver.store(component, artifact);
    if (!results) return;
    artifact.files.vinyls.map(async file => {
      const url = results[file.relative];
      if (url) {
        file.url = url;
      }
    });
  }

  /**
   * Go over the artifact files and send them to the resolver one by one
   * @param storageResolver
   * @param artifact
   * @param component
   */
  storeArtifactFilesByResolver(storageResolver, artifact, component) {
    const promises = artifact.files.vinyls.map(async file => {
      const url = await storageResolver.storeFile(component, artifact, file);
      if (url) {
        file.url = url;
      }
    });
    return Promise.all(promises);
  }
  static fromArtifactObjects(artifactObjects) {
    const artifacts = artifactObjects.map(object => _artifact().Artifact.fromArtifactObject(object));
    return ArtifactList.fromArray(artifacts);
  }
  static fromArray(artifacts) {
    return new ArtifactList(...artifacts);
  }
}
exports.ArtifactList = ArtifactList;

//# sourceMappingURL=artifact-list.js.map