"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.routePath = exports.defaultExtension = exports.BuilderRoute = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _archiver() {
  const data = _interopRequireDefault(require("archiver"));
  _archiver = function () {
    return data;
  };
  return data;
}
function _mime() {
  const data = _interopRequireDefault(require("mime"));
  _mime = function () {
    return data;
  };
  return data;
}
const routePath = `builder`;
exports.routePath = routePath;
const defaultExtension = '.tgz';
exports.defaultExtension = defaultExtension;
class BuilderRoute {
  constructor(builder, scope, logger) {
    this.builder = builder;
    this.scope = scope;
    this.logger = logger;
    (0, _defineProperty2().default)(this, "route", `/${routePath}/*`);
    (0, _defineProperty2().default)(this, "method", 'get');
    (0, _defineProperty2().default)(this, "middlewares", [async (req, res) => {
      // @ts-ignore TODO: @guy please fix.
      const component = req.component;
      const {
        params
      } = req;
      const [aspectIdStr, filePath] = params[1].split('~');
      // remove trailing slash
      const aspectId = aspectIdStr.replace(/\/$/, '');
      const artifacts = aspectId ? this.builder.getArtifactsByAspect(component, aspectId) : this.builder.getArtifacts(component);
      if (!artifacts) return res.status(404).jsonp({
        error: `no artifacts found for component ${component.id} by aspect ${aspectId}`
      });
      const extensionsWithArtifacts = await Promise.all(artifacts.map(async artifact => {
        const files = await artifact.files.getVinylsAndImportIfMissing(component.id._legacy, this.scope.legacyScope);
        if (!filePath) return {
          extensionId: artifact.task.aspectId,
          files
        };
        return {
          extensionId: artifact.task.aspectId,
          files: files.filter(file => file.path === filePath)
        };
      }));
      const artifactFilesCount = extensionsWithArtifacts.reduce((accum, next) => accum + next.files.length, 0);
      if (artifactFilesCount === 0) return res.status(404).jsonp({
        error: `no artifacts found for component ${component.id} by aspect ${aspectId}`
      });
      if (artifactFilesCount === 1) {
        const extensionWithArtifact = extensionsWithArtifacts.find(e => e.files.length > 0);
        const fileName = `${extensionWithArtifact === null || extensionWithArtifact === void 0 ? void 0 : extensionWithArtifact.extensionId}_${extensionWithArtifact === null || extensionWithArtifact === void 0 ? void 0 : extensionWithArtifact.files[0].path}`;
        const fileContent = extensionWithArtifact === null || extensionWithArtifact === void 0 ? void 0 : extensionWithArtifact.files[0].contents;
        const fileExt = (extensionWithArtifact === null || extensionWithArtifact === void 0 ? void 0 : extensionWithArtifact.files[0].extname) || defaultExtension;
        const contentType = _mime().default.getType(fileExt);
        res.set('Content-disposition', `attachment; filename=${fileName}`);
        if (contentType) res.set('Content-Type', contentType);
        return res.send(fileContent);
      }

      /**
       * if more than 1 file requested, zip them before sending
       */
      const archive = (0, _archiver().default)('tar', {
        gzip: true
      });
      archive.on('warning', warn => {
        this.logger.warn(warn.message);
      });
      archive.on('error', err => {
        this.logger.error(err.message);
      });
      extensionsWithArtifacts.forEach(extensionWithArtifacts => {
        extensionWithArtifacts.files.forEach(artifact => {
          archive.append(artifact.contents, {
            name: `${extensionWithArtifacts.extensionId}_${artifact.path}`
          });
        });
      });
      try {
        archive.pipe(res);
        /**
         *  promise that is returned from the await zip.finalize(); is resolved before the archive is actually finalized
         *  resolving it results in setting the headers before the stream is finished
         */
        // eslint-disable-next-line no-void
        void archive.finalize();
        return res.attachment(`${aspectId.replace('/', '_')}.tar`);
      } catch (e) {
        return res.send({
          error: e.toString()
        });
      }
    }]);
  }
}
exports.BuilderRoute = BuilderRoute;

//# sourceMappingURL=builder.route.js.map