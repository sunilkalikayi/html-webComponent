import { EnvDefinition } from '@teambit/envs';
import type { TaskSlot } from './builder.main.runtime';
import { TasksQueue } from './tasks-queue';
/**
 * there are two ways how to add tasks to build pipeline.
 * 1. `getBuildPipe()` method of the env.
 * 2. registering to the `builder.registerBuildTask()`.
 *
 * in the option #1, it's possible to determine the order. e.g. `getBuildPipe() { return [taskA, taskB, taskC]; }`
 * in the option #2, the register happens once the extension is loaded, so there is no way to put
 * one task before/after another task.
 *
 * To be able to determine the order, you can do the following
 * 1. "task.location", it has two options "start" and "end". the rest are "middle".
 * 2. "task.dependencies", the dependencies must be completed for all envs before this task starts.
 * the dependencies are applicable inside a location and not across locations. see getLocation()
 * or/and continue reading for more info about this.
 *
 * to determine the final order of the tasks, the following is done:
 * 1. split all tasks to three groups: start, middle and end.
 * 2. for each group define a dependencies graph for the tasks with "dependencies" prop and the pipeline.
 * 3. start with the first group "start", toposort the dependencies graph and push the found tasks
 * to a queue. once completed, iterate the pipeline and add all tasks to the queue.
 * 4. do the same for the "middle" and "end" groups.
 *
 * the reason for splitting the tasks to the three groups and not using the "dependencies" field
 * alone to determine the order is that the "start" and "end" groups are mostly core and "middle"
 * is mostly the user entering tasks to the pipeline and we as the core don't know about the users
 * tasks. For example, a core task "PublishComponent" must happen after the compiler, however, a
 * user might have an env without a compiler. if we determine the order only by the dependencies
 * field, the "PublishComponent" would have a dependency "compiler" and because in this case there
 * is no compiler task, it would throw an error about missing dependencies.
 */
export declare function calculatePipelineOrder(taskSlot: TaskSlot, envs: EnvDefinition[], pipeNameOnEnv?: string, tasks?: string[], skipTests?: boolean): TasksQueue;
