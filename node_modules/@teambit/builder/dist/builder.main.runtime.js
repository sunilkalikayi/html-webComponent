"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat-map.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat-map.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FILE_PATH_PARAM_DELIM = exports.BuilderMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _artifactFiles() {
  const data = require("@teambit/legacy/dist/consumer/component/sources/artifact-files");
  _artifactFiles = function () {
    return data;
  };
  return data;
}
function _aspectLoader() {
  const data = require("@teambit/aspect-loader");
  _aspectLoader = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = require("@teambit/envs");
  _envs = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = require("@teambit/graphql");
  _graphql = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = require("@teambit/scope");
  _scope = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = require("@teambit/workspace");
  _workspace = function () {
    return data;
  };
  return data;
}
function _isolator() {
  const data = require("@teambit/isolator");
  _isolator = function () {
    return data;
  };
  return data;
}
function _bootstrap() {
  const data = require("@teambit/legacy/dist/bootstrap");
  _bootstrap = function () {
    return data;
  };
  return data;
}
function _findDuplications() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/array/find-duplications"));
  _findDuplications = function () {
    return data;
  };
  return data;
}
function _generator() {
  const data = require("@teambit/generator");
  _generator = function () {
    return data;
  };
  return data;
}
function _artifact() {
  const data = require("./artifact");
  _artifact = function () {
    return data;
  };
  return data;
}
function _artifactFactory() {
  const data = require("./artifact/artifact-factory");
  _artifactFactory = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("./builder.aspect");
  _builder = function () {
    return data;
  };
  return data;
}
function _builder2() {
  const data = require("./builder.graphql");
  _builder2 = function () {
    return data;
  };
  return data;
}
function _builder3() {
  const data = require("./builder.service");
  _builder3 = function () {
    return data;
  };
  return data;
}
function _build() {
  const data = require("./build.cmd");
  _build = function () {
    return data;
  };
  return data;
}
function _buildTask() {
  const data = require("./build-task");
  _buildTask = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _buildPipelineResultList() {
  const data = require("./build-pipeline-result-list");
  _buildPipelineResultList = function () {
    return data;
  };
  return data;
}
function _artifacts() {
  const data = require("./artifact/artifacts.cmd");
  _artifacts = function () {
    return data;
  };
  return data;
}
function _buildTask2() {
  const data = require("./templates/build-task");
  _buildTask2 = function () {
    return data;
  };
  return data;
}
function _builder4() {
  const data = require("./builder.route");
  _builder4 = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const FILE_PATH_PARAM_DELIM = '~';

/**
 * builder data format for the bit object store
 */
exports.FILE_PATH_PARAM_DELIM = FILE_PATH_PARAM_DELIM;
class BuilderMain {
  constructor(envs, workspace, buildService, tagService, snapService, scope, isolator, aspectLoader, componentAspect, buildTaskSlot, tagTaskSlot, snapTaskSlot) {
    this.envs = envs;
    this.workspace = workspace;
    this.buildService = buildService;
    this.tagService = tagService;
    this.snapService = snapService;
    this.scope = scope;
    this.isolator = isolator;
    this.aspectLoader = aspectLoader;
    this.componentAspect = componentAspect;
    this.buildTaskSlot = buildTaskSlot;
    this.tagTaskSlot = tagTaskSlot;
    this.snapTaskSlot = snapTaskSlot;
  }
  async storeArtifacts(tasksResults) {
    const artifacts = tasksResults.flatMap(t => t.artifacts ? [t.artifacts] : []);
    const storeP = artifacts.map(async artifactMap => {
      return Promise.all(artifactMap.toArray().map(async ([component, artifactList]) => {
        try {
          return await artifactList.store(component);
        } catch (err) {
          throw new (_exceptions().ArtifactStorageError)(err, component);
        }
      }));
    });
    await Promise.all(storeP);
  }
  pipelineResultsToBuilderData(components, buildPipelineResults) {
    const buildPipelineResultList = new (_buildPipelineResultList().BuildPipelineResultList)(buildPipelineResults, components);
    return _component().ComponentMap.as(components, component => {
      const aspectsData = buildPipelineResultList.getDataOfComponent(component.id);
      const pipelineReport = buildPipelineResultList.getPipelineReportOfComponent(component.id);
      const artifacts = buildPipelineResultList.getArtifactsDataOfComponent(component.id);
      return {
        pipeline: pipelineReport,
        artifacts,
        aspectsData,
        bitVersion: (0, _bootstrap().getHarmonyVersion)(true)
      };
    });
  }
  async tagListener(components, options = {}, isolateOptions = {}) {
    const pipeResults = [];
    const {
      throwOnError,
      forceDeploy,
      disableTagAndSnapPipelines,
      isSnap
    } = options;
    const envsExecutionResults = await this.build(components, _objectSpread({
      emptyRootDir: true
    }, isolateOptions), {
      skipTests: options.skipTests
    });
    if (throwOnError && !forceDeploy) envsExecutionResults.throwErrorsIfExist();
    const allTasksResults = [...envsExecutionResults.tasksResults];
    pipeResults.push(envsExecutionResults);
    if (forceDeploy || !disableTagAndSnapPipelines && !envsExecutionResults.hasErrors()) {
      const deployEnvsExecutionResults = isSnap ? await this.runSnapTasks(components, isolateOptions, envsExecutionResults.tasksResults) : await this.runTagTasks(components, isolateOptions, envsExecutionResults.tasksResults);
      if (throwOnError && !forceDeploy) deployEnvsExecutionResults.throwErrorsIfExist();
      allTasksResults.push(...deployEnvsExecutionResults.tasksResults);
      pipeResults.push(deployEnvsExecutionResults);
    }
    await this.storeArtifacts(allTasksResults);
    const builderDataMap = this.pipelineResultsToBuilderData(components, allTasksResults);
    this.validateBuilderDataMap(builderDataMap);
    return {
      builderDataMap,
      pipeResults
    };
  }
  validateBuilderDataMap(builderDataMap) {
    builderDataMap.forEach((buildData, component) => {
      const taskSerializedIds = buildData.pipeline.map(t => _buildTask().BuildTaskHelper.serializeId({
        aspectId: t.taskId,
        name: t.taskName
      }));
      const duplications = (0, _findDuplications().default)(taskSerializedIds);
      if (duplications.length) {
        throw new Error(`build-task-results validation has failed. the following task(s) of "${component.id.toString()}" are duplicated: ${duplications.join(', ')}`);
      }
    });
  }

  // TODO: merge with getArtifactsVinylByExtensionAndName by getting aspect name and name as object with optional props
  async getArtifactsVinylByAspect(component, aspectName) {
    const artifacts = this.getArtifactsByAspect(component, aspectName);
    const vinyls = await artifacts.getVinylsAndImportIfMissing(component.id._legacy, this.scope.legacyScope);
    return vinyls;
  }
  async getArtifactsVinylByAspectAndName(component, aspectName, name) {
    const artifacts = this.getArtifactsByAspectAndName(component, aspectName, name);
    const vinyls = await artifacts.getVinylsAndImportIfMissing(component.id._legacy, this.scope.legacyScope);
    return vinyls;
  }
  async getArtifactsVinylByAspectAndTaskName(component, aspectName, name) {
    const artifacts = this.getArtifactsbyAspectAndTaskName(component, aspectName, name);
    const vinyls = await artifacts.getVinylsAndImportIfMissing(component.id._legacy, this.scope.legacyScope);
    return vinyls;
  }
  getArtifactsByName(component, name) {
    const artifacts = this.getArtifacts(component).byAspectNameAndName(undefined, name);
    return artifacts;
  }
  getArtifactsByAspect(component, aspectName) {
    const artifacts = this.getArtifacts(component).byAspectNameAndName(aspectName);
    return artifacts;
  }
  getArtifactsByAspectAndName(component, aspectName, name) {
    const artifacts = this.getArtifacts(component).byAspectNameAndName(aspectName, name);
    return artifacts;
  }
  getArtifactsbyAspectAndTaskName(component, aspectName, taskName) {
    const artifacts = this.getArtifacts(component).byAspectNameAndTaskName(aspectName, taskName);
    return artifacts;
  }
  getDataByAspect(component, aspectName) {
    var _this$getBuilderData;
    const aspectsData = (_this$getBuilderData = this.getBuilderData(component)) === null || _this$getBuilderData === void 0 ? void 0 : _this$getBuilderData.aspectsData;
    const data = aspectsData === null || aspectsData === void 0 ? void 0 : aspectsData.find(aspectData => aspectData.aspectId === aspectName);
    return data === null || data === void 0 ? void 0 : data.data;
  }
  getArtifacts(component) {
    var _this$getBuilderData2;
    const artifacts = ((_this$getBuilderData2 = this.getBuilderData(component)) === null || _this$getBuilderData2 === void 0 ? void 0 : _this$getBuilderData2.artifacts) || _artifact().ArtifactList.fromArray([]);
    return artifacts;
  }
  getBuilderData(component) {
    var _component$get, _clonedData$artifacts;
    const data = (_component$get = component.get(_builder().BuilderAspect.id)) === null || _component$get === void 0 ? void 0 : _component$get.data;
    if (!data) return undefined;
    const clonedData = (0, _lodash().cloneDeep)(data);
    let artifactFiles;
    (_clonedData$artifacts = clonedData.artifacts) === null || _clonedData$artifacts === void 0 ? void 0 : _clonedData$artifacts.forEach(artifact => {
      if (!(artifact.files instanceof _artifactFiles().ArtifactFiles)) {
        artifactFiles = _artifactFiles().ArtifactFiles.fromObject(artifact.files);
      } else {
        artifactFiles = artifact.files;
      }
      if (!(artifact instanceof _artifact().Artifact)) {
        Object.assign(artifact, {
          files: artifactFiles
        });
        Object.assign(artifact, _artifact().Artifact.fromArtifactObject(artifact));
      }
    });
    clonedData.artifacts = _artifact().ArtifactList.fromArray(clonedData.artifacts || []);
    return clonedData;
  }

  /**
   * build given components for release.
   * for each one of the envs it runs a series of tasks.
   * in case of an error in a task, it stops the execution of that env and continue to the next
   * env. at the end, the results contain the data and errors per env.
   */
  async build(components, isolateOptions, builderOptions) {
    const ids = components.map(c => c.id);
    const network = await this.isolator.isolateComponents(ids, isolateOptions, this.scope.legacyScope);
    const envs = await this.envs.createEnvironment(network.graphCapsules.getAllComponents());
    const builderServiceOptions = _objectSpread({
      seedersOnly: isolateOptions === null || isolateOptions === void 0 ? void 0 : isolateOptions.seedersOnly,
      originalSeeders: ids
    }, builderOptions || {});
    const buildResult = await envs.runOnce(this.buildService, builderServiceOptions);
    return buildResult;
  }
  async runTagTasks(components, isolateOptions, previousTasksResults) {
    const envs = await this.envs.createEnvironment(components);
    const buildResult = await envs.runOnce(this.tagService, {
      seedersOnly: isolateOptions === null || isolateOptions === void 0 ? void 0 : isolateOptions.seedersOnly,
      previousTasksResults
    });
    return buildResult;
  }
  async runSnapTasks(components, isolateOptions, previousTasksResults) {
    const envs = await this.envs.createEnvironment(components);
    const buildResult = await envs.runOnce(this.snapService, {
      seedersOnly: isolateOptions === null || isolateOptions === void 0 ? void 0 : isolateOptions.seedersOnly,
      previousTasksResults
    });
    return buildResult;
  }
  listTasks(component) {
    const compEnv = this.envs.getEnv(component);
    const buildTasks = this.buildService.getCurrentPipeTasks(compEnv);
    const tagTasks = this.tagService.getCurrentPipeTasks(compEnv);
    const snapTasks = this.snapService.getCurrentPipeTasks(compEnv);
    return {
      id: component.id,
      envId: compEnv.id,
      buildTasks,
      tagTasks,
      snapTasks
    };
  }

  /**
   * register a build task to apply on all component build pipelines.
   * build happens on `bit build` and as part of `bit tag --persist`.
   */
  registerBuildTasks(tasks) {
    this.buildTaskSlot.register(tasks);
    return this;
  }

  /**
   * @deprecated use registerTagTasks or registerSnapTasks
   */
  registerDeployTasks(tasks) {
    this.tagTaskSlot.register(tasks);
    return this;
  }

  /**
   * tag tasks that don't get executed on `bit build`, only on `bit tag'.
   * this pipeline is running once the build-pipeline has completed.
   */
  registerTagTasks(tasks) {
    this.tagTaskSlot.register(tasks);
    return this;
  }

  /**
   * tag tasks that don't get executed on `bit build`, only on `bit snap'.
   * this pipeline is running once the build-pipeline has completed.
   */
  registerSnapTasks(tasks) {
    this.snapTaskSlot.register(tasks);
    return this;
  }
  getDownloadUrlForArtifact(componentId, taskId, path) {
    return `/api/${componentId}/~aspect/builder/${taskId}/${path ? `${FILE_PATH_PARAM_DELIM}${path}` : ''}`;
  }
  static async provider([cli, envs, workspace, scope, isolator, loggerExt, aspectLoader, graphql, generator, component], config, [buildTaskSlot, tagTaskSlot, snapTaskSlot]) {
    const artifactFactory = new (_artifactFactory().ArtifactFactory)();
    const logger = loggerExt.createLogger(_builder().BuilderAspect.id);
    const buildService = new (_builder3().BuilderService)(isolator, logger, buildTaskSlot, 'getBuildPipe', 'build', artifactFactory, scope);
    envs.registerService(buildService);
    const tagService = new (_builder3().BuilderService)(isolator, logger, tagTaskSlot, 'getTagPipe', 'tag', artifactFactory, scope);
    const snapService = new (_builder3().BuilderService)(isolator, logger, snapTaskSlot, 'getSnapPipe', 'snap', artifactFactory, scope);
    const builder = new BuilderMain(envs, workspace, buildService, tagService, snapService, scope, isolator, aspectLoader, component, buildTaskSlot, tagTaskSlot, snapTaskSlot);
    component.registerRoute([new (_builder4().BuilderRoute)(builder, scope, logger)]);
    graphql.register((0, _builder2().builderSchema)(builder));
    generator.registerComponentTemplate([_buildTask2().buildTaskTemplate]);
    const commands = [new (_build().BuilderCmd)(builder, workspace, logger), new (_artifacts().ArtifactsCmd)(builder, scope)];
    cli.register(...commands);
    return builder;
  }
}
exports.BuilderMain = BuilderMain;
(0, _defineProperty2().default)(BuilderMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(BuilderMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(BuilderMain, "dependencies", [_cli().CLIAspect, _envs().EnvsAspect, _workspace().WorkspaceAspect, _scope().ScopeAspect, _isolator().IsolatorAspect, _logger().LoggerAspect, _aspectLoader().AspectLoaderAspect, _graphql().GraphqlAspect, _generator().GeneratorAspect, _component().ComponentAspect]);
_builder().BuilderAspect.addRuntime(BuilderMain);

//# sourceMappingURL=builder.main.runtime.js.map