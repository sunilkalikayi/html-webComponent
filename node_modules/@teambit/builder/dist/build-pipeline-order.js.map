{"version":3,"names":["calculatePipelineOrder","taskSlot","envs","pipeNameOnEnv","tasks","skipTests","graphs","locations","forEach","location","push","graph","Graph","pipelineEnvs","envDefinition","pipeline","getPipelineForEnv","env","flattenedPipeline","map","pipelineEnv","flat","task","addDependenciesToGraph","dataPerLocation","pipelineEnvsPerLocation","filter","tasksQueue","TasksQueue","addTasksToGraph","length","includes","name","aspectId","TesterAspect","id","data","find","d","sorted","toposort","taskNode","BuildTaskHelper","deserializeId","attr","taskIndex","findIndex","pipelineTask","splice","dependencies","taskId","serializeId","dependency","deserializeIdAllowEmptyName","dependencyTasks","Error","dependencyTask","getLocation","graphLocation","g","dependencyId","setNode","Node","setEdge","Edge","taskLocation","dependencyLocation","isDependencyAhead","isDependencyEqual","buildTasks","slotsTasks","values","tasksAtStart","tasksAtEnd","mergedTasks"],"sources":["build-pipeline-order.ts"],"sourcesContent":["import { Graph, Node, Edge } from '@teambit/graph.cleargraph';\nimport TesterAspect from '@teambit/tester';\nimport { EnvDefinition, Environment } from '@teambit/envs';\nimport { BuildTask, BuildTaskHelper } from './build-task';\nimport type { TaskSlot } from './builder.main.runtime';\nimport { TasksQueue } from './tasks-queue';\n\ntype TaskDependenciesGraph = Graph<string, string>;\ntype Location = 'start' | 'middle' | 'end';\ntype TasksLocationGraph = { location: Location; graph: TaskDependenciesGraph };\ntype PipelineEnv = { env: EnvDefinition; pipeline: BuildTask[] };\ntype DataPerLocation = { location: Location; graph: TaskDependenciesGraph; pipelineEnvs: PipelineEnv[] };\n\n/**\n * there are two ways how to add tasks to build pipeline.\n * 1. `getBuildPipe()` method of the env.\n * 2. registering to the `builder.registerBuildTask()`.\n *\n * in the option #1, it's possible to determine the order. e.g. `getBuildPipe() { return [taskA, taskB, taskC]; }`\n * in the option #2, the register happens once the extension is loaded, so there is no way to put\n * one task before/after another task.\n *\n * To be able to determine the order, you can do the following\n * 1. \"task.location\", it has two options \"start\" and \"end\". the rest are \"middle\".\n * 2. \"task.dependencies\", the dependencies must be completed for all envs before this task starts.\n * the dependencies are applicable inside a location and not across locations. see getLocation()\n * or/and continue reading for more info about this.\n *\n * to determine the final order of the tasks, the following is done:\n * 1. split all tasks to three groups: start, middle and end.\n * 2. for each group define a dependencies graph for the tasks with \"dependencies\" prop and the pipeline.\n * 3. start with the first group \"start\", toposort the dependencies graph and push the found tasks\n * to a queue. once completed, iterate the pipeline and add all tasks to the queue.\n * 4. do the same for the \"middle\" and \"end\" groups.\n *\n * the reason for splitting the tasks to the three groups and not using the \"dependencies\" field\n * alone to determine the order is that the \"start\" and \"end\" groups are mostly core and \"middle\"\n * is mostly the user entering tasks to the pipeline and we as the core don't know about the users\n * tasks. For example, a core task \"PublishComponent\" must happen after the compiler, however, a\n * user might have an env without a compiler. if we determine the order only by the dependencies\n * field, the \"PublishComponent\" would have a dependency \"compiler\" and because in this case there\n * is no compiler task, it would throw an error about missing dependencies.\n */\nexport function calculatePipelineOrder(\n  taskSlot: TaskSlot,\n  envs: EnvDefinition[],\n  pipeNameOnEnv = 'getBuildPipe',\n  tasks: string[] = [],\n  skipTests = false\n): TasksQueue {\n  const graphs: TasksLocationGraph[] = [];\n  const locations: Location[] = ['start', 'middle', 'end']; // the order is important here!\n  locations.forEach((location) => {\n    graphs.push({ location, graph: new Graph<string, string>() });\n  });\n  const pipelineEnvs: PipelineEnv[] = [];\n  envs.forEach((envDefinition) => {\n    const pipeline = getPipelineForEnv(taskSlot, envDefinition.env, pipeNameOnEnv);\n    pipelineEnvs.push({ env: envDefinition, pipeline });\n  });\n\n  const flattenedPipeline: BuildTask[] = pipelineEnvs.map((pipelineEnv) => pipelineEnv.pipeline).flat();\n  flattenedPipeline.forEach((task) => addDependenciesToGraph(graphs, flattenedPipeline, task));\n\n  const dataPerLocation: DataPerLocation[] = graphs.map(({ location, graph }) => {\n    const pipelineEnvsPerLocation: PipelineEnv[] = pipelineEnvs.map(({ env, pipeline }) => {\n      return { env, pipeline: pipeline.filter((task) => (task.location || 'middle') === location) };\n    });\n    return { location, graph, pipelineEnvs: pipelineEnvsPerLocation };\n  });\n\n  const tasksQueue = new TasksQueue();\n  locations.forEach((location) => addTasksToGraph(tasksQueue, dataPerLocation, location));\n  if (tasks.length) {\n    return new TasksQueue(\n      ...tasksQueue.filter(({ task }) => tasks.includes(task.name) || tasks.includes(task.aspectId))\n    );\n  }\n  if (skipTests) {\n    return new TasksQueue(...tasksQueue.filter(({ task }) => task.aspectId !== TesterAspect.id));\n  }\n  return tasksQueue;\n}\n\nfunction addTasksToGraph(tasksQueue: TasksQueue, dataPerLocation: DataPerLocation[], location: Location) {\n  const data = dataPerLocation.find((d) => d.location === location);\n  if (!data) return;\n  const sorted = data.graph.toposort();\n  sorted.forEach((taskNode) => {\n    const { aspectId, name } = BuildTaskHelper.deserializeId(taskNode.attr);\n    data.pipelineEnvs.forEach(({ env, pipeline }) => {\n      const taskIndex = pipeline.findIndex(\n        (pipelineTask) => pipelineTask.aspectId === aspectId && pipelineTask.name === name\n      );\n      if (taskIndex < 0) return;\n      const task = pipeline[taskIndex];\n      tasksQueue.push({ env, task });\n      pipeline.splice(taskIndex, 1); // delete the task from the pipeline\n    });\n  });\n  data.pipelineEnvs.forEach(({ env, pipeline }) => {\n    pipeline.forEach((task) => tasksQueue.push({ env, task }));\n  });\n}\n\nfunction addDependenciesToGraph(graphs: TasksLocationGraph[], pipeline: BuildTask[], task: BuildTask) {\n  if (!task.dependencies || !task.dependencies.length) return;\n  const taskId = BuildTaskHelper.serializeId(task);\n  task.dependencies.forEach((dependency) => {\n    const { aspectId, name } = BuildTaskHelper.deserializeIdAllowEmptyName(dependency);\n    const dependencyTasks = pipeline.filter((pipelineTask) => {\n      if (pipelineTask.aspectId !== aspectId) return false;\n      return name ? name === pipelineTask.name : true;\n    });\n    if (dependencyTasks.length === 0) {\n      throw new Error(\n        `unable to find dependency \"${dependency}\" of \"${BuildTaskHelper.serializeId(task)}\" in the pipeline`\n      );\n    }\n    dependencyTasks.forEach((dependencyTask) => {\n      const location = getLocation(task, dependencyTask);\n      if (!location) {\n        // the dependency is behind and will be in the correct order regardless the graph.\n        return;\n      }\n      const graphLocation = graphs.find((g) => g.location === location);\n      if (!graphLocation) throw new Error(`unable to find graph for location ${location}`);\n      const dependencyId = BuildTaskHelper.serializeId(dependencyTask);\n      const graph = graphLocation.graph;\n      graph.setNode(new Node(taskId, taskId));\n      graph.setNode(new Node(dependencyId, dependencyId));\n      graph.setEdge(new Edge(dependencyId, taskId, 'dependency'));\n    });\n  });\n}\n\n/**\n * since the task execution is happening per group: \"start\", \"middle\" and \"end\", the dependencies\n * need to be inside the same group.\n * e.g. if a dependency located at \"end\" group and the task located at \"start\", it's impossible to\n * complete the dependency before the task, there it throws an error.\n * it's ok to have the dependency located earlier, e.g. \"start\" and the task at \"end\", and in this\n * case, it will not be part of the graph because there is no need to do any special calculation.\n */\nfunction getLocation(task: BuildTask, dependencyTask: BuildTask): Location | null {\n  const taskLocation = task.location || 'middle';\n  const dependencyLocation = dependencyTask.location || 'middle';\n\n  const isDependencyAhead =\n    (taskLocation === 'start' && dependencyLocation !== 'start') ||\n    (taskLocation === 'middle' && dependencyLocation === 'end');\n\n  const isDependencyEqual = taskLocation === dependencyLocation;\n\n  if (isDependencyAhead) {\n    throw new Error(`a task \"${BuildTaskHelper.serializeId(task)}\" located at ${taskLocation}\nhas a dependency \"${BuildTaskHelper.serializeId(dependencyTask)} located at ${dependencyLocation},\nwhich is invalid. the dependency must be located earlier or in the same location as the task\"`);\n  }\n\n  if (isDependencyEqual) {\n    return taskLocation;\n  }\n\n  // dependency is behind. e.g. task is \"end\" and dependency is \"start\". no need to enter to the\n  // graph as it's going to be executed in the right order regardless the graph.\n  return null;\n}\n\nfunction getPipelineForEnv(taskSlot: TaskSlot, env: Environment, pipeNameOnEnv: string): BuildTask[] {\n  const buildTasks: BuildTask[] = env[pipeNameOnEnv] ? env[pipeNameOnEnv]() : [];\n  const slotsTasks = taskSlot.values().flat();\n  const tasksAtStart: BuildTask[] = [];\n  const tasksAtEnd: BuildTask[] = [];\n  slotsTasks.forEach((task) => {\n    if (task.location === 'start') {\n      tasksAtStart.push(task);\n      return;\n    }\n    if (task.location === 'end') {\n      tasksAtEnd.push(task);\n      return;\n    }\n    tasksAtStart.push(task);\n  });\n\n  // merge with extension registered tasks.\n  const mergedTasks = [...tasksAtStart, ...buildTasks, ...tasksAtEnd];\n\n  return mergedTasks;\n}\n"],"mappings":"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"}