"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BuilderService = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _react() {
  const data = _interopRequireDefault(require("react"));
  _react = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _ink() {
  const data = require("ink");
  _ink = function () {
    return data;
  };
  return data;
}
function _buildPipe() {
  const data = require("./build-pipe");
  _buildPipe = function () {
    return data;
  };
  return data;
}
function _buildTask() {
  const data = require("./build-task");
  _buildTask = function () {
    return data;
  };
  return data;
}
function _buildPipelineOrder() {
  const data = require("./build-pipeline-order");
  _buildPipelineOrder = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("./builder.aspect");
  _builder = function () {
    return data;
  };
  return data;
}
const pipeNames = {
  getBuildPipe: 'build',
  getTagPipe: 'tag',
  getSnapPipe: 'snap'
};
class BuilderService {
  constructor(
  /**
   * isolator extension.
   */
  isolator,
  /**
   * logger extension.
   */
  logger,
  /**
   * task slot (e.g tasks registered by other extensions.).
   */
  taskSlot,
  /**
   * a method with such name should be implemented on the env in order to run the pipe tasks.
   */
  pipeNameOnEnv,
  /**
   * pipe name to display on the console during the execution
   */
  displayPipeName, artifactFactory, scope) {
    this.isolator = isolator;
    this.logger = logger;
    this.taskSlot = taskSlot;
    this.pipeNameOnEnv = pipeNameOnEnv;
    this.displayPipeName = displayPipeName;
    this.artifactFactory = artifactFactory;
    this.scope = scope;
    (0, _defineProperty2().default)(this, "name", 'builder');
  }

  /**
   * runs all tasks for all envs
   */
  async runOnce(envsExecutionContext, options) {
    const envs = envsExecutionContext.map(executionContext => executionContext.envDefinition);
    const tasksQueue = (0, _buildPipelineOrder().calculatePipelineOrder)(this.taskSlot, envs, this.pipeNameOnEnv, options.tasks, options.skipTests);
    tasksQueue.validate();
    this.logger.info(`going to run tasks in the following order:\n${tasksQueue.toString()}`);
    const title = `running ${this.displayPipeName} pipe for ${envs.length} environments, total ${tasksQueue.length} tasks`;
    const longProcessLogger = this.logger.createLongProcessLogger(title);
    this.logger.consoleTitle(title);
    const envsBuildContext = {};
    await (0, _pMapSeries().default)(envsExecutionContext, async executionContext => {
      const componentIds = executionContext.components.map(component => component.id);
      const {
        originalSeeders
      } = options;
      const originalSeedersOfThisEnv = componentIds.filter(compId => originalSeeders ? originalSeeders.find(seeder => compId.isEqual(seeder)) : true);
      const capsuleNetwork = await this.isolator.isolateComponents(componentIds, {
        getExistingAsIs: true,
        seedersOnly: options.seedersOnly
      });
      capsuleNetwork._originalSeeders = originalSeedersOfThisEnv;
      this.logger.console(`generated graph for env "${executionContext.id}", originalSeedersOfThisEnv: ${originalSeedersOfThisEnv.length}, graphOfThisEnv: ${capsuleNetwork.seedersCapsules.length}, graph total: ${capsuleNetwork.graphCapsules.length}`);
      const buildContext = Object.assign(executionContext, {
        capsuleNetwork,
        previousTasksResults: [],
        pipeName: this.displayPipeName,
        dev: options.dev,
        laneId: this.scope.legacyScope.currentLaneId
      });
      envsBuildContext[executionContext.id] = buildContext;
    });
    const buildPipe = new (_buildPipe().BuildPipe)(tasksQueue, envsBuildContext, this.logger, this.artifactFactory, options.previousTasksResults);
    const buildResults = await buildPipe.execute();
    longProcessLogger.end();
    buildResults.hasErrors() ? this.logger.consoleFailure() : this.logger.consoleSuccess();
    return buildResults;
  }
  render(env) {
    const pipes = this.getDescriptor(env);
    return /*#__PURE__*/_react().default.createElement(_ink().Text, {
      key: _builder().BuilderAspect.id
    }, pipes.map(({
      pipeName,
      tasks
    }) => this.renderOnePipe(pipeName, tasks)));
  }
  renderOnePipe(pipeName, tasks) {
    if (!tasks || !tasks.length) return null;
    return /*#__PURE__*/_react().default.createElement(_ink().Text, {
      key: pipeName
    }, /*#__PURE__*/_react().default.createElement(_ink().Text, {
      underline: true,
      color: "green"
    }, pipeName, " pipe"), /*#__PURE__*/_react().default.createElement(_ink().Newline, null), /*#__PURE__*/_react().default.createElement(_ink().Text, {
      color: "cyan"
    }, "total ", tasks.length, " tasks are configured to be executed in the following order"), /*#__PURE__*/_react().default.createElement(_ink().Newline, null), tasks.map((task, index) => /*#__PURE__*/_react().default.createElement(_ink().Text, {
      key: index
    }, /*#__PURE__*/_react().default.createElement(_ink().Text, null, index + 1, ". ", task), /*#__PURE__*/_react().default.createElement(_ink().Newline, null))), /*#__PURE__*/_react().default.createElement(_ink().Newline, null));
  }
  getDescriptor(env) {
    // @ts-ignore
    const tasks = Object.keys(pipeNames).map(pipeFuncName => {
      const tasksQueue = this.getTasksNamesByPipeFunc(env, pipeFuncName);
      return {
        pipeName: pipeNames[pipeFuncName],
        tasks: tasksQueue
      };
    });
    return tasks;
  }
  getTasksNamesByPipeFunc(env, pipeFuncName) {
    const tasksQueue = (0, _buildPipelineOrder().calculatePipelineOrder)(this.taskSlot, [env], pipeFuncName).map(({
      task
    }) => _buildTask().BuildTaskHelper.serializeId(task));
    return tasksQueue;
  }
  getCurrentPipeTasks(env) {
    return this.getTasksNamesByPipeFunc(env, this.pipeNameOnEnv);
  }
}
exports.BuilderService = BuilderService;

//# sourceMappingURL=builder.service.js.map