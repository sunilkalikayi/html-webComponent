{"version":3,"names":["BuildPipelineResultList","constructor","tasksResults","components","artifactListsMap","getFlattenedArtifactListsMapFromAllTasks","artifactListsMaps","flatMap","t","artifacts","ComponentMap","as","component","forEach","artifactListMap","artifactList","getValueByComponentId","id","push","ArtifactList","fromArray","getMetadataFromTaskResults","componentId","compResults","reduce","acc","current","foundComponent","componentsResults","find","c","isEqual","taskId","task","aspectId","metadata","mergeDataIfPossible","getPipelineReportOfComponent","map","taskResults","pipelineReport","taskName","name","taskDescription","description","errors","warnings","startTime","endTime","compact","getDataOfComponent","tasksData","Object","keys","data","getArtifactsDataOfComponent","toObject","currentData","existingData","isEmpty","Error","Array","isArray"],"sources":["build-pipeline-result-list.ts"],"sourcesContent":["import { ComponentID, ComponentMap, Component } from '@teambit/component';\nimport { isEmpty, compact } from 'lodash';\nimport type { ArtifactObject } from '@teambit/legacy/dist/consumer/component/sources/artifact-files';\nimport { Artifact, ArtifactList } from './artifact';\nimport { TaskResults } from './build-pipe';\nimport { Serializable, TaskMetadata } from './types';\n\nexport type PipelineReport = {\n  taskId: string; // task aspect-id\n  taskName: string;\n  taskDescription?: string;\n  startTime?: number;\n  endTime?: number;\n  errors?: Array<Error | string>;\n  warnings?: string[];\n};\n\nexport type AspectData = {\n  aspectId: string;\n  data: Serializable;\n};\n\n/**\n * Helper to get the data and artifacts from the TasksResultsList before saving during the tag\n */\nexport class BuildPipelineResultList {\n  private artifactListsMap: ComponentMap<ArtifactList<Artifact>>;\n  constructor(private tasksResults: TaskResults[], private components: Component[]) {\n    this.artifactListsMap = this.getFlattenedArtifactListsMapFromAllTasks();\n  }\n\n  private getFlattenedArtifactListsMapFromAllTasks(): ComponentMap<ArtifactList<Artifact>> {\n    const artifactListsMaps = this.tasksResults.flatMap((t) => (t.artifacts ? [t.artifacts] : []));\n    return ComponentMap.as<ArtifactList<Artifact>>(this.components, (component) => {\n      const artifacts: Artifact[] = [];\n      artifactListsMaps.forEach((artifactListMap) => {\n        const artifactList = artifactListMap.getValueByComponentId(component.id);\n        if (artifactList) artifacts.push(...artifactList);\n      });\n      return ArtifactList.fromArray(artifacts);\n    });\n  }\n\n  public getMetadataFromTaskResults(componentId: ComponentID): { [taskId: string]: TaskMetadata } {\n    const compResults = this.tasksResults.reduce((acc, current: TaskResults) => {\n      const foundComponent = current.componentsResults.find((c) => c.component.id.isEqual(componentId));\n      const taskId = current.task.aspectId;\n      if (foundComponent && foundComponent.metadata) {\n        acc[taskId] = this.mergeDataIfPossible(foundComponent.metadata, acc[taskId], taskId);\n      }\n      return acc;\n    }, {});\n    return compResults;\n  }\n\n  public getPipelineReportOfComponent(componentId: ComponentID): PipelineReport[] {\n    const compResults = this.tasksResults.map((taskResults: TaskResults) => {\n      const foundComponent = taskResults.componentsResults.find((c) => c.component.id.isEqual(componentId));\n      if (!foundComponent) return null;\n      const pipelineReport: PipelineReport = {\n        taskId: taskResults.task.aspectId,\n        taskName: taskResults.task.name,\n        taskDescription: taskResults.task.description,\n        errors: foundComponent.errors,\n        warnings: foundComponent.warnings,\n        startTime: foundComponent.startTime,\n        endTime: foundComponent.endTime,\n      };\n      return pipelineReport;\n    });\n    return compact(compResults);\n  }\n\n  public getDataOfComponent(componentId: ComponentID): AspectData[] {\n    const tasksData = this.getMetadataFromTaskResults(componentId);\n    return Object.keys(tasksData).map((taskId) => ({\n      aspectId: taskId,\n      data: tasksData[taskId],\n    }));\n  }\n\n  public getArtifactsDataOfComponent(componentId: ComponentID): ArtifactObject[] | undefined {\n    return this.artifactListsMap.getValueByComponentId(componentId)?.toObject();\n  }\n\n  private mergeDataIfPossible(currentData: Serializable, existingData: Serializable | undefined, taskId: string) {\n    if (!existingData || isEmpty(existingData)) return currentData;\n    // both exist\n    if (typeof currentData !== 'object') {\n      throw new Error(`task data must be \"object\", get ${typeof currentData} for ${taskId}`);\n    }\n    if (Array.isArray(currentData)) {\n      throw new Error(`task data must be \"object\", get Array for ${taskId}`);\n    }\n    return { ...currentData, ...existingData };\n  }\n}\n"],"mappings":"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"}