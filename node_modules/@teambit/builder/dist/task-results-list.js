"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TaskResultsList = void 0;
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _buildTask() {
  const data = require("./build-task");
  _buildTask = function () {
    return data;
  };
  return data;
}
class TaskResultsList {
  constructor(tasksQueue,
  /**
   * results of all tasks executed in the build pipeline.
   */
  tasksResults) {
    this.tasksQueue = tasksQueue;
    this.tasksResults = tasksResults;
  }
  hasErrors() {
    return this.tasksResults.some(taskResult => taskResult.componentsResults.find(c => {
      var _c$errors;
      return (_c$errors = c.errors) === null || _c$errors === void 0 ? void 0 : _c$errors.length;
    }));
  }
  throwErrorsIfExist() {
    const errorMessage = this.getErrorMessageFormatted();
    if (errorMessage) {
      throw new (_bitError().BitError)(errorMessage);
    }
  }

  /**
   * group errors from all tasks and show them nicely to the user
   */
  getErrorMessageFormatted() {
    const tasksErrors = [];
    let totalErrors = 0;
    this.tasksResults.forEach(taskResult => {
      const compsWithErrors = taskResult.componentsResults.filter(c => {
        var _c$errors2;
        return (_c$errors2 = c.errors) === null || _c$errors2 === void 0 ? void 0 : _c$errors2.length;
      });
      if (!compsWithErrors.length) return;
      const title = _chalk().default.bold(`Failed task ${tasksErrors.length + 1}: "${_buildTask().BuildTaskHelper.serializeId(taskResult.task)}" of env "${taskResult.env.id}"\n`);
      const errorsStr = compsWithErrors.map(compWithErrors => this.aggregateTaskErrorsToOneString(compWithErrors)).join('\n\n');
      const taskErrors = compsWithErrors.reduce((acc, current) => acc + (current.errors || []).length, 0);
      const summery = `\n\nFound ${taskErrors} errors in ${compsWithErrors.length} components`;
      totalErrors += taskErrors;
      tasksErrors.push(title + errorsStr + summery);
    });
    if (!tasksErrors.length) return null;
    const title = `\nThe following errors were found while running the build pipeline\n`;
    const errorsStr = tasksErrors.join('\n\n');
    const totalTasks = this.tasksQueue.length;
    const totalFailed = tasksErrors.length;
    const totalSucceed = this.tasksResults.length - totalFailed;
    const totalSkipped = totalTasks - this.tasksResults.length;
    const summery = `\n\n\nâœ– Total ${totalTasks} tasks. ${totalSucceed} succeeded. ${totalFailed} failed. ${totalSkipped} skipped. Total errors: ${totalErrors}.`;
    return title + errorsStr + summery;
  }
  aggregateTaskErrorsToOneString(componentResult) {
    const rawErrors = componentResult.errors || [];
    const errors = rawErrors.map(e => typeof e === 'string' ? e : e.toString());
    return `component: ${componentResult.component.id.toString()}\n${errors.join('\n')}`;
  }
}
exports.TaskResultsList = TaskResultsList;

//# sourceMappingURL=task-results-list.js.map