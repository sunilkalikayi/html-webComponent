"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactRouterUI = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _react() {
  const data = _interopRequireDefault(require("react"));
  _react = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _ui() {
  const data = require("@teambit/ui");
  _ui = function () {
    return data;
  };
  return data;
}
function _reactRouter() {
  const data = require("./react-router.aspect");
  _reactRouter = function () {
    return data;
  };
  return data;
}
function _routeContext() {
  const data = require("./route-context");
  _routeContext = function () {
    return data;
  };
  return data;
}
function _routingMethod() {
  const data = require("./routing-method");
  _routingMethod = function () {
    return data;
  };
  return data;
}
function _LocationHooks() {
  const data = require("./LocationHooks");
  _LocationHooks = function () {
    return data;
  };
  return data;
}
class ReactRouterUI {
  constructor(
  /**
   * route slot.
   */
  routeSlot,
  /**
   *
   */
  routeChangeListener) {
    this.routeSlot = routeSlot;
    this.routeChangeListener = routeChangeListener;
    (0, _defineProperty2().default)(this, "routingMode", _routingMethod().Routing.url);
    (0, _defineProperty2().default)(this, "navigateTo", (path, action) => {
      var _this$navigate, _this$navigate2;
      const state = typeof path !== 'string' ? path.state : undefined;
      switch (action) {
        case 'POP':
          return;
        // TBD;
        case 'REPLACE':
          (_this$navigate = this.navigate) === null || _this$navigate === void 0 ? void 0 : _this$navigate.call(this, path, {
            replace: true,
            state
          });
          return;
        case 'PUSH':
        default:
          (_this$navigate2 = this.navigate) === null || _this$navigate2 === void 0 ? void 0 : _this$navigate2.call(this, path, {
            state
          });
      }
    });
    (0, _defineProperty2().default)(this, "navigate", undefined);
    (0, _defineProperty2().default)(this, "handleLocationChange", (location, action) => {
      const listeners = this.routeChangeListener.values();
      listeners.forEach(listener => listener(location, action));
    });
    (0, _defineProperty2().default)(this, "RoutingContext", ({
      children,
      renderCtx
    }) => {
      return /*#__PURE__*/_react().default.createElement(_routeContext().RouteContext, {
        reactRouterUi: this,
        routing: this.routingMode,
        location: renderCtx === null || renderCtx === void 0 ? void 0 : renderCtx.initialLocation
      }, children, /*#__PURE__*/_react().default.createElement(_LocationHooks().LocationHooks, {
        onLocationChange: this.handleLocationChange,
        onNavigatorChange: nav => this.navigate = nav
      }));
    });
    (0, _defineProperty2().default)(this, "ServerRouting", ({
      children,
      renderCtx
    }) => {
      return /*#__PURE__*/_react().default.createElement(_routeContext().RouteContext, {
        reactRouterUi: this,
        routing: _routingMethod().Routing.static,
        location: renderCtx === null || renderCtx === void 0 ? void 0 : renderCtx.initialLocation
      }, children, /*#__PURE__*/_react().default.createElement(_LocationHooks().LocationHooks, {
        onLocationChange: this.handleLocationChange,
        onNavigatorChange: nav => this.navigate = nav
      }));
    });
    (0, _defineProperty2().default)(this, "renderPlugin", {
      browserInit: () => {
        const initialLocation = `${window.location.pathname}${window.location.search}${window.location.hash}`;
        return {
          initialLocation
        };
      },
      serverInit: ({
        browser
      }) => {
        const initialLocation = browser === null || browser === void 0 ? void 0 : browser.location.url;
        return {
          initialLocation
        };
      },
      reactClientContext: this.RoutingContext,
      reactServerContext: this.ServerRouting
    });
  }

  /**
   * render all slot routes.
   */
  renderRoutes(routes) {
    return /*#__PURE__*/_react().default.createElement(_routeContext().RootRoute, {
      routeSlot: this.routeSlot,
      rootRoutes: routes
    });
  }

  /** decides how navigation is stored and applied.
   * Url - updates the `window.location.pathname`.
   * Hash - updates `window.location.hash`.
   * InMemory - store state internally and don't update the browser.
   */
  setRoutingMode(routing) {
    this.routingMode = routing;
  }

  /**
   * register a new route.
   */
  register(route) {
    this.routeSlot.register(route);
    return this;
  }
  registerListener(listener) {
    this.routeChangeListener.register(listener);
  }

  /**
   * change browser location
   */

  static async provider(deps, config, [routeSlot, routeChangeSlot]) {
    return new ReactRouterUI(routeSlot, routeChangeSlot);
  }
}
exports.ReactRouterUI = ReactRouterUI;
(0, _defineProperty2().default)(ReactRouterUI, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(ReactRouterUI, "runtime", _ui().UIRuntime);
_reactRouter().ReactRouterAspect.addRuntime(ReactRouterUI);

//# sourceMappingURL=react-router.ui.runtime.js.map