"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ListCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _ramda() {
  const data = _interopRequireDefault(require("ramda"));
  _ramda = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _hasWildcard() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/string/has-wildcard"));
  _hasWildcard = function () {
    return data;
  };
  return data;
}
function _listTemplate() {
  const data = require("./list-template");
  _listTemplate = function () {
    return data;
  };
  return data;
}
class ListCmd {
  constructor(lister) {
    this.lister = lister;
    (0, _defineProperty2().default)(this, "name", 'list [remote-scope]');
    (0, _defineProperty2().default)(this, "description", 'list components on a workspace, local scope or a remote scope.');
    (0, _defineProperty2().default)(this, "group", 'discover');
    (0, _defineProperty2().default)(this, "extendedDescription", `https://${_constants().BASE_DOCS_DOMAIN}/reference/cli-reference#list`);
    (0, _defineProperty2().default)(this, "alias", 'ls');
    (0, _defineProperty2().default)(this, "options", [['i', 'ids', 'show only component ids unformatted'], ['s', 'scope', 'show only components stored in the local scope, including indirect dependencies'], ['o', 'outdated', 'show latest versions from remotes'], ['j', 'json', 'show the output in JSON format'], ['n', 'namespace <string>', 'show only specified namespace by using wildcards']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "skipWorkspace", true);
    (0, _defineProperty2().default)(this, "remoteOp", true);
  }
  async report([scopeName], listFlags) {
    const listScopeResults = await this.getListResults(scopeName, listFlags);
    const {
      ids,
      scope = false,
      outdated = false
    } = listFlags;
    function decideHeaderSentence() {
      if (!scope) return `found ${listScopeResults.length} components\n`;
      return _chalk().default.white(`found ${listScopeResults.length} components in ${_chalk().default.bold(scopeName)}\n`);
    }
    if (_ramda().default.isEmpty(listScopeResults)) {
      return _chalk().default.white(decideHeaderSentence());
    }
    if (ids) return JSON.stringify(listScopeResults.map(result => result.id.toString()));
    // TODO - use a cheaper list for ids flag (do not fetch versions at all) @!IMPORTANT
    return decideHeaderSentence() + (0, _listTemplate().listTemplate)(listScopeResults, false, outdated);
  }
  async json([scopeName], listFlags) {
    const listScopeResults = await this.getListResults(scopeName, listFlags);
    if (_ramda().default.isEmpty(listScopeResults)) {
      return [];
    }
    const {
      ids,
      outdated = false
    } = listFlags;
    if (ids) return listScopeResults.map(result => result.id.toString());
    return (0, _listTemplate().listTemplate)(listScopeResults, true, outdated);
  }
  async getListResults(scopeName, {
    namespace,
    scope,
    outdated
  } = {}) {
    const getNamespaceWithWildcard = () => {
      if (!namespace) return undefined;
      if ((0, _hasWildcard().default)(namespace)) return namespace;
      return `${namespace}/*`;
    };
    const namespaceWithWildcard = getNamespaceWithWildcard();
    return scopeName ? this.lister.remoteList(scopeName, namespaceWithWildcard) : this.lister.localList(scope, outdated, namespaceWithWildcard);
  }
}
exports.ListCmd = ListCmd;

//# sourceMappingURL=list.cmd.js.map