"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RenamingMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/bit/component-id-to-package-name"));
  _componentIdToPackageName = function () {
    return data;
  };
  return data;
}
function _config() {
  const data = require("@teambit/config");
  _config = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = _interopRequireWildcard(require("@teambit/component"));
  _component = function () {
    return data;
  };
  return data;
}
function _deprecation() {
  const data = require("@teambit/deprecation");
  _deprecation = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = _interopRequireDefault(require("@teambit/graphql"));
  _graphql = function () {
    return data;
  };
  return data;
}
function _newComponentHelper() {
  const data = _interopRequireDefault(require("@teambit/new-component-helper"));
  _newComponentHelper = function () {
    return data;
  };
  return data;
}
function _refactoring() {
  const data = _interopRequireDefault(require("@teambit/refactoring"));
  _refactoring = function () {
    return data;
  };
  return data;
}
function _componentConfig() {
  const data = require("@teambit/legacy/dist/consumer/config/component-config");
  _componentConfig = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _install() {
  const data = require("@teambit/install");
  _install = function () {
    return data;
  };
  return data;
}
function _rename() {
  const data = require("./rename.cmd");
  _rename = function () {
    return data;
  };
  return data;
}
function _renaming() {
  const data = require("./renaming.aspect");
  _renaming = function () {
    return data;
  };
  return data;
}
function _renaming2() {
  const data = require("./renaming.fragment");
  _renaming2 = function () {
    return data;
  };
  return data;
}
function _renaming3() {
  const data = require("./renaming.graphql");
  _renaming3 = function () {
    return data;
  };
  return data;
}
function _scopeRename() {
  const data = require("./scope-rename.cmd");
  _scopeRename = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class RenamingMain {
  constructor(workspace, install, newComponentHelper, deprecation, refactoring, config) {
    this.workspace = workspace;
    this.install = install;
    this.newComponentHelper = newComponentHelper;
    this.deprecation = deprecation;
    this.refactoring = refactoring;
    this.config = config;
  }
  async rename(sourceIdStr, targetIdStr, options) {
    const sourceId = await this.workspace.resolveComponentId(sourceIdStr);
    const isTagged = sourceId.hasVersion();
    const sourceComp = await this.workspace.get(sourceId);
    const targetId = this.newComponentHelper.getNewComponentId(targetIdStr, undefined, options === null || options === void 0 ? void 0 : options.scope);
    if (isTagged) {
      const config = await this.getConfig(sourceComp);
      await this.newComponentHelper.writeAndAddNewComp(sourceComp, targetId, options, config);
      await this.deprecation.deprecate(sourceId, targetId);
    } else {
      this.workspace.bitMap.renameNewComponent(sourceId, targetId);
      await this.workspace.bitMap.write();
    }
    if (options.refactor) {
      const allComponents = await this.workspace.list();
      const {
        changedComponents
      } = await this.refactoring.refactorDependencyName(allComponents, sourceId, targetId);
      await Promise.all(changedComponents.map(comp => this.workspace.write(comp)));
    }
    await this.install.link();
    return {
      sourceId,
      targetId
    };
  }
  getRenamingInfo(component) {
    var _component$state$aspe;
    const renameConfig = (_component$state$aspe = component.state.aspects.get(_renaming().RenamingAspect.id)) === null || _component$state$aspe === void 0 ? void 0 : _component$state$aspe.config;
    if (!renameConfig) return null;
    return {
      renamedFrom: _component().ComponentID.fromObject(renameConfig.renamedFrom)
    };
  }

  /**
   * change the default-scope for new components. optionally (if refactor is true), change the source code to match the
   * new scope-name.
   * keep in mind that this is working for new components only, for tagged/exported it's impossible. See the errors
   * thrown in such cases in this method.
   */
  async renameScope(oldScope, newScope, options) {
    const allComponents = await this.workspace.list();
    const componentsUsingOldScope = allComponents.filter(comp => comp.id.scope === oldScope);
    if (!componentsUsingOldScope.length && this.workspace.defaultScope !== oldScope) {
      throw new (_bitError().BitError)(`none of the components is using "${oldScope}". also, the workspace is not configured with "${oldScope}"`);
    }
    // verify they're all new.
    const exported = componentsUsingOldScope.filter(comp => comp.id._legacy.hasScope());
    if (exported.length) {
      const idsStr = exported.map(comp => comp.id.toString()).join(', ');
      throw new (_bitError().BitError)(`unable to rename the scope for the following exported components:\n${idsStr}
because these components were exported already, other components may use them and they'll break upon rename.
instead, deprecate the above components (using "bit deprecate"), tag, export and then eject them.
once they are not in the workspace, you can fork them ("bit fork") with the new scope-name`);
    }
    const tagged = componentsUsingOldScope.filter(comp => comp.id.hasVersion());
    if (tagged.length) {
      const idsStr = tagged.map(comp => comp.id.toString()).join(', ');
      throw new (_bitError().BitError)(`unable to rename the scope for the following tagged components:\n${idsStr}
because these components were tagged, the objects have the dependencies data of the old-scope.
to be able to rename the scope, please untag the components first (using "bit reset" command)`);
    }
    if (this.workspace.defaultScope === oldScope) {
      await this.workspace.setDefaultScope(newScope);
      componentsUsingOldScope.forEach(comp => this.workspace.bitMap.removeDefaultScope(comp.id));
    } else {
      componentsUsingOldScope.forEach(comp => this.workspace.bitMap.setDefaultScope(comp.id, newScope));
    }
    await this.workspace.bitMap.write();
    const refactoredIds = [];
    if (options.refactor) {
      const legacyComps = componentsUsingOldScope.map(c => c.state._consumer);
      const packagesToReplace = legacyComps.map(comp => {
        return {
          oldStr: (0, _componentIdToPackageName().default)(comp),
          newStr: (0, _componentIdToPackageName().default)(_objectSpread(_objectSpread({}, comp), {}, {
            bindingPrefix: (0, _componentConfig().getBindingPrefixByDefaultScope)(newScope),
            id: comp.id,
            defaultScope: newScope
          }))
        };
      });
      const {
        changedComponents
      } = await this.refactoring.replaceMultipleStrings(allComponents, packagesToReplace);
      await this.renameScopeOfAspectIdsInWorkspaceConfig(componentsUsingOldScope.map(c => c.id), newScope);
      await Promise.all(changedComponents.map(comp => this.workspace.write(comp)));
      refactoredIds.push(...changedComponents.map(c => c.id));
    }
    return {
      scopeRenamedComponentIds: componentsUsingOldScope.map(comp => comp.id),
      refactoredIds
    };
  }
  async renameScopeOfAspectIdsInWorkspaceConfig(ids, newScope) {
    const config = this.config.workspaceConfig;
    if (!config) throw new Error('unable to get workspace config');
    let hasChanged = false;
    ids.forEach(id => {
      const changed = config.renameExtensionInRaw(id.toStringWithoutVersion(), id._legacy.changeScope(newScope).toStringWithoutVersion());
      if (changed) hasChanged = true;
    });
    if (hasChanged) await config.write();
  }
  async getConfig(comp) {
    const fromExisting = await this.newComponentHelper.getConfigFromExistingToNewComponent(comp);
    return _objectSpread(_objectSpread({}, fromExisting), {}, {
      [_renaming().RenamingAspect.id]: {
        renamedFrom: comp.id.toObject()
      }
    });
  }
  static async provider([cli, workspace, deprecation, newComponentHelper, componentMain, graphql, refactoring, install, config]) {
    var _scopeCommand$command;
    const renaming = new RenamingMain(workspace, install, newComponentHelper, deprecation, refactoring, config);
    cli.register(new (_rename().RenameCmd)(renaming));
    const scopeCommand = cli.getCommand('scope');
    scopeCommand === null || scopeCommand === void 0 ? void 0 : (_scopeCommand$command = scopeCommand.commands) === null || _scopeCommand$command === void 0 ? void 0 : _scopeCommand$command.push(new (_scopeRename().ScopeRenameCmd)(renaming));
    graphql.register((0, _renaming3().renamingSchema)(renaming));
    componentMain.registerShowFragments([new (_renaming2().RenamingFragment)(renaming)]);
    return renaming;
  }
}
exports.RenamingMain = RenamingMain;
(0, _defineProperty2().default)(RenamingMain, "slots", []);
(0, _defineProperty2().default)(RenamingMain, "dependencies", [_cli().CLIAspect, _workspace().default, _deprecation().DeprecationAspect, _newComponentHelper().default, _component().default, _graphql().default, _refactoring().default, _install().InstallAspect, _config().ConfigAspect]);
(0, _defineProperty2().default)(RenamingMain, "runtime", _cli().MainRuntime);
_renaming().RenamingAspect.addRuntime(RenamingMain);

//# sourceMappingURL=renaming.main.runtime.js.map