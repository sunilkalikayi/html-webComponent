{"version":3,"names":["GraphFromFsBuilder","constructor","workspace","logger","ignoreIds","BitIds","shouldLoadItsDeps","shouldThrowOnMissingDep","LegacyGraph","consumer","buildGraph","ids","debug","length","start","Date","now","components","loadManyComponents","processManyComponents","graph","getAllDepsUnfiltered","component","getAllDependenciesIds","difference","getAllDepsFiltered","depsWithoutIgnore","shouldLoadFunc","deps","mapSeries","depId","shouldLoad","push","fromArray","compact","depth","importObjects","allDependencies","processOneComponent","allDependenciesFlattened","flatten","allDeps","map","c","flat","allDepsWithScope","filter","dep","hasScope","scopeComponentsImporter","ScopeComponentsImporter","scope","importMany","uniqFromArray","throwForDependencyNotFound","throwForSeederNotFound","reFetchUnBuiltVersion","idStr","id","toString","completed","includes","allIds","Object","entries","depsIdsGroupedByType","forEach","depType","depsIds","has","hasNode","Error","warn","setEdge","componentsIds","dependenciesOf","comp","fromGraph","node","loadComponent","setNode","err","ComponentNotFound","ComponentNotFoundInScope","ScopeNotFound","BitError","error","componentId","compId","resolveComponentId","get","state","_consumer"],"sources":["build-graph-from-fs.ts"],"sourcesContent":["import mapSeries from 'p-map-series';\nimport { flatten } from 'lodash';\nimport { Consumer } from '@teambit/legacy/dist/consumer';\nimport BitIds from '@teambit/legacy/dist/bit-id/bit-ids';\nimport Component from '@teambit/legacy/dist/consumer/component/consumer-component';\nimport LegacyGraph from '@teambit/legacy/dist/scope/graph/graph';\nimport ScopeComponentsImporter from '@teambit/legacy/dist/scope/component-ops/scope-components-importer';\nimport { ComponentNotFound, ScopeNotFound } from '@teambit/legacy/dist/scope/exceptions';\nimport { ComponentNotFound as ComponentNotFoundInScope } from '@teambit/scope';\nimport compact from 'lodash.compact';\nimport { BitId } from '@teambit/legacy-bit-id';\nimport { Logger } from '@teambit/logger';\nimport { BitError } from '@teambit/bit-error';\nimport { Workspace } from './workspace';\n\nexport type ShouldLoadFunc = (bitId: BitId) => Promise<boolean>;\n\nexport class GraphFromFsBuilder {\n  private graph = new LegacyGraph();\n  private completed: string[] = [];\n  private depth = 1;\n  private consumer: Consumer;\n  constructor(\n    private workspace: Workspace,\n    private logger: Logger,\n    private ignoreIds = new BitIds(),\n    private shouldLoadItsDeps?: ShouldLoadFunc,\n    private shouldThrowOnMissingDep = true\n  ) {\n    this.consumer = this.workspace.consumer;\n  }\n\n  /**\n   * create a graph with all dependencies and flattened dependencies of the given components.\n   * the nodes are components and the edges has a label of the dependency type.\n   *\n   * the way how it is done is iterations by depths. each depth we gather all the dependencies of\n   * that depths, make sure all objects exist and then check their dependencies for the next depth.\n   * once there is no dependency left, we're on the last depth level and the graph is ready.\n   *\n   * for example, imagine the following graph:\n   * A1 -> A2 -> A3\n   * B1 -> B2 -> B3\n   * C1 -> C2 -> C3\n   *\n   * where the buildGraph is given [A1, B1, C1].\n   * first, it saves all these components as nodes in the graph. then, it finds the dependencies of\n   * the next level, in this case they're [A2, B2, C2]. it runs `importMany` in case some objects\n   * are missing. then, it loads them all (some from FS, some from the model) and sets the edges\n   * between the component and the dependencies.\n   * once done, it finds all their dependencies, which are [A3, B3, C3] and repeat the process\n   * above. since there are no more dependencies, the graph is completed.\n   * in this case, the total depth levels are 3.\n   *\n   * even with a huge project, there are not many depth levels. by iterating through depth levels\n   * we keep performance sane as the importMany doesn't run multiple time and therefore the round\n   * trips to the remotes are minimal.\n   *\n   * normally, one importMany of the seeders is enough as importMany knows to fetch all flattened.\n   * however, since this buildGraph is performed on the workspace, a dependency may be new or\n   * modified and as such, we don't know its flattened yet.\n   */\n  async buildGraph(ids: BitId[]): Promise<LegacyGraph> {\n    this.logger.debug(`GraphFromFsBuilder, buildGraph with ${ids.length} seeders`);\n    const start = Date.now();\n    const components = await this.loadManyComponents(ids);\n    await this.processManyComponents(components);\n    this.logger.debug(\n      `GraphFromFsBuilder, buildGraph with ${ids.length} seeders completed (${(Date.now() - start) / 1000} sec)`\n    );\n    return this.graph;\n  }\n\n  private getAllDepsUnfiltered(component: Component) {\n    return component.getAllDependenciesIds().difference(this.ignoreIds);\n  }\n\n  private async getAllDepsFiltered(component: Component): Promise<BitIds> {\n    const depsWithoutIgnore = this.getAllDepsUnfiltered(component);\n    const shouldLoadFunc = this.shouldLoadItsDeps;\n    if (!shouldLoadFunc) return depsWithoutIgnore;\n    const deps = await mapSeries(depsWithoutIgnore, async (depId) => {\n      const shouldLoad = await shouldLoadFunc(depId);\n      if (!shouldLoad) this.ignoreIds.push(depId);\n      return shouldLoad ? depId : null;\n    });\n    return BitIds.fromArray(compact(deps));\n  }\n\n  private async processManyComponents(components: Component[]) {\n    this.logger.debug(`GraphFromFsBuilder.processManyComponents depth ${this.depth}, ${components.length} components`);\n    this.depth += 1;\n    await this.importObjects(components);\n    const allDependencies = await mapSeries(components, (component) => this.processOneComponent(component));\n    const allDependenciesFlattened = flatten(allDependencies);\n    if (allDependenciesFlattened.length) await this.processManyComponents(allDependenciesFlattened);\n  }\n\n  private async importObjects(components: Component[]) {\n    const allDeps = components.map((c) => this.getAllDepsUnfiltered(c)).flat();\n    const allDepsWithScope = allDeps.filter((dep) => dep.hasScope());\n    const scopeComponentsImporter = new ScopeComponentsImporter(this.consumer.scope);\n    await scopeComponentsImporter.importMany({\n      ids: BitIds.uniqFromArray(allDepsWithScope),\n      throwForDependencyNotFound: this.shouldThrowOnMissingDep,\n      throwForSeederNotFound: this.shouldThrowOnMissingDep,\n      reFetchUnBuiltVersion: false,\n    });\n  }\n\n  private async processOneComponent(component: Component) {\n    const idStr = component.id.toString();\n    if (this.completed.includes(idStr)) return [];\n    const allIds = await this.getAllDepsFiltered(component);\n\n    const allDependencies = await this.loadManyComponents(allIds, idStr);\n    Object.entries(component.depsIdsGroupedByType).forEach(([depType, depsIds]) => {\n      depsIds.forEach((depId) => {\n        if (this.ignoreIds.has(depId)) return;\n        if (!this.graph.hasNode(depId.toString())) {\n          if (this.shouldThrowOnMissingDep) {\n            throw new Error(`buildOneComponent: missing node of ${depId.toString()}`);\n          }\n          this.logger.warn(`ignoring missing ${depId.toString()}`);\n          return;\n        }\n        this.graph.setEdge(idStr, depId.toString(), depType);\n      });\n    });\n    this.completed.push(idStr);\n    return allDependencies;\n  }\n\n  private async loadManyComponents(componentsIds: BitId[], dependenciesOf?: string): Promise<Component[]> {\n    const components = await mapSeries(componentsIds, async (comp: BitId) => {\n      const idStr = comp.toString();\n      const fromGraph = this.graph.node(idStr);\n      if (fromGraph) return fromGraph;\n      try {\n        const component = await this.loadComponent(comp);\n        this.graph.setNode(idStr, component);\n        return component;\n      } catch (err: any) {\n        if (\n          err instanceof ComponentNotFound ||\n          err instanceof ComponentNotFoundInScope ||\n          err instanceof ScopeNotFound\n        ) {\n          if (dependenciesOf && !this.shouldThrowOnMissingDep) {\n            this.logger.warn(\n              `component ${idStr}, dependency of ${dependenciesOf} was not found. continuing without it`\n            );\n            return null;\n          }\n          throw new BitError(\n            `error: component \"${idStr}\" was not found.\\nthis component is a dependency of \"${\n              dependenciesOf || '<none>'\n            }\" and is needed as part of the graph generation`\n          );\n        }\n        if (dependenciesOf) this.logger.error(`failed loading dependencies of ${dependenciesOf}`);\n        throw err;\n      }\n    });\n    return compact(components);\n  }\n  private async loadComponent(componentId: BitId): Promise<Component> {\n    const compId = await this.workspace.resolveComponentId(componentId);\n    const comp = await this.workspace.get(compId);\n    return comp.state._consumer;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAEA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAEA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAGA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAKO,MAAMA,kBAAkB,CAAC;EAK9BC,WAAW,CACDC,SAAoB,EACpBC,MAAc,EACdC,SAAS,GAAG,KAAIC,iBAAM,GAAE,EACxBC,iBAAkC,EAClCC,uBAAuB,GAAG,IAAI,EACtC;IAAA,KALQL,SAAoB,GAApBA,SAAoB;IAAA,KACpBC,MAAc,GAAdA,MAAc;IAAA,KACdC,SAAS,GAATA,SAAS;IAAA,KACTE,iBAAkC,GAAlCA,iBAAkC;IAAA,KAClCC,uBAAuB,GAAvBA,uBAAuB;IAAA,+CATjB,KAAIC,gBAAW,GAAE;IAAA,mDACH,EAAE;IAAA,+CAChB,CAAC;IAAA;IASf,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACP,SAAS,CAACO,QAAQ;EACzC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,UAAU,CAACC,GAAY,EAAwB;IACnD,IAAI,CAACR,MAAM,CAACS,KAAK,CAAE,uCAAsCD,GAAG,CAACE,MAAO,UAAS,CAAC;IAC9E,MAAMC,KAAK,GAAGC,IAAI,CAACC,GAAG,EAAE;IACxB,MAAMC,UAAU,GAAG,MAAM,IAAI,CAACC,kBAAkB,CAACP,GAAG,CAAC;IACrD,MAAM,IAAI,CAACQ,qBAAqB,CAACF,UAAU,CAAC;IAC5C,IAAI,CAACd,MAAM,CAACS,KAAK,CACd,uCAAsCD,GAAG,CAACE,MAAO,uBAAsB,CAACE,IAAI,CAACC,GAAG,EAAE,GAAGF,KAAK,IAAI,IAAK,OAAM,CAC3G;IACD,OAAO,IAAI,CAACM,KAAK;EACnB;EAEQC,oBAAoB,CAACC,SAAoB,EAAE;IACjD,OAAOA,SAAS,CAACC,qBAAqB,EAAE,CAACC,UAAU,CAAC,IAAI,CAACpB,SAAS,CAAC;EACrE;EAEA,MAAcqB,kBAAkB,CAACH,SAAoB,EAAmB;IACtE,MAAMI,iBAAiB,GAAG,IAAI,CAACL,oBAAoB,CAACC,SAAS,CAAC;IAC9D,MAAMK,cAAc,GAAG,IAAI,CAACrB,iBAAiB;IAC7C,IAAI,CAACqB,cAAc,EAAE,OAAOD,iBAAiB;IAC7C,MAAME,IAAI,GAAG,MAAM,IAAAC,qBAAS,EAACH,iBAAiB,EAAE,MAAOI,KAAK,IAAK;MAC/D,MAAMC,UAAU,GAAG,MAAMJ,cAAc,CAACG,KAAK,CAAC;MAC9C,IAAI,CAACC,UAAU,EAAE,IAAI,CAAC3B,SAAS,CAAC4B,IAAI,CAACF,KAAK,CAAC;MAC3C,OAAOC,UAAU,GAAGD,KAAK,GAAG,IAAI;IAClC,CAAC,CAAC;IACF,OAAOzB,iBAAM,CAAC4B,SAAS,CAAC,IAAAC,kBAAO,EAACN,IAAI,CAAC,CAAC;EACxC;EAEA,MAAcT,qBAAqB,CAACF,UAAuB,EAAE;IAC3D,IAAI,CAACd,MAAM,CAACS,KAAK,CAAE,kDAAiD,IAAI,CAACuB,KAAM,KAAIlB,UAAU,CAACJ,MAAO,aAAY,CAAC;IAClH,IAAI,CAACsB,KAAK,IAAI,CAAC;IACf,MAAM,IAAI,CAACC,aAAa,CAACnB,UAAU,CAAC;IACpC,MAAMoB,eAAe,GAAG,MAAM,IAAAR,qBAAS,EAACZ,UAAU,EAAGK,SAAS,IAAK,IAAI,CAACgB,mBAAmB,CAAChB,SAAS,CAAC,CAAC;IACvG,MAAMiB,wBAAwB,GAAG,IAAAC,iBAAO,EAACH,eAAe,CAAC;IACzD,IAAIE,wBAAwB,CAAC1B,MAAM,EAAE,MAAM,IAAI,CAACM,qBAAqB,CAACoB,wBAAwB,CAAC;EACjG;EAEA,MAAcH,aAAa,CAACnB,UAAuB,EAAE;IACnD,MAAMwB,OAAO,GAAGxB,UAAU,CAACyB,GAAG,CAAEC,CAAC,IAAK,IAAI,CAACtB,oBAAoB,CAACsB,CAAC,CAAC,CAAC,CAACC,IAAI,EAAE;IAC1E,MAAMC,gBAAgB,GAAGJ,OAAO,CAACK,MAAM,CAAEC,GAAG,IAAKA,GAAG,CAACC,QAAQ,EAAE,CAAC;IAChE,MAAMC,uBAAuB,GAAG,KAAIC,kCAAuB,EAAC,IAAI,CAACzC,QAAQ,CAAC0C,KAAK,CAAC;IAChF,MAAMF,uBAAuB,CAACG,UAAU,CAAC;MACvCzC,GAAG,EAAEN,iBAAM,CAACgD,aAAa,CAACR,gBAAgB,CAAC;MAC3CS,0BAA0B,EAAE,IAAI,CAAC/C,uBAAuB;MACxDgD,sBAAsB,EAAE,IAAI,CAAChD,uBAAuB;MACpDiD,qBAAqB,EAAE;IACzB,CAAC,CAAC;EACJ;EAEA,MAAclB,mBAAmB,CAAChB,SAAoB,EAAE;IACtD,MAAMmC,KAAK,GAAGnC,SAAS,CAACoC,EAAE,CAACC,QAAQ,EAAE;IACrC,IAAI,IAAI,CAACC,SAAS,CAACC,QAAQ,CAACJ,KAAK,CAAC,EAAE,OAAO,EAAE;IAC7C,MAAMK,MAAM,GAAG,MAAM,IAAI,CAACrC,kBAAkB,CAACH,SAAS,CAAC;IAEvD,MAAMe,eAAe,GAAG,MAAM,IAAI,CAACnB,kBAAkB,CAAC4C,MAAM,EAAEL,KAAK,CAAC;IACpEM,MAAM,CAACC,OAAO,CAAC1C,SAAS,CAAC2C,oBAAoB,CAAC,CAACC,OAAO,CAAC,CAAC,CAACC,OAAO,EAAEC,OAAO,CAAC,KAAK;MAC7EA,OAAO,CAACF,OAAO,CAAEpC,KAAK,IAAK;QACzB,IAAI,IAAI,CAAC1B,SAAS,CAACiE,GAAG,CAACvC,KAAK,CAAC,EAAE;QAC/B,IAAI,CAAC,IAAI,CAACV,KAAK,CAACkD,OAAO,CAACxC,KAAK,CAAC6B,QAAQ,EAAE,CAAC,EAAE;UACzC,IAAI,IAAI,CAACpD,uBAAuB,EAAE;YAChC,MAAM,IAAIgE,KAAK,CAAE,sCAAqCzC,KAAK,CAAC6B,QAAQ,EAAG,EAAC,CAAC;UAC3E;UACA,IAAI,CAACxD,MAAM,CAACqE,IAAI,CAAE,oBAAmB1C,KAAK,CAAC6B,QAAQ,EAAG,EAAC,CAAC;UACxD;QACF;QACA,IAAI,CAACvC,KAAK,CAACqD,OAAO,CAAChB,KAAK,EAAE3B,KAAK,CAAC6B,QAAQ,EAAE,EAAEQ,OAAO,CAAC;MACtD,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,IAAI,CAACP,SAAS,CAAC5B,IAAI,CAACyB,KAAK,CAAC;IAC1B,OAAOpB,eAAe;EACxB;EAEA,MAAcnB,kBAAkB,CAACwD,aAAsB,EAAEC,cAAuB,EAAwB;IACtG,MAAM1D,UAAU,GAAG,MAAM,IAAAY,qBAAS,EAAC6C,aAAa,EAAE,MAAOE,IAAW,IAAK;MACvE,MAAMnB,KAAK,GAAGmB,IAAI,CAACjB,QAAQ,EAAE;MAC7B,MAAMkB,SAAS,GAAG,IAAI,CAACzD,KAAK,CAAC0D,IAAI,CAACrB,KAAK,CAAC;MACxC,IAAIoB,SAAS,EAAE,OAAOA,SAAS;MAC/B,IAAI;QACF,MAAMvD,SAAS,GAAG,MAAM,IAAI,CAACyD,aAAa,CAACH,IAAI,CAAC;QAChD,IAAI,CAACxD,KAAK,CAAC4D,OAAO,CAACvB,KAAK,EAAEnC,SAAS,CAAC;QACpC,OAAOA,SAAS;MAClB,CAAC,CAAC,OAAO2D,GAAQ,EAAE;QACjB,IACEA,GAAG,YAAYC,+BAAiB,IAChCD,GAAG,YAAYE,0BAAwB,IACvCF,GAAG,YAAYG,2BAAa,EAC5B;UACA,IAAIT,cAAc,IAAI,CAAC,IAAI,CAACpE,uBAAuB,EAAE;YACnD,IAAI,CAACJ,MAAM,CAACqE,IAAI,CACb,aAAYf,KAAM,mBAAkBkB,cAAe,uCAAsC,CAC3F;YACD,OAAO,IAAI;UACb;UACA,MAAM,KAAIU,oBAAQ,EACf,qBAAoB5B,KAAM,wDACzBkB,cAAc,IAAI,QACnB,iDAAgD,CAClD;QACH;QACA,IAAIA,cAAc,EAAE,IAAI,CAACxE,MAAM,CAACmF,KAAK,CAAE,kCAAiCX,cAAe,EAAC,CAAC;QACzF,MAAMM,GAAG;MACX;IACF,CAAC,CAAC;IACF,OAAO,IAAA/C,kBAAO,EAACjB,UAAU,CAAC;EAC5B;EACA,MAAc8D,aAAa,CAACQ,WAAkB,EAAsB;IAClE,MAAMC,MAAM,GAAG,MAAM,IAAI,CAACtF,SAAS,CAACuF,kBAAkB,CAACF,WAAW,CAAC;IACnE,MAAMX,IAAI,GAAG,MAAM,IAAI,CAAC1E,SAAS,CAACwF,GAAG,CAACF,MAAM,CAAC;IAC7C,OAAOZ,IAAI,CAACe,KAAK,CAACC,SAAS;EAC7B;AACF;AAAC"}