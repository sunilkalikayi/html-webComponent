"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.workspaceDrawer = void 0;
function _extends2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
  _extends2 = function () {
    return data;
  };
  return data;
}
function _react() {
  const data = _interopRequireDefault(require("react"));
  _react = function () {
    return data;
  };
  return data;
}
function _componentUi() {
  const data = require("@teambit/component.ui.component-drawer");
  _componentUi = function () {
    return data;
  };
  return data;
}
function _uiFoundationUi() {
  const data = require("@teambit/ui-foundation.ui.side-bar");
  _uiFoundationUi = function () {
    return data;
  };
  return data;
}
function _lanesHooks() {
  const data = require("@teambit/lanes.hooks.use-lanes");
  _lanesHooks = function () {
    return data;
  };
  return data;
}
function _lanesHooks2() {
  const data = require("@teambit/lanes.hooks.use-lane-components");
  _lanesHooks2 = function () {
    return data;
  };
  return data;
}
const workspaceDrawer = ({
  treeWidgets,
  filtersSlot,
  drawerWidgetSlot
}) => new (_componentUi().ComponentsDrawer)({
  order: 0,
  id: 'workspace-components-drawer',
  name: 'COMPONENTS',
  plugins: {
    tree: {
      widgets: treeWidgets,
      customRenderer: treeNodeSlot => function TreeNode(props) {
        const children = props.node.children;
        if (!children) return /*#__PURE__*/_react().default.createElement(_uiFoundationUi().ComponentView, (0, _extends2().default)({}, props, {
          treeNodeSlot: treeNodeSlot
        })); // non collapse

        if (props.node.payload instanceof _uiFoundationUi().ScopePayload) return /*#__PURE__*/_react().default.createElement(_uiFoundationUi().ScopeTreeNode, props);
        return /*#__PURE__*/_react().default.createElement(_uiFoundationUi().NamespaceTreeNode, props);
      }
    },
    filters: filtersSlot,
    drawerWidgets: drawerWidgetSlot
  },
  emptyMessage: 'Workspace is empty',
  useComponents: () => {
    var _lanesModel$viewedLan;
    const {
      lanesModel,
      loading: lanesLoading
    } = (0, _lanesHooks().useLanes)();
    const viewedLaneId = lanesModel === null || lanesModel === void 0 ? void 0 : (_lanesModel$viewedLan = lanesModel.viewedLane) === null || _lanesModel$viewedLan === void 0 ? void 0 : _lanesModel$viewedLan.id;
    const defaultLane = lanesModel === null || lanesModel === void 0 ? void 0 : lanesModel.getDefaultLane();
    const isViewingDefaultLane = viewedLaneId && (defaultLane === null || defaultLane === void 0 ? void 0 : defaultLane.id.isEqual(viewedLaneId));
    const {
      components: laneComponents = [],
      loading: laneCompsLoading
    } = (0, _lanesHooks2().useLaneComponents)(viewedLaneId);
    const {
      components: mainComponents = [],
      loading: mainCompsLoading
    } = (0, _lanesHooks2().useLaneComponents)(!isViewingDefaultLane ? defaultLane === null || defaultLane === void 0 ? void 0 : defaultLane.id : undefined);

    // lane components + main components
    const components = isViewingDefaultLane ? laneComponents : mergeComponents(mainComponents, laneComponents);
    return {
      loading: lanesLoading || laneCompsLoading || mainCompsLoading,
      components
    };
  }
});
exports.workspaceDrawer = workspaceDrawer;
function mergeComponents(mainComponents, laneComponents) {
  const mainComponentsThatAreNotOnLane = mainComponents.filter(mainComponent => {
    return !laneComponents.find(laneComponent => laneComponent.id.toStringWithoutVersion() === mainComponent.id.toStringWithoutVersion());
  });
  return laneComponents.concat(mainComponentsThatAreNotOnLane);
}

//# sourceMappingURL=workspace.ui.drawer.js.map