"use strict";

require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BitMap = void 0;
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _config() {
  const data = require("@teambit/legacy/dist/consumer/config");
  _config = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
/**
 * consider extracting to a new component.
 * (pro: making Workspace aspect smaller. con: it's an implementation details of the workspace)
 */
class BitMap {
  constructor(legacyBitMap, consumer) {
    this.legacyBitMap = legacyBitMap;
    this.consumer = consumer;
  }

  /**
   * adds component config to the .bitmap file.
   * later, upon `bit tag`, the data is saved in the scope.
   * returns a boolean indicating whether a change has been made.
   */
  addComponentConfig(id, aspectId, config = {}, shouldMergeConfig = false) {
    if (!aspectId || typeof aspectId !== 'string') throw new Error(`expect aspectId to be string, got ${aspectId}`);
    const bitMapEntry = this.getBitmapEntry(id, {
      ignoreScopeAndVersion: true
    });
    const currentConfig = (bitMapEntry.config || (bitMapEntry.config = {}))[aspectId];
    if ((0, _lodash().isEqual)(currentConfig, config)) {
      return false; // no changes
    }

    const getNewConfig = () => {
      if (!config) return null;
      if (!shouldMergeConfig) return config;
      // should merge
      if (!currentConfig) return config;
      if (currentConfig === '-') return config;
      // lodash merge performs a deep merge. (the native concatenation don't)
      return (0, _lodash().merge)(currentConfig, config);
    };
    const newConfig = getNewConfig();
    if (newConfig) {
      bitMapEntry.config[aspectId] = newConfig;
    } else {
      delete bitMapEntry.config[aspectId];
    }
    this.legacyBitMap.markAsChanged();
    return true; // changes have been made
  }

  removeComponentConfig(id, aspectId, markWithMinusIfNotExist) {
    if (!aspectId || typeof aspectId !== 'string') throw new Error(`expect aspectId to be string, got ${aspectId}`);
    const bitMapEntry = this.getBitmapEntry(id, {
      ignoreScopeAndVersion: true
    });
    const currentConfig = (bitMapEntry.config || (bitMapEntry.config = {}))[aspectId];
    if (currentConfig) {
      delete bitMapEntry.config[aspectId];
    } else {
      if (!markWithMinusIfNotExist) {
        return false; // no changes
      }

      bitMapEntry.config[aspectId] = _config().REMOVE_EXTENSION_SPECIAL_SIGN;
    }
    this.legacyBitMap.markAsChanged();
    return true; // changes have been made
  }

  removeEntireConfig(id) {
    const bitMapEntry = this.getBitmapEntry(id, {
      ignoreScopeAndVersion: true
    });
    if (!bitMapEntry.config) return false;
    delete bitMapEntry.config;
    this.legacyBitMap.markAsChanged();
    return true;
  }
  setEntireConfig(id, config) {
    const bitMapEntry = this.getBitmapEntry(id, {
      ignoreScopeAndVersion: true
    });
    bitMapEntry.config = config;
    this.legacyBitMap.markAsChanged();
  }
  removeDefaultScope(id) {
    const bitMapEntry = this.getBitmapEntry(id, {
      ignoreScopeAndVersion: true
    });
    if (bitMapEntry.defaultScope) {
      delete bitMapEntry.defaultScope;
      this.legacyBitMap.markAsChanged();
    }
  }
  setDefaultScope(id, defaultScope) {
    const bitMapEntry = this.getBitmapEntry(id, {
      ignoreScopeAndVersion: true
    });
    bitMapEntry.defaultScope = defaultScope;
    this.legacyBitMap.markAsChanged();
  }

  /**
   * write .bitmap object to the filesystem
   */
  async write() {
    await this.consumer.writeBitMap();
  }

  /**
   * get the data saved in the .bitmap file for this component-id.
   */
  getBitmapEntry(id, {
    ignoreVersion,
    ignoreScopeAndVersion
  } = {}) {
    return this.legacyBitMap.getComponent(id._legacy, {
      ignoreVersion,
      ignoreScopeAndVersion
    });
  }
  getAspectIdFromConfig(componentId, aspectId, ignoreAspectVersion = false) {
    const bitMapEntry = this.getBitmapEntry(componentId);
    const config = bitMapEntry.config;
    if (!config) {
      return undefined;
    }
    if (config[aspectId.toString()]) {
      return aspectId.toString();
    }
    if (!ignoreAspectVersion) {
      return undefined;
    }
    const allVersions = Object.keys(config).filter(id => id.startsWith(`${aspectId.toStringWithoutVersion()}@`));
    if (allVersions.length > 1) {
      throw new (_bitError().BitError)(`error: the same aspect ${aspectId.toStringWithoutVersion} configured multiple times for "${componentId.toString()}"\n${allVersions.join('\n')}`);
    }
    return allVersions.length === 1 ? allVersions[0] : undefined;
  }

  /**
   * components that were not tagged yet are safe to rename them from the .bitmap file.
   */
  renameNewComponent(sourceId, targetId) {
    const bitMapEntry = this.getBitmapEntry(sourceId);
    if (bitMapEntry.id.hasVersion()) {
      throw new Error(`unable to rename tagged or exported component: ${bitMapEntry.id.toString()}`);
    }
    if (sourceId.isEqual(targetId)) {
      throw new Error(`source-id and target-id are equal: "${sourceId.toString()}"`);
    }
    if (sourceId.fullName !== targetId.fullName) {
      this.legacyBitMap.removeComponent(bitMapEntry.id);
      bitMapEntry.id = targetId._legacy;
      this.legacyBitMap.setComponent(bitMapEntry.id, bitMapEntry);
    }
    if (sourceId.scope !== targetId.scope) {
      this.setDefaultScope(targetId, targetId.scope);
    }
  }
  removeComponent(id) {
    this.legacyBitMap.removeComponent(id._legacy);
  }

  /**
   * this is the lane-id of the recently exported lane. in case of a new lane, which was not exported yet, this will be
   * empty.
   */
  getExportedLaneId() {
    return this.legacyBitMap.isLaneExported ? this.legacyBitMap.laneId : undefined;
  }

  /**
   * whether .bitmap file has changed in-memory
   */
  hasChanged() {
    return this.legacyBitMap.hasChanged;
  }
}
exports.BitMap = BitMap;

//# sourceMappingURL=bit-map.js.map