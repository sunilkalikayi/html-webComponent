import { Component, ComponentID, InvalidComponent } from '@teambit/component';
import ConsumerComponent from '@teambit/legacy/dist/consumer/component';
import { DependencyResolverMain } from '@teambit/dependency-resolver';
import { Logger } from '@teambit/logger';
import { EnvsMain } from '@teambit/envs';
import { ComponentLoadOptions } from '@teambit/legacy/dist/consumer/component/component-loader';
import { Workspace } from '../workspace';
export declare class WorkspaceComponentLoader {
    private workspace;
    private logger;
    private dependencyResolver;
    private envs;
    private componentsCache;
    constructor(workspace: Workspace, logger: Logger, dependencyResolver: DependencyResolverMain, envs: EnvsMain);
    getMany(ids: Array<ComponentID>, loadOpts?: ComponentLoadOptions): Promise<Component[]>;
    getInvalid(ids: Array<ComponentID>): Promise<InvalidComponent[]>;
    get(componentId: ComponentID, legacyComponent?: ConsumerComponent, useCache?: boolean, storeInCache?: boolean, loadOpts?: ComponentLoadOptions): Promise<Component>;
    getIfExist(componentId: ComponentID): Promise<Component | undefined>;
    private addMultipleEnvsIssueIfNeeded;
    clearCache(): void;
    clearComponentCache(id: ComponentID): void;
    private loadOne;
    private saveInCache;
    /**
     * make sure that not only the id-str match, but also the legacy-id.
     * this is needed because the ComponentID.toString() is the same whether or not the legacy-id has
     * scope-name, as it includes the defaultScope if the scope is empty.
     * as a result, when out-of-sync is happening and the id is changed to include scope-name in the
     * legacy-id, the component is the cache has the old id.
     */
    private getFromCache;
    private getConsumerComponent;
    private isComponentNotExistsError;
    private executeLoadSlot;
    private newComponentFromState;
    private upsertExtensionData;
    private getDataEntry;
}
