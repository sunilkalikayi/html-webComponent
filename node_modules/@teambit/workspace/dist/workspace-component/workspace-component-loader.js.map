{"version":3,"names":["WorkspaceComponentLoader","constructor","workspace","logger","dependencyResolver","envs","componentsCache","createInMemoryCache","maxSize","getMaxSizeForComponents","getMany","ids","loadOpts","idsWithoutEmpty","compact","errors","longProcessLogger","createLongProcessLogger","length","componentsP","mapSeries","id","logProgress","toString","get","undefined","catch","err","isComponentNotExistsError","push","components","forEach","console","warn","filteredComponents","end","getInvalid","consumer","loadComponent","_legacy","ConsumerComponent","isComponentInvalidByErrorType","componentId","legacyComponent","useCache","storeInCache","bitIdWithVersion","getLatestVersionNumber","bitmapIdsFromCurrentLane","version","changeVersion","fromCache","getFromCache","consumerComponent","getConsumerComponent","updatedId","ComponentID","fromLegacy","scope","component","loadOne","addMultipleEnvsIssueIfNeeded","saveInCache","getIfExist","getAllEnvsConfiguredOnComponent","envIds","uniq","map","env","state","issues","getOrCreate","IssuesClasses","MultipleEnvs","data","clearCache","deleteAll","clearComponentCache","idStr","cacheKey","keys","startsWith","delete","componentFromScope","MissingBitMapComponent","extensions","componentExtensions","extensionsFromConsumerComponent","ExtensionDataList","extensionDataList","mergeConfigs","filterRemovedExtensions","State","Config","mainFile","createAspectList","ComponentFS","fromVinyls","files","dependencies","workspaceComponent","WorkspaceComponent","head","tags","updatedComp","executeLoadSlot","newComponentFromState","createComponentCacheKey","set","isEqual","debug","name","message","ComponentNotFound","ComponentNotFoundInPath","_consumer","removed","envsData","getEnvSystemDescriptor","policy","mergeVariantPolicies","config","dependenciesList","extractDepsFromLegacy","dependenciesFromUnmergedHead","unmergedComponent","getUnmergedComponent","mergedDependencies","DependencyList","merge","depResolverData","serialize","Promise","all","upsertExtensionData","EnvsAspect","DependencyResolverAspect","aspectListWithEnvsAndDeps","aspects","entries","onComponentLoadSlot","toArray","promises","extension","onLoad","updatedAspectList","TagMap","existingExtension","findExtension","Object","assign","getDataEntry","ExtensionDataEntry","JSON","stringify","sortKeys","obj","fromPairs","sort","k1","k2","localeCompare"],"sources":["workspace-component-loader.ts"],"sourcesContent":["import { Component, ComponentFS, ComponentID, Config, InvalidComponent, State, TagMap } from '@teambit/component';\nimport { BitId } from '@teambit/legacy-bit-id';\nimport { ExtensionDataList } from '@teambit/legacy/dist/consumer/config/extension-data';\nimport mapSeries from 'p-map-series';\nimport { compact, fromPairs, uniq } from 'lodash';\nimport ConsumerComponent from '@teambit/legacy/dist/consumer/component';\nimport { MissingBitMapComponent } from '@teambit/legacy/dist/consumer/bit-map/exceptions';\nimport { getLatestVersionNumber } from '@teambit/legacy/dist/utils';\nimport { IssuesClasses } from '@teambit/component-issues';\nimport { ComponentNotFound } from '@teambit/legacy/dist/scope/exceptions';\nimport { DependencyList, DependencyResolverAspect, DependencyResolverMain } from '@teambit/dependency-resolver';\nimport { Logger } from '@teambit/logger';\nimport { EnvsAspect, EnvsMain } from '@teambit/envs';\nimport { ExtensionDataEntry } from '@teambit/legacy/dist/consumer/config';\nimport { getMaxSizeForComponents, InMemoryCache } from '@teambit/legacy/dist/cache/in-memory-cache';\nimport { createInMemoryCache } from '@teambit/legacy/dist/cache/cache-factory';\nimport ComponentNotFoundInPath from '@teambit/legacy/dist/consumer/component/exceptions/component-not-found-in-path';\nimport { ComponentLoadOptions } from '@teambit/legacy/dist/consumer/component/component-loader';\nimport { Workspace } from '../workspace';\nimport { WorkspaceComponent } from './workspace-component';\n\nexport class WorkspaceComponentLoader {\n  private componentsCache: InMemoryCache<Component>; // cache loaded components\n  constructor(\n    private workspace: Workspace,\n    private logger: Logger,\n    private dependencyResolver: DependencyResolverMain,\n    private envs: EnvsMain\n  ) {\n    this.componentsCache = createInMemoryCache({ maxSize: getMaxSizeForComponents() });\n  }\n\n  async getMany(ids: Array<ComponentID>, loadOpts?: ComponentLoadOptions): Promise<Component[]> {\n    const idsWithoutEmpty = compact(ids);\n    const errors: { id: ComponentID; err: Error }[] = [];\n    const longProcessLogger = this.logger.createLongProcessLogger('loading components', ids.length);\n    const componentsP = mapSeries(idsWithoutEmpty, async (id: ComponentID) => {\n      longProcessLogger.logProgress(id.toString());\n      return this.get(id, undefined, undefined, undefined, loadOpts).catch((err) => {\n        if (this.isComponentNotExistsError(err)) {\n          errors.push({\n            id,\n            err,\n          });\n          return undefined;\n        }\n        throw err;\n      });\n    });\n    const components = await componentsP;\n    errors.forEach((err) => {\n      this.logger.console(`failed loading component ${err.id.toString()}, see full error in debug.log file`);\n      this.logger.warn(`failed loading component ${err.id.toString()}`, err.err);\n    });\n    // remove errored components\n    const filteredComponents: Component[] = compact(components);\n    longProcessLogger.end();\n    return filteredComponents;\n  }\n\n  async getInvalid(ids: Array<ComponentID>): Promise<InvalidComponent[]> {\n    const idsWithoutEmpty = compact(ids);\n    const errors: InvalidComponent[] = [];\n    const longProcessLogger = this.logger.createLongProcessLogger('loading components', ids.length);\n    await mapSeries(idsWithoutEmpty, async (id: ComponentID) => {\n      longProcessLogger.logProgress(id.toString());\n      try {\n        await this.workspace.consumer.loadComponent(id._legacy);\n      } catch (err: any) {\n        if (ConsumerComponent.isComponentInvalidByErrorType(err)) {\n          errors.push({\n            id,\n            err,\n          });\n          return;\n        }\n        throw err;\n      }\n    });\n    return errors;\n  }\n\n  async get(\n    componentId: ComponentID,\n    legacyComponent?: ConsumerComponent,\n    useCache = true,\n    storeInCache = true,\n    loadOpts?: ComponentLoadOptions\n  ): Promise<Component> {\n    const bitIdWithVersion: BitId = getLatestVersionNumber(\n      this.workspace.consumer.bitmapIdsFromCurrentLane,\n      componentId._legacy\n    );\n    const id = bitIdWithVersion.version ? componentId.changeVersion(bitIdWithVersion.version) : componentId;\n    const fromCache = this.getFromCache(id, loadOpts);\n    if (fromCache && useCache) {\n      return fromCache;\n    }\n    const consumerComponent = legacyComponent || (await this.getConsumerComponent(id));\n    // in case of out-of-sync, the id may changed during the load process\n    const updatedId = consumerComponent ? ComponentID.fromLegacy(consumerComponent.id, id.scope) : id;\n    const component = await this.loadOne(updatedId, consumerComponent, loadOpts);\n    if (storeInCache) {\n      this.addMultipleEnvsIssueIfNeeded(component); // it's in storeInCache block, otherwise, it wasn't fully loaded\n      this.saveInCache(component, loadOpts);\n    }\n    return component;\n  }\n\n  async getIfExist(componentId: ComponentID) {\n    try {\n      return await this.get(componentId);\n    } catch (err: any) {\n      if (this.isComponentNotExistsError(err)) {\n        return undefined;\n      }\n      throw err;\n    }\n  }\n\n  private addMultipleEnvsIssueIfNeeded(component: Component) {\n    const envs = this.envs.getAllEnvsConfiguredOnComponent(component);\n    const envIds = uniq(envs.map((env) => env.id));\n    if (envIds.length < 2) {\n      return;\n    }\n    component.state.issues.getOrCreate(IssuesClasses.MultipleEnvs).data = envIds;\n  }\n\n  clearCache() {\n    this.componentsCache.deleteAll();\n  }\n  clearComponentCache(id: ComponentID) {\n    const idStr = id.toString();\n    for (const cacheKey of this.componentsCache.keys()) {\n      if (cacheKey === idStr || cacheKey.startsWith(`${idStr}:`)) {\n        this.componentsCache.delete(cacheKey);\n      }\n    }\n  }\n\n  private async loadOne(id: ComponentID, consumerComponent?: ConsumerComponent, loadOpts?: ComponentLoadOptions) {\n    const componentFromScope = await this.workspace.scope.get(id);\n    if (!consumerComponent) {\n      if (!componentFromScope) throw new MissingBitMapComponent(id.toString());\n      return componentFromScope;\n    }\n    const { extensions } = await this.workspace.componentExtensions(id, componentFromScope);\n    const extensionsFromConsumerComponent = consumerComponent.extensions || new ExtensionDataList();\n    // Merge extensions added by the legacy code in memory (for example data of dependency resolver)\n    const extensionDataList = ExtensionDataList.mergeConfigs([\n      extensionsFromConsumerComponent,\n      extensions,\n    ]).filterRemovedExtensions();\n\n    // temporarily mutate consumer component extensions until we remove all direct access from legacy to extensions data\n    // TODO: remove this once we remove all direct access from legacy code to extensions data\n    consumerComponent.extensions = extensionDataList;\n\n    const state = new State(\n      new Config(consumerComponent.mainFile, extensionDataList),\n      await this.workspace.createAspectList(extensionDataList),\n      ComponentFS.fromVinyls(consumerComponent.files),\n      consumerComponent.dependencies,\n      consumerComponent\n    );\n    if (componentFromScope) {\n      // Removed by @gilad. do not mutate the component from the scope\n      // componentFromScope.state = state;\n      // const workspaceComponent = WorkspaceComponent.fromComponent(componentFromScope, this.workspace);\n      const workspaceComponent = new WorkspaceComponent(\n        componentFromScope.id,\n        componentFromScope.head,\n        state,\n        componentFromScope.tags,\n        this.workspace\n      );\n      const updatedComp = await this.executeLoadSlot(workspaceComponent, loadOpts);\n      return updatedComp;\n    }\n    return this.executeLoadSlot(this.newComponentFromState(id, state), loadOpts);\n  }\n\n  private saveInCache(component: Component, loadOpts?: ComponentLoadOptions): void {\n    const cacheKey = createComponentCacheKey(component.id, loadOpts);\n    this.componentsCache.set(cacheKey, component);\n  }\n\n  /**\n   * make sure that not only the id-str match, but also the legacy-id.\n   * this is needed because the ComponentID.toString() is the same whether or not the legacy-id has\n   * scope-name, as it includes the defaultScope if the scope is empty.\n   * as a result, when out-of-sync is happening and the id is changed to include scope-name in the\n   * legacy-id, the component is the cache has the old id.\n   */\n  private getFromCache(id: ComponentID, loadOpts?: ComponentLoadOptions): Component | undefined {\n    const cacheKey = createComponentCacheKey(id, loadOpts);\n    const fromCache = this.componentsCache.get(cacheKey);\n    if (fromCache && fromCache.id._legacy.isEqual(id._legacy)) {\n      return fromCache;\n    }\n    return undefined;\n  }\n\n  private async getConsumerComponent(id: ComponentID): Promise<ConsumerComponent | undefined> {\n    try {\n      return await this.workspace.consumer.loadComponent(id._legacy);\n    } catch (err: any) {\n      // don't return undefined for any error. otherwise, if the component is invalid (e.g. main\n      // file is missing) it returns the model component later unexpectedly, or if it's new, it\n      // shows MissingBitMapComponent error incorrectly.\n      if (this.isComponentNotExistsError(err)) {\n        this.logger.debug(\n          `failed loading component \"${id.toString()}\" from the workspace due to \"${err.name}\" error\\n${err.message}`\n        );\n        return undefined;\n      }\n      throw err;\n    }\n  }\n\n  private isComponentNotExistsError(err: Error): boolean {\n    return (\n      err instanceof ComponentNotFound ||\n      err instanceof MissingBitMapComponent ||\n      err instanceof ComponentNotFoundInPath\n    );\n  }\n\n  private async executeLoadSlot(component: Component, loadOpts?: ComponentLoadOptions) {\n    if (component.state._consumer.removed) {\n      // if it was soft-removed now, the component is not in the FS. loading aspects such as composition ends up with\n      // errors as they try to read component files from the filesystem.\n      return component;\n    }\n\n    // Special load events which runs from the workspace but should run from the correct aspect\n    // TODO: remove this once those extensions dependent on workspace\n    const envsData = await this.workspace.getEnvSystemDescriptor(component);\n\n    // Move to deps resolver main runtime once we switch ws<> deps resolver direction\n    const policy = await this.dependencyResolver.mergeVariantPolicies(component.config.extensions);\n    const dependenciesList = await this.dependencyResolver.extractDepsFromLegacy(component, policy);\n    let dependenciesFromUnmergedHead;\n    // Get dependencies from unmerged head if needed\n    // we take it from there, as they might not be installed yet and we need to get their versions from the model\n    const unmergedComponent = await this.workspace.getUnmergedComponent(component.id);\n    if (unmergedComponent) {\n      dependenciesFromUnmergedHead = await this.dependencyResolver.extractDepsFromLegacy(unmergedComponent, policy);\n    }\n    const mergedDependencies = dependenciesFromUnmergedHead\n      ? DependencyList.merge([dependenciesList, dependenciesFromUnmergedHead])\n      : dependenciesList;\n\n    const depResolverData = {\n      dependencies: mergedDependencies.serialize(),\n      policy: policy.serialize(),\n    };\n\n    // Make sure we are adding the envs / deps data first because other on load events might depend on it\n    await Promise.all([\n      this.upsertExtensionData(component, EnvsAspect.id, envsData),\n      this.upsertExtensionData(component, DependencyResolverAspect.id, depResolverData),\n    ]);\n\n    // We are updating the component state with the envs and deps data here, so in case we have other slots that depend on this data\n    // they will be able to get it, as it's very common use case that during on load someone want to access to the component env for example\n    const aspectListWithEnvsAndDeps = await this.workspace.createAspectList(component.state.config.extensions);\n    component.state.aspects = aspectListWithEnvsAndDeps;\n\n    const entries = this.workspace.onComponentLoadSlot.toArray();\n    const promises = entries.map(async ([extension, onLoad]) => {\n      const data = await onLoad(component, loadOpts);\n      return this.upsertExtensionData(component, extension, data);\n    });\n\n    await Promise.all(promises);\n\n    // Update the aspect list to have changes happened during the on load slot (new data added above)\n    const updatedAspectList = await this.workspace.createAspectList(component.state.config.extensions);\n    component.state.aspects = updatedAspectList;\n    return component;\n  }\n\n  private newComponentFromState(id: ComponentID, state: State): Component {\n    return new WorkspaceComponent(id, null, state, new TagMap(), this.workspace);\n  }\n\n  private async upsertExtensionData(component: Component, extension: string, data: any) {\n    if (!data) return;\n    const existingExtension = component.state.config.extensions.findExtension(extension);\n    if (existingExtension) {\n      // Only merge top level of extension data\n      Object.assign(existingExtension.data, data);\n      return;\n    }\n    component.state.config.extensions.push(await this.getDataEntry(extension, data));\n  }\n\n  private async getDataEntry(extension: string, data: { [key: string]: any }): Promise<ExtensionDataEntry> {\n    // TODO: @gilad we need to refactor the extension data entry api.\n    return new ExtensionDataEntry(undefined, undefined, extension, undefined, data);\n  }\n}\n\nfunction createComponentCacheKey(id: ComponentID, loadOpts?: ComponentLoadOptions): string {\n  return `${id.toString()}:${JSON.stringify(sortKeys(loadOpts ?? {}))}`;\n}\n\nfunction sortKeys(obj: Object) {\n  return fromPairs(Object.entries(obj).sort(([k1], [k2]) => k1.localeCompare(k2)));\n}\n"],"mappings":";;;;;;;;;;;;;;;;;AAAA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAEA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAEA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAGA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAEO,MAAMA,wBAAwB,CAAC;EACe;EACnDC,WAAW,CACDC,SAAoB,EACpBC,MAAc,EACdC,kBAA0C,EAC1CC,IAAc,EACtB;IAAA,KAJQH,SAAoB,GAApBA,SAAoB;IAAA,KACpBC,MAAc,GAAdA,MAAc;IAAA,KACdC,kBAA0C,GAA1CA,kBAA0C;IAAA,KAC1CC,IAAc,GAAdA,IAAc;IAAA;IAEtB,IAAI,CAACC,eAAe,GAAG,IAAAC,mCAAmB,EAAC;MAAEC,OAAO,EAAE,IAAAC,wCAAuB;IAAG,CAAC,CAAC;EACpF;EAEA,MAAMC,OAAO,CAACC,GAAuB,EAAEC,QAA+B,EAAwB;IAC5F,MAAMC,eAAe,GAAG,IAAAC,iBAAO,EAACH,GAAG,CAAC;IACpC,MAAMI,MAAyC,GAAG,EAAE;IACpD,MAAMC,iBAAiB,GAAG,IAAI,CAACb,MAAM,CAACc,uBAAuB,CAAC,oBAAoB,EAAEN,GAAG,CAACO,MAAM,CAAC;IAC/F,MAAMC,WAAW,GAAG,IAAAC,qBAAS,EAACP,eAAe,EAAE,MAAOQ,EAAe,IAAK;MACxEL,iBAAiB,CAACM,WAAW,CAACD,EAAE,CAACE,QAAQ,EAAE,CAAC;MAC5C,OAAO,IAAI,CAACC,GAAG,CAACH,EAAE,EAAEI,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEb,QAAQ,CAAC,CAACc,KAAK,CAAEC,GAAG,IAAK;QAC5E,IAAI,IAAI,CAACC,yBAAyB,CAACD,GAAG,CAAC,EAAE;UACvCZ,MAAM,CAACc,IAAI,CAAC;YACVR,EAAE;YACFM;UACF,CAAC,CAAC;UACF,OAAOF,SAAS;QAClB;QACA,MAAME,GAAG;MACX,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,MAAMG,UAAU,GAAG,MAAMX,WAAW;IACpCJ,MAAM,CAACgB,OAAO,CAAEJ,GAAG,IAAK;MACtB,IAAI,CAACxB,MAAM,CAAC6B,OAAO,CAAE,4BAA2BL,GAAG,CAACN,EAAE,CAACE,QAAQ,EAAG,oCAAmC,CAAC;MACtG,IAAI,CAACpB,MAAM,CAAC8B,IAAI,CAAE,4BAA2BN,GAAG,CAACN,EAAE,CAACE,QAAQ,EAAG,EAAC,EAAEI,GAAG,CAACA,GAAG,CAAC;IAC5E,CAAC,CAAC;IACF;IACA,MAAMO,kBAA+B,GAAG,IAAApB,iBAAO,EAACgB,UAAU,CAAC;IAC3Dd,iBAAiB,CAACmB,GAAG,EAAE;IACvB,OAAOD,kBAAkB;EAC3B;EAEA,MAAME,UAAU,CAACzB,GAAuB,EAA+B;IACrE,MAAME,eAAe,GAAG,IAAAC,iBAAO,EAACH,GAAG,CAAC;IACpC,MAAMI,MAA0B,GAAG,EAAE;IACrC,MAAMC,iBAAiB,GAAG,IAAI,CAACb,MAAM,CAACc,uBAAuB,CAAC,oBAAoB,EAAEN,GAAG,CAACO,MAAM,CAAC;IAC/F,MAAM,IAAAE,qBAAS,EAACP,eAAe,EAAE,MAAOQ,EAAe,IAAK;MAC1DL,iBAAiB,CAACM,WAAW,CAACD,EAAE,CAACE,QAAQ,EAAE,CAAC;MAC5C,IAAI;QACF,MAAM,IAAI,CAACrB,SAAS,CAACmC,QAAQ,CAACC,aAAa,CAACjB,EAAE,CAACkB,OAAO,CAAC;MACzD,CAAC,CAAC,OAAOZ,GAAQ,EAAE;QACjB,IAAIa,qBAAiB,CAACC,6BAA6B,CAACd,GAAG,CAAC,EAAE;UACxDZ,MAAM,CAACc,IAAI,CAAC;YACVR,EAAE;YACFM;UACF,CAAC,CAAC;UACF;QACF;QACA,MAAMA,GAAG;MACX;IACF,CAAC,CAAC;IACF,OAAOZ,MAAM;EACf;EAEA,MAAMS,GAAG,CACPkB,WAAwB,EACxBC,eAAmC,EACnCC,QAAQ,GAAG,IAAI,EACfC,YAAY,GAAG,IAAI,EACnBjC,QAA+B,EACX;IACpB,MAAMkC,gBAAuB,GAAG,IAAAC,+BAAsB,EACpD,IAAI,CAAC7C,SAAS,CAACmC,QAAQ,CAACW,wBAAwB,EAChDN,WAAW,CAACH,OAAO,CACpB;IACD,MAAMlB,EAAE,GAAGyB,gBAAgB,CAACG,OAAO,GAAGP,WAAW,CAACQ,aAAa,CAACJ,gBAAgB,CAACG,OAAO,CAAC,GAAGP,WAAW;IACvG,MAAMS,SAAS,GAAG,IAAI,CAACC,YAAY,CAAC/B,EAAE,EAAET,QAAQ,CAAC;IACjD,IAAIuC,SAAS,IAAIP,QAAQ,EAAE;MACzB,OAAOO,SAAS;IAClB;IACA,MAAME,iBAAiB,GAAGV,eAAe,KAAK,MAAM,IAAI,CAACW,oBAAoB,CAACjC,EAAE,CAAC,CAAC;IAClF;IACA,MAAMkC,SAAS,GAAGF,iBAAiB,GAAGG,wBAAW,CAACC,UAAU,CAACJ,iBAAiB,CAAChC,EAAE,EAAEA,EAAE,CAACqC,KAAK,CAAC,GAAGrC,EAAE;IACjG,MAAMsC,SAAS,GAAG,MAAM,IAAI,CAACC,OAAO,CAACL,SAAS,EAAEF,iBAAiB,EAAEzC,QAAQ,CAAC;IAC5E,IAAIiC,YAAY,EAAE;MAChB,IAAI,CAACgB,4BAA4B,CAACF,SAAS,CAAC,CAAC,CAAC;MAC9C,IAAI,CAACG,WAAW,CAACH,SAAS,EAAE/C,QAAQ,CAAC;IACvC;IACA,OAAO+C,SAAS;EAClB;EAEA,MAAMI,UAAU,CAACrB,WAAwB,EAAE;IACzC,IAAI;MACF,OAAO,MAAM,IAAI,CAAClB,GAAG,CAACkB,WAAW,CAAC;IACpC,CAAC,CAAC,OAAOf,GAAQ,EAAE;MACjB,IAAI,IAAI,CAACC,yBAAyB,CAACD,GAAG,CAAC,EAAE;QACvC,OAAOF,SAAS;MAClB;MACA,MAAME,GAAG;IACX;EACF;EAEQkC,4BAA4B,CAACF,SAAoB,EAAE;IACzD,MAAMtD,IAAI,GAAG,IAAI,CAACA,IAAI,CAAC2D,+BAA+B,CAACL,SAAS,CAAC;IACjE,MAAMM,MAAM,GAAG,IAAAC,cAAI,EAAC7D,IAAI,CAAC8D,GAAG,CAAEC,GAAG,IAAKA,GAAG,CAAC/C,EAAE,CAAC,CAAC;IAC9C,IAAI4C,MAAM,CAAC/C,MAAM,GAAG,CAAC,EAAE;MACrB;IACF;IACAyC,SAAS,CAACU,KAAK,CAACC,MAAM,CAACC,WAAW,CAACC,gCAAa,CAACC,YAAY,CAAC,CAACC,IAAI,GAAGT,MAAM;EAC9E;EAEAU,UAAU,GAAG;IACX,IAAI,CAACrE,eAAe,CAACsE,SAAS,EAAE;EAClC;EACAC,mBAAmB,CAACxD,EAAe,EAAE;IACnC,MAAMyD,KAAK,GAAGzD,EAAE,CAACE,QAAQ,EAAE;IAC3B,KAAK,MAAMwD,QAAQ,IAAI,IAAI,CAACzE,eAAe,CAAC0E,IAAI,EAAE,EAAE;MAClD,IAAID,QAAQ,KAAKD,KAAK,IAAIC,QAAQ,CAACE,UAAU,CAAE,GAAEH,KAAM,GAAE,CAAC,EAAE;QAC1D,IAAI,CAACxE,eAAe,CAAC4E,MAAM,CAACH,QAAQ,CAAC;MACvC;IACF;EACF;EAEA,MAAcnB,OAAO,CAACvC,EAAe,EAAEgC,iBAAqC,EAAEzC,QAA+B,EAAE;IAC7G,MAAMuE,kBAAkB,GAAG,MAAM,IAAI,CAACjF,SAAS,CAACwD,KAAK,CAAClC,GAAG,CAACH,EAAE,CAAC;IAC7D,IAAI,CAACgC,iBAAiB,EAAE;MACtB,IAAI,CAAC8B,kBAAkB,EAAE,MAAM,KAAIC,oCAAsB,EAAC/D,EAAE,CAACE,QAAQ,EAAE,CAAC;MACxE,OAAO4D,kBAAkB;IAC3B;IACA,MAAM;MAAEE;IAAW,CAAC,GAAG,MAAM,IAAI,CAACnF,SAAS,CAACoF,mBAAmB,CAACjE,EAAE,EAAE8D,kBAAkB,CAAC;IACvF,MAAMI,+BAA+B,GAAGlC,iBAAiB,CAACgC,UAAU,IAAI,KAAIG,kCAAiB,GAAE;IAC/F;IACA,MAAMC,iBAAiB,GAAGD,kCAAiB,CAACE,YAAY,CAAC,CACvDH,+BAA+B,EAC/BF,UAAU,CACX,CAAC,CAACM,uBAAuB,EAAE;;IAE5B;IACA;IACAtC,iBAAiB,CAACgC,UAAU,GAAGI,iBAAiB;IAEhD,MAAMpB,KAAK,GAAG,KAAIuB,kBAAK,EACrB,KAAIC,mBAAM,EAACxC,iBAAiB,CAACyC,QAAQ,EAAEL,iBAAiB,CAAC,EACzD,MAAM,IAAI,CAACvF,SAAS,CAAC6F,gBAAgB,CAACN,iBAAiB,CAAC,EACxDO,wBAAW,CAACC,UAAU,CAAC5C,iBAAiB,CAAC6C,KAAK,CAAC,EAC/C7C,iBAAiB,CAAC8C,YAAY,EAC9B9C,iBAAiB,CAClB;IACD,IAAI8B,kBAAkB,EAAE;MACtB;MACA;MACA;MACA,MAAMiB,kBAAkB,GAAG,KAAIC,wCAAkB,EAC/ClB,kBAAkB,CAAC9D,EAAE,EACrB8D,kBAAkB,CAACmB,IAAI,EACvBjC,KAAK,EACLc,kBAAkB,CAACoB,IAAI,EACvB,IAAI,CAACrG,SAAS,CACf;MACD,MAAMsG,WAAW,GAAG,MAAM,IAAI,CAACC,eAAe,CAACL,kBAAkB,EAAExF,QAAQ,CAAC;MAC5E,OAAO4F,WAAW;IACpB;IACA,OAAO,IAAI,CAACC,eAAe,CAAC,IAAI,CAACC,qBAAqB,CAACrF,EAAE,EAAEgD,KAAK,CAAC,EAAEzD,QAAQ,CAAC;EAC9E;EAEQkD,WAAW,CAACH,SAAoB,EAAE/C,QAA+B,EAAQ;IAC/E,MAAMmE,QAAQ,GAAG4B,uBAAuB,CAAChD,SAAS,CAACtC,EAAE,EAAET,QAAQ,CAAC;IAChE,IAAI,CAACN,eAAe,CAACsG,GAAG,CAAC7B,QAAQ,EAAEpB,SAAS,CAAC;EAC/C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACUP,YAAY,CAAC/B,EAAe,EAAET,QAA+B,EAAyB;IAC5F,MAAMmE,QAAQ,GAAG4B,uBAAuB,CAACtF,EAAE,EAAET,QAAQ,CAAC;IACtD,MAAMuC,SAAS,GAAG,IAAI,CAAC7C,eAAe,CAACkB,GAAG,CAACuD,QAAQ,CAAC;IACpD,IAAI5B,SAAS,IAAIA,SAAS,CAAC9B,EAAE,CAACkB,OAAO,CAACsE,OAAO,CAACxF,EAAE,CAACkB,OAAO,CAAC,EAAE;MACzD,OAAOY,SAAS;IAClB;IACA,OAAO1B,SAAS;EAClB;EAEA,MAAc6B,oBAAoB,CAACjC,EAAe,EAA0C;IAC1F,IAAI;MACF,OAAO,MAAM,IAAI,CAACnB,SAAS,CAACmC,QAAQ,CAACC,aAAa,CAACjB,EAAE,CAACkB,OAAO,CAAC;IAChE,CAAC,CAAC,OAAOZ,GAAQ,EAAE;MACjB;MACA;MACA;MACA,IAAI,IAAI,CAACC,yBAAyB,CAACD,GAAG,CAAC,EAAE;QACvC,IAAI,CAACxB,MAAM,CAAC2G,KAAK,CACd,6BAA4BzF,EAAE,CAACE,QAAQ,EAAG,gCAA+BI,GAAG,CAACoF,IAAK,YAAWpF,GAAG,CAACqF,OAAQ,EAAC,CAC5G;QACD,OAAOvF,SAAS;MAClB;MACA,MAAME,GAAG;IACX;EACF;EAEQC,yBAAyB,CAACD,GAAU,EAAW;IACrD,OACEA,GAAG,YAAYsF,gCAAiB,IAChCtF,GAAG,YAAYyD,oCAAsB,IACrCzD,GAAG,YAAYuF,kCAAuB;EAE1C;EAEA,MAAcT,eAAe,CAAC9C,SAAoB,EAAE/C,QAA+B,EAAE;IACnF,IAAI+C,SAAS,CAACU,KAAK,CAAC8C,SAAS,CAACC,OAAO,EAAE;MACrC;MACA;MACA,OAAOzD,SAAS;IAClB;;IAEA;IACA;IACA,MAAM0D,QAAQ,GAAG,MAAM,IAAI,CAACnH,SAAS,CAACoH,sBAAsB,CAAC3D,SAAS,CAAC;;IAEvE;IACA,MAAM4D,MAAM,GAAG,MAAM,IAAI,CAACnH,kBAAkB,CAACoH,oBAAoB,CAAC7D,SAAS,CAAC8D,MAAM,CAACpC,UAAU,CAAC;IAC9F,MAAMqC,gBAAgB,GAAG,MAAM,IAAI,CAACtH,kBAAkB,CAACuH,qBAAqB,CAAChE,SAAS,EAAE4D,MAAM,CAAC;IAC/F,IAAIK,4BAA4B;IAChC;IACA;IACA,MAAMC,iBAAiB,GAAG,MAAM,IAAI,CAAC3H,SAAS,CAAC4H,oBAAoB,CAACnE,SAAS,CAACtC,EAAE,CAAC;IACjF,IAAIwG,iBAAiB,EAAE;MACrBD,4BAA4B,GAAG,MAAM,IAAI,CAACxH,kBAAkB,CAACuH,qBAAqB,CAACE,iBAAiB,EAAEN,MAAM,CAAC;IAC/G;IACA,MAAMQ,kBAAkB,GAAGH,4BAA4B,GACnDI,oCAAc,CAACC,KAAK,CAAC,CAACP,gBAAgB,EAAEE,4BAA4B,CAAC,CAAC,GACtEF,gBAAgB;IAEpB,MAAMQ,eAAe,GAAG;MACtB/B,YAAY,EAAE4B,kBAAkB,CAACI,SAAS,EAAE;MAC5CZ,MAAM,EAAEA,MAAM,CAACY,SAAS;IAC1B,CAAC;;IAED;IACA,MAAMC,OAAO,CAACC,GAAG,CAAC,CAChB,IAAI,CAACC,mBAAmB,CAAC3E,SAAS,EAAE4E,kBAAU,CAAClH,EAAE,EAAEgG,QAAQ,CAAC,EAC5D,IAAI,CAACiB,mBAAmB,CAAC3E,SAAS,EAAE6E,8CAAwB,CAACnH,EAAE,EAAE6G,eAAe,CAAC,CAClF,CAAC;;IAEF;IACA;IACA,MAAMO,yBAAyB,GAAG,MAAM,IAAI,CAACvI,SAAS,CAAC6F,gBAAgB,CAACpC,SAAS,CAACU,KAAK,CAACoD,MAAM,CAACpC,UAAU,CAAC;IAC1G1B,SAAS,CAACU,KAAK,CAACqE,OAAO,GAAGD,yBAAyB;IAEnD,MAAME,OAAO,GAAG,IAAI,CAACzI,SAAS,CAAC0I,mBAAmB,CAACC,OAAO,EAAE;IAC5D,MAAMC,QAAQ,GAAGH,OAAO,CAACxE,GAAG,CAAC,OAAO,CAAC4E,SAAS,EAAEC,MAAM,CAAC,KAAK;MAC1D,MAAMtE,IAAI,GAAG,MAAMsE,MAAM,CAACrF,SAAS,EAAE/C,QAAQ,CAAC;MAC9C,OAAO,IAAI,CAAC0H,mBAAmB,CAAC3E,SAAS,EAAEoF,SAAS,EAAErE,IAAI,CAAC;IAC7D,CAAC,CAAC;IAEF,MAAM0D,OAAO,CAACC,GAAG,CAACS,QAAQ,CAAC;;IAE3B;IACA,MAAMG,iBAAiB,GAAG,MAAM,IAAI,CAAC/I,SAAS,CAAC6F,gBAAgB,CAACpC,SAAS,CAACU,KAAK,CAACoD,MAAM,CAACpC,UAAU,CAAC;IAClG1B,SAAS,CAACU,KAAK,CAACqE,OAAO,GAAGO,iBAAiB;IAC3C,OAAOtF,SAAS;EAClB;EAEQ+C,qBAAqB,CAACrF,EAAe,EAAEgD,KAAY,EAAa;IACtE,OAAO,KAAIgC,wCAAkB,EAAChF,EAAE,EAAE,IAAI,EAAEgD,KAAK,EAAE,KAAI6E,mBAAM,GAAE,EAAE,IAAI,CAAChJ,SAAS,CAAC;EAC9E;EAEA,MAAcoI,mBAAmB,CAAC3E,SAAoB,EAAEoF,SAAiB,EAAErE,IAAS,EAAE;IACpF,IAAI,CAACA,IAAI,EAAE;IACX,MAAMyE,iBAAiB,GAAGxF,SAAS,CAACU,KAAK,CAACoD,MAAM,CAACpC,UAAU,CAAC+D,aAAa,CAACL,SAAS,CAAC;IACpF,IAAII,iBAAiB,EAAE;MACrB;MACAE,MAAM,CAACC,MAAM,CAACH,iBAAiB,CAACzE,IAAI,EAAEA,IAAI,CAAC;MAC3C;IACF;IACAf,SAAS,CAACU,KAAK,CAACoD,MAAM,CAACpC,UAAU,CAACxD,IAAI,CAAC,MAAM,IAAI,CAAC0H,YAAY,CAACR,SAAS,EAAErE,IAAI,CAAC,CAAC;EAClF;EAEA,MAAc6E,YAAY,CAACR,SAAiB,EAAErE,IAA4B,EAA+B;IACvG;IACA,OAAO,KAAI8E,4BAAkB,EAAC/H,SAAS,EAAEA,SAAS,EAAEsH,SAAS,EAAEtH,SAAS,EAAEiD,IAAI,CAAC;EACjF;AACF;AAAC;AAED,SAASiC,uBAAuB,CAACtF,EAAe,EAAET,QAA+B,EAAU;EACzF,OAAQ,GAAES,EAAE,CAACE,QAAQ,EAAG,IAAGkI,IAAI,CAACC,SAAS,CAACC,QAAQ,CAAC/I,QAAQ,aAARA,QAAQ,cAARA,QAAQ,GAAI,CAAC,CAAC,CAAC,CAAE,EAAC;AACvE;AAEA,SAAS+I,QAAQ,CAACC,GAAW,EAAE;EAC7B,OAAO,IAAAC,mBAAS,EAACR,MAAM,CAACV,OAAO,CAACiB,GAAG,CAAC,CAACE,IAAI,CAAC,CAAC,CAACC,EAAE,CAAC,EAAE,CAACC,EAAE,CAAC,KAAKD,EAAE,CAACE,aAAa,CAACD,EAAE,CAAC,CAAC,CAAC;AAClF"}