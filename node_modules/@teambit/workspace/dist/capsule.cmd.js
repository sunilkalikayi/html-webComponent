"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CapsuleListCmd = exports.CapsuleDeleteCmd = exports.CapsuleCreateCmd = exports.CapsuleCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class CapsuleCreateCmd {
  constructor(workspace, isolator) {
    this.workspace = workspace;
    this.isolator = isolator;
    (0, _defineProperty2().default)(this, "name", 'create [component-id...]');
    (0, _defineProperty2().default)(this, "description", `create capsules for components`);
    (0, _defineProperty2().default)(this, "group", 'capsules');
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['b', 'base-dir <name>', 'set base dir of all capsules (hashed to create the base dir inside the root dir - host path by default)'], ['r', 'root-base-dir <name>', 'set root base dir of all capsules (absolute path to use as root dir)'], ['a', 'always-new', 'create new environment for capsule'], ['s', 'seeders-only', 'create capsules for the seeders only (not for the entire graph)'], ['i', 'id <name>', 'reuse capsule of certain name'], ['j', 'json', 'json format'], ['d', 'install-packages', 'install packages by the package-manager'], ['p', 'package-manager <name>', 'npm, yarn or pnpm, default to npm']]);
  }
  async create([componentIds = []], {
    baseDir,
    rootBaseDir,
    alwaysNew = false,
    id,
    installPackages = false,
    seedersOnly = false
  }) {
    // @todo: why it is not an array?
    if (componentIds && !Array.isArray(componentIds)) componentIds = [componentIds];
    const capsuleOptions = {
      baseDir,
      rootBaseDir,
      installOptions: {
        installPackages
      },
      alwaysNew,
      seedersOnly,
      includeFromNestedHosts: true,
      name: id
    };
    const ids = await this.workspace.resolveMultipleComponentIds(componentIds);
    const network = await this.isolator.isolateComponents(ids, capsuleOptions);
    const capsules = network.graphCapsules;
    return capsules;
  }
  async report([componentIds], opts) {
    // @ts-ignore
    const capsules = await this.create(componentIds, opts);
    const capsuleOutput = capsules.map(capsule => `${_chalk().default.bold(capsule.component.id.toString())} - ${capsule.path}`).join('\n');
    const title = `${capsules.length} capsule(s) were created successfully`;
    return `${_chalk().default.green(title)}\n${capsuleOutput}`;
  }
  async json([componentIds], opts) {
    // @ts-ignore
    const capsules = await this.create(componentIds, opts);
    return capsules.map(c => ({
      id: c.component.id.toString(),
      path: c.path
    }));
  }
}
exports.CapsuleCreateCmd = CapsuleCreateCmd;
class CapsuleListCmd {
  constructor(isolator, workspace) {
    this.isolator = isolator;
    this.workspace = workspace;
    (0, _defineProperty2().default)(this, "name", 'list');
    (0, _defineProperty2().default)(this, "description", `list the capsules generated for this workspace`);
    (0, _defineProperty2().default)(this, "group", 'capsules');
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['j', 'json', 'json format']]);
  }
  async report() {
    const list = await this.isolator.list(this.workspace.path);
    const {
      workspaceCapsulesRootDir,
      scopeAspectsCapsulesRootDir
    } = this.getCapsulesRootDirs();
    // TODO: improve output
    return _chalk().default.green(`found ${_chalk().default.cyan(list.capsules.length.toString())} capsule(s) for workspace:  ${_chalk().default.cyan(list.workspace)}
workspace capsules root-dir:       ${_chalk().default.cyan(workspaceCapsulesRootDir)}
scope's aspects capsules root-dir: ${_chalk().default.cyan(scopeAspectsCapsulesRootDir)}
use --json to get the list of all workspace capsules`);
  }
  async json() {
    const list = await this.isolator.list(this.workspace.path);
    const rootDirs = this.getCapsulesRootDirs();
    return _objectSpread(_objectSpread({}, list), rootDirs);
  }
  getCapsulesRootDirs() {
    const workspaceCapsulesRootDir = this.isolator.getCapsulesRootDir(this.workspace.path);
    const scopeAspectsCapsulesRootDir = this.isolator.getCapsulesRootDir(this.workspace.scope.getAspectCapsulePath());
    return {
      workspaceCapsulesRootDir,
      scopeAspectsCapsulesRootDir
    };
  }
}
exports.CapsuleListCmd = CapsuleListCmd;
class CapsuleDeleteCmd {
  constructor(isolator, workspace) {
    this.isolator = isolator;
    this.workspace = workspace;
    (0, _defineProperty2().default)(this, "name", 'delete');
    (0, _defineProperty2().default)(this, "description", `delete capsules`);
    (0, _defineProperty2().default)(this, "extendedDescription", `with no args, only workspace's capsules are deleted`);
    (0, _defineProperty2().default)(this, "group", 'capsules');
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['', 'scope-aspects', 'delete scope-aspects capsules'], ['a', 'all', 'delete all capsules for all workspaces and scopes']]);
  }
  async report(args, {
    all,
    scopeAspects
  }) {
    const capsuleBaseDirToDelete = () => {
      if (all) return null;
      if (scopeAspects) return this.workspace.scope.getAspectCapsulePath();
      return this.workspace.path;
    };
    const capsuleBaseDir = capsuleBaseDirToDelete();
    const deletedDir = await this.isolator.deleteCapsules(capsuleBaseDir);
    return _chalk().default.green(`the following capsules dir has been deleted ${_chalk().default.bold(deletedDir)}`);
  }
}
exports.CapsuleDeleteCmd = CapsuleDeleteCmd;
class CapsuleCmd {
  constructor() {
    (0, _defineProperty2().default)(this, "name", 'capsule <sub-command>');
    (0, _defineProperty2().default)(this, "description", 'manage capsules');
    (0, _defineProperty2().default)(this, "extendedDescription", `a capsule is a directory containing the component code, isolated from the workspace.
normally, capsules are created during the build process, the component files are copied and the packages are installed
via the configured package-manager. the purpose is to compile/test them in isolation to make sure they will work for
other users after publishing/exporting them.`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "group", 'capsules');
    (0, _defineProperty2().default)(this, "commands", []);
    (0, _defineProperty2().default)(this, "options", []);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async report(args) {
    // it should never be here. Yargs throws an error before reaching this method.
    return `Please specify a sub-command`;
  }
}
exports.CapsuleCmd = CapsuleCmd;

//# sourceMappingURL=capsule.cmd.js.map