"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = provideWorkspace;
function _consumer() {
  const data = require("@teambit/legacy/dist/consumer");
  _consumer = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component"));
  _component = function () {
    return data;
  };
  return data;
}
function _componentLoader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/component-loader"));
  _componentLoader = function () {
    return data;
  };
  return data;
}
function _extensionData() {
  const data = require("@teambit/legacy/dist/consumer/config/extension-data");
  _extensionData = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("./constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _ejectConf() {
  const data = _interopRequireDefault(require("./eject-conf.cmd"));
  _ejectConf = function () {
    return data;
  };
  return data;
}
function _watch() {
  const data = require("./watch/watch.cmd");
  _watch = function () {
    return data;
  };
  return data;
}
function _watcher() {
  const data = require("./watch/watcher");
  _watcher = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = require("./workspace");
  _workspace = function () {
    return data;
  };
  return data;
}
function _workspace2() {
  const data = _interopRequireDefault(require("./workspace.graphql"));
  _workspace2 = function () {
    return data;
  };
  return data;
}
function _workspace3() {
  const data = require("./workspace.ui-root");
  _workspace3 = function () {
    return data;
  };
  return data;
}
function _capsule() {
  const data = require("./capsule.cmd");
  _capsule = function () {
    return data;
  };
  return data;
}
function _envsSet() {
  const data = require("./envs-subcommands/envs-set.cmd");
  _envsSet = function () {
    return data;
  };
  return data;
}
function _envsUnset() {
  const data = require("./envs-subcommands/envs-unset.cmd");
  _envsUnset = function () {
    return data;
  };
  return data;
}
function _pattern() {
  const data = require("./pattern.cmd");
  _pattern = function () {
    return data;
  };
  return data;
}
function _envsReplace() {
  const data = require("./envs-subcommands/envs-replace.cmd");
  _envsReplace = function () {
    return data;
  };
  return data;
}
function _scopeSet() {
  const data = require("./scope-subcommands/scope-set.cmd");
  _scopeSet = function () {
    return data;
  };
  return data;
}
function _use() {
  const data = require("./use.cmd");
  _use = function () {
    return data;
  };
  return data;
}
async function provideWorkspace([pubsub, cli, scope, component, isolator, dependencyResolver, variants, loggerExt, graphql, ui, bundler, aspectLoader, envs], config, [onComponentLoadSlot, onComponentChangeSlot, onComponentAddSlot, onComponentRemoveSlot, onPreWatchSlot], harmony) {
  var _envsCommand$commands, _envsCommand$commands2, _envsCommand$commands3, _scopeCommand$command;
  const bitConfig = harmony.config.get('teambit.harmony/bit');
  const consumer = await getConsumer(bitConfig.cwd);
  if (!consumer) return undefined;
  // TODO: get the 'workspace' name in a better way
  const logger = loggerExt.createLogger(_constants().EXT_NAME);
  const workspace = new (_workspace().Workspace)(pubsub, config, consumer, scope, component, dependencyResolver, variants, aspectLoader, logger, undefined, harmony, onComponentLoadSlot, onComponentChangeSlot, envs, onComponentAddSlot, onComponentRemoveSlot, onPreWatchSlot, graphql);
  const getWorkspacePolicyFromPackageJson = () => {
    var _workspace$consumer$p;
    const packageJson = ((_workspace$consumer$p = workspace.consumer.packageJson) === null || _workspace$consumer$p === void 0 ? void 0 : _workspace$consumer$p.packageJsonObject) || {};
    const policyFromPackageJson = dependencyResolver.getWorkspacePolicyFromPackageJson(packageJson);
    return policyFromPackageJson;
  };
  dependencyResolver.registerRootPolicy(getWorkspacePolicyFromPackageJson());
  consumer.onCacheClear.push(() => workspace.clearCache());
  _componentLoader().default.registerOnComponentLoadSubscriber(async (legacyComponent, opts) => {
    const id = await workspace.resolveComponentId(legacyComponent.id);
    const newComponent = await workspace.get(id, legacyComponent, true, true, opts);
    return newComponent.state._consumer;
  });
  _component().default.registerOnComponentConfigLoading(_constants().EXT_NAME, async id => {
    const componentId = await workspace.resolveComponentId(id);
    // We call here directly workspace.scope.get instead of workspace.get because part of the workspace get is loading consumer component
    // which in turn run this event, which will make an infinite loop
    // This component from scope here are only used for merging the extensions with the workspace components
    const componentFromScope = await workspace.scope.get(componentId);
    const {
      extensions
    } = await workspace.componentExtensions(componentId, componentFromScope);
    const defaultScope = await workspace.componentDefaultScope(componentId);
    const extensionsWithLegacyIdsP = extensions.map(async extension => {
      const legacyEntry = extension.clone();
      if (legacyEntry.extensionId) {
        const compId = await workspace.resolveComponentId(legacyEntry.extensionId);
        legacyEntry.extensionId = compId._legacy;
        legacyEntry.newExtensionId = compId;
      }
      return legacyEntry;
    });
    const extensionsWithLegacyIds = await Promise.all(extensionsWithLegacyIdsP);
    return {
      defaultScope,
      extensions: _extensionData().ExtensionDataList.fromArray(extensionsWithLegacyIds)
    };
  });
  const workspaceSchema = (0, _workspace2().default)(workspace, graphql);
  ui.registerUiRoot(new (_workspace3().WorkspaceUIRoot)(workspace, bundler));
  graphql.register(workspaceSchema);
  const capsuleCmd = new (_capsule().CapsuleCmd)();
  capsuleCmd.commands = [new (_capsule().CapsuleListCmd)(isolator, workspace), new (_capsule().CapsuleCreateCmd)(workspace, isolator), new (_capsule().CapsuleDeleteCmd)(isolator, workspace)];
  const watcher = new (_watcher().Watcher)(workspace, pubsub);
  const commands = [new (_ejectConf().default)(workspace), capsuleCmd, new (_watch().WatchCommand)(pubsub, logger, watcher), new (_use().UseCmd)(workspace)];
  commands.push(new (_pattern().PatternCommand)(workspace));
  cli.register(...commands);
  component.registerHost(workspace);
  cli.registerOnStart(async () => {
    await workspace.importCurrentLaneIfMissing();
    await workspace.loadAspects(aspectLoader.getNotLoadedConfiguredExtensions(), undefined, 'workspace.cli.registerOnStart');
  });

  // add sub-commands "set" and "unset" to envs command.
  const envsCommand = cli.getCommand('envs');
  envsCommand === null || envsCommand === void 0 ? void 0 : (_envsCommand$commands = envsCommand.commands) === null || _envsCommand$commands === void 0 ? void 0 : _envsCommand$commands.push(new (_envsSet().EnvsSetCmd)(workspace)); // bit envs set
  envsCommand === null || envsCommand === void 0 ? void 0 : (_envsCommand$commands2 = envsCommand.commands) === null || _envsCommand$commands2 === void 0 ? void 0 : _envsCommand$commands2.push(new (_envsUnset().EnvsUnsetCmd)(workspace)); // bit envs unset
  envsCommand === null || envsCommand === void 0 ? void 0 : (_envsCommand$commands3 = envsCommand.commands) === null || _envsCommand$commands3 === void 0 ? void 0 : _envsCommand$commands3.push(new (_envsReplace().EnvsReplaceCmd)(workspace)); // bit envs replace

  // add sub-command "set" to scope command.
  const scopeCommand = cli.getCommand('scope');
  scopeCommand === null || scopeCommand === void 0 ? void 0 : (_scopeCommand$command = scopeCommand.commands) === null || _scopeCommand$command === void 0 ? void 0 : _scopeCommand$command.push(new (_scopeSet().ScopeSetCmd)(workspace));
  return workspace;
}

/**
 * don't use loadConsumer() here, which throws ConsumerNotFound because some commands don't require
 * the consumer to be available. such as, `bit init` or `bit list --remote`.
 * most of the commands do need the consumer. the legacy commands that need the consumer throw an
 * error when is missing. in the new/Harmony commands, such as `bis compile`, the workspace object
 * is passed to the provider, so before using it, make sure it exists.
 * keep in mind that you can't verify it in the provider itself, because the provider is running
 * always for all commands before anything else is happening.
 */
async function getConsumer(path) {
  return (0, _consumer().loadConsumerIfExist)(path);
}

//# sourceMappingURL=workspace.provider.js.map