"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GraphFromFsBuilder = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _bitIds() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/bit-id/bit-ids"));
  _bitIds = function () {
    return data;
  };
  return data;
}
function _graph() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/scope/graph/graph"));
  _graph = function () {
    return data;
  };
  return data;
}
function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/scope/component-ops/scope-components-importer"));
  _scopeComponentsImporter = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/scope/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = require("@teambit/scope");
  _scope = function () {
    return data;
  };
  return data;
}
function _lodash2() {
  const data = _interopRequireDefault(require("lodash.compact"));
  _lodash2 = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
class GraphFromFsBuilder {
  constructor(workspace, logger, ignoreIds = new (_bitIds().default)(), shouldLoadItsDeps, shouldThrowOnMissingDep = true) {
    this.workspace = workspace;
    this.logger = logger;
    this.ignoreIds = ignoreIds;
    this.shouldLoadItsDeps = shouldLoadItsDeps;
    this.shouldThrowOnMissingDep = shouldThrowOnMissingDep;
    (0, _defineProperty2().default)(this, "graph", new (_graph().default)());
    (0, _defineProperty2().default)(this, "completed", []);
    (0, _defineProperty2().default)(this, "depth", 1);
    (0, _defineProperty2().default)(this, "consumer", void 0);
    this.consumer = this.workspace.consumer;
  }

  /**
   * create a graph with all dependencies and flattened dependencies of the given components.
   * the nodes are components and the edges has a label of the dependency type.
   *
   * the way how it is done is iterations by depths. each depth we gather all the dependencies of
   * that depths, make sure all objects exist and then check their dependencies for the next depth.
   * once there is no dependency left, we're on the last depth level and the graph is ready.
   *
   * for example, imagine the following graph:
   * A1 -> A2 -> A3
   * B1 -> B2 -> B3
   * C1 -> C2 -> C3
   *
   * where the buildGraph is given [A1, B1, C1].
   * first, it saves all these components as nodes in the graph. then, it finds the dependencies of
   * the next level, in this case they're [A2, B2, C2]. it runs `importMany` in case some objects
   * are missing. then, it loads them all (some from FS, some from the model) and sets the edges
   * between the component and the dependencies.
   * once done, it finds all their dependencies, which are [A3, B3, C3] and repeat the process
   * above. since there are no more dependencies, the graph is completed.
   * in this case, the total depth levels are 3.
   *
   * even with a huge project, there are not many depth levels. by iterating through depth levels
   * we keep performance sane as the importMany doesn't run multiple time and therefore the round
   * trips to the remotes are minimal.
   *
   * normally, one importMany of the seeders is enough as importMany knows to fetch all flattened.
   * however, since this buildGraph is performed on the workspace, a dependency may be new or
   * modified and as such, we don't know its flattened yet.
   */
  async buildGraph(ids) {
    this.logger.debug(`GraphFromFsBuilder, buildGraph with ${ids.length} seeders`);
    const start = Date.now();
    const components = await this.loadManyComponents(ids);
    await this.processManyComponents(components);
    this.logger.debug(`GraphFromFsBuilder, buildGraph with ${ids.length} seeders completed (${(Date.now() - start) / 1000} sec)`);
    return this.graph;
  }
  getAllDepsUnfiltered(component) {
    return component.getAllDependenciesIds().difference(this.ignoreIds);
  }
  async getAllDepsFiltered(component) {
    const depsWithoutIgnore = this.getAllDepsUnfiltered(component);
    const shouldLoadFunc = this.shouldLoadItsDeps;
    if (!shouldLoadFunc) return depsWithoutIgnore;
    const deps = await (0, _pMapSeries().default)(depsWithoutIgnore, async depId => {
      const shouldLoad = await shouldLoadFunc(depId);
      if (!shouldLoad) this.ignoreIds.push(depId);
      return shouldLoad ? depId : null;
    });
    return _bitIds().default.fromArray((0, _lodash2().default)(deps));
  }
  async processManyComponents(components) {
    this.logger.debug(`GraphFromFsBuilder.processManyComponents depth ${this.depth}, ${components.length} components`);
    this.depth += 1;
    await this.importObjects(components);
    const allDependencies = await (0, _pMapSeries().default)(components, component => this.processOneComponent(component));
    const allDependenciesFlattened = (0, _lodash().flatten)(allDependencies);
    if (allDependenciesFlattened.length) await this.processManyComponents(allDependenciesFlattened);
  }
  async importObjects(components) {
    const allDeps = components.map(c => this.getAllDepsUnfiltered(c)).flat();
    const allDepsWithScope = allDeps.filter(dep => dep.hasScope());
    const scopeComponentsImporter = new (_scopeComponentsImporter().default)(this.consumer.scope);
    await scopeComponentsImporter.importMany({
      ids: _bitIds().default.uniqFromArray(allDepsWithScope),
      throwForDependencyNotFound: this.shouldThrowOnMissingDep,
      throwForSeederNotFound: this.shouldThrowOnMissingDep,
      reFetchUnBuiltVersion: false
    });
  }
  async processOneComponent(component) {
    const idStr = component.id.toString();
    if (this.completed.includes(idStr)) return [];
    const allIds = await this.getAllDepsFiltered(component);
    const allDependencies = await this.loadManyComponents(allIds, idStr);
    Object.entries(component.depsIdsGroupedByType).forEach(([depType, depsIds]) => {
      depsIds.forEach(depId => {
        if (this.ignoreIds.has(depId)) return;
        if (!this.graph.hasNode(depId.toString())) {
          if (this.shouldThrowOnMissingDep) {
            throw new Error(`buildOneComponent: missing node of ${depId.toString()}`);
          }
          this.logger.warn(`ignoring missing ${depId.toString()}`);
          return;
        }
        this.graph.setEdge(idStr, depId.toString(), depType);
      });
    });
    this.completed.push(idStr);
    return allDependencies;
  }
  async loadManyComponents(componentsIds, dependenciesOf) {
    const components = await (0, _pMapSeries().default)(componentsIds, async comp => {
      const idStr = comp.toString();
      const fromGraph = this.graph.node(idStr);
      if (fromGraph) return fromGraph;
      try {
        const component = await this.loadComponent(comp);
        this.graph.setNode(idStr, component);
        return component;
      } catch (err) {
        if (err instanceof _exceptions().ComponentNotFound || err instanceof _scope().ComponentNotFound || err instanceof _exceptions().ScopeNotFound) {
          if (dependenciesOf && !this.shouldThrowOnMissingDep) {
            this.logger.warn(`component ${idStr}, dependency of ${dependenciesOf} was not found. continuing without it`);
            return null;
          }
          throw new (_bitError().BitError)(`error: component "${idStr}" was not found.\nthis component is a dependency of "${dependenciesOf || '<none>'}" and is needed as part of the graph generation`);
        }
        if (dependenciesOf) this.logger.error(`failed loading dependencies of ${dependenciesOf}`);
        throw err;
      }
    });
    return (0, _lodash2().default)(components);
  }
  async loadComponent(componentId) {
    const compId = await this.workspace.resolveComponentId(componentId);
    const comp = await this.workspace.get(compId);
    return comp.state._consumer;
  }
}
exports.GraphFromFsBuilder = GraphFromFsBuilder;

//# sourceMappingURL=build-graph-from-fs.js.map