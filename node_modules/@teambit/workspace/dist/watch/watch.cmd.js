"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WatchCommand = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _moment() {
  const data = _interopRequireDefault(require("moment"));
  _moment = function () {
    return data;
  };
  return data;
}
function _compiler() {
  const data = require("@teambit/compiler");
  _compiler = function () {
    return data;
  };
  return data;
}
function _outputFormatter() {
  const data = require("./output-formatter");
  _outputFormatter = function () {
    return data;
  };
  return data;
}
function _checkTypes() {
  const data = require("./check-types");
  _checkTypes = function () {
    return data;
  };
  return data;
}
// import IDs and events

class WatchCommand {
  constructor(
  /**
   * logger extension.
   */
  pubsub,
  /**
   * logger extension.
   */
  logger,
  /**
   * watcher extension.
   */
  watcher) {
    this.pubsub = pubsub;
    this.logger = logger;
    this.watcher = watcher;
    (0, _defineProperty2().default)(this, "msgs", {
      onAll: (event, path) => this.logger.console(`Event: "${event}". Path: ${path}`),
      onStart: () => {},
      onReady: (workspace, watchPathsSortByComponent, verbose) => {
        clearOutdatedData();
        if (verbose) {
          this.logger.console((0, _outputFormatter().formatWatchPathsSortByComponent)(watchPathsSortByComponent));
        }
        this.logger.console(_chalk().default.yellow(`Watching for component changes in workspace ${workspace.config.name} (${(0, _moment().default)().format('HH:mm:ss')})...\n`));
      },
      onChange: (filePaths, buildResults, verbose, duration, failureMsg) => {
        const files = filePaths.join(', ');
        // clearOutdatedData();
        if (!buildResults.length) {
          failureMsg = failureMsg || `The files ${files} have been changed, but nothing to compile`;
          this.logger.console(`${failureMsg}\n\n`);
          return;
        }
        this.logger.console(`The file(s) ${files} have been changed.\n\n`);
        this.logger.console((0, _outputFormatter().formatCompileResults)(buildResults, verbose));
        this.logger.console(`Finished. (${duration}ms)`);
        this.logger.console(_chalk().default.yellow(`Watching for component changes (${(0, _moment().default)().format('HH:mm:ss')})...`));
      },
      onAdd: (filePaths, buildResults, verbose, duration, failureMsg) => {
        const files = filePaths.join(', ');
        // clearOutdatedData();
        if (!buildResults.length) {
          failureMsg = failureMsg || `The files ${files} have been added, but nothing to compile`;
          this.logger.console(`${failureMsg}\n\n`);
          return;
        }
        this.logger.console(`The file(s) ${filePaths} have been added.\n\n`);
        this.logger.console((0, _outputFormatter().formatCompileResults)(buildResults, verbose));
        this.logger.console(`Finished. (${duration}ms)`);
        this.logger.console(_chalk().default.yellow(`Watching for component changes (${(0, _moment().default)().format('HH:mm:ss')})...`));
      },
      onUnlink: p => {
        this.logger.console(`file ${p} has been removed`);
      },
      onError: err => {
        this.logger.console(`Watcher error ${err}`);
      }
    });
    (0, _defineProperty2().default)(this, "name", 'watch');
    (0, _defineProperty2().default)(this, "description", 'automatically recompile modified components (on save)');
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "options", [['v', 'verbose', 'show npm verbose output for inspection and print the stack trace'], ['', 'skip-pre-compilation', 'skip the compilation step before starting to watch'], ['t', 'check-types [string]', 'EXPERIMENTAL. show errors/warnings for types. options are [file, project] to investigate only changed file or entire project. defaults to project']]);
    (0, _defineProperty2().default)(this, "eventsListener", event => {
      switch (event.type) {
        case _compiler().CompilerErrorEvent.TYPE:
          this.logger.console(`Watcher error ${event.data.error}, 'error'`);
          break;
        default:
      }
    });
    this.registerToEvents();
  }
  registerToEvents() {
    this.pubsub.sub(_compiler().CompilerAspect.id, this.eventsListener);
  }
  async report(cliArgs, watchCmdOpts) {
    const {
      verbose,
      checkTypes
    } = watchCmdOpts;
    const getCheckTypesEnum = () => {
      switch (checkTypes) {
        case undefined:
        case false:
          return _checkTypes().CheckTypes.None;
        case 'project':
        case true:
          // project is the default
          return _checkTypes().CheckTypes.EntireProject;
        case 'file':
          return _checkTypes().CheckTypes.ChangedFile;
        default:
          throw new Error(`check-types can be either "file" or "project". got "${checkTypes}"`);
      }
    };
    const watchOpts = {
      msgs: this.msgs,
      verbose,
      preCompile: !watchCmdOpts.skipPreCompilation,
      spawnTSServer: Boolean(checkTypes),
      // if check-types is enabled, it must spawn the tsserver.
      checkTypes: getCheckTypesEnum()
    };
    await this.watcher.watchAll(watchOpts);
    return 'watcher terminated';
  }
}

/**
 * with console.clear() all history is deleted from the console. this function preserver the history.
 */
exports.WatchCommand = WatchCommand;
function clearOutdatedData() {
  process.stdout.write('\x1Bc');
}

//# sourceMappingURL=watch.cmd.js.map