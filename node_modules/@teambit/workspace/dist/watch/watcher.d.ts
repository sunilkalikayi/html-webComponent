/// <reference types="node" />
import { PubsubMain } from '@teambit/pubsub';
import { ComponentID } from '@teambit/component';
import { BitId } from '@teambit/legacy-bit-id';
import { Consumer } from '@teambit/legacy/dist/consumer';
import { ChildProcess } from 'child_process';
import { PathLinux } from '@teambit/legacy/dist/utils/path';
import { CompilationInitiator } from '@teambit/compiler';
import { Workspace } from '../workspace';
import { CheckTypes } from './check-types';
export declare type WatcherProcessData = {
    watchProcess: ChildProcess;
    compilerId: BitId;
    componentIds: BitId[];
};
export declare type EventMessages = {
    onAll: Function;
    onStart: Function;
    onReady: Function;
    onChange: Function;
    onAdd: Function;
    onUnlink: Function;
    onError: Function;
};
export declare type WatchOptions = {
    msgs?: EventMessages;
    initiator?: CompilationInitiator;
    verbose?: boolean;
    spawnTSServer?: boolean;
    checkTypes?: CheckTypes;
    preCompile?: boolean;
};
export declare class Watcher {
    private workspace;
    private pubsub;
    private trackDirs;
    private verbose;
    private multipleWatchers;
    private fsWatcher;
    private changedFilesPerComponent;
    private watchQueue;
    private bitMapChangesInProgress;
    constructor(workspace: Workspace, pubsub: PubsubMain, trackDirs?: {
        [dir: PathLinux]: ComponentID;
    }, verbose?: boolean, multipleWatchers?: WatcherProcessData[]);
    get consumer(): Consumer;
    watchAll(opts: WatchOptions): Promise<unknown>;
    /**
     * *** DEBOUNCING ***
     * some actions trigger multiple files changes at (almost) the same time. e.g. "git pull".
     * this causes some performance and instability issues. a debouncing mechanism was implemented to help with this.
     * the way how it works is that the first file of the same component starts the execution with a delay (e.g. 200ms).
     * if, in the meanwhile, another file of the same component was changed, it won't start a new execution, instead,
     * it'll only add the file to `this.changedFilesPerComponent` prop.
     * once the execution starts, it'll delete this component-id from the `this.changedFilesPerComponent` array,
     * indicating the next file-change to start a new execution.
     *
     * implementation wise, `lodash.debounce` doesn't help here, because:
     * A) it doesn't return the results, unless "leading" option is true. here, it must be false, otherwise, it'll start
     * the execution immediately.
     * B) it debounces the method regardless the param passes to it. so it'll disregard the component-id and will delay
     * other components undesirably.
     *
     * *** QUEUE ***
     * the debouncing helps to not execute the same component multiple times concurrently. however, multiple components
     * and .bitmap changes execution can still be processed concurrently.
     * the following example explains why this is an issue.
     * compA is changed in the .bitmap file from version 0.0.1 to 0.0.2. its files were changed as well.
     * all these changes get pulled at the same time by "git pull", as a result, the execution of compA and the .bitmap
     * happen at the same time.
     * during the execution of compA, the component id is parsed as compA@0.0.1, later, it asks for the Workspace for this
     * id. while the workspace is looking for this id, the .bitmap execution reloaded the consumer and changed all versions.
     * after this change, the workspace doesn't have this id anymore, which will trigger an error.
     * to ensure this won't happen, we keep a flag to indicate whether the .bitmap execution is running, and if so, all
     * other executions are paused until the queue is empty (this is done by awaiting for queue.onIdle).
     * once the queue is empty, we know the .bitmap process was done and the workspace has all new ids.
     * in the example above, at this stage, the id will be resolved to compA@0.0.2.
     * one more thing, the queue is configured to have concurrency of 1. to make sure two components are not processed at
     * the same time. (the same way is done when loading all components from the filesystem/scope).
     * this way we can also ensure that if compA was started before the .bitmap execution, it will complete before the
     * .bitmap execution starts.
     */
    private handleChange;
    private sleep;
    /**
     * if a file was added/remove, once the component is loaded, it changes .bitmap, and then the
     * entire cache is invalidated and the consumer is reloaded.
     * when a file just changed, no need to reload the consumer, it is enough to just delete the
     * component from the cache (both, workspace and consumer)
     */
    private triggerCompChanges;
    /**
     * if .bitmap changed, it's possible that a new component has been added. trigger onComponentAdd.
     */
    private handleBitmapChanges;
    private executeWatchOperationsOnRemove;
    private executeWatchOperationsOnComponent;
    private creatOnComponentRemovedEvent;
    private creatOnComponentChangeEvent;
    private creatOnComponentAddEvent;
    private isComponentWatchedExternally;
    private getComponentIdByPath;
    private getRelativePathLinux;
    private findTrackDirByFilePathRecursively;
    private createWatcher;
    setTrackDirs(): Promise<void>;
    private getPathsToWatch;
}
