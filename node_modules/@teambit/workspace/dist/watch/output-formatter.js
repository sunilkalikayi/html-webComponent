"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatCompileResults = formatCompileResults;
exports.formatWatchPathsSortByComponent = void 0;
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
const verboseComponentFilesArrayToString = componentFiles => {
  return componentFiles.reduce((outputString, filePath) => `${outputString} \t - ${filePath}\n`, ``);
};
const resultsForExtensionArrayToString = (resultsForExtension, verbose) => {
  return resultsForExtension.reduce((outputString, resultForExtension) => `${outputString}${_chalk().default.green('√')}SUCCESS\t${resultForExtension.component}\n
     ${verbose ? resultForExtension.componentFilesAsString : ''}\n`, '');
};
const formatWatchPathsSortByComponent = trackDirs => {
  return Object.keys(trackDirs).reduce((outputString, watchPath) => `${outputString}
    ${_chalk().default.green('√')} SUCCESS\t${trackDirs[watchPath]}\n
    \t - ${watchPath}\n\n`, ` ${_chalk().default.underline('STATUS\t\tCOMPONENT ID')}\n`);
};

/**
 * todo: this was implemented incorrectly.
 * the original idea of `SerializableResults` was to have each one of the aspects registered to the slot, the
 * ability to have their own formatting to their results, and then `toString()` method to print them.
 * Here, the printing is specifically to the Compiler aspect. It should move to where it belongs.
 */
exports.formatWatchPathsSortByComponent = formatWatchPathsSortByComponent;
function formatCompileResults(compileResults, verbose) {
  if (!compileResults.length || !Array.isArray(compileResults)) return '';
  return compileResults.filter(compileResult => {
    var _compileResult$result, _compileResult$result2;
    return ((_compileResult$result = compileResult.results) === null || _compileResult$result === void 0 ? void 0 : _compileResult$result.results) && Array.isArray((_compileResult$result2 = compileResult.results) === null || _compileResult$result2 === void 0 ? void 0 : _compileResult$result2.results);
  }).map(compileResult => {
    var _compileResult$result3, _compileResult$result4;
    return {
      extensionId: compileResult.extensionId,
      resultsForExtension: (_compileResult$result3 = compileResult.results) === null || _compileResult$result3 === void 0 ? void 0 : (_compileResult$result4 = _compileResult$result3.results) === null || _compileResult$result4 === void 0 ? void 0 : _compileResult$result4.map(resultForExtension => ({
        component: resultForExtension.component,
        componentFilesAsString: verboseComponentFilesArrayToString(resultForExtension.buildResults)
      }))
    };
  }).reduce((outputString, compileResult) => `${outputString}
  ${resultsForExtensionArrayToString(compileResult.resultsForExtension, verbose)}`, ` ${_chalk().default.underline('STATUS\tCOMPONENT ID')}`);
}

//# sourceMappingURL=output-formatter.js.map