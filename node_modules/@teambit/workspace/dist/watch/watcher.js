"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Watcher = void 0;
function _objectWithoutProperties2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
  _objectWithoutProperties2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@teambit/legacy/dist/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _chokidar() {
  const data = _interopRequireDefault(require("chokidar"));
  _chokidar = function () {
    return data;
  };
  return data;
}
function _() {
  const data = require("../");
  _ = function () {
    return data;
  };
  return data;
}
function _events() {
  const data = require("../events");
  _events = function () {
    return data;
  };
  return data;
}
function _watchQueue() {
  const data = require("./watch-queue");
  _watchQueue = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const DEBOUNCE_WAIT_MS = 100;
class Watcher {
  constructor(workspace, pubsub, trackDirs = {}, verbose = false, multipleWatchers = []) {
    this.workspace = workspace;
    this.pubsub = pubsub;
    this.trackDirs = trackDirs;
    this.verbose = verbose;
    this.multipleWatchers = multipleWatchers;
    (0, _defineProperty2().default)(this, "fsWatcher", void 0);
    (0, _defineProperty2().default)(this, "changedFilesPerComponent", {});
    (0, _defineProperty2().default)(this, "watchQueue", new (_watchQueue().WatchQueue)());
    (0, _defineProperty2().default)(this, "bitMapChangesInProgress", false);
  }
  get consumer() {
    return this.workspace.consumer;
  }
  async watchAll(opts) {
    const {
        msgs
      } = opts,
      watchOpts = (0, _objectWithoutProperties2().default)(opts, ["msgs"]);
    // TODO: run build in the beginning of process (it's work like this in other envs)
    const pathsToWatch = await this.getPathsToWatch();
    const componentIds = Object.values(this.trackDirs);
    await this.workspace.triggerOnPreWatch(componentIds, watchOpts);
    await this.createWatcher(pathsToWatch);
    const watcher = this.fsWatcher;
    msgs === null || msgs === void 0 ? void 0 : msgs.onStart(this.workspace);
    return new Promise((resolve, reject) => {
      // prefix your command with "BIT_LOG=*" to see all watch events
      if (process.env.BIT_LOG) {
        // @ts-ignore
        if (msgs !== null && msgs !== void 0 && msgs.onAll) watcher.on('all', msgs === null || msgs === void 0 ? void 0 : msgs.onAll);
      }
      watcher.on('ready', () => {
        msgs === null || msgs === void 0 ? void 0 : msgs.onReady(this.workspace, this.trackDirs, this.verbose);
      });
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      watcher.on('change', async filePath => {
        const startTime = new Date().getTime();
        const {
          files,
          results,
          debounced,
          failureMsg
        } = await this.handleChange(filePath, opts === null || opts === void 0 ? void 0 : opts.initiator);
        if (debounced) {
          return;
        }
        const duration = new Date().getTime() - startTime;
        msgs === null || msgs === void 0 ? void 0 : msgs.onChange(files, results, this.verbose, duration, failureMsg);
      });
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      watcher.on('add', async filePath => {
        const startTime = new Date().getTime();
        const {
          files,
          results,
          debounced,
          failureMsg
        } = await this.handleChange(filePath, opts === null || opts === void 0 ? void 0 : opts.initiator);
        if (debounced) {
          return;
        }
        const duration = new Date().getTime() - startTime;
        msgs === null || msgs === void 0 ? void 0 : msgs.onAdd(files, results, this.verbose, duration, failureMsg);
      });
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      watcher.on('unlink', async p => {
        msgs === null || msgs === void 0 ? void 0 : msgs.onUnlink(p);
        await this.handleChange(p);
      });
      watcher.on('error', err => {
        msgs === null || msgs === void 0 ? void 0 : msgs.onError(err);
        reject(err);
      });
    });
  }

  /**
   * *** DEBOUNCING ***
   * some actions trigger multiple files changes at (almost) the same time. e.g. "git pull".
   * this causes some performance and instability issues. a debouncing mechanism was implemented to help with this.
   * the way how it works is that the first file of the same component starts the execution with a delay (e.g. 200ms).
   * if, in the meanwhile, another file of the same component was changed, it won't start a new execution, instead,
   * it'll only add the file to `this.changedFilesPerComponent` prop.
   * once the execution starts, it'll delete this component-id from the `this.changedFilesPerComponent` array,
   * indicating the next file-change to start a new execution.
   *
   * implementation wise, `lodash.debounce` doesn't help here, because:
   * A) it doesn't return the results, unless "leading" option is true. here, it must be false, otherwise, it'll start
   * the execution immediately.
   * B) it debounces the method regardless the param passes to it. so it'll disregard the component-id and will delay
   * other components undesirably.
   *
   * *** QUEUE ***
   * the debouncing helps to not execute the same component multiple times concurrently. however, multiple components
   * and .bitmap changes execution can still be processed concurrently.
   * the following example explains why this is an issue.
   * compA is changed in the .bitmap file from version 0.0.1 to 0.0.2. its files were changed as well.
   * all these changes get pulled at the same time by "git pull", as a result, the execution of compA and the .bitmap
   * happen at the same time.
   * during the execution of compA, the component id is parsed as compA@0.0.1, later, it asks for the Workspace for this
   * id. while the workspace is looking for this id, the .bitmap execution reloaded the consumer and changed all versions.
   * after this change, the workspace doesn't have this id anymore, which will trigger an error.
   * to ensure this won't happen, we keep a flag to indicate whether the .bitmap execution is running, and if so, all
   * other executions are paused until the queue is empty (this is done by awaiting for queue.onIdle).
   * once the queue is empty, we know the .bitmap process was done and the workspace has all new ids.
   * in the example above, at this stage, the id will be resolved to compA@0.0.2.
   * one more thing, the queue is configured to have concurrency of 1. to make sure two components are not processed at
   * the same time. (the same way is done when loading all components from the filesystem/scope).
   * this way we can also ensure that if compA was started before the .bitmap execution, it will complete before the
   * .bitmap execution starts.
   */
  async handleChange(filePath, initiator) {
    try {
      if (filePath.endsWith(_constants().BIT_MAP)) {
        this.bitMapChangesInProgress = true;
        const buildResults = await this.watchQueue.add(() => this.handleBitmapChanges());
        this.bitMapChangesInProgress = false;
        _loader().default.stop();
        return {
          results: buildResults,
          files: [filePath]
        };
      }
      if (this.bitMapChangesInProgress) {
        await this.watchQueue.onIdle();
      }
      const componentId = this.getComponentIdByPath(filePath);
      if (!componentId) {
        const failureMsg = `file ${filePath} is not part of any component, ignoring it`;
        _logger().default.debug(failureMsg);
        _loader().default.stop();
        return {
          results: [],
          files: [filePath],
          failureMsg
        };
      }
      const compIdStr = componentId.toString();
      if (this.changedFilesPerComponent[compIdStr]) {
        this.changedFilesPerComponent[compIdStr].push(filePath);
        _loader().default.stop();
        return {
          results: [],
          debounced: true
        };
      }
      this.changedFilesPerComponent[compIdStr] = [filePath];
      await this.sleep(DEBOUNCE_WAIT_MS);
      const files = this.changedFilesPerComponent[compIdStr];
      delete this.changedFilesPerComponent[compIdStr];
      const buildResults = await this.watchQueue.add(() => this.triggerCompChanges(componentId, files, initiator));
      const failureMsg = buildResults.length ? undefined : `files ${files.join(', ')} are inside the component ${compIdStr} but configured to be ignored`;
      _loader().default.stop();
      return {
        results: buildResults,
        files,
        failureMsg
      };
    } catch (err) {
      const msg = `watcher found an error while handling ${filePath}`;
      _logger().default.error(msg, err);
      _logger().default.console(`${msg}, ${err.message}`);
      _loader().default.stop();
      return {
        results: [],
        files: [filePath],
        failureMsg: err.message
      };
    }
  }
  async sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * if a file was added/remove, once the component is loaded, it changes .bitmap, and then the
   * entire cache is invalidated and the consumer is reloaded.
   * when a file just changed, no need to reload the consumer, it is enough to just delete the
   * component from the cache (both, workspace and consumer)
   */
  async triggerCompChanges(componentId, files, initiator) {
    this.workspace.clearComponentCache(componentId);
    const component = await this.workspace.get(componentId);
    const componentMap = component.state._consumer.componentMap;
    const compFiles = files.filter(filePath => {
      const relativeFile = this.getRelativePathLinux(filePath);
      const isCompFile = Boolean(componentMap.getFilesRelativeToConsumer().find(p => p === relativeFile));
      if (!isCompFile) {
        _logger().default.debug(`file ${filePath} is inside the component ${componentId.toString()} but configured to be ignored`);
      }
      return isCompFile;
    });
    if (!compFiles.length) {
      return [];
    }
    const buildResults = await this.executeWatchOperationsOnComponent(componentId, compFiles, true, initiator);
    return buildResults;
  }

  /**
   * if .bitmap changed, it's possible that a new component has been added. trigger onComponentAdd.
   */
  async handleBitmapChanges() {
    const previewsTrackDirs = _objectSpread({}, this.trackDirs);
    await this.workspace._reloadConsumer();
    await this.setTrackDirs();
    const newDirs = (0, _lodash().difference)(Object.keys(this.trackDirs), Object.keys(previewsTrackDirs));
    const removedDirs = (0, _lodash().difference)(Object.keys(previewsTrackDirs), Object.keys(this.trackDirs));
    const results = [];
    if (newDirs.length) {
      this.fsWatcher.add(newDirs);
      const addResults = await (0, _pMapSeries().default)(newDirs, async dir => this.executeWatchOperationsOnComponent(this.trackDirs[dir], [], false));
      results.push(...addResults.flat());
    }
    if (removedDirs.length) {
      await this.fsWatcher.unwatch(removedDirs);
      await (0, _pMapSeries().default)(removedDirs, dir => this.executeWatchOperationsOnRemove(previewsTrackDirs[dir]));
    }
    return results;
  }
  async executeWatchOperationsOnRemove(componentId) {
    _logger().default.debug(`running OnComponentRemove hook for ${_chalk().default.bold(componentId.toString())}`);
    this.pubsub.pub(_().WorkspaceAspect.id, this.creatOnComponentRemovedEvent(componentId.toString()));
    await this.workspace.triggerOnComponentRemove(componentId);
  }
  async executeWatchOperationsOnComponent(componentId, files, isChange = true, initiator) {
    if (this.isComponentWatchedExternally(componentId)) {
      // update capsule, once done, it automatically triggers the external watcher
      await this.workspace.get(componentId);
      return [];
    }
    const idStr = componentId.toString();
    if (isChange) {
      _logger().default.debug(`running OnComponentChange hook for ${_chalk().default.bold(idStr)}`);
      this.pubsub.pub(_().WorkspaceAspect.id, this.creatOnComponentChangeEvent(idStr, 'OnComponentChange'));
    } else {
      _logger().default.debug(`running OnComponentAdd hook for ${_chalk().default.bold(idStr)}`);
      this.pubsub.pub(_().WorkspaceAspect.id, this.creatOnComponentAddEvent(idStr, 'OnComponentAdd'));
    }
    let buildResults;
    try {
      buildResults = isChange ? await this.workspace.triggerOnComponentChange(componentId, files, initiator) : await this.workspace.triggerOnComponentAdd(componentId);
    } catch (err) {
      // do not exit the watch process on errors, just print them
      const msg = `found an issue during onComponentChange or onComponentAdd hooks`;
      _logger().default.error(msg, err);
      _logger().default.console(`\n${msg}: ${err.message || err}`);
      return [];
    }
    return buildResults;
  }
  creatOnComponentRemovedEvent(idStr) {
    return new (_events().OnComponentRemovedEvent)(Date.now(), idStr);
  }
  creatOnComponentChangeEvent(idStr, hook) {
    return new (_events().OnComponentChangeEvent)(Date.now(), idStr, hook);
  }
  creatOnComponentAddEvent(idStr, hook) {
    return new (_events().OnComponentAddEvent)(Date.now(), idStr, hook);
  }
  isComponentWatchedExternally(componentId) {
    const watcherData = this.multipleWatchers.find(m => m.componentIds.find(id => id.isEqual(componentId._legacy)));
    if (watcherData) {
      _logger().default.debug(`${componentId.toString()} is watched by ${watcherData.compilerId.toString()}`);
      return true;
    }
    return false;
  }
  getComponentIdByPath(filePath) {
    const relativeFile = this.getRelativePathLinux(filePath);
    const trackDir = this.findTrackDirByFilePathRecursively(relativeFile);
    if (!trackDir) {
      // the file is not part of any component. If it was a new component, or a new file of
      // existing component, then, handleBitmapChanges() should deal with it.
      return null;
    }
    return this.trackDirs[trackDir];
  }
  getRelativePathLinux(filePath) {
    return (0, _utils().pathNormalizeToLinux)(this.consumer.getPathRelativeToConsumer(filePath));
  }
  findTrackDirByFilePathRecursively(filePath) {
    if (this.trackDirs[filePath]) return filePath;
    const parentDir = (0, _path().dirname)(filePath);
    if (parentDir === filePath) return null;
    return this.findTrackDirByFilePathRecursively(parentDir);
  }
  async createWatcher(pathsToWatch) {
    this.fsWatcher = _chokidar().default.watch(pathsToWatch, {
      ignoreInitial: true,
      // Using the function way since the regular way not working as expected
      // It might be solved when upgrading to chokidar > 3.0.0
      // See:
      // https://github.com/paulmillr/chokidar/issues/773
      // https://github.com/paulmillr/chokidar/issues/492
      // https://github.com/paulmillr/chokidar/issues/724
      ignored: path => {
        // Ignore package.json temporarily since it cerates endless loop since it's re-written after each build
        if (path.includes(`${_path().sep}node_modules${_path().sep}`) || path.includes(`${_path().sep}package.json`)) {
          return true;
        }
        return false;
      },
      persistent: true,
      useFsEvents: false
    });
  }
  async setTrackDirs() {
    this.trackDirs = {};
    const componentsFromBitMap = this.consumer.bitMap.getAllComponents();
    await Promise.all(componentsFromBitMap.map(async componentMap => {
      const bitId = componentMap.id;
      const rootDir = componentMap.getRootDir();
      if (!rootDir) throw new Error(`${bitId.toString()} has no rootDir, which is invalid in Harmony`);
      const componentId = await this.workspace.resolveComponentId(bitId);
      this.trackDirs[rootDir] = componentId;
    }));
  }
  async getPathsToWatch() {
    await this.setTrackDirs();
    const paths = [...Object.keys(this.trackDirs), _constants().BIT_MAP];
    const pathsAbsolute = paths.map(dir => this.consumer.toAbsolutePath(dir));
    return pathsAbsolute;
  }
}
exports.Watcher = Watcher;

//# sourceMappingURL=watcher.js.map