"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CLIMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/legacy/dist/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _community() {
  const data = require("@teambit/community");
  _community = function () {
    return data;
  };
  return data;
}
function _commandGroups() {
  const data = require("@teambit/legacy/dist/cli/command-groups");
  _commandGroups = function () {
    return data;
  };
  return data;
}
function _consumer() {
  const data = require("@teambit/legacy/dist/consumer");
  _consumer = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _cli2() {
  const data = require("./cli.aspect");
  _cli2 = function () {
    return data;
  };
  return data;
}
function _getCommandId() {
  const data = require("./get-command-id");
  _getCommandId = function () {
    return data;
  };
  return data;
}
function _legacyCommandAdapter() {
  const data = require("./legacy-command-adapter");
  _legacyCommandAdapter = function () {
    return data;
  };
  return data;
}
function _cliParser() {
  const data = require("./cli-parser");
  _cliParser = function () {
    return data;
  };
  return data;
}
function _completion() {
  const data = require("./completion.cmd");
  _completion = function () {
    return data;
  };
  return data;
}
function _cli3() {
  const data = require("./cli.cmd");
  _cli3 = function () {
    return data;
  };
  return data;
}
function _help() {
  const data = require("./help.cmd");
  _help = function () {
    return data;
  };
  return data;
}
class CLIMain {
  // if it's not cloned, it is cached across loadBit() instances
  constructor(commandsSlot, onStartSlot, community, logger) {
    this.commandsSlot = commandsSlot;
    this.onStartSlot = onStartSlot;
    this.community = community;
    this.logger = logger;
    (0, _defineProperty2().default)(this, "groups", (0, _lodash().clone)(_commandGroups().groups));
  }

  /**
   * registers a new command in to the CLI.
   */
  register(...commands) {
    commands.forEach(command => {
      this.setDefaults(command);
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      command.commands.forEach(cmd => this.setDefaults(cmd));
    });
    this.commandsSlot.register(commands);
  }

  /**
   * helpful for having the same command name in different environments (e.g. legacy and non-legacy).
   * for example `cli.unregister('tag');` removes the "bit tag" command.
   */
  unregister(commandName) {
    this.commandsSlot.toArray().forEach(([aspectId, commands]) => {
      const filteredCommands = commands.filter(command => {
        return (0, _getCommandId().getCommandId)(command.name) !== commandName;
      });
      this.commandsSlot.map.set(aspectId, filteredCommands);
    });
  }

  /**
   * list of all registered commands. (legacy and new).
   */
  get commands() {
    return this.commandsSlot.values().flat();
  }

  /**
   * get an instance of a registered command. (useful for aspects to modify and extend existing commands)
   */
  getCommand(name) {
    return this.commands.find(command => (0, _getCommandId().getCommandId)(command.name) === name);
  }

  /**
   * when running `bit help`, commands are grouped by categories.
   * this method helps registering a new group by providing its name and a description.
   * the name is what needs to be assigned to the `group` property of the Command interface.
   * the description is what shown in the `bit help` output.
   */
  registerGroup(name, description) {
    if (this.groups[name]) {
      this.logger.consoleWarning(`CLI group "${name}" is already registered`);
    } else {
      this.groups[name] = description;
    }
  }
  registerOnStart(onStartFn) {
    this.onStartSlot.register(onStartFn);
    return this;
  }

  /**
   * execute commands registered to this aspect.
   */
  async run(hasWorkspace) {
    await this.invokeOnStart(hasWorkspace);
    const CliParser = new (_cliParser().CLIParser)(this.commands, this.groups, undefined, this.community.getDocsDomain());
    await CliParser.parse();
  }
  async invokeOnStart(hasWorkspace) {
    const onStartFns = this.onStartSlot.values();
    const promises = onStartFns.map(async onStart => onStart(hasWorkspace));
    return Promise.all(promises);
  }
  setDefaults(command) {
    command.alias = command.alias || '';
    command.description = command.description || '';
    command.extendedDescription = command.extendedDescription || '';
    command.group = command.group || 'ungrouped';
    command.options = command.options || [];
    command.private = command.private || false;
    command.commands = command.commands || [];
    if (command.loader === undefined) {
      if (command.internal) {
        command.loader = false;
      } else {
        command.loader = true;
      }
    }
    if (command.helpUrl && !isFullUrl(command.helpUrl)) {
      command.helpUrl = `https://${this.community.getDocsDomain()}/${command.helpUrl}`;
    }
  }
  static async provider([community, loggerMain], config, [commandsSlot, onStartSlot]) {
    const logger = loggerMain.createLogger(_cli2().CLIAspect.id);
    const cliMain = new CLIMain(commandsSlot, onStartSlot, community, logger);
    const legacyRegistry = (0, _cli().buildRegistry)();
    await ensureWorkspaceAndScope();
    const legacyCommands = legacyRegistry.commands;
    const legacyCommandsAdapters = legacyCommands.map(command => new (_legacyCommandAdapter().LegacyCommandAdapter)(command, cliMain));
    const cliGenerateCmd = new (_cli3().CliGenerateCmd)(cliMain);
    const cliCmd = new (_cli3().CliCmd)(cliMain, community.getDocsDomain());
    const helpCmd = new (_help().HelpCmd)(cliMain, community.getDocsDomain());
    cliCmd.commands.push(cliGenerateCmd);
    cliMain.register(...legacyCommandsAdapters, new (_completion().CompletionCmd)(), cliCmd, helpCmd);
    return cliMain;
  }
}
exports.CLIMain = CLIMain;
(0, _defineProperty2().default)(CLIMain, "dependencies", [_community().CommunityAspect, _logger().LoggerAspect]);
(0, _defineProperty2().default)(CLIMain, "runtime", _cli2().MainRuntime);
(0, _defineProperty2().default)(CLIMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType()]);
_cli2().CLIAspect.addRuntime(CLIMain);

/**
 * kind of a hack.
 * in the legacy, this is running at the beginning and it take care of issues when Bit files are missing,
 * such as ".bit".
 * (to make this process better, you can easily remove it and run the e2e-tests. you'll see some failing)
 */
async function ensureWorkspaceAndScope() {
  try {
    await (0, _consumer().loadConsumerIfExist)();
  } catch (err) {
    // do nothing. it could fail for example with ScopeNotFound error, which is taken care of in "bit init".
  }
}
function isFullUrl(url) {
  return url.startsWith('http://') || url.startsWith('https://');
}

//# sourceMappingURL=cli.main.runtime.js.map