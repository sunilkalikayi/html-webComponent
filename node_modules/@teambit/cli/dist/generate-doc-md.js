"use strict";

require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenerateCommandsDoc = void 0;
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _getCommandId() {
  const data = require("./get-command-id");
  _getCommandId = function () {
    return data;
  };
  return data;
}
class GenerateCommandsDoc {
  constructor(commands, options) {
    this.commands = commands;
    this.options = options;
  }
  generate() {
    const commands = this.getAllPublicCommandsSorted();
    let output = `${this.getFrontmatter()}
# CLI Reference

Commands that are marked as workspace only must be executed inside a workspace. Commands that are marked as not workspace only, can be executed from anywhere and will run on a remote server.
`;
    output += commands.map(cmd => this.generateCommand(cmd)).join('\n');
    return output;
  }
  generateJson() {
    return this.commandsToObjects();
  }
  commandsToObjects(commands = this.commands) {
    return commands.map(command => {
      var _command$commands;
      const cmdObject = oneCommandToObject(command);
      if ((_command$commands = command.commands) !== null && _command$commands !== void 0 && _command$commands.length) {
        cmdObject.commands = this.commandsToObjects(command.commands);
      }
      return cmdObject;
    });
  }
  getFrontmatter() {
    const metadata = this.options.metadata;
    if (!metadata) {
      return '';
    }
    const metadataStr = Object.keys(metadata).map(key => `${key}: ${metadata[key]}`).join('\n');
    return `---
    ${metadataStr}
    ---
`;
  }
  getAllPublicCommandsSorted() {
    const publicCommands = this.commands.filter(cmd => !cmd.private);
    return publicCommands.sort((a, b) => a.name.localeCompare(b.name));
  }
  generateCommand(cmd) {
    const commandName = (0, _getCommandId().getCommandId)(cmd.name);
    let result = `## ${commandName}  \n\n`;
    if (cmd.alias && cmd.alias.length > 0) {
      result += `**Alias**: \`${cmd.alias}\`  \n`;
    }
    result += `**Workspace only**: ${cmd.skipWorkspace ? 'no' : 'yes'}  \n`;
    result += `**Description**: ${this.formatDescription(cmd)}`;
    result += `\`bit ${cmd.name}\`  \n\n`;
    if (cmd.commands && cmd.commands.length > 0) {
      result += this.generateSubCommands(cmd.commands, cmd);
    }
    result += this.generateOptions(cmd.options);
    result += `---  \n`;
    return result;
  }
  generateSubCommands(subCommands, command) {
    let ret = '';
    subCommands.forEach(subCommand => {
      const commandName = (0, _getCommandId().getCommandId)(command.name);
      const subcommandName = (0, _getCommandId().getCommandId)(subCommand.name);
      const usage = `${commandName} ${subCommand.name}`;
      ret += `### ${commandName} ${subcommandName} \n`;
      ret += `**Usage**: \`${usage}\`  \n\n`;
      ret += `**Description**: ${this.formatDescription(subCommand)}`;
      ret += '\n';
      ret += this.generateOptions(subCommand.options);
    });
    return ret;
  }
  generateOptions(options) {
    if (!options || options.length <= 0) return '';
    let output = `| **Option** | **Option alias** | **Description**|  \n`;
    output += `|---|:-----:|---|\n`;
    options.forEach(opt => {
      const [alias, flag, description] = opt;
      const aliasFormatted = alias ? `\`-${alias}\`` : '   ';
      const flagFormatted = `--${flag}`;
      output += `|\`${flagFormatted}\`|${aliasFormatted}|${description}|\n`;
    });
    output += `\n`;
    return output;
  }
  formatStringToMD(str) {
    return str.split('\n').join('  \n');
  }
  formatDescription(command) {
    const extendedDescription = command.extendedDescription ? `  \n${this.formatStringToMD(command.extendedDescription)}` : '';
    const description = this.formatStringToMD(command.description);
    return `${description}${extendedDescription}  \n\n`;
  }
}
exports.GenerateCommandsDoc = GenerateCommandsDoc;
function oneCommandToObject(command) {
  return (0, _lodash().pick)(command, ['name', 'alias', 'options', 'description', 'extendedDescription', 'group', 'private', 'internal', 'remoteOp', 'skipWorkspace', 'arguments', 'examples']);
}

//# sourceMappingURL=generate-doc-md.js.map