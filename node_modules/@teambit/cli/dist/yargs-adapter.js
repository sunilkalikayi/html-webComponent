"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.trim.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.YargsAdapter = exports.STANDARD_GROUP = exports.GLOBAL_GROUP = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _commandRunner() {
  const data = require("./command-runner");
  _commandRunner = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const GLOBAL_GROUP = 'Global';
exports.GLOBAL_GROUP = GLOBAL_GROUP;
const STANDARD_GROUP = 'Options';
exports.STANDARD_GROUP = STANDARD_GROUP;
class YargsAdapter {
  constructor(commanderCommand) {
    this.commanderCommand = commanderCommand;
    (0, _defineProperty2().default)(this, "command", void 0);
    (0, _defineProperty2().default)(this, "describe", void 0);
    (0, _defineProperty2().default)(this, "aliases", void 0);
    this.command = commanderCommand.name;
    this.describe = commanderCommand.description;
    this.aliases = commanderCommand.alias;
  }
  builder(yargs) {
    var _this$commanderComman, _this$commanderComman2;
    const options = YargsAdapter.optionsToBuilder(this.commanderCommand);
    yargs.option(options);
    (_this$commanderComman = this.commanderCommand.arguments) === null || _this$commanderComman === void 0 ? void 0 : _this$commanderComman.forEach(arg => {
      yargs.positional(arg.name, {
        description: arg.description
      });
    });
    (_this$commanderComman2 = this.commanderCommand.examples) === null || _this$commanderComman2 === void 0 ? void 0 : _this$commanderComman2.forEach(example => {
      yargs.example(example.cmd, example.description);
    });
    return yargs;
  }
  handler(argv) {
    const enteredArgs = getArgsFromCommandName(this.commanderCommand.name);
    const argsValues = enteredArgs.map(a => argv[a]);
    // a workaround to get a flag syntax such as "--all [version]" work with yargs.
    const flags = Object.keys(argv).reduce((acc, current) => {
      if (current === '_' || current === '$0' || current === '--') return acc;
      // const flagName = current.split(' ')[0];
      const val = typeof argv[current] === 'string' && !argv[current] ? true : argv[current];
      acc[current] = val;
      return acc;
    }, {});
    this.commanderCommand._packageManagerArgs = argv['--'] || [];
    const commandRunner = new (_commandRunner().CommandRunner)(this.commanderCommand, argsValues, flags);
    return commandRunner.runCommand();
  }
  get positional() {
    return this.commanderCommand.arguments;
  }
  static optionsToBuilder(command) {
    const option = command.options.reduce((acc, [alias, opt, desc]) => {
      const optName = opt.split(' ')[0];
      acc[optName] = {
        alias,
        describe: desc,
        group: STANDARD_GROUP,
        type: opt.includes(' ') ? 'string' : 'boolean',
        requiresArg: opt.includes('<')
      };
      return acc;
    }, {});
    const globalOptions = YargsAdapter.getGlobalOptions(command);
    return _objectSpread(_objectSpread({}, option), globalOptions);
  }
  static getGlobalOptions(command) {
    const globalOptions = {};
    if (command.remoteOp) {
      globalOptions[_constants().TOKEN_FLAG] = {
        describe: 'authentication token',
        group: GLOBAL_GROUP
      };
    }
    if (!command.internal) {
      globalOptions.log = {
        describe: 'print log messages to the screen, options are: [trace, debug, info, warn, error, fatal], the default is info',
        group: GLOBAL_GROUP
      };
      globalOptions['safe-mode'] = {
        describe: 'bootstrap the bare-minimum with only the CLI aspect. useful mainly for low-level commands when bit refuses to load',
        group: GLOBAL_GROUP
      };
    }
    return globalOptions;
  }
}
exports.YargsAdapter = YargsAdapter;
function getArgsFromCommandName(commandName) {
  const commandSplit = commandName.split(' ');
  commandSplit.shift(); // remove the first element, it's the command-name

  return commandSplit.map(existArg => {
    const trimmed = existArg.trim();
    if (!trimmed.startsWith('<') && !trimmed.startsWith('[') || !trimmed.endsWith('>') && !trimmed.endsWith(']')) {
      throw new Error(`expect arg "${trimmed}" of "${commandName}" to be wrapped with "[]" or "<>"`);
    }
    // remove the opening and closing brackets
    const withoutBrackets = trimmed.slice(1, -1);
    return (0, _lodash().camelCase)(withoutBrackets);
  });
}

//# sourceMappingURL=yargs-adapter.js.map