"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CLIParser = void 0;
function _didyoumean() {
  const data = _interopRequireDefault(require("didyoumean"));
  _didyoumean = function () {
    return data;
  };
  return data;
}
function _yargs() {
  const data = _interopRequireDefault(require("yargs"));
  _yargs = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _consumer() {
  const data = require("@teambit/legacy/dist/consumer");
  _consumer = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _getCommandId() {
  const data = require("./get-command-id");
  _getCommandId = function () {
    return data;
  };
  return data;
}
function _help() {
  const data = require("./help");
  _help = function () {
    return data;
  };
  return data;
}
function _yargsAdapter() {
  const data = require("./yargs-adapter");
  _yargsAdapter = function () {
    return data;
  };
  return data;
}
function _commandNotFound() {
  const data = require("./exceptions/command-not-found");
  _commandNotFound = function () {
    return data;
  };
  return data;
}
class CLIParser {
  constructor(commands, groups, parser = _yargs().default, docsDomain) {
    this.commands = commands;
    this.groups = groups;
    this.parser = parser;
    this.docsDomain = docsDomain;
  }
  async parse(args = process.argv.slice(2)) {
    this.throwForNonExistsCommand(args[0]);
    _logger().default.debug(`[+] CLI-INPUT: ${args.join(' ')}`);
    (0, _yargs().default)(args);
    _yargs().default.help(false);
    this.configureParser();
    this.commands.forEach(command => {
      if (command.commands && command.commands.length) {
        this.parseCommandWithSubCommands(command);
      } else {
        const yargsCommand = this.getYargsCommand(command);
        _yargs().default.command(yargsCommand);
      }
    });
    this.configureGlobalFlags();
    this.setHelpMiddleware();
    this.handleCommandFailure();
    this.configureCompletion();
    _yargs().default.strict(); // don't allow non-exist flags and non-exist commands

    _yargs().default
    // .recommendCommands() // don't use it, it brings the global help of yargs, we have a custom one
    .wrap(null);
    await _yargs().default.parse();
  }
  setHelpMiddleware() {
    _yargs().default.middleware(argv => {
      if (argv._.length === 0 && argv.help) {
        // this is the main help page
        this.printHelp();
        process.exit(0);
      }
      if (argv.help) {
        _loader().default.off(); // stop the "loading bit..." before showing help if needed
        // this is a command help page
        _yargs().default.showHelp(this.logCommandHelp.bind(this));
        if (!_logger().default.isDaemon) process.exit(0);
      }
    }, true);
  }
  handleCommandFailure() {
    _yargs().default.fail((msg, err) => {
      _loader().default.stop();
      if (err) {
        throw err;
      }
      _yargs().default.showHelp(this.logCommandHelp.bind(this));
      const args = process.argv.slice(2);
      const isHelpFlagEntered = args.includes('--help') || args.includes('-h');
      const isMsgAboutMissingArgs = msg.startsWith('Not enough non-option arguments');
      // avoid showing the "Not enough non-option arguments" message when the user is trying to get the command help
      if (!isMsgAboutMissingArgs || !isHelpFlagEntered) {
        // eslint-disable-next-line no-console
        console.log(`\n${_chalk().default.yellow(msg)}`);
      }
      if (!_logger().default.isDaemon) process.exit(1);
    });
  }
  configureCompletion() {
    const commandsToShowComponentIdsForCompletion = ['show', 'diff', 'tag', 'export', 'env', 'envs', 'compile', 'build', 'test', 'lint', 'log', 'dependents', 'dependencies'];
    // @ts-ignore
    _yargs().default.completion('completion', async function (current, argv, completionFilter, done) {
      if (!current.startsWith('-') && commandsToShowComponentIdsForCompletion.includes(argv._[1])) {
        const consumer = await (0, _consumer().loadConsumerIfExist)();
        done(consumer === null || consumer === void 0 ? void 0 : consumer.bitmapIdsFromCurrentLane.map(id => id.toStringWithoutVersion()));
      } else {
        completionFilter();
      }
    });
  }
  printHelp() {
    const help = (0, _help().formatHelp)(this.commands, this.groups, this.docsDomain);
    // eslint-disable-next-line no-console
    console.log(help);
  }
  configureParser() {
    _yargs().default.parserConfiguration({
      // 'strip-dashed': true, // we can't enable it, otherwise, the completion doesn't work
      'strip-aliased': true,
      'boolean-negation': false,
      'populate--': true
    });
  }
  parseCommandWithSubCommands(command) {
    const yarnCommand = this.getYargsCommand(command);
    const builderFunc = () => {
      var _command$commands;
      (_command$commands = command.commands) === null || _command$commands === void 0 ? void 0 : _command$commands.forEach(cmd => {
        const subCommand = this.getYargsCommand(cmd);
        _yargs().default.command(subCommand);
      });
      // since the "builder" method is overridden, the global flags of the main command are gone, this fixes it.
      _yargs().default.options(_yargsAdapter().YargsAdapter.getGlobalOptions(command));
      return _yargs().default;
    };
    yarnCommand.builder = builderFunc;
    _yargs().default.command(yarnCommand);
  }
  getYargsCommand(command) {
    const yarnCommand = new (_yargsAdapter().YargsAdapter)(command);
    yarnCommand.builder = yarnCommand.builder.bind(yarnCommand);
    yarnCommand.handler = yarnCommand.handler.bind(yarnCommand);
    return yarnCommand;
  }
  configureGlobalFlags() {
    _yargs().default.option('help', {
      alias: 'h',
      describe: 'show help',
      group: _yargsAdapter().GLOBAL_GROUP
    }).option('version', {
      global: false,
      alias: 'v',
      describe: 'show version',
      group: _yargsAdapter().GLOBAL_GROUP
    });
  }
  throwForNonExistsCommand(commandName) {
    if (!commandName || commandName.startsWith('-')) {
      return;
    }
    const commandsNames = this.commands.map(c => (0, _getCommandId().getCommandId)(c.name));
    const aliases = this.commands.map(c => c.alias).filter(a => a);
    const existingGlobalFlags = ['-V', '--version'];
    const validCommands = [...commandsNames, ...aliases, ...existingGlobalFlags];
    const commandExist = validCommands.includes(commandName);
    if (!commandExist) {
      _didyoumean().default.returnFirstMatch = true;
      const suggestions = (0, _didyoumean().default)(commandName, this.commands.filter(c => !c.private).map(c => (0, _getCommandId().getCommandId)(c.name)));
      const suggestion = suggestions && Array.isArray(suggestions) ? suggestions[0] : suggestions;
      throw new (_commandNotFound().CommandNotFound)(commandName, suggestion);
    }
  }

  /**
   * manipulate the command help output. there is no API from Yarn to do any of this, so it needs to be done manually.
   * see https://github.com/yargs/yargs/issues/1956
   *
   * the original order of the output:
   * description
   * Options
   * Commands
   * Global
   * Positionals
   * Examples
   */
  logCommandHelp(help) {
    const command = this.findCommandByArgv();
    const replacer = (_, p1, p2) => `${p1}${_chalk().default.green(p2)}`;
    const lines = help.split('\n');
    const linesWithoutEmpty = (0, _lodash().compact)(lines);
    const cmdLine = linesWithoutEmpty[0];
    const description = [];
    const options = [];
    const globalOptions = [];
    const subCommands = [];
    const args = [];
    const examples = [];
    let optionsStarted = false;
    let globalStarted = false;
    let subCommandsStarted = false;
    let positionalsStarted = false;
    let examplesStarted = false;
    for (let i = 1; i < linesWithoutEmpty.length; i += 1) {
      const currentLine = linesWithoutEmpty[i];
      if (currentLine === _yargsAdapter().STANDARD_GROUP) {
        optionsStarted = true;
      } else if (currentLine === _yargsAdapter().GLOBAL_GROUP) {
        globalStarted = true;
      } else if (currentLine === 'Commands:') {
        subCommandsStarted = true;
      } else if (currentLine === 'Positionals:') {
        positionalsStarted = true;
      } else if (currentLine === 'Examples:') {
        examplesStarted = true;
      } else if (examplesStarted) {
        examples.push(currentLine);
      } else if (positionalsStarted) {
        args.push(currentLine);
      } else if (globalStarted) {
        globalOptions.push(currentLine);
      } else if (optionsStarted) {
        options.push(currentLine);
      } else if (subCommandsStarted) {
        subCommands.push(currentLine);
      } else {
        description.push(currentLine);
      }
    }

    // show the flags in green
    const optionsColored = options.map(opt => opt.replace(/(--)([\w-]+)/, replacer).replace(/(-)([\w-]+)/, replacer));
    const argsColored = args.map(arg => arg.replace(/^ {2}\S+/, argName => _chalk().default.green(argName))); // regex: two spaces then the first word until a white space
    const optionsStr = options.length ? `\n${_yargsAdapter().STANDARD_GROUP}\n${optionsColored.join('\n')}\n` : '';
    const argumentsStr = args.length ? `\nArguments:\n${argsColored.join('\n')}\n` : '';
    const examplesStr = examples.length ? `\nExamples:\n${examples.join('\n')}\n` : '';
    const subCommandsStr = subCommands.length ? `\n${'Commands:'}\n${subCommands.join('\n')}\n` : '';
    // show the description in bold
    const descriptionColored = description.map(desc => _chalk().default.bold(desc));
    if (command !== null && command !== void 0 && command.extendedDescription) {
      descriptionColored.push(command === null || command === void 0 ? void 0 : command.extendedDescription);
    }
    if (command !== null && command !== void 0 && command.helpUrl) {
      descriptionColored.push(`for more info, visit: ${_chalk().default.underline(command.helpUrl)}`);
    }
    const descriptionStr = descriptionColored.join('\n');
    const globalOptionsStr = globalOptions.join('\n');
    const finalOutput = `${cmdLine}

${descriptionStr}
${argumentsStr}${subCommandsStr}${optionsStr}${examplesStr}
${_yargsAdapter().GLOBAL_GROUP}
${globalOptionsStr}`;

    // eslint-disable-next-line no-console
    console.log(finalOutput);
  }
  findCommandByArgv() {
    const args = process.argv.slice(2);
    const enteredCommand = args[0];
    const enteredSubCommand = args[1];
    if (!enteredCommand) {
      return undefined;
    }
    const isCommandMatch = (cmd, str) => {
      return cmd.name.startsWith(`${str} `) ||
      // e.g. "tag <id>".startsWith("tag ")
      cmd.name === str ||
      // e.g. "globals" === "globals"
      cmd.alias === str; // e.g. "t" === "t"
    };

    const command = this.commands.find(cmd => isCommandMatch(cmd, enteredCommand));
    if (!command) {
      return undefined;
    }
    if (!command.commands || !enteredSubCommand) {
      return command; // no sub-commands.
    }

    const subCommand = command.commands.find(cmd => isCommandMatch(cmd, enteredSubCommand));
    return subCommand || command;
  }
}
exports.CLIParser = CLIParser;

//# sourceMappingURL=cli-parser.js.map