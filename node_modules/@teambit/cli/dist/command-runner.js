"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.flags.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CommandRunner = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _ink() {
  const data = require("ink");
  _ink = function () {
    return data;
  };
  return data;
}
function _consumer() {
  const data = require("@teambit/legacy/dist/api/consumer");
  _consumer = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _commandRegistry() {
  const data = require("@teambit/legacy/dist/cli/command-registry");
  _commandRegistry = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
function _handleErrors() {
  const data = require("@teambit/legacy/dist/cli/handle-errors");
  _handleErrors = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _globalFlags() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/global-flags"));
  _globalFlags = function () {
    return data;
  };
  return data;
}
function _analytics() {
  const data = require("@teambit/legacy/dist/analytics/analytics");
  _analytics = function () {
    return data;
  };
  return data;
}
class CommandRunner {
  constructor(command, args, flags) {
    this.command = command;
    this.args = args;
    this.flags = flags;
    (0, _defineProperty2().default)(this, "commandName", void 0);
    this.commandName = (0, _commandRegistry().parseCommandName)(this.command.name);
  }

  /**
   * run command using one of the handler, "json"/"report"/"render". once done, exit the process.
   */
  async runCommand() {
    try {
      this.bootstrapCommand();
      await this.runMigrateIfNeeded();
      this.determineConsoleWritingDuringCommand();
      if (this.flags.json) {
        return await this.runJsonHandler();
      }
      if (this.shouldRunRender()) {
        return await this.runRenderHandler();
      }
      if (this.command.report) {
        return await this.runReportHandler();
      }
    } catch (err) {
      return (0, _handleErrors().handleErrorAndExit)(err, this.commandName, this.command.internal);
    }
    throw new Error(`command "${this.commandName}" doesn't implement "render" nor "report" methods`);
  }
  bootstrapCommand() {
    _analytics().Analytics.init(this.commandName, this.flags, this.args);
    _logger().default.info(`[*] started a new command: "${this.commandName}" with the following data:`, {
      args: this.args,
      flags: this.flags
    });
    const token = this.flags[_constants().TOKEN_FLAG_NAME];
    if (token) {
      _globalFlags().default.token = token.toString();
    }
  }

  /**
   * when both "render" and "report" were implemented, check whether it's a terminal.
   * if it's a terminal, use "render", if not, use "report" because "report" is just a string
   */
  shouldRunRender() {
    const isTerminal = process.stdout.isTTY;
    if (this.command.report && !isTerminal) {
      return false;
    }
    return Boolean(this.command.render);
  }

  /**
   * this works for both, Harmony commands and Legacy commands (the legacy-command-adapter
   * implements json() method)
   */
  async runJsonHandler() {
    if (!this.flags.json) return null;
    if (!this.command.json) throw new Error(`command "${this.commandName}" doesn't implement "json" method`);
    const result = await this.command.json(this.args, this.flags);
    const code = result.code || 0;
    const data = result.data || result;
    return this.writeAndExit(JSON.stringify(data, null, 2), code);
  }
  async runRenderHandler() {
    if (!this.command.render) throw new Error('runRenderHandler expects command.render to be implemented');
    const result = await this.command.render(this.args, this.flags);
    _loader().default.off();
    const {
      data,
      code
    } = toRenderResult(result);
    const {
      waitUntilExit
    } = (0, _ink().render)(data);
    await waitUntilExit();
    return _logger().default.exitAfterFlush(code, this.commandName);
  }
  async runReportHandler() {
    if (!this.command.report) throw new Error('runReportHandler expects command.report to be implemented');
    const result = await this.command.report(this.args, this.flags);
    _loader().default.off();
    const data = typeof result === 'string' ? result : result.data;
    const exitCode = typeof result === 'string' ? 0 : result.code;
    return this.writeAndExit(`${data}\n`, exitCode);
  }

  /**
   * the loader and logger.console write output to the console during the command execution.
   * for internals commands, such as, _put, _fetch, the command.loader = false.
   */
  determineConsoleWritingDuringCommand() {
    if (this.command.loader && !this.flags.json && !this.flags['get-yargs-completions']) {
      _loader().default.on();
      _loader().default.start(`running command "${this.commandName}"...`);
      _logger().default.shouldWriteToConsole = true;
    } else {
      _loader().default.off();
      _logger().default.shouldWriteToConsole = false;
    }
    if (this.flags.log) {
      // probably not necessary anymore. it is handled in src/logger - determineWritingLogToScreen()
      const logValue = typeof this.flags.log === 'string' ? this.flags.log : undefined;
      _logger().default.switchToConsoleLogger(logValue);
    }
  }
  async writeAndExit(data, exitCode) {
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    return process.stdout.write(data, async () => _logger().default.exitAfterFlush(exitCode, this.commandName, data));
  }
  async runMigrateIfNeeded() {
    // @ts-ignore LegacyCommandAdapter has .migration
    if (this.command.migration) {
      _logger().default.debug('Checking if a migration is needed');
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return (0, _consumer().migrate)(null, false);
    }
    return null;
  }
}
exports.CommandRunner = CommandRunner;
function toRenderResult(obj) {
  return isRenderResult(obj) ? obj : {
    data: obj,
    code: 0
  };
}
function isRenderResult(obj) {
  // eslint-disable-next-line no-prototype-builtins
  return typeof obj === 'object' && typeof obj.code === 'number' && obj.hasOwnProperty('data');
}

//# sourceMappingURL=command-runner.js.map