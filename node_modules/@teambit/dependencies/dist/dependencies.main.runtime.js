"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DependenciesMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _dependenciesCmd() {
  const data = require("./dependencies-cmd");
  _dependenciesCmd = function () {
    return data;
  };
  return data;
}
function _dependencies() {
  const data = require("./dependencies.aspect");
  _dependencies = function () {
    return data;
  };
  return data;
}
class DependenciesMain {
  constructor(workspace, dependencyResolver) {
    this.workspace = workspace;
    this.dependencyResolver = dependencyResolver;
  }
  async setDependency(componentPattern, packages, options) {
    const compIds = await this.workspace.idsByPattern(componentPattern);
    const getDepField = () => {
      if (options.dev) return 'devDependencies';
      if (options.peer) return 'peerDependencies';
      return 'dependencies';
    };
    const packagesObj = {};
    await Promise.all(packages.map(async pkg => {
      const [name, version] = await this.getPackageNameAndVerResolved(pkg);
      packagesObj[name] = version;
    }));
    const config = {
      policy: {
        [getDepField()]: packagesObj
      }
    };
    await Promise.all(compIds.map(async compId => {
      await this.workspace.addSpecificComponentConfig(compId, _dependencyResolver().DependencyResolverAspect.id, config, true);
    }));
    await this.workspace.bitMap.write();
    return {
      changedComps: compIds.map(compId => compId.toStringWithoutVersion()),
      addedPackages: packagesObj
    };
  }
  async removeDependency(componentPattern, packages) {
    const compIds = await this.workspace.idsByPattern(componentPattern);
    const results = await Promise.all(compIds.map(async compId => {
      const component = await this.workspace.get(compId);
      const depList = await this.dependencyResolver.getDependencies(component);
      const currentDepResolverConfig = await this.workspace.getSpecificComponentConfig(compId, _dependencyResolver().DependencyResolverAspect.id);
      const newDepResolverConfig = (0, _lodash().cloneDeep)(currentDepResolverConfig || {});
      const removedPackagesWithNulls = await (0, _pMapSeries().default)(packages, async pkg => {
        var _dependency$getPackag, _newDepResolverConfig, _newDepResolverConfig2;
        const [name, version] = this.splitPkgToNameAndVer(pkg);
        const dependency = depList.findByPkgNameOrCompId(name, version);
        if (!dependency) return null;
        const depField = _dependencyResolver().KEY_NAME_BY_LIFECYCLE_TYPE[dependency.lifecycle];
        const depName = ((_dependency$getPackag = dependency.getPackageName) === null || _dependency$getPackag === void 0 ? void 0 : _dependency$getPackag.call(dependency)) || dependency.id;
        const existsInSpecificConfig = (_newDepResolverConfig = newDepResolverConfig.policy) === null || _newDepResolverConfig === void 0 ? void 0 : (_newDepResolverConfig2 = _newDepResolverConfig[depField]) === null || _newDepResolverConfig2 === void 0 ? void 0 : _newDepResolverConfig2[depName];
        if (existsInSpecificConfig) {
          if (existsInSpecificConfig === '-') return null;
          delete newDepResolverConfig.policy[depField][depName];
        } else {
          (0, _lodash().set)(newDepResolverConfig, ['policy', depField, depName], '-');
        }
        return `${depName}@${dependency.version}`;
      });
      const removedPackages = (0, _lodash().compact)(removedPackagesWithNulls);
      if (!removedPackages.length) return null;
      await this.workspace.addSpecificComponentConfig(compId, _dependencyResolver().DependencyResolverAspect.id, newDepResolverConfig);
      return {
        id: compId,
        removedPackages
      };
    }));
    await this.workspace.bitMap.write();
    return (0, _lodash().compact)(results);
  }
  async getPackageNameAndVerResolved(pkg) {
    const resolveLatest = async pkgName => {
      const versionResolver = await this.dependencyResolver.getVersionResolver({});
      const resolved = await versionResolver.resolveRemoteVersion(pkgName, {
        rootDir: ''
      });
      if (!resolved.version) throw new Error(`unable to resolve version for ${pkgName}`);
      return resolved.version;
    };
    const [name, version] = this.splitPkgToNameAndVer(pkg);
    const versionResolved = !version || version === 'latest' ? await resolveLatest(name) : version;
    return [name, versionResolved];
  }
  splitPkgToNameAndVer(pkg) {
    const packageSplit = pkg.split('@');
    if (pkg.startsWith('@')) {
      // scoped package
      if (packageSplit.length > 3) throw new Error(`invalid package "${pkg}" syntax, expected "package[@version]"`);
      return [`@${packageSplit[1]}`, packageSplit[2]];
    }
    if (packageSplit.length > 2) throw new Error(`invalid package "${pkg}" syntax, expected "package[@version]"`);
    return [packageSplit[0], packageSplit[1]];
  }
  static async provider([cli, workspace, depsResolver]) {
    const depsMain = new DependenciesMain(workspace, depsResolver);
    const depsCmd = new (_dependenciesCmd().DependenciesCmd)();
    depsCmd.commands = [new (_dependenciesCmd().DependenciesGetCmd)(), new (_dependenciesCmd().DependenciesRemoveCmd)(depsMain), new (_dependenciesCmd().DependenciesDebugCmd)(), new (_dependenciesCmd().DependenciesSetCmd)(depsMain)];
    cli.register(depsCmd);
    return depsMain;
  }
}
exports.DependenciesMain = DependenciesMain;
(0, _defineProperty2().default)(DependenciesMain, "slots", []);
(0, _defineProperty2().default)(DependenciesMain, "dependencies", [_cli().CLIAspect, _workspace().default, _dependencyResolver().DependencyResolverAspect]);
(0, _defineProperty2().default)(DependenciesMain, "runtime", _cli().MainRuntime);
_dependencies().DependenciesAspect.addRuntime(DependenciesMain);
var _default = DependenciesMain;
exports.default = _default;

//# sourceMappingURL=dependencies.main.runtime.js.map