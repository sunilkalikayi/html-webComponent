"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PreviewMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("@teambit/builder");
  _builder = function () {
    return data;
  };
  return data;
}
function _bundler() {
  const data = require("@teambit/bundler");
  _bundler = function () {
    return data;
  };
  return data;
}
function _pubsub() {
  const data = require("@teambit/pubsub");
  _pubsub = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = require("@teambit/envs");
  _envs = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _ui() {
  const data = require("@teambit/ui");
  _ui = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _objectHash() {
  const data = _interopRequireDefault(require("object-hash"));
  _objectHash = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = require("fs-extra");
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _pkg() {
  const data = require("@teambit/pkg");
  _pkg = function () {
    return data;
  };
  return data;
}
function _aspectLoader() {
  const data = require("@teambit/aspect-loader");
  _aspectLoader = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _artifactFiles() {
  const data = require("@teambit/legacy/dist/consumer/component/sources/artifact-files");
  _artifactFiles = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = _interopRequireDefault(require("@teambit/graphql"));
  _graphql = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _generateLink() {
  const data = require("./generate-link");
  _generateLink = function () {
    return data;
  };
  return data;
}
function _previewArtifact() {
  const data = require("./preview-artifact");
  _previewArtifact = function () {
    return data;
  };
  return data;
}
function _preview() {
  const data = require("./preview.aspect");
  _preview = function () {
    return data;
  };
  return data;
}
function _preview2() {
  const data = require("./preview.route");
  _preview2 = function () {
    return data;
  };
  return data;
}
function _preview3() {
  const data = require("./preview.task");
  _preview3 = function () {
    return data;
  };
  return data;
}
function _strategies() {
  const data = require("./strategies");
  _strategies = function () {
    return data;
  };
  return data;
}
function _executionRef() {
  const data = require("./execution-ref");
  _executionRef = function () {
    return data;
  };
  return data;
}
function _preview4() {
  const data = require("./preview.start-plugin");
  _preview4 = function () {
    return data;
  };
  return data;
}
function _envPreviewTemplate() {
  const data = require("./env-preview-template.task");
  _envPreviewTemplate = function () {
    return data;
  };
  return data;
}
function _envTemplate() {
  const data = require("./env-template.route");
  _envTemplate = function () {
    return data;
  };
  return data;
}
function _componentPreview() {
  const data = require("./component-preview.route");
  _componentPreview = function () {
    return data;
  };
  return data;
}
function _componentStrategy() {
  const data = require("./strategies/component-strategy");
  _componentStrategy = function () {
    return data;
  };
  return data;
}
function _envStrategy() {
  const data = require("./strategies/env-strategy");
  _envStrategy = function () {
    return data;
  };
  return data;
}
function _preview5() {
  const data = require("./preview.graphql");
  _preview5 = function () {
    return data;
  };
  return data;
}
function _previewAssets() {
  const data = require("./preview-assets.route");
  _previewAssets = function () {
    return data;
  };
  return data;
}
const noopResult = {
  results: [],
  toString: () => `updating link file`
};
const DEFAULT_TEMP_DIR = (0, _path().join)(_constants().CACHE_ROOT, _preview().PreviewAspect.id);
class PreviewMain {
  constructor(
  /**
   * harmony context.
   */
  harmony,
  /**
   * slot for preview definitions.
   */
  previewSlot, ui, envs, componentAspect, pkg, aspectLoader, config, bundlingStrategySlot, builder, workspace, logger, dependencyResolver) {
    this.harmony = harmony;
    this.previewSlot = previewSlot;
    this.ui = ui;
    this.envs = envs;
    this.componentAspect = componentAspect;
    this.pkg = pkg;
    this.aspectLoader = aspectLoader;
    this.config = config;
    this.bundlingStrategySlot = bundlingStrategySlot;
    this.builder = builder;
    this.workspace = workspace;
    this.logger = logger;
    this.dependencyResolver = dependencyResolver;
    (0, _defineProperty2().default)(this, "writeHash", new Map());
    (0, _defineProperty2().default)(this, "timestamp", Date.now());
    (0, _defineProperty2().default)(this, "executionRefs", new Map());
    (0, _defineProperty2().default)(this, "handleComponentChange", async (c, updater) => {
      const env = this.envs.getEnv(c);
      const envId = env.id.toString();
      const executionRef = this.executionRefs.get(envId);
      if (!executionRef) {
        this.logger.warn(`failed to update link file for component "${c.id.toString()}" - could not find execution context for ${envId}`);
        return noopResult;
      }

      // add / remove / etc
      updater(executionRef);
      await this.updateLinkFiles(executionRef.currentComponents, executionRef.executionCtx);
      return noopResult;
    });
    (0, _defineProperty2().default)(this, "handleComponentRemoval", cId => {
      let component;
      this.executionRefs.forEach(components => {
        const found = components.get(cId);
        if (found) component = found;
      });
      if (!component) return Promise.resolve(noopResult);
      return this.handleComponentChange(component, currentComponents => currentComponents.remove(cId));
    });
  }
  get tempFolder() {
    var _this$workspace;
    return ((_this$workspace = this.workspace) === null || _this$workspace === void 0 ? void 0 : _this$workspace.getTempDir(_preview().PreviewAspect.id)) || DEFAULT_TEMP_DIR;
  }
  getComponentBundleSize(component) {
    const data = this.builder.getDataByAspect(component, _preview().PreviewAspect.id);
    if (!data) return undefined;
    return data[_componentStrategy().COMPONENT_STRATEGY_SIZE_KEY_NAME];
  }
  async getPreview(component) {
    const artifacts = await this.builder.getArtifactsVinylByAspectAndTaskName(component, _preview().PreviewAspect.id, _preview3().PREVIEW_TASK_NAME);
    if (!artifacts) return undefined;
    return new (_previewArtifact().PreviewArtifact)(artifacts);
  }

  /**
   * Get a list of all the artifact files generated during the GeneratePreview task
   * @param component
   * @returns
   */
  async getPreviewFiles(component) {
    const artifacts = await this.getPreview(component);
    const isBundledWithEnv = await this.isBundledWithEnv(component);
    if (!artifacts) return undefined;
    return {
      files: artifacts.getPaths(),
      isBundledWithEnv
    };
  }

  /**
   * Check if the component preview bundle contain the env as part of the bundle or only the component code
   * (we used in the past to bundle them together, there might also be specific envs which still uses the env strategy)
   * @param component
   * @returns
   */
  async isBundledWithEnv(component) {
    const artifacts = await this.builder.getArtifactsVinylByAspectAndName(component, _preview().PreviewAspect.id, _componentStrategy().COMPONENT_STRATEGY_ARTIFACT_NAME);
    if (!artifacts || !artifacts.length) return true;
    return false;
  }

  // This used on component load to calc the final result of support is scaling for a given component
  // This calc based on the env, env data, env preview config and more
  // if you want to get the final result use the `doesScaling` method below
  // This should be used only for component load
  async calcDoesScalingForComponent(component) {
    const isBundledWithEnv = await this.isBundledWithEnv(component);
    // if it's a core env and the env template is apart from the component it means the template bundle already contain the scaling functionality
    if (this.envs.isUsingCoreEnv(component)) {
      // If the component is new, no point to check the is bundle with env (there is no artifacts so it will for sure return false)
      // If it's new, and we are here, it means that we already use a version of the env that support scaling
      const isNew = await component.isNew();
      if (isNew) {
        return true;
      }
      return isBundledWithEnv === false;
    }
    // For envs that bundled with the env return true always
    if (isBundledWithEnv) {
      return true;
    }
    const envComponent = await this.envs.getEnvComponent(component);
    return this.isEnvSupportScaling(envComponent);
  }

  /**
   * can the current component preview scale in size for different preview sizes.
   * this calculation is based on the env of the component and if the env of the component support it.
   */
  async doesScaling(component) {
    var _this$workspace2, _component$state$aspe;
    const inWorkspace = await ((_this$workspace2 = this.workspace) === null || _this$workspace2 === void 0 ? void 0 : _this$workspace2.hasId(component.id));
    // Support case when we have the dev server for the env, in that case we calc the data of the env as we can't rely on the env data from the scope
    // since we bundle it for the dev server again
    if (inWorkspace) {
      const envComponent = await this.envs.getEnvComponent(component);
      const envSupportScaling = await this.calculateIsEnvSupportScaling(envComponent);
      return envSupportScaling !== null && envSupportScaling !== void 0 ? envSupportScaling : true;
    }
    const previewData = (_component$state$aspe = component.state.aspects.get(_preview().PreviewAspect.id)) === null || _component$state$aspe === void 0 ? void 0 : _component$state$aspe.data;
    if (!previewData) return false;
    // Get the does scaling (the new calculation) or the old calc used in isScaling (between versions (about) 848 and 860)
    if (previewData.doesScaling !== undefined) return previewData.doesScaling;
    // in case this component were tagged with versions between 848 and 860 we need to use the old calculation
    // together with the env calculation
    // In that case it means the component already tagged, so we take the env calc from the env data and not re-calc it
    if (previewData.isScaling) {
      const envComponent = await this.envs.getEnvComponent(component);
      const envSupportScaling = this.isEnvSupportScaling(envComponent);
      return !!envSupportScaling;
    }
    return false;
  }

  /**
   * Check if the current version of the env support scaling
   * @param envComponent
   * @returns
   */
  isEnvSupportScaling(envComponent) {
    var _envComponent$state$a;
    const previewData = (_envComponent$state$a = envComponent.state.aspects.get(_preview().PreviewAspect.id)) === null || _envComponent$state$a === void 0 ? void 0 : _envComponent$state$a.data;
    return !!(previewData !== null && previewData !== void 0 && previewData.isScaling);
  }

  /**
   * This function is calculate the isScaling support flag for the component preview.
   * This is calculated only for the env component and not for the component itself.
   * It should be only used during the (env) component on load.
   * Once the component load, you should only use the `isEnvSupportScaling` to fetch it from the calculated data.
   * If you want to check if an env for a given component support scaling, use the `isScaling` function.
   * @param component
   * @returns
   */
  async calculateIsEnvSupportScaling(envComponent) {
    var _previewAspectConfig$;
    const isEnv = this.envs.isEnv(envComponent);
    // If the component is not an env, we don't want to store anything in the data
    if (!isEnv) return undefined;
    const previewAspectConfig = this.getPreviewConfig(envComponent);
    // default to true if the env doesn't have a preview config
    return (_previewAspectConfig$ = previewAspectConfig === null || previewAspectConfig === void 0 ? void 0 : previewAspectConfig.isScaling) !== null && _previewAspectConfig$ !== void 0 ? _previewAspectConfig$ : true;
  }

  /**
   * Get the preview config of the component.
   * (config that was set by variants or on bitmap)
   * @param component
   * @returns
   */
  getPreviewConfig(component) {
    var _component$state$aspe2;
    return (_component$state$aspe2 = component.state.aspects.get(_preview().PreviewAspect.id)) === null || _component$state$aspe2 === void 0 ? void 0 : _component$state$aspe2.config;
  }

  /**
   * Check if the component preview bundle contain the header inside of it (legacy)
   * today we are not including the header inside anymore
   * @param component
   * @returns
   */
  async isLegacyHeader(component) {
    // these envs had header in their docs
    const ENV_WITH_LEGACY_DOCS = ['react', 'env', 'aspect', 'lit', 'html', 'node', 'mdx', 'react-native', 'readme'];
    const artifacts = await this.builder.getArtifactsVinylByAspectAndName(component, _preview().PreviewAspect.id, _envStrategy().ENV_STRATEGY_ARTIFACT_NAME);
    const envType = this.envs.getEnvData(component).type;
    return !!artifacts && !!artifacts.length && ENV_WITH_LEGACY_DOCS.includes(envType);
  }

  /**
   * Getting the env template artifact
   * This should be called with the env itself or it will return undefined
   * If you want to get the env template from the env of the component,
   * use: getEnvTemplateFromComponentEnv below
   *
   * @param component
   * @returns
   */
  async getEnvTemplate(component) {
    const artifacts = await this.builder.getArtifactsVinylByAspectAndTaskName(component, _preview().PreviewAspect.id, _envPreviewTemplate().GENERATE_ENV_TEMPLATE_TASK_NAME);
    if (!artifacts || !artifacts.length) return undefined;
    return new (_previewArtifact().PreviewArtifact)(artifacts);
  }

  /**
   * This is a special method to get a core env template
   * As the core envs doesn't exist in the scope we need to bring it from other place
   * We will bring it from the core env package files
   */
  async getCoreEnvTemplate(envId) {
    const coreEnvDir = (0, _aspectLoader().getAspectDir)(envId);
    // const finalDir = join(coreEnvDir, getEnvTemplateArtifactDirectory());
    const artifactDef = (0, _envPreviewTemplate().getArtifactDef)()[0];
    const artifactFactory = new (_builder().ArtifactFactory)();
    let rootDir = artifactFactory.getRootDir(coreEnvDir, artifactDef);
    if (!(0, _fsExtra().existsSync)(rootDir)) {
      // fallback to the bvm folder
      const coreEnvDirFromBvm = (0, _aspectLoader().getAspectDirFromBvm)(envId);
      rootDir = artifactFactory.getRootDir(coreEnvDirFromBvm, artifactDef);
    }
    if (!(0, _fsExtra().existsSync)(rootDir)) {
      return undefined;
    }
    const paths = artifactFactory.resolvePaths(rootDir, artifactDef);
    if (!paths || !paths.length) {
      return undefined;
    }
    const artifactFiles = new (_artifactFiles().ArtifactFiles)(paths);
    artifactFiles.populateVinylsFromPaths(rootDir);
    return new (_previewArtifact().PreviewArtifact)(artifactFiles.vinyls);
  }

  /**
   * This will fetch the component env, then will take the env template from the component env
   * @param component
   */
  async getEnvTemplateFromComponentEnv(component) {
    const envId = this.envs.getEnvId(component);
    return this.getEnvTemplateByEnvId(envId);
  }

  /**
   * This will fetch the component env, then will take the env template from the component env
   * @param component
   */
  async getEnvTemplateByEnvId(envId) {
    // Special treatment for core envs
    if (this.aspectLoader.isCoreEnv(envId)) {
      return this.getCoreEnvTemplate(envId);
    }
    const host = this.componentAspect.getHost();
    const resolvedEnvId = await host.resolveComponentId(envId);
    const envComponent = await host.get(resolvedEnvId);
    if (!envComponent) {
      throw new (_bitError().BitError)(`can't load env. env id is ${envId}`);
    }
    return this.getEnvTemplate(envComponent);
  }
  getDefs() {
    return this.previewSlot.values();
  }
  /**
   * write a link to load custom modules dynamically.
   * @param prefix write
   * @param moduleMap map of components to module paths to require.
   * @param defaultModule
   * @param dirName
   */
  writeLink(prefix, moduleMap, defaultModule, dirName, isSplitComponentBundle) {
    const contents = (0, _generateLink().generateLink)(prefix, moduleMap, defaultModule, isSplitComponentBundle);
    return this.writeLinkContents(contents, dirName, prefix);
  }
  writeLinkContents(contents, targetDir, prefix) {
    const hash = (0, _objectHash().default)(contents);
    const targetPath = (0, _path().join)(targetDir, `${prefix}-${this.timestamp}.js`);

    // write only if link has changed (prevents triggering fs watches)
    if (this.writeHash.get(targetPath) !== hash) {
      (0, _fsExtra().writeFileSync)(targetPath, contents);
      this.writeHash.set(targetPath, hash);
    }
    return targetPath;
  }
  async getPreviewTarget( /** execution context (of the specific env) */
  context) {
    // store context for later link-file updates
    // also register related envs that this context is acting on their behalf
    [context.id, ...context.relatedContexts].forEach(ctxId => {
      this.executionRefs.set(ctxId, new (_executionRef().ExecutionRef)(context));
    });
    const previewRuntime = await this.writePreviewRuntime(context);
    const linkFiles = await this.updateLinkFiles(context.components, context);
    return [...linkFiles, previewRuntime];
  }
  updateLinkFiles(components = [], context) {
    const previews = this.previewSlot.values();
    const paths = previews.map(async previewDef => {
      var _previewDef$renderTem, _this$getEnvPreviewCo;
      const templatePath = await ((_previewDef$renderTem = previewDef.renderTemplatePath) === null || _previewDef$renderTem === void 0 ? void 0 : _previewDef$renderTem.call(previewDef, context));
      const map = await previewDef.getModuleMap(components);
      const isSplitComponentBundle = (_this$getEnvPreviewCo = this.getEnvPreviewConfig().splitComponentBundle) !== null && _this$getEnvPreviewCo !== void 0 ? _this$getEnvPreviewCo : false;
      const withPaths = map.map((files, component) => {
        var _environment$getCompi, _compilerInstance$get;
        const environment = this.envs.getEnv(component).env;
        const compilerInstance = (_environment$getCompi = environment.getCompiler) === null || _environment$getCompi === void 0 ? void 0 : _environment$getCompi.call(environment);
        const modulePath = (compilerInstance === null || compilerInstance === void 0 ? void 0 : (_compilerInstance$get = compilerInstance.getPreviewComponentRootPath) === null || _compilerInstance$get === void 0 ? void 0 : _compilerInstance$get.call(compilerInstance, component)) || this.pkg.getRuntimeModulePath(component);
        return files.map(file => {
          if (!this.workspace || !compilerInstance) {
            return file.path;
          }
          const distRelativePath = compilerInstance.getDistPathBySrcPath(file.relative);
          return (0, _path().join)(this.workspace.path, modulePath, distRelativePath);
        });
        // return files.map((file) => file.path);
      });

      const dirPath = (0, _path().join)(this.tempFolder, context.id);
      if (!(0, _fsExtra().existsSync)(dirPath)) (0, _fsExtra().mkdirSync)(dirPath, {
        recursive: true
      });
      const link = this.writeLink(previewDef.prefix, withPaths, templatePath, dirPath, isSplitComponentBundle);
      return link;
    });
    return Promise.all(paths);
  }
  async writePreviewRuntime(context, aspectsIdsToNotFilterOut = []) {
    const [name, uiRoot] = this.getUi();
    const resolvedAspects = await this.resolveAspects(_preview().PreviewRuntime.name, undefined, uiRoot);
    const filteredAspects = this.filterAspectsByExecutionContext(resolvedAspects, context, aspectsIdsToNotFilterOut);
    const filePath = await this.ui.generateRoot(filteredAspects, name, 'preview', _preview().PreviewAspect.id);
    return filePath;
  }
  async resolveAspects(runtimeName, componentIds, uiRoot, opts) {
    const root = uiRoot || this.getUi()[1];
    runtimeName = runtimeName || _cli().MainRuntime.name;
    const resolvedAspects = await root.resolveAspects(runtimeName, componentIds, opts);
    return resolvedAspects;
  }
  getUi() {
    const ui = this.ui.getUi();
    if (!ui) throw new Error('ui not found');
    return ui;
  }

  /**
   * Filter the aspects to have only aspects that are:
   * 1. core aspects
   * 2. configured on the host (workspace/scope)
   * 3. used by at least one component from the context
   * @param aspects
   * @param context
   */
  filterAspectsByExecutionContext(aspects, context, aspectsIdsToNotFilterOut = []) {
    let allComponentContextAspects = [];
    allComponentContextAspects = context.components.reduce((acc, curr) => {
      return acc.concat(curr.state.aspects.ids);
    }, allComponentContextAspects);
    const hostAspects = Object.keys(this.harmony.config.toObject());
    const allAspectsToInclude = (0, _lodash().uniq)(hostAspects.concat(allComponentContextAspects));
    const filtered = aspects.filter(aspect => {
      if (!aspect.getId) {
        return false;
      }
      return this.aspectLoader.isCoreAspect(aspect.getId) || allAspectsToInclude.includes(aspect.getId) || aspectsIdsToNotFilterOut.includes(aspect.getId);
    });
    return filtered;
  }
  getDefaultStrategies() {
    return [new (_strategies().EnvBundlingStrategy)(this, this.pkg, this.dependencyResolver), new (_strategies().ComponentBundlingStrategy)(this, this.pkg, this.dependencyResolver)];
  }

  // TODO - executionContext should be responsible for updating components list, and emit 'update' events
  // instead we keep track of changes

  getEnvPreviewConfig(env) {
    const config = env !== null && env !== void 0 && env.getPreviewConfig && typeof (env === null || env === void 0 ? void 0 : env.getPreviewConfig) === 'function' ? env === null || env === void 0 ? void 0 : env.getPreviewConfig() : {};
    return config;
  }

  /**
   * return the configured bundling strategy.
   */
  getBundlingStrategy(env) {
    const defaultStrategies = this.getDefaultStrategies();
    const envPreviewConfig = this.getEnvPreviewConfig(env);
    const strategyFromEnv = envPreviewConfig === null || envPreviewConfig === void 0 ? void 0 : envPreviewConfig.strategyName;
    const strategyName = strategyFromEnv || this.config.bundlingStrategy || 'env';
    const strategies = this.bundlingStrategySlot.values().concat(defaultStrategies);
    const selected = strategies.find(strategy => {
      return strategy.name === strategyName;
    });
    if (!selected) throw new (_exceptions().BundlingStrategyNotFound)(strategyName);
    return selected;
  }

  /**
   * register a new bundling strategy. default available strategies are `env` and ``
   */
  registerBundlingStrategy(bundlingStrategy) {
    this.bundlingStrategySlot.register(bundlingStrategy);
    return this;
  }

  /**
   * register a new preview definition.
   */
  registerDefinition(previewDef) {
    this.previewSlot.register(previewDef);
  }
  static async provider(
  // eslint-disable-next-line max-len
  [bundler, builder, componentExtension, uiMain, envs, workspace, pkg, pubsub, aspectLoader, loggerMain, dependencyResolver, graphql], config, [previewSlot, bundlingStrategySlot], harmony) {
    const logger = loggerMain.createLogger(_preview().PreviewAspect.id);
    // app.registerApp(new PreviewApp());
    const preview = new PreviewMain(harmony, previewSlot, uiMain, envs, componentExtension, pkg, aspectLoader, config, bundlingStrategySlot, builder, workspace, logger, dependencyResolver);
    if (workspace) uiMain.registerStartPlugin(new (_preview4().PreviewStartPlugin)(workspace, bundler, uiMain, pubsub, logger));
    componentExtension.registerRoute([new (_preview2().PreviewRoute)(preview, logger), new (_componentPreview().ComponentPreviewRoute)(preview, logger),
    // @ts-ignore
    new (_envTemplate().EnvTemplateRoute)(preview, logger), new (_previewAssets().PreviewAssetsRoute)(preview, logger)]);
    bundler.registerTarget([{
      entry: preview.getPreviewTarget.bind(preview)
    }]);
    if (!config.disabled) builder.registerBuildTasks([new (_envPreviewTemplate().EnvPreviewTemplateTask)(preview, envs, aspectLoader, dependencyResolver, logger), new (_preview3().PreviewTask)(bundler, preview, dependencyResolver, logger)]);
    if (workspace) {
      workspace.registerOnComponentAdd(c => preview.handleComponentChange(c, currentComponents => currentComponents.add(c)));
      workspace.onComponentLoad(async component => {
        const doesScaling = await preview.calcDoesScalingForComponent(component);
        const isScaling = await preview.calculateIsEnvSupportScaling(component);
        const data = {
          doesScaling
        };
        // If there is no isScaling result at all, it's probably not an env. don't store any data.
        if (isScaling !== undefined) {
          data.isScaling = isScaling;
        }
        return data;
      });
      workspace.registerOnComponentChange(c => preview.handleComponentChange(c, currentComponents => currentComponents.update(c)));
      workspace.registerOnComponentRemove(cId => preview.handleComponentRemoval(cId));
    }
    graphql.register((0, _preview5().previewSchema)(preview));
    return preview;
  }
}
exports.PreviewMain = PreviewMain;
(0, _defineProperty2().default)(PreviewMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(PreviewMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(PreviewMain, "dependencies", [_bundler().BundlerAspect, _builder().BuilderAspect, _component().ComponentAspect, _ui().UIAspect, _envs().EnvsAspect, _workspace().default, _pkg().PkgAspect, _pubsub().PubsubAspect, _aspectLoader().AspectLoaderAspect, _logger().LoggerAspect, _dependencyResolver().DependencyResolverAspect, _graphql().default]);
(0, _defineProperty2().default)(PreviewMain, "defaultConfig", {
  disabled: false
});
_preview().PreviewAspect.addRuntime(PreviewMain);

//# sourceMappingURL=preview.main.runtime.js.map