"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnvBundlingStrategy = exports.ENV_STRATEGY_ARTIFACT_NAME = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = require("fs-extra");
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _htmlTemplate() {
  const data = require("../bundler/html-template");
  _htmlTemplate = function () {
    return data;
  };
  return data;
}
const ENV_STRATEGY_ARTIFACT_NAME = 'preview';

/**
 * bundles all components in a given env into the same bundle.
 */
exports.ENV_STRATEGY_ARTIFACT_NAME = ENV_STRATEGY_ARTIFACT_NAME;
class EnvBundlingStrategy {
  constructor(preview, pkg, dependencyResolver) {
    this.preview = preview;
    this.pkg = pkg;
    this.dependencyResolver = dependencyResolver;
    (0, _defineProperty2().default)(this, "name", 'env');
  }
  async computeTargets(context, previewDefs) {
    const outputPath = this.getOutputPath(context);
    if (!(0, _fsExtra().existsSync)(outputPath)) (0, _fsExtra().mkdirpSync)(outputPath);
    const htmlConfig = this.generateHtmlConfig({
      dev: context.dev
    });
    const peers = await this.dependencyResolver.getPeerDependenciesListFromEnv(context.env);
    return [{
      entries: await this.computePaths(outputPath, previewDefs, context),
      html: [htmlConfig],
      components: context.components,
      outputPath,
      /* It's a path to the root of the host component. */
      // hostRootDir, handle this
      hostDependencies: peers,
      aliasHostDependencies: true
    }];
  }
  generateHtmlConfig(options) {
    var _options$dev;
    const config = {
      title: 'Preview',
      templateContent: (0, _htmlTemplate().html)('Preview'),
      cache: false,
      minify: (_options$dev = options === null || options === void 0 ? void 0 : options.dev) !== null && _options$dev !== void 0 ? _options$dev : true
    };
    return config;
  }
  async computeResults(context, results) {
    const result = results[0];
    const componentsResults = result.components.map(component => {
      return {
        component,
        errors: result.errors.map(err => typeof err === 'string' ? err : err.message),
        warning: result.warnings,
        startTime: result.startTime,
        endTime: result.endTime
      };
    });
    const artifacts = this.getArtifactDef(context);
    return {
      componentsResults,
      artifacts
    };
  }
  getArtifactDef(context) {
    // eslint-disable-next-line @typescript-eslint/prefer-as-const
    const env = 'env';
    const rootDir = this.getDirName(context);
    return [{
      name: ENV_STRATEGY_ARTIFACT_NAME,
      globPatterns: ['public/**'],
      rootDir,
      context: env
    }];
  }
  getDirName(context) {
    const envName = context.id.replace('/', '__');
    return `${envName}-preview`;
  }
  getOutputPath(context) {
    return (0, _path().resolve)(`${context.capsuleNetwork.capsulesRootDir}/${this.getDirName(context)}`);
  }
  getPaths(context, files, capsule) {
    const compiler = context.env.getCompiler();
    return files.map(file => (0, _path().join)(capsule.path, compiler.getDistPathBySrcPath(file.relative)));
  }
  async computePaths(outputPath, defs, context) {
    const previewMain = await this.preview.writePreviewRuntime(context);
    const moduleMapsPromise = defs.map(async previewDef => {
      const moduleMap = await previewDef.getModuleMap(context.components);
      const paths = _component().ComponentMap.as(context.components, component => {
        const capsule = context.capsuleNetwork.graphCapsules.getCapsule(component.id);
        const maybeFiles = moduleMap.get(component);
        if (!maybeFiles || !capsule) return [];
        const [, files] = maybeFiles;
        const compiledPaths = this.getPaths(context, files, capsule);
        return compiledPaths;
      });
      const template = previewDef.renderTemplatePath ? await previewDef.renderTemplatePath(context) : 'undefined';
      const link = this.preview.writeLink(previewDef.prefix, paths, previewDef.renderTemplatePath ? await previewDef.renderTemplatePath(context) : undefined, outputPath, false);
      const files = (0, _lodash().flatten)(paths.toArray().map(([, file]) => file)).concat([link]);
      if (template) return files.concat([template]);
      return files;
    });
    const moduleMaps = await Promise.all(moduleMapsPromise);
    return (0, _lodash().flatten)(moduleMaps.concat([previewMain]));
  }
}
exports.EnvBundlingStrategy = EnvBundlingStrategy;

//# sourceMappingURL=env-strategy.js.map