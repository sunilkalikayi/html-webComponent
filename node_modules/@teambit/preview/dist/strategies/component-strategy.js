"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PREVIEW_CHUNK_SUFFIX = exports.PREVIEW_CHUNK_FILENAME_SUFFIX = exports.ComponentBundlingStrategy = exports.COMPONENT_STRATEGY_SIZE_KEY_NAME = exports.COMPONENT_STRATEGY_ARTIFACT_NAME = exports.COMPONENT_CHUNK_SUFFIX = exports.COMPONENT_CHUNK_FILENAME_SUFFIX = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = require("fs-extra");
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("@teambit/builder");
  _builder = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _generateComponentLink() {
  const data = require("./generate-component-link");
  _generateComponentLink = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("../exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
const PREVIEW_CHUNK_SUFFIX = 'preview';
exports.PREVIEW_CHUNK_SUFFIX = PREVIEW_CHUNK_SUFFIX;
const COMPONENT_CHUNK_SUFFIX = 'component';
exports.COMPONENT_CHUNK_SUFFIX = COMPONENT_CHUNK_SUFFIX;
const PREVIEW_CHUNK_FILENAME_SUFFIX = `${PREVIEW_CHUNK_SUFFIX}.js`;
exports.PREVIEW_CHUNK_FILENAME_SUFFIX = PREVIEW_CHUNK_FILENAME_SUFFIX;
const COMPONENT_CHUNK_FILENAME_SUFFIX = `${COMPONENT_CHUNK_SUFFIX}.js`;
exports.COMPONENT_CHUNK_FILENAME_SUFFIX = COMPONENT_CHUNK_FILENAME_SUFFIX;
const COMPONENT_STRATEGY_SIZE_KEY_NAME = 'size';
exports.COMPONENT_STRATEGY_SIZE_KEY_NAME = COMPONENT_STRATEGY_SIZE_KEY_NAME;
const COMPONENT_STRATEGY_ARTIFACT_NAME = 'preview-component';
exports.COMPONENT_STRATEGY_ARTIFACT_NAME = COMPONENT_STRATEGY_ARTIFACT_NAME;
/**
 * bundles all components in a given env into the same bundle.
 */
class ComponentBundlingStrategy {
  constructor(preview, pkg, dependencyResolver) {
    this.preview = preview;
    this.pkg = pkg;
    this.dependencyResolver = dependencyResolver;
    (0, _defineProperty2().default)(this, "name", 'component');
  }
  async computeTargets(context, previewDefs) {
    const outputPath = this.getOutputPath(context);
    if (!(0, _fsExtra().existsSync)(outputPath)) (0, _fsExtra().mkdirpSync)(outputPath);

    // const entriesArr = flatten(
    //   await Promise.all(
    //     context.capsuleNetwork.seedersCapsules.map((capsule) => {
    //       return this.computeComponentEntry(previewDefs, capsule.component, context);
    //     }, {})
    //   )
    // );

    const origComponents = context.capsuleNetwork.originalSeedersCapsules.map(capsule => capsule.component);
    const entriesArr = await Promise.all(origComponents.map(component => {
      return this.computeComponentEntry(previewDefs, component, context);
    }, {}));
    const chunkSize = this.preview.config.maxChunkSize;
    const chunks = chunkSize ? (0, _lodash().chunk)(entriesArr, chunkSize) : [entriesArr];
    const peers = await this.dependencyResolver.getPeerDependenciesListFromEnv(context.env);
    const targets = chunks.map(currentChunk => {
      const entries = {};
      const components = [];
      currentChunk.forEach(entry => {
        Object.assign(entries, entry.entries);
        components.push(entry.component);
      });
      return {
        entries,
        components,
        outputPath,
        /* It's a path to the root of the host component. */
        // hostRootDir, handle this
        hostDependencies: peers,
        aliasHostDependencies: true,
        externalizeHostDependencies: true
      };
    });
    return targets;
    // const entries = entriesArr.reduce((entriesMap, entry) => {
    //   entriesMap[entry.library.name] = entry;
    //   return entriesMap;
    // }, {});

    // const modules = await Promise.all(entriesArr.map(async (entry) => {
    //   const dependencies = await this.dependencyResolver.getDependencies(entry.component);
    //   const manifest = dependencies.toDependenciesManifest();
    //   const peer = Object.entries(manifest.peerDependencies || {}).reduce((acc, [packageName, version]) => {
    //     acc[packageName] = {
    //       singleton: true,
    //       requiredVersion: version
    //     };

    //     return acc;
    //   }, {});
    //   // console.log(entry);
    //   return {
    //     name: entry.library.name,
    //     exposes: {
    //       '.': entry.import || ''
    //     },
    //     shared: {
    //       ...manifest.dependencies,
    //       ...peer
    //     },
    //   };
    // }));
  }

  async computeComponentEntry(previewDefs, component, context) {
    const componentPreviewPath = await this.computePaths(previewDefs, context, component);
    const [componentPath] = this.getPaths(context, component, [component.mainFile]);
    const chunks = {
      componentPreview: this.getComponentChunkId(component.id, 'preview'),
      component: context.splitComponentBundle ? component.id.toStringWithoutVersion() : undefined
    };
    const entries = {
      [chunks.componentPreview]: {
        filename: this.getComponentChunkFileName(component.id.toString({
          fsCompatible: true,
          ignoreVersion: true
        }), 'preview'),
        import: componentPreviewPath,
        dependOn: chunks.component,
        library: {
          name: chunks.componentPreview,
          type: 'umd'
        }
      }
    };
    if (chunks.component) {
      entries[chunks.component] = {
        filename: this.getComponentChunkFileName(component.id.toString({
          fsCompatible: true,
          ignoreVersion: true
        }), 'component'),
        dependOn: undefined,
        import: componentPath,
        library: {
          name: chunks.component,
          type: 'umd'
        }
      };
    }
    return {
      component,
      entries
    };
  }
  getComponentChunkId(componentId, type) {
    const id = type === 'component' ? componentId.toStringWithoutVersion() : `${componentId.toStringWithoutVersion()}-${PREVIEW_CHUNK_SUFFIX}`;
    return id;
  }
  getComponentChunkFileName(idstr, type) {
    const suffix = type === 'component' ? COMPONENT_CHUNK_FILENAME_SUFFIX : PREVIEW_CHUNK_FILENAME_SUFFIX;
    return `${idstr}-${suffix}`;
  }
  getAssetAbsolutePath(context, asset) {
    const path = this.getOutputPath(context);
    return (0, _path().join)(path, 'public', this.getAssetFilename(asset));
  }
  getAssetFilename(asset) {
    // handle cases where the asset name is something like my-image.svg?hash (while the filename in the fs is just my-image.svg)
    const [name] = asset.name.split('?');
    return name;
  }
  copyAssetsToCapsules(context, result) {
    context.components.forEach(component => {
      const capsule = context.capsuleNetwork.graphCapsules.getCapsule(component.id);
      if (!capsule) return;
      const files = this.findAssetsForComponent(component, result.assets, result.entriesAssetsMap || {});
      if (!files) return;
      const artifactDirFullPath = (0, _path().join)(capsule.path, this.getArtifactDirectory());
      // We don't use the mkdirSync as it uses the capsule fs which uses memfs, which doesn't know to handle nested none existing folders
      (0, _fsExtra().mkdirpSync)(artifactDirFullPath);
      files.forEach(asset => {
        const filePath = this.getAssetAbsolutePath(context, asset);
        if (!(0, _fsExtra().existsSync)(filePath)) {
          throw new (_exceptions().PreviewOutputFileNotFound)(component.id, filePath);
        }
        const destFilePath = (0, _path().join)(artifactDirFullPath, this.getAssetFilename(asset));
        (0, _fsExtra().mkdirpSync)((0, _path().dirname)(destFilePath));
        capsule.fs.copyFileSync(filePath, destFilePath);
      });
    });
  }

  // private getCssFileName(componentId: ComponentID): string {
  //   return `${componentId.toString({ ignoreVersion: true, fsCompatible: true })}.css`;
  // }

  findAssetsForComponent(component, assets, entriesAssetsMap) {
    var _entriesAssetsMap$com, _entriesAssetsMap$com2, _entriesAssetsMap$com3, _entriesAssetsMap$com4;
    if (!assets) return undefined;
    const componentEntryId = component.id.toStringWithoutVersion();
    const componentPreviewEntryId = this.getComponentChunkId(component.id, 'preview');
    const componentFiles = ((_entriesAssetsMap$com = entriesAssetsMap[componentEntryId]) === null || _entriesAssetsMap$com === void 0 ? void 0 : _entriesAssetsMap$com.assets) || [];
    const componentAuxiliaryFiles = ((_entriesAssetsMap$com2 = entriesAssetsMap[componentEntryId]) === null || _entriesAssetsMap$com2 === void 0 ? void 0 : _entriesAssetsMap$com2.auxiliaryAssets) || [];
    const componentPreviewFiles = ((_entriesAssetsMap$com3 = entriesAssetsMap[componentPreviewEntryId]) === null || _entriesAssetsMap$com3 === void 0 ? void 0 : _entriesAssetsMap$com3.assets) || [];
    const componentPreviewAuxiliaryFiles = ((_entriesAssetsMap$com4 = entriesAssetsMap[componentPreviewEntryId]) === null || _entriesAssetsMap$com4 === void 0 ? void 0 : _entriesAssetsMap$com4.auxiliaryAssets) || [];
    const files = componentFiles.concat(componentAuxiliaryFiles).concat(componentPreviewFiles).concat(componentPreviewAuxiliaryFiles);
    return files;
  }
  getArtifactDirectory() {
    return (0, _path().join)(_builder().CAPSULE_ARTIFACTS_DIR, 'preview');
  }
  computeComponentMetadata(context, result, component) {
    var _result$entriesAssets, _result$entriesAssets2, _result$entriesAssets3, _result$entriesAssets4, _result$entriesAssets5, _result$entriesAssets6;
    const componentEntryId = component.id.toStringWithoutVersion();
    if (!(result !== null && result !== void 0 && result.entriesAssetsMap) || !(result !== null && result !== void 0 && result.entriesAssetsMap[componentEntryId])) {
      return {};
    }
    const files = (((_result$entriesAssets = result.entriesAssetsMap[componentEntryId]) === null || _result$entriesAssets === void 0 ? void 0 : _result$entriesAssets.assets) || []).map(file => {
      return {
        name: (0, _path().basename)(file.name),
        size: file.size,
        compressedSize: file.compressedSize
      };
    });
    const filesTotalSize = ((_result$entriesAssets2 = result.entriesAssetsMap[componentEntryId]) === null || _result$entriesAssets2 === void 0 ? void 0 : _result$entriesAssets2.assetsSize) || 0;
    const compressedTotalFiles = ((_result$entriesAssets3 = result.entriesAssetsMap[componentEntryId]) === null || _result$entriesAssets3 === void 0 ? void 0 : _result$entriesAssets3.compressedAssetsSize) || 0;
    const assets = (((_result$entriesAssets4 = result.entriesAssetsMap[componentEntryId]) === null || _result$entriesAssets4 === void 0 ? void 0 : _result$entriesAssets4.auxiliaryAssets) || []).map(file => {
      return {
        name: (0, _path().basename)(file.name),
        size: file.size,
        compressedSize: file.compressedSize
      };
    });
    const assetsTotalSize = ((_result$entriesAssets5 = result.entriesAssetsMap[componentEntryId]) === null || _result$entriesAssets5 === void 0 ? void 0 : _result$entriesAssets5.auxiliaryAssetsSize) || 0;
    const compressedTotalAssets = ((_result$entriesAssets6 = result.entriesAssetsMap[componentEntryId]) === null || _result$entriesAssets6 === void 0 ? void 0 : _result$entriesAssets6.compressedAuxiliaryAssetsSize) || 0;
    const totalSize = filesTotalSize + assetsTotalSize;
    const compressedTotal = compressedTotalFiles + compressedTotalAssets;
    const metadata = {
      [COMPONENT_STRATEGY_SIZE_KEY_NAME]: {
        files,
        assets,
        totalFiles: filesTotalSize,
        totalAssets: assetsTotalSize,
        total: totalSize,
        compressedTotalFiles,
        compressedTotalAssets,
        compressedTotal
      }
    };
    return metadata;
  }
  async computeResults(context, results) {
    const componentsResults = (0, _lodash().flatten)(await Promise.all(results.map(result => this.computeTargetResult(context, result))));
    const artifacts = this.getArtifactDef();
    return {
      componentsResults,
      artifacts
    };
  }
  async computeTargetResult(context, result) {
    if ((0, _lodash().isEmpty)(result.errors)) {
      // In case there are errors files will not be emitted so trying to copy them will fail anyway
      this.copyAssetsToCapsules(context, result);
    }
    const componentsResults = result.components.map(component => {
      const metadata = this.computeComponentMetadata(context, result, component);
      return {
        component,
        metadata,
        errors: result.errors.map(err => typeof err === 'string' ? err : err.message),
        warning: result.warnings,
        startTime: result.startTime,
        endTime: result.endTime
      };
    });
    return componentsResults;
  }
  getArtifactDef() {
    // eslint-disable-next-line @typescript-eslint/prefer-as-const
    // const env: 'env' = 'env';
    // const rootDir = this.getDirName(context);

    return [{
      name: COMPONENT_STRATEGY_ARTIFACT_NAME,
      globPatterns: ['**'],
      rootDir: this.getArtifactDirectory()
      // context: env,
    }];
  }

  getDirName(context) {
    const envName = context.id.replace('/', '__');
    return `${envName}-preview`;
  }
  getOutputPath(context) {
    return (0, _path().resolve)(`${context.capsuleNetwork.capsulesRootDir}/${this.getDirName(context)}`);
  }
  getPaths(context, component, files) {
    const capsule = context.capsuleNetwork.graphCapsules.getCapsule(component.id);
    if (!capsule) return [];
    const compiler = context.env.getCompiler();
    return files.map(file => (0, _path().join)(capsule.path, compiler.getDistPathBySrcPath(file.relative)));
  }
  getComponentOutputPath(capsule) {
    return (0, _path().resolve)(`${capsule.path}`);
  }
  async computePaths(defs, context, component) {
    // const previewMain = await this.preview.writePreviewRuntime(context);
    const capsule = context.capsuleNetwork.graphCapsules.getCapsule(component.id);
    // if (!capsule) return undefined;
    if (!capsule) throw new (_bitError().BitError)(`could not find capsule for component ${component.id.toString()} during compute paths to bundle`);
    const moduleMapsPromise = defs.map(async previewDef => {
      const moduleMap = await previewDef.getModuleMap([component]);
      const metadata = previewDef.getMetadata ? await previewDef.getMetadata(component) : undefined;
      const maybeFiles = moduleMap.get(component);
      if (!maybeFiles || !capsule) return {
        prefix: previewDef.prefix,
        paths: []
      };
      const [, files] = maybeFiles;
      const compiledPaths = this.getPaths(context, component, files);
      return {
        prefix: previewDef.prefix,
        paths: compiledPaths,
        metadata
      };
    });
    const moduleMaps = await Promise.all(moduleMapsPromise);
    const contents = (0, _generateComponentLink().generateComponentLink)(moduleMaps);
    return this.preview.writeLinkContents(contents, this.getComponentOutputPath(capsule), 'preview');
    // return flatten(moduleMaps);
  }
}
exports.ComponentBundlingStrategy = ComponentBundlingStrategy;

//# sourceMappingURL=component-strategy.js.map