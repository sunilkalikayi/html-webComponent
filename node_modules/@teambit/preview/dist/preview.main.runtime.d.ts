import type { BuilderMain } from '@teambit/builder';
import { Asset, BundlerMain } from '@teambit/bundler';
import { PubsubMain } from '@teambit/pubsub';
import { Component, ComponentMain, ComponentMap, ComponentID, ResolveAspectsOptions } from '@teambit/component';
import type { EnvsMain, PreviewEnv } from '@teambit/envs';
import { SlotRegistry, Harmony } from '@teambit/harmony';
import { UiMain, UIRoot } from '@teambit/ui';
import { PkgMain } from '@teambit/pkg';
import type { AspectDefinition, AspectLoaderMain } from '@teambit/aspect-loader';
import { Workspace } from '@teambit/workspace';
import { LoggerMain, Logger } from '@teambit/logger';
import type { DependencyResolverMain } from '@teambit/dependency-resolver';
import { GraphqlMain } from '@teambit/graphql';
import { PreviewArtifact } from './preview-artifact';
import { PreviewDefinition } from './preview-definition';
import { BundlingStrategy } from './bundling-strategy';
export declare type PreviewDefinitionRegistry = SlotRegistry<PreviewDefinition>;
declare type PreviewFiles = {
    files: string[];
    isBundledWithEnv: boolean;
};
export declare type ComponentPreviewSizedFile = Asset;
export declare type ComponentPreviewSize = {
    files: ComponentPreviewSizedFile[];
    assets: ComponentPreviewSizedFile[];
    totalFiles: number;
    compressedTotalFiles?: number;
    totalAssets: number;
    compressedTotalAssets?: number;
    total: number;
    compressedTotal?: number;
};
export declare type ComponentPreviewMetaData = {
    size?: ComponentPreviewSize;
};
export declare type PreviewVariantConfig = {
    isScaling?: boolean;
};
/**
 * Preview data that stored on the component on load
 */
export declare type PreviewComponentData = {
    doesScaling?: boolean;
    isScaling?: boolean;
};
export declare type PreviewConfig = {
    bundlingStrategy?: string;
    disabled: boolean;
    /**
     * limit concurrent components when running the bundling step for your bundler during generate components preview task.
     * this helps mitigate large memory consumption for the build pipeline. This may increase the overall time for the generate-preview task, but reduce memory footprint.
     * default - no limit.
     */
    maxChunkSize?: number;
};
export declare type EnvPreviewConfig = {
    strategyName?: string;
    splitComponentBundle?: boolean;
};
export declare type BundlingStrategySlot = SlotRegistry<BundlingStrategy>;
export declare type GenerateLinkFn = (prefix: string, componentMap: ComponentMap<string[]>, defaultModule?: string) => string;
export declare class PreviewMain {
    /**
     * harmony context.
     */
    private harmony;
    /**
     * slot for preview definitions.
     */
    private previewSlot;
    private ui;
    private envs;
    private componentAspect;
    private pkg;
    private aspectLoader;
    readonly config: PreviewConfig;
    private bundlingStrategySlot;
    private builder;
    private workspace;
    private logger;
    private dependencyResolver;
    constructor(
    /**
     * harmony context.
     */
    harmony: Harmony, 
    /**
     * slot for preview definitions.
     */
    previewSlot: PreviewDefinitionRegistry, ui: UiMain, envs: EnvsMain, componentAspect: ComponentMain, pkg: PkgMain, aspectLoader: AspectLoaderMain, config: PreviewConfig, bundlingStrategySlot: BundlingStrategySlot, builder: BuilderMain, workspace: Workspace | undefined, logger: Logger, dependencyResolver: DependencyResolverMain);
    get tempFolder(): string;
    getComponentBundleSize(component: Component): ComponentPreviewSize | undefined;
    getPreview(component: Component): Promise<PreviewArtifact | undefined>;
    /**
     * Get a list of all the artifact files generated during the GeneratePreview task
     * @param component
     * @returns
     */
    getPreviewFiles(component: Component): Promise<PreviewFiles | undefined>;
    /**
     * Check if the component preview bundle contain the env as part of the bundle or only the component code
     * (we used in the past to bundle them together, there might also be specific envs which still uses the env strategy)
     * @param component
     * @returns
     */
    isBundledWithEnv(component: Component): Promise<boolean>;
    private calcDoesScalingForComponent;
    /**
     * can the current component preview scale in size for different preview sizes.
     * this calculation is based on the env of the component and if the env of the component support it.
     */
    doesScaling(component: Component): Promise<boolean>;
    /**
     * Check if the current version of the env support scaling
     * @param envComponent
     * @returns
     */
    isEnvSupportScaling(envComponent: Component): boolean;
    /**
     * This function is calculate the isScaling support flag for the component preview.
     * This is calculated only for the env component and not for the component itself.
     * It should be only used during the (env) component on load.
     * Once the component load, you should only use the `isEnvSupportScaling` to fetch it from the calculated data.
     * If you want to check if an env for a given component support scaling, use the `isScaling` function.
     * @param component
     * @returns
     */
    private calculateIsEnvSupportScaling;
    /**
     * Get the preview config of the component.
     * (config that was set by variants or on bitmap)
     * @param component
     * @returns
     */
    getPreviewConfig(component: Component): PreviewVariantConfig | undefined;
    /**
     * Check if the component preview bundle contain the header inside of it (legacy)
     * today we are not including the header inside anymore
     * @param component
     * @returns
     */
    isLegacyHeader(component: Component): Promise<boolean>;
    /**
     * Getting the env template artifact
     * This should be called with the env itself or it will return undefined
     * If you want to get the env template from the env of the component,
     * use: getEnvTemplateFromComponentEnv below
     *
     * @param component
     * @returns
     */
    getEnvTemplate(component: Component): Promise<PreviewArtifact | undefined>;
    /**
     * This is a special method to get a core env template
     * As the core envs doesn't exist in the scope we need to bring it from other place
     * We will bring it from the core env package files
     */
    private getCoreEnvTemplate;
    /**
     * This will fetch the component env, then will take the env template from the component env
     * @param component
     */
    getEnvTemplateFromComponentEnv(component: Component): Promise<PreviewArtifact | undefined>;
    /**
     * This will fetch the component env, then will take the env template from the component env
     * @param component
     */
    getEnvTemplateByEnvId(envId: string): Promise<PreviewArtifact | undefined>;
    getDefs(): PreviewDefinition[];
    private writeHash;
    private timestamp;
    /**
     * write a link to load custom modules dynamically.
     * @param prefix write
     * @param moduleMap map of components to module paths to require.
     * @param defaultModule
     * @param dirName
     */
    writeLink(prefix: string, moduleMap: ComponentMap<string[]>, defaultModule: string | undefined, dirName: string, isSplitComponentBundle: boolean): string;
    writeLinkContents(contents: string, targetDir: string, prefix: string): string;
    private executionRefs;
    private getPreviewTarget;
    private updateLinkFiles;
    writePreviewRuntime(context: {
        components: Component[];
    }, aspectsIdsToNotFilterOut?: string[]): Promise<string>;
    resolveAspects(runtimeName?: string, componentIds?: ComponentID[], uiRoot?: UIRoot, opts?: ResolveAspectsOptions): Promise<AspectDefinition[]>;
    private getUi;
    /**
     * Filter the aspects to have only aspects that are:
     * 1. core aspects
     * 2. configured on the host (workspace/scope)
     * 3. used by at least one component from the context
     * @param aspects
     * @param context
     */
    private filterAspectsByExecutionContext;
    private getDefaultStrategies;
    private handleComponentChange;
    private handleComponentRemoval;
    getEnvPreviewConfig(env?: PreviewEnv): EnvPreviewConfig;
    /**
     * return the configured bundling strategy.
     */
    getBundlingStrategy(env?: PreviewEnv): BundlingStrategy;
    /**
     * register a new bundling strategy. default available strategies are `env` and ``
     */
    registerBundlingStrategy(bundlingStrategy: BundlingStrategy): this;
    /**
     * register a new preview definition.
     */
    registerDefinition(previewDef: PreviewDefinition): void;
    static slots: (((registerFn: () => string) => SlotRegistry<PreviewDefinition>) | ((registerFn: () => string) => SlotRegistry<BundlingStrategy>))[];
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: import("@teambit/harmony").Aspect[];
    static defaultConfig: {
        disabled: boolean;
    };
    static provider([bundler, builder, componentExtension, uiMain, envs, workspace, pkg, pubsub, aspectLoader, loggerMain, dependencyResolver, graphql,]: [
        BundlerMain,
        BuilderMain,
        ComponentMain,
        UiMain,
        EnvsMain,
        Workspace | undefined,
        PkgMain,
        PubsubMain,
        AspectLoaderMain,
        LoggerMain,
        DependencyResolverMain,
        GraphqlMain
    ], config: PreviewConfig, [previewSlot, bundlingStrategySlot]: [PreviewDefinitionRegistry, BundlingStrategySlot], harmony: Harmony): Promise<PreviewMain>;
}
export {};
