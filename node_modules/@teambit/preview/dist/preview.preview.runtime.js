"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/web.url.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PreviewPreview = void 0;
Object.defineProperty(exports, "linkModules", {
  enumerable: true,
  get: function () {
    return _previewModules().linkModules;
  }
});
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pubsub() {
  const data = _interopRequireDefault(require("@teambit/pubsub"));
  _pubsub = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _componentId() {
  const data = require("@teambit/component-id");
  _componentId = function () {
    return data;
  };
  return data;
}
function _crossFetch() {
  const data = _interopRequireDefault(require("cross-fetch"));
  _crossFetch = function () {
    return data;
  };
  return data;
}
function _memoizee() {
  const data = _interopRequireDefault(require("memoizee"));
  _memoizee = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _preview() {
  const data = require("./preview.aspect");
  _preview = function () {
    return data;
  };
  return data;
}
function _events() {
  const data = require("./events");
  _events = function () {
    return data;
  };
  return data;
}
function _renderingContext() {
  const data = require("./rendering-context");
  _renderingContext = function () {
    return data;
  };
  return data;
}
function _fetchComponentAspects() {
  const data = require("./gql/fetch-component-aspects");
  _fetchComponentAspects = function () {
    return data;
  };
  return data;
}
function _previewModules() {
  const data = require("./preview-modules");
  _previewModules = function () {
    return data;
  };
  return data;
}
function _htmlUtils() {
  const data = require("./html-utils");
  _htmlUtils = function () {
    return data;
  };
  return data;
}
function _sizeEvent() {
  const data = require("./size-event");
  _sizeEvent = function () {
    return data;
  };
  return data;
}
// forward linkModules() for generate-link.ts

class PreviewPreview {
  constructor(
  /**
   * register to pubsub
   */
  pubsub,
  /**
   * preview slot.
   */
  previewSlot, renderingContextSlot) {
    this.pubsub = pubsub;
    this.previewSlot = previewSlot;
    this.renderingContextSlot = renderingContextSlot;
    (0, _defineProperty2().default)(this, "isDev", false);
    (0, _defineProperty2().default)(this, "_setupPromise", void 0);
    (0, _defineProperty2().default)(this, "setup", () => {
      var _this$_setupPromise;
      if (this.isReady()) return Promise.resolve();
      (_this$_setupPromise = this._setupPromise) !== null && _this$_setupPromise !== void 0 ? _this$_setupPromise : this._setupPromise = new Promise(resolve => {
        _previewModules().PREVIEW_MODULES.onSet.add(() => {
          if (this.isReady()) resolve();
        });
      });
      return this._setupPromise;
    });
    (0, _defineProperty2().default)(this, "render", async rootExt => {
      // fit content always.
      window.document.body.style.width = 'fit-content';
      const {
        previewName,
        componentId
      } = this.getLocation();
      const name = previewName || this.getDefault();
      if (rootExt) this.isDev = rootExt === 'teambit.workspace/workspace';
      const preview = this.getPreview(name);
      if (!preview || !componentId) {
        throw new (_exceptions().PreviewNotFound)(previewName);
      }
      const includesAll = await Promise.all((preview.include || []).map(async inclPreviewName => {
        var _includedPreview$sele;
        const includedPreview = this.getPreview(inclPreviewName);
        if (!includedPreview) return undefined;
        const inclPreviewModule = await this.getPreviewModule(inclPreviewName, componentId);
        return (_includedPreview$sele = includedPreview.selectPreviewModel) === null || _includedPreview$sele === void 0 ? void 0 : _includedPreview$sele.call(includedPreview, componentId.fullName, inclPreviewModule);
      }));
      const includes = includesAll.filter(module => !!module);
      // during build / tag, the component is isolated, so all aspects are relevant, and do not require filtering
      const componentAspects = this.isDev ? await this.getComponentAspects(componentId.toString()) : undefined;
      const previewModule = await this.getPreviewModule(name, componentId);
      const render = preview.render(componentId, previewModule, includes, this.getRenderingContext(componentAspects));
      this.reportSize();
      this.setViewport();
      return render;
    });
    (0, _defineProperty2().default)(this, "getComponentAspects", (0, _memoizee().default)(_fetchComponentAspects().fetchComponentAspects, {
      max: 100,
      maxAge: 12 * 60 * 60 * 1000
    }));
    this.registerClickPubSub();
  }
  registerClickPubSub() {
    window.addEventListener('click', e => {
      const timestamp = Date.now();
      const clickEvent = Object.assign({}, e);
      this.pubsub.pub(_preview().PreviewAspect.id, new (_events().ClickInsideAnIframeEvent)(timestamp, clickEvent));
    });
  }
  isReady() {
    var _preview$include$ever, _preview$include;
    const {
      previewName
    } = this.getLocation();
    const name = previewName || this.getDefault();
    if (!_previewModules().PREVIEW_MODULES.has(name)) return false;
    const preview = this.getPreview(name);
    if (!preview) return false;
    const includedReady = (_preview$include$ever = (_preview$include = preview.include) === null || _preview$include === void 0 ? void 0 : _preview$include.every(included => _previewModules().PREVIEW_MODULES.has(included))) !== null && _preview$include$ever !== void 0 ? _preview$include$ever : true;
    if (!includedReady) return false;
    return true;
  }
  setViewport() {
    const query = this.getQuery();
    const viewPort = this.getParam(query, 'viewport');
    if (!viewPort) {
      window.document.body.style.width = '100%';
      return;
    }
    window.document.body.style.maxWidth = `${viewPort}px`;
  }
  reportSize() {
    var _window, _window2;
    if (!((_window = window) !== null && _window !== void 0 && _window.parent) || !((_window2 = window) !== null && _window2 !== void 0 && _window2.document)) return;
    // TODO: discuss with gilad for a better way to resolve page loaded here.

    const sendPubsubEvent = () => {
      this.pubsub.pub(_preview().PreviewAspect.id, new (_sizeEvent().SizeEvent)({
        width: window.document.body.offsetWidth,
        height: window.document.body.offsetHeight
      }));
    };
    window.document.body.addEventListener('resize', (0, _lodash().debounce)(sendPubsubEvent, 300));
    let counter = 0;
    const interval = setInterval(() => {
      // TODO: think
      counter += 1;
      if (counter > 10) {
        clearInterval(interval);
        return;
      }
      this.pubsub.pub(_preview().PreviewAspect.id, new (_sizeEvent().SizeEvent)({
        width: window.document.body.offsetWidth,
        height: window.document.body.offsetHeight
      }));
    }, 200);
  }
  async getPreviewModule(previewName, id) {
    const compShortId = id.fullName;
    const relevantModel = _previewModules().PREVIEW_MODULES.get(previewName);
    if (!relevantModel) throw new Error(`[preview.preview] missing preview "${previewName}"`);
    if (relevantModel.componentMap[compShortId]) return relevantModel;
    const componentPreviews = await this.fetchComponentPreview(id, previewName);
    _previewModules().PREVIEW_MODULES.loadComponentPreviews(compShortId, componentPreviews);
    const component = componentPreviews[previewName];
    const metadata = componentPreviews[`${previewName}_metadata`];
    return {
      mainModule: relevantModel.mainModule,
      componentMap: {
        [id.fullName]: component
      },
      componentMapMetadata: {
        [id.fullName]: metadata
      }
    };
  }
  async fetchComponentPreview(id, name) {
    let previewFile;
    const allFiles = await this.fetchComponentPreviewFiles(id, name);
    // It's a component bundled with the env
    if (allFiles === null) return {};
    await Promise.all(allFiles.map(file => {
      // We want to run the preview file always last
      if (file.endsWith('-preview.js')) {
        previewFile = file;
        return undefined;
      }
      return this.addComponentFileElement(id, file);
    }));
    if (!previewFile) return {};
    return this.loadPreviewScript(id, name, previewFile);
  }
  addComponentFileElement(id, previewBundleFileName) {
    if (previewBundleFileName.endsWith('.js')) {
      return this.addComponentFileScriptElement(id, previewBundleFileName);
    }

    // TODO - should we load assets other than .css / .js?
    // if (previewBundleFileName.endsWith('.css')) {
    this.addComponentFileLinkElement(id, previewBundleFileName).catch(err => {
      throw new Error(`[preview.preview] failed loading asset "${previewBundleFileName}". Error - "${err === null || err === void 0 ? void 0 : err.toString()}"`);
    });

    // do NOT await non js assets, as they might never load (like images), and not critical for rendering.
    return undefined;
  }
  async fetchComponentPreviewFiles(id, previewName) {
    const previewAssetsRoute = `~aspect/preview-assets`;
    const stringId = id.toString();
    const url = `/api/${stringId}/${previewAssetsRoute}`;
    const res = await (0, _crossFetch().default)(url);
    if (res.status >= 400) {
      throw new (_exceptions().PreviewNotFound)(previewName);
    }
    const parsed = await res.json();
    // This is component bundled with the env, no reason to bring the files, as they will be the files of the env
    if (parsed.isBundledWithEnv) {
      return null;
    }
    if (!parsed.files || !parsed.files.length) {
      throw new (_exceptions().PreviewNotFound)(previewName);
    }
    return parsed.files;
  }
  addComponentFileScriptElement(id, previewBundleFileName) {
    const previewRoute = `~aspect/component-preview`;
    const stringId = id.toString();
    const src = `/api/${stringId}/${previewRoute}/${previewBundleFileName}`;
    return (0, _htmlUtils().loadScript)({
      src
    });
  }
  addComponentFileLinkElement(id, previewBundleFileName) {
    const stringId = id.toString();
    const previewRoute = `~aspect/component-preview`;
    const href = `/api/${stringId}/${previewRoute}/${previewBundleFileName}`;
    return (0, _htmlUtils().loadLink)({
      href
    });
  }
  async loadPreviewScript(id, previewName, previewBundleFileName) {
    const previewRoute = `~aspect/component-preview`;
    const src = `/api/${id.toString()}/${previewRoute}/${previewBundleFileName}`;
    await (0, _htmlUtils().loadScript)({
      src
    });

    // TODO - replace with jsonp
    const globalId = `${id.toStringWithoutVersion()}-preview`;
    const componentPreview = window[globalId];
    if (!componentPreview) throw new (_exceptions().PreviewNotFound)(previewName);
    return componentPreview;
  }
  /**
   * register a new preview.
   */
  registerPreview(preview) {
    this.previewSlot.register(preview);
    return this;
  }

  /**
   * get the preview rendering context.
   */
  getRenderingContext(aspectsFilter) {
    return new (_renderingContext().RenderingContext)(this.renderingContextSlot, {
      aspectsFilter
    });
  }

  /**
   * allows aspects to add rendering contexts.
   * render context is available through all preview definitions.
   */
  registerRenderContext(renderContext) {
    this.renderingContextSlot.register(renderContext);
    return this;
  }
  getDefault() {
    const previews = this.previewSlot.values();
    const defaultOne = previews.find(previewCandidate => previewCandidate.default);
    return (defaultOne === null || defaultOne === void 0 ? void 0 : defaultOne.name) || previews[0].name;
  }
  getPreview(previewName) {
    const previews = this.previewSlot.values();
    const preview = previews.find(previewCandidate => previewCandidate.name === previewName);
    return preview;
  }
  getParam(query, param) {
    const params = new URLSearchParams(query);
    return params.get(param);
  }
  getQuery() {
    const withoutHash = window.location.hash.substring(1);
    const [, after] = withoutHash.split('?');
    return after;
  }
  getLocation() {
    const withoutHash = window.location.hash.substring(1);
    const [before, after] = withoutHash.split('?');
    return {
      previewName: this.getParam(after, 'preview'),
      componentId: _componentId().ComponentID.tryFromString(before)
    };
  }
  static async provider([pubsub], config, [previewSlot, renderingContextSlot]) {
    const preview = new PreviewPreview(pubsub, previewSlot, renderingContextSlot);
    window.addEventListener('hashchange', () => {
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      preview.render();
    });
    return preview;
  }
}
exports.PreviewPreview = PreviewPreview;
(0, _defineProperty2().default)(PreviewPreview, "runtime", _preview().PreviewRuntime);
(0, _defineProperty2().default)(PreviewPreview, "dependencies", [_pubsub().default]);
(0, _defineProperty2().default)(PreviewPreview, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType()]);
_preview().PreviewAspect.addRuntime(PreviewPreview);

//# sourceMappingURL=preview.preview.runtime.js.map