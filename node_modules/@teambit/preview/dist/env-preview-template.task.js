"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GENERATE_ENV_TEMPLATE_TASK_NAME = exports.EnvPreviewTemplateTask = void 0;
exports.getArtifactDef = getArtifactDef;
exports.getArtifactDirectory = getArtifactDirectory;
function _objectWithoutProperties2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
  _objectWithoutProperties2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("@teambit/builder");
  _builder = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = require("fs-extra");
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _chunks() {
  const data = require("./bundler/chunks");
  _chunks = function () {
    return data;
  };
  return data;
}
function _htmlPlugin() {
  const data = require("./bundler/html-plugin");
  _htmlPlugin = function () {
    return data;
  };
  return data;
}
function _createPeersLink() {
  const data = require("./bundler/create-peers-link");
  _createPeersLink = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const GENERATE_ENV_TEMPLATE_TASK_NAME = 'GenerateEnvTemplate';
exports.GENERATE_ENV_TEMPLATE_TASK_NAME = GENERATE_ENV_TEMPLATE_TASK_NAME;
class EnvPreviewTemplateTask {
  // readonly dependencies = [CompilerAspect.id];

  constructor(preview, envs, aspectLoader, dependencyResolver, logger) {
    this.preview = preview;
    this.envs = envs;
    this.aspectLoader = aspectLoader;
    this.dependencyResolver = dependencyResolver;
    this.logger = logger;
    (0, _defineProperty2().default)(this, "aspectId", 'teambit.preview/preview');
    (0, _defineProperty2().default)(this, "name", GENERATE_ENV_TEMPLATE_TASK_NAME);
    (0, _defineProperty2().default)(this, "location", 'end');
  }
  async execute(context) {
    const previewDefs = this.preview.getDefs();
    const htmlConfig = previewDefs.map(previewModule => (0, _htmlPlugin().generateHtmlConfig)(previewModule, {
      dev: context.dev
    }));
    const originalSeedersIds = context.capsuleNetwork.originalSeedersCapsules.map(c => c.component.id.toString());
    const grouped = {};
    await Promise.all(context.components.map(async component => {
      // Do not run over other components in the graph. it make the process much longer with no need
      if (originalSeedersIds && originalSeedersIds.length && !originalSeedersIds.includes(component.id.toString())) {
        return undefined;
      }
      const envDef = this.envs.getEnvFromComponent(component);
      if (!envDef) return undefined;
      const env = envDef.env;
      const bundlingStrategy = this.preview.getBundlingStrategy(envDef.env);
      if (bundlingStrategy.name === 'env') {
        return undefined;
      }
      const target = await this.getEnvTargetFromComponent(context, component, envDef, htmlConfig);
      if (!target) return undefined;
      const shouldUseDefaultBundler = this.shouldUseDefaultBundler(envDef);
      let envToGetBundler = this.envs.getEnvsEnvDefinition().env;
      let groupEnvId = 'default';
      if (!shouldUseDefaultBundler) {
        envToGetBundler = env;
        groupEnvId = envDef.id;
      }
      if (!grouped[groupEnvId]) {
        grouped[groupEnvId] = {
          env,
          envToGetBundler,
          targets: [target]
        };
      } else {
        grouped[groupEnvId].targets.push(target);
      }
      return undefined;
    }));
    if ((0, _lodash().isEmpty)(grouped)) {
      return {
        componentsResults: []
      };
    }
    return this.runBundlerForGroups(context, grouped);
  }
  async runBundlerForGroups(context, groups) {
    const bundlerContext = Object.assign(context, {
      targets: [],
      entry: [],
      development: context.dev,
      metaData: {
        initiator: `${GENERATE_ENV_TEMPLATE_TASK_NAME} task`,
        envId: context.id
      }
    });
    const bundlerResults = await (0, _pMapSeries().default)(Object.entries(groups), async ([, targetsGroup]) => {
      bundlerContext.targets = targetsGroup.targets;
      const bundler = await targetsGroup.envToGetBundler.getTemplateBundler(bundlerContext);
      const bundlerResult = await bundler.run();
      return bundlerResult;
    });
    const results = await this.computeResults(bundlerContext, (0, _lodash().flatten)(bundlerResults));
    return results;
  }
  shouldUseDefaultBundler(envDef) {
    if (this.aspectLoader.isCoreEnv(envDef.id) && envDef.id !== 'teambit.react/react-native') return true;
    const env = envDef.env;
    if (env.getTemplateBundler && typeof env.getTemplateBundler === 'function') return false;
    return true;
  }
  async getEnvTargetFromComponent(context, envComponent, envDef, htmlConfig) {
    var _envPreviewConfig$spl;
    const env = envDef.env;
    const envPreviewConfig = this.preview.getEnvPreviewConfig(envDef.env);
    const peers = await this.dependencyResolver.getPeerDependenciesListFromEnv(env);
    // const module = await this.getPreviewModule(envComponent);
    // const entries = Object.keys(module).map((key) => module.exposes[key]);
    const capsule = context.capsuleNetwork.graphCapsules.getCapsule(envComponent.id);
    if (!capsule) throw new Error('no capsule found');
    // Passing here the env itself to make sure it's preview runtime will be part of the preview root file
    // that's needed to make sure the providers register there are running correctly
    const previewRoot = await this.preview.writePreviewRuntime(context, [envComponent.id.toString()]);
    const entries = await this.generateEntries({
      envDef,
      splitComponentBundle: (_envPreviewConfig$spl = envPreviewConfig.splitComponentBundle) !== null && _envPreviewConfig$spl !== void 0 ? _envPreviewConfig$spl : false,
      workDir: capsule.path,
      peers,
      previewRoot
    });
    const outputPath = this.computeOutputPath(context, envComponent);
    if (!(0, _fsExtra().existsSync)(outputPath)) (0, _fsExtra().mkdirpSync)(outputPath);
    const resolvedEnvAspects = await this.preview.resolveAspects(_cli().MainRuntime.name, [envComponent.id], undefined, {
      requestedOnly: true
    });
    const resolvedEnv = resolvedEnvAspects[0];
    const hostRootDir = resolvedEnv === null || resolvedEnv === void 0 ? void 0 : resolvedEnv.aspectPath;
    if (!hostRootDir) {
      this.logger.warn(`env preview template task, hostRootDir is not defined, for env ${envComponent.id.toString()}`);
    }
    return {
      peers,
      html: htmlConfig,
      entries,
      chunking: {
        splitChunks: true
      },
      components: [envComponent],
      outputPath,
      /* It's a path to the root of the host component. */
      hostRootDir,
      hostDependencies: peers,
      aliasHostDependencies: true
    };
  }
  async generateEntries({
    previewRoot,
    workDir,
    peers,
    envDef,
    splitComponentBundle
  }) {
    const previewModules = await this.getPreviewModules(envDef);
    const previewEntries = previewModules.map(_ref => {
      let {
          name,
          path
        } = _ref,
        rest = (0, _objectWithoutProperties2().default)(_ref, ["name", "path"]);
      const linkFile = this.preview.writeLink(name, _component().ComponentMap.create([]), path, workDir, splitComponentBundle);
      return _objectSpread(_objectSpread({
        name,
        path
      }, rest), {}, {
        entry: linkFile
      });
    });
    const peerLink = await (0, _createPeersLink().writePeerLink)(peers, workDir);
    const entries = (0, _chunks().generateTemplateEntries)({
      peers: peerLink,
      previewRootPath: previewRoot,
      previewModules: previewEntries
    });
    return entries;
  }
  async computeResults(context, results) {
    const allResults = results.map(result => {
      const componentsResults = result.components.map(component => {
        return {
          component,
          errors: result.errors.map(err => typeof err === 'string' ? err : err.message),
          warning: result.warnings,
          startTime: result.startTime,
          endTime: result.endTime
        };
      });
      return componentsResults;
    });
    const componentsResults = (0, _lodash().flatten)(allResults);
    const artifacts = getArtifactDef();
    return {
      componentsResults,
      artifacts
    };
  }
  async getPreviewModules(envDef) {
    const previewDefs = this.preview.getDefs();
    const modules = (0, _lodash().compact)(await Promise.all(previewDefs.map(async def => {
      if (!def.renderTemplatePathByEnv) return undefined;
      return {
        name: def.prefix,
        path: await def.renderTemplatePathByEnv(envDef.env),
        include: def.include
      };
    })));
    return modules;
  }
  computeOutputPath(context, component) {
    const capsule = context.capsuleNetwork.graphCapsules.getCapsule(component.id);
    if (!capsule) throw new Error('no capsule found');
    return (0, _path().join)(capsule.path, getArtifactDirectory());
  }
}
exports.EnvPreviewTemplateTask = EnvPreviewTemplateTask;
function getArtifactDirectory() {
  return (0, _path().join)(_builder().CAPSULE_ARTIFACTS_DIR, 'env-template');
}
function getArtifactDef() {
  return [{
    name: 'env-template',
    globPatterns: ['**'],
    rootDir: getArtifactDirectory()
  }];
}

//# sourceMappingURL=env-preview-template.task.js.map