"use strict";

require("core-js/modules/es.array.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateLink = generateLink;
function _toolboxPath() {
  const data = require("@teambit/toolbox.path.to-windows-compatible-path");
  _toolboxPath = function () {
    return data;
  };
  return data;
}
// :TODO refactor to building an AST and generate source code based on it.
function generateLink(prefix, componentMap, mainModule, isSplitComponentBundle = false) {
  const links = componentMap.toArray().map(([component, modulePath], compIdx) => ({
    componentIdentifier: component.id.fullName,
    modules: modulePath.map((path, pathIdx) => ({
      varName: moduleVarName(compIdx, pathIdx),
      resolveFrom: (0, _toolboxPath().toWindowsCompatiblePath)(path)
    }))
  }));
  return `
import { linkModules } from '${(0, _toolboxPath().toWindowsCompatiblePath)(require.resolve('./preview.preview.runtime'))}';
${mainModule ? `import * as mainModule from '${(0, _toolboxPath().toWindowsCompatiblePath)(mainModule)}';` : 'const mainModule = {};'}

${links.map(link => link.modules.map(module => `import * as ${module.varName} from "${module.resolveFrom}";`).join('\n')).filter(line => line !== '') // prevent empty lines
  .join('\n')}

linkModules('${prefix}', {
  mainModule,
  isSplitComponentBundle: ${isSplitComponentBundle},
  componentMap: {
${links
  // must include all components, including empty
  .map(link => `    "${link.componentIdentifier}": [${link.modules.map(module => module.varName).join(', ')}]`).join(',\n')}
  }
});
`;
}
function moduleVarName(componentIdx, fileIdx) {
  return `file_${componentIdx}_${fileIdx}`;
}

//# sourceMappingURL=generate-link.js.map