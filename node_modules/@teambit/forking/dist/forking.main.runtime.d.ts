import { CLIMain } from '@teambit/cli';
import { DependencyResolverMain } from '@teambit/dependency-resolver';
import { Workspace } from '@teambit/workspace';
import { Component, ComponentID, ComponentMain } from '@teambit/component';
import { ComponentIdObj } from '@teambit/component-id';
import { GraphqlMain } from '@teambit/graphql';
import { RefactoringMain } from '@teambit/refactoring';
import { PkgMain } from '@teambit/pkg';
import { NewComponentHelperMain } from '@teambit/new-component-helper';
import { InstallMain } from '@teambit/install';
import { ForkOptions } from './fork.cmd';
export declare type ForkInfo = {
    forkedFrom: ComponentID;
};
declare type MultipleComponentsToFork = Array<{
    sourceId: string;
    targetId?: string;
    path?: string;
}>;
declare type MultipleForkOptions = {
    refactor?: boolean;
    scope?: string;
    install?: boolean;
};
export declare class ForkingMain {
    private workspace;
    private install;
    private dependencyResolver;
    private newComponentHelper;
    private refactoring;
    private pkg;
    constructor(workspace: Workspace, install: InstallMain, dependencyResolver: DependencyResolverMain, newComponentHelper: NewComponentHelperMain, refactoring: RefactoringMain, pkg: PkgMain);
    /**
     * create a new copy of existing/remote component.
     * the new component holds a reference to the old one for future reference.
     * if refactor option is enable, change the source-code to update all dependencies with the new name.
     */
    fork(sourceId: string, targetId?: string, options?: ForkOptions): Promise<ComponentID>;
    /**
     * get the forking data, such as the source where a component was forked from
     */
    getForkInfo(component: Component): ForkInfo | null;
    forkMultipleFromRemote(componentsToFork: MultipleComponentsToFork, options?: MultipleForkOptions): Promise<void>;
    private refactorMultipleAndInstall;
    /**
     * fork all components of the given scope
     */
    forkScope(originalScope: string, newScope: string): Promise<ComponentID[]>;
    private forkExistingInWorkspace;
    private forkRemoteComponent;
    private saveDeps;
    private installDeps;
    private extractDeps;
    private getConfig;
    static slots: never[];
    static dependencies: import("@teambit/harmony").Aspect[];
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static provider([cli, workspace, dependencyResolver, componentMain, newComponentHelper, graphql, refactoring, pkg, install,]: [
        CLIMain,
        Workspace,
        DependencyResolverMain,
        ComponentMain,
        NewComponentHelperMain,
        GraphqlMain,
        RefactoringMain,
        PkgMain,
        InstallMain
    ]): Promise<ForkingMain>;
}
export declare type ForkConfig = {
    forkedFrom: ComponentIdObj;
};
export {};
