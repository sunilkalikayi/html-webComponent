"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ForkingMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");
  _legacyBitId = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = _interopRequireWildcard(require("@teambit/component"));
  _component = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = _interopRequireDefault(require("@teambit/graphql"));
  _graphql = function () {
    return data;
  };
  return data;
}
function _refactoring() {
  const data = _interopRequireDefault(require("@teambit/refactoring"));
  _refactoring = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _pkg() {
  const data = _interopRequireDefault(require("@teambit/pkg"));
  _pkg = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _newComponentHelper() {
  const data = _interopRequireDefault(require("@teambit/new-component-helper"));
  _newComponentHelper = function () {
    return data;
  };
  return data;
}
function _install() {
  const data = require("@teambit/install");
  _install = function () {
    return data;
  };
  return data;
}
function _fork() {
  const data = require("./fork.cmd");
  _fork = function () {
    return data;
  };
  return data;
}
function _forking() {
  const data = require("./forking.aspect");
  _forking = function () {
    return data;
  };
  return data;
}
function _forking2() {
  const data = require("./forking.fragment");
  _forking2 = function () {
    return data;
  };
  return data;
}
function _forking3() {
  const data = require("./forking.graphql");
  _forking3 = function () {
    return data;
  };
  return data;
}
function _scopeFork() {
  const data = require("./scope-fork.cmd");
  _scopeFork = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class ForkingMain {
  constructor(workspace, install, dependencyResolver, newComponentHelper, refactoring, pkg) {
    this.workspace = workspace;
    this.install = install;
    this.dependencyResolver = dependencyResolver;
    this.newComponentHelper = newComponentHelper;
    this.refactoring = refactoring;
    this.pkg = pkg;
  }

  /**
   * create a new copy of existing/remote component.
   * the new component holds a reference to the old one for future reference.
   * if refactor option is enable, change the source-code to update all dependencies with the new name.
   */
  async fork(sourceId, targetId, options) {
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    const sourceCompId = await this.workspace.resolveComponentId(sourceId);
    const exists = this.workspace.exists(sourceCompId);
    if (exists) {
      const existingInWorkspace = await this.workspace.get(sourceCompId);
      return this.forkExistingInWorkspace(existingInWorkspace, targetId, options);
    }
    const sourceIdWithScope = sourceCompId._legacy.scope ? sourceCompId : _component().ComponentID.fromLegacy(_legacyBitId().BitId.parse(sourceId, true));
    const {
      targetCompId,
      component
    } = await this.forkRemoteComponent(sourceIdWithScope, targetId, options);
    await this.saveDeps(component);
    if (!(options !== null && options !== void 0 && options.skipDependencyInstallation)) await this.installDeps();
    return targetCompId;
  }

  /**
   * get the forking data, such as the source where a component was forked from
   */
  getForkInfo(component) {
    var _component$state$aspe;
    const forkConfig = (_component$state$aspe = component.state.aspects.get(_forking().ForkingAspect.id)) === null || _component$state$aspe === void 0 ? void 0 : _component$state$aspe.config;
    if (!forkConfig) return null;
    return {
      forkedFrom: _component().ComponentID.fromObject(forkConfig.forkedFrom)
    };
  }
  async forkMultipleFromRemote(componentsToFork, options = {}) {
    const {
      scope
    } = options;
    const results = await (0, _pMapSeries().default)(componentsToFork, async ({
      sourceId,
      targetId,
      path
    }) => {
      const sourceCompId = await this.workspace.resolveComponentId(sourceId);
      const sourceIdWithScope = sourceCompId._legacy.scope ? sourceCompId : _component().ComponentID.fromLegacy(_legacyBitId().BitId.parse(sourceId, true));
      const {
        targetCompId,
        component
      } = await this.forkRemoteComponent(sourceIdWithScope, targetId, {
        scope,
        path
      });
      return {
        targetCompId,
        sourceId,
        component
      };
    });
    await this.refactorMultipleAndInstall(results, options);
  }
  async refactorMultipleAndInstall(results, options = {}) {
    const oldPackages = [];
    const stringsToReplace = results.map(({
      targetCompId,
      sourceId,
      component
    }) => {
      const oldPackageName = this.pkg.getPackageName(component);
      oldPackages.push(oldPackageName);
      const newName = targetCompId.fullName.replace(/\//g, '.');
      const scopeToReplace = targetCompId.scope.replace('.', '/');
      const newPackageName = `@${scopeToReplace}.${newName}`;
      return [{
        oldStr: oldPackageName,
        newStr: newPackageName
      }, {
        oldStr: sourceId,
        newStr: targetCompId.toStringWithoutVersion()
      }];
    }).flat();
    const allComponents = await this.workspace.list();
    if (options.refactor) {
      const {
        changedComponents
      } = await this.refactoring.replaceMultipleStrings(allComponents, stringsToReplace);
      await Promise.all(changedComponents.map(comp => this.workspace.write(comp)));
    }
    const forkedComponents = results.map(result => result.component);
    const policy = await Promise.all(forkedComponents.map(comp => this.extractDeps(comp)));
    const policyFlatAndUnique = (0, _lodash().uniqBy)(policy.flat(), 'dependencyId');
    const policyWithoutWorkspaceComps = policyFlatAndUnique.filter(dep => !oldPackages.includes(dep.dependencyId));
    this.dependencyResolver.addToRootPolicy(policyWithoutWorkspaceComps, {
      updateExisting: true
    });
    await this.dependencyResolver.persistConfig(this.workspace.path);
    if (options.install) {
      await this.installDeps();
    }
  }

  /**
   * fork all components of the given scope
   */
  async forkScope(originalScope, newScope) {
    const idsFromOriginalScope = await this.workspace.scope.listRemoteScope(originalScope);
    if (!idsFromOriginalScope.length) {
      throw new Error(`unable to find components to fork from ${originalScope}`);
    }
    const workspaceIds = await this.workspace.listIds();
    const workspaceBitIds = _bitId().BitIds.fromArray(workspaceIds.map(id => id._legacy));
    idsFromOriginalScope.forEach(id => {
      const existInWorkspace = workspaceBitIds.searchWithoutScopeAndVersion(id._legacy);
      if (existInWorkspace) {
        throw new Error(`unable to fork "${id.toString()}". the workspace has a component "${existInWorkspace.toString()}" with the same name`);
      }
    });
    const multipleForkInfo = [];
    const components = await this.workspace.scope.getManyRemoteComponents(idsFromOriginalScope);
    await (0, _pMapSeries().default)(components, async component => {
      const config = await this.getConfig(component);
      const targetCompId = _component().ComponentID.fromObject({
        name: component.id.fullName
      }, newScope);
      await this.newComponentHelper.writeAndAddNewComp(component, targetCompId, {
        scope: newScope
      }, config);
      multipleForkInfo.push({
        targetCompId,
        sourceId: component.id.toStringWithoutVersion(),
        component
      });
    });
    await this.refactorMultipleAndInstall(multipleForkInfo, {
      refactor: true,
      install: true
    });
    return multipleForkInfo.map(info => info.targetCompId);
  }
  async forkExistingInWorkspace(existing, targetId, options) {
    if (!targetId) {
      throw new Error(`error: unable to create "${existing.id.toStringWithoutVersion()}" component, a component with the same name already exists.
please specify the target-id arg`);
    }
    const targetCompId = this.newComponentHelper.getNewComponentId(targetId, undefined, options === null || options === void 0 ? void 0 : options.scope);
    const config = await this.getConfig(existing);
    await this.newComponentHelper.writeAndAddNewComp(existing, targetCompId, options, config);
    if (options !== null && options !== void 0 && options.refactor) {
      const allComponents = await this.workspace.list();
      const {
        changedComponents
      } = await this.refactoring.refactorDependencyName(allComponents, existing.id, targetId);
      await Promise.all(changedComponents.map(comp => this.workspace.write(comp)));
    }
    return targetCompId;
  }
  async forkRemoteComponent(sourceId, targetId, options) {
    if (options !== null && options !== void 0 && options.refactor) {
      throw new (_bitError().BitError)(`the component ${sourceId.toStringWithoutVersion()} is not in the workspace, you can't use the --refactor flag.
the reason is that the refactor changes the components using ${sourceId.toStringWithoutVersion()}, since it's not in the workspace, no components were using it, so nothing to refactor`);
    }
    const targetName = targetId || sourceId.fullName;
    const targetCompId = this.newComponentHelper.getNewComponentId(targetName, undefined, options === null || options === void 0 ? void 0 : options.scope);
    const component = await this.workspace.scope.getRemoteComponent(sourceId);
    await this.refactoring.replaceMultipleStrings([component], [{
      oldStr: sourceId.toStringWithoutVersion(),
      newStr: targetCompId.toStringWithoutVersion()
    }]);
    const config = await this.getConfig(component);
    await this.newComponentHelper.writeAndAddNewComp(component, targetCompId, options, config);
    return {
      targetCompId,
      component
    };
  }
  async saveDeps(component) {
    const workspacePolicyEntries = await this.extractDeps(component);
    this.dependencyResolver.addToRootPolicy(workspacePolicyEntries, {
      updateExisting: true
    });
    await this.dependencyResolver.persistConfig(this.workspace.path);
  }
  async installDeps() {
    await this.install.install(undefined, {
      dedupe: true,
      import: false,
      copyPeerToRuntimeOnRoot: true,
      copyPeerToRuntimeOnComponents: false,
      updateExisting: false
    });
  }
  async extractDeps(component) {
    const deps = await this.dependencyResolver.getDependencies(component);
    return deps.filter(dep => dep.source === 'auto').map(dep => {
      var _dep$getPackageName;
      return {
        dependencyId: ((_dep$getPackageName = dep.getPackageName) === null || _dep$getPackageName === void 0 ? void 0 : _dep$getPackageName.call(dep)) || dep.id,
        lifecycleType: dep.lifecycle === 'dev' ? 'runtime' : dep.lifecycle,
        value: {
          version: dep.version
        }
      };
    });
  }
  async getConfig(comp) {
    const fromExisting = await this.newComponentHelper.getConfigFromExistingToNewComponent(comp);
    return _objectSpread(_objectSpread({}, fromExisting), {}, {
      [_forking().ForkingAspect.id]: {
        forkedFrom: comp.id.toObject()
      }
    });
  }
  static async provider([cli, workspace, dependencyResolver, componentMain, newComponentHelper, graphql, refactoring, pkg, install]) {
    var _scopeCommand$command;
    const forkingMain = new ForkingMain(workspace, install, dependencyResolver, newComponentHelper, refactoring, pkg);
    cli.register(new (_fork().ForkCmd)(forkingMain));
    graphql.register((0, _forking3().forkingSchema)(forkingMain));
    componentMain.registerShowFragments([new (_forking2().ForkingFragment)(forkingMain)]);
    const scopeCommand = cli.getCommand('scope');
    scopeCommand === null || scopeCommand === void 0 ? void 0 : (_scopeCommand$command = scopeCommand.commands) === null || _scopeCommand$command === void 0 ? void 0 : _scopeCommand$command.push(new (_scopeFork().ScopeForkCmd)(forkingMain));
    return forkingMain;
  }
}
exports.ForkingMain = ForkingMain;
(0, _defineProperty2().default)(ForkingMain, "slots", []);
(0, _defineProperty2().default)(ForkingMain, "dependencies", [_cli().CLIAspect, _workspace().default, _dependencyResolver().DependencyResolverAspect, _component().default, _newComponentHelper().default, _graphql().default, _refactoring().default, _pkg().default, _install().InstallAspect]);
(0, _defineProperty2().default)(ForkingMain, "runtime", _cli().MainRuntime);
_forking().ForkingAspect.addRuntime(ForkingMain);

//# sourceMappingURL=forking.main.runtime.js.map