"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ApplicationMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _aspectLoader() {
  const data = require("@teambit/aspect-loader");
  _aspectLoader = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("@teambit/builder");
  _builder = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = require("@teambit/envs");
  _envs = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = _interopRequireWildcard(require("@teambit/component"));
  _component = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _application() {
  const data = require("./application.aspect");
  _application = function () {
    return data;
  };
  return data;
}
function _appList() {
  const data = require("./app-list.cmd");
  _appList = function () {
    return data;
  };
  return data;
}
function _build() {
  const data = require("./build.task");
  _build = function () {
    return data;
  };
  return data;
}
function _run() {
  const data = require("./run.cmd");
  _run = function () {
    return data;
  };
  return data;
}
function _application2() {
  const data = require("./application.service");
  _application2 = function () {
    return data;
  };
  return data;
}
function _app() {
  const data = require("./app.cmd");
  _app = function () {
    return data;
  };
  return data;
}
function _app2() {
  const data = require("./app.plugin");
  _app2 = function () {
    return data;
  };
  return data;
}
function _appType() {
  const data = require("./app-type.plugin");
  _appType = function () {
    return data;
  };
  return data;
}
function _appContext() {
  const data = require("./app-context");
  _appContext = function () {
    return data;
  };
  return data;
}
function _deploy() {
  const data = require("./deploy.task");
  _deploy = function () {
    return data;
  };
  return data;
}
function _appNoSsr() {
  const data = require("./exceptions/app-no-ssr");
  _appNoSsr = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class ApplicationMain {
  constructor(appSlot,
  // TODO unused
  appTypeSlot, deploymentProviderSlot, envs, componentAspect, appService, aspectLoader, workspace, logger) {
    this.appSlot = appSlot;
    this.appTypeSlot = appTypeSlot;
    this.deploymentProviderSlot = deploymentProviderSlot;
    this.envs = envs;
    this.componentAspect = componentAspect;
    this.appService = appService;
    this.aspectLoader = aspectLoader;
    this.workspace = workspace;
    this.logger = logger;
    (0, _defineProperty2().default)(this, "defaultOpts", {
      dev: false,
      ssr: false,
      watch: true,
      defaultPortRange: [3100, 3500]
    });
  }

  /**
   * register a new app.
   */
  registerApp(app) {
    this.appSlot.register([app]);
    return this;
  }

  /**
   * list all registered apps.
   */
  listApps() {
    return (0, _lodash().flatten)(this.appSlot.values());
  }

  /**
   * map all apps by component ID.
   */
  mapApps() {
    return this.appSlot.toArray();
  }

  /**
   * list apps by a component id.
   */
  listAppsById(id) {
    if (!id) return undefined;
    return this.appSlot.get(id.toString());
  }

  /**
   * get an application by a component id.
   */
  getAppById(id) {
    const apps = this.listAppsById(id);
    if (!apps) return undefined;
    return (0, _lodash().head)(apps);
  }

  /**
   * get an app.
   */
  getApp(appName, id) {
    const apps = this.listAppsById(id) || this.listApps();
    return apps.find(app => app.name === appName);
  }
  getAppByNameOrId(appNameOrId) {
    const byName = this.getApp(appNameOrId);
    if (byName) return byName;
    const byId = this.appSlot.get(appNameOrId);
    if (!byId || !byId.length) return undefined;
    if (byId.length > 1) {
      throw new (_bitError().BitError)(`unable to figure out what app to retrieve. the id "${appNameOrId}" has more than one app. please use the app-name`);
    }
    return byId[0];
  }

  /**
   * registers a new app and sets a plugin for it.
   */
  registerAppType(appType) {
    const plugin = new (_appType().AppTypePlugin)(`*.${appType.name}.*`, appType, this.appSlot);
    this.aspectLoader.registerPlugins([plugin]);
    this.appTypeSlot.register([appType]);
    return this;
  }

  /**
   * get an app AspectId.
   */
  getAppAspect(appName) {
    var _this$appSlot$toArray;
    return (_this$appSlot$toArray = this.appSlot.toArray().find(([, apps]) => apps.find(app => app.name === appName))) === null || _this$appSlot$toArray === void 0 ? void 0 : _this$appSlot$toArray[0];
  }

  /**
   * get app to throw.
   */
  getAppOrThrow(appName) {
    const app = this.getAppByNameOrId(appName);
    if (!app) throw new (_exceptions().AppNotFound)(appName);
    return app;
  }
  computeOptions(opts = {}) {
    return _objectSpread(_objectSpread({}, this.defaultOpts), opts);
  }
  async runApp(appName, options) {
    options = this.computeOptions(options);
    const app = this.getAppOrThrow(appName);
    const context = await this.createAppContext(app.name);
    if (!context) throw new (_exceptions().AppNotFound)(appName);
    if (options.ssr) {
      if (!app.runSsr) throw new (_appNoSsr().AppNoSsr)(appName);
      const result = await app.runSsr(context);
      return _objectSpread({
        app
      }, result);
    }
    const port = await app.run(context);
    if (options.watch) {
      this.workspace.watcher.watchAll({
        preCompile: false
      }).catch(err => {
        // don't throw an error, we don't want to break the "run" process
        this.logger.error(`compilation failed`, err);
      });
    }
    return {
      app,
      port,
      errors: undefined
    };
  }

  /**
   * get the component ID of a certain app.
   */
  getAppIdOrThrow(appName) {
    const maybeApp = this.appSlot.toArray().find(([, apps]) => {
      return apps.find(app => app.name === appName);
    });
    if (!maybeApp) throw new (_exceptions().AppNotFound)(appName);
    return _component().ComponentID.fromString(maybeApp[0]);
  }
  async createAppContext(appName) {
    const host = this.componentAspect.getHost();
    const components = await host.list();
    const id = this.getAppIdOrThrow(appName);
    const component = components.find(c => c.id.isEqual(id));
    if (!component) throw new (_exceptions().AppNotFound)(appName);
    // console.log(comp)

    const env = await this.envs.createEnvironment([component]);
    const res = await env.run(this.appService);
    const context = res.results[0].data;
    if (!context) throw new (_exceptions().AppNotFound)(appName);
    const hostRootDir = this.workspace.getComponentPackagePath(component);
    const appContext = new (_appContext().AppContext)(appName, context.dev, component, this.workspace.path, context, hostRootDir);
    return appContext;
  }
  static async provider([cli, loggerAspect, builder, envs, component, aspectLoader, workspace], config, [appTypeSlot, appSlot, deploymentProviderSlot]) {
    const logger = loggerAspect.createLogger(_application().ApplicationAspect.id);
    const appService = new (_application2().AppService)();
    const application = new ApplicationMain(appSlot, appTypeSlot, deploymentProviderSlot, envs, component, appService, aspectLoader, workspace, logger);
    const appCmd = new (_app().AppCmd)();
    appCmd.commands = [new (_app().AppListCmd)(application), new (_run().RunCmd)(application, logger)];
    aspectLoader.registerPlugins([new (_app2().AppPlugin)(appSlot)]);
    builder.registerBuildTasks([new (_build().AppsBuildTask)(application)]);
    builder.registerSnapTasks([new (_deploy().DeployTask)(application, builder)]);
    builder.registerTagTasks([new (_deploy().DeployTask)(application, builder)]);
    cli.registerGroup('apps', 'Applications');
    cli.register(new (_run().RunCmd)(application, logger), new (_appList().AppListCmdDeprecated)(application), appCmd);
    if (workspace) {
      workspace.onComponentLoad(async loadedComponent => {
        const app = application.getAppById(loadedComponent.id);
        if (!app) return {};
        return {
          appName: app === null || app === void 0 ? void 0 : app.name,
          type: app === null || app === void 0 ? void 0 : app.applicationType
        };
      });
    }
    return application;
  }
}
exports.ApplicationMain = ApplicationMain;
(0, _defineProperty2().default)(ApplicationMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(ApplicationMain, "dependencies", [_cli().CLIAspect, _logger().LoggerAspect, _builder().BuilderAspect, _envs().EnvsAspect, _component().default, _aspectLoader().AspectLoaderAspect, _workspace().default]);
(0, _defineProperty2().default)(ApplicationMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType()]);
_application().ApplicationAspect.addRuntime(ApplicationMain);

//# sourceMappingURL=application.main.runtime.js.map