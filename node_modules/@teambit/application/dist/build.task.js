"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat-map.js");
require("core-js/modules/es.array.unscopables.flat-map.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BUILD_TASK = exports.AppsBuildTask = exports.ARTIFACTS_DIR_NAME = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("@teambit/builder");
  _builder = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _application() {
  const data = require("./application.aspect");
  _application = function () {
    return data;
  };
  return data;
}
const BUILD_TASK = 'build_application';
exports.BUILD_TASK = BUILD_TASK;
const ARTIFACTS_DIR_NAME = 'apps';
exports.ARTIFACTS_DIR_NAME = ARTIFACTS_DIR_NAME;
class AppsBuildTask {
  constructor(application, opt = {
    deploy: true
  }) {
    this.application = application;
    this.opt = opt;
    (0, _defineProperty2().default)(this, "name", BUILD_TASK);
    (0, _defineProperty2().default)(this, "aspectId", _application().ApplicationAspect.id);
    (0, _defineProperty2().default)(this, "location", 'end');
  }
  async execute(context) {
    const apps = this.application.listApps();
    const {
      capsuleNetwork
    } = context;
    const componentsResults = await (0, _pMapSeries().default)(apps, async app => {
      const aspectId = this.application.getAppAspect(app.name);
      if (!aspectId) return undefined;
      const capsule = capsuleNetwork.seedersCapsules.getCapsuleIgnoreVersion(_component().ComponentID.fromString(aspectId));
      if (!capsule || !app.build) return undefined;
      const {
        component
      } = capsule;
      const appDeployContext = Object.assign(context, {
        capsule,
        appComponent: component,
        name: app.name,
        artifactsDir: this.getArtifactDirectory()
      });
      const deployContext = await app.build(appDeployContext);
      const defaultArtifacts = this.getDefaultArtifactDef(app.applicationType || app.name);
      const artifacts = defaultArtifacts.concat(deployContext.artifacts || []);
      return {
        artifacts,
        componentResult: {
          component: capsule.component,
          errors: deployContext.errors,
          warnings: deployContext.warnings,
          /**
           * @guysaar223
           * @ram8
           * TODO: we need to think how to pass private metadata between build pipes, maybe create shared context
           * or create new deploy context on builder
           */
          // @ts-ignore
          _metadata: {
            deployContext
          }
        }
      };
    });
    const artifacts = componentsResults.flatMap(res => {
      return res === null || res === void 0 ? void 0 : res.artifacts;
    }).filter(a => !!a);
    const _componentsResults = componentsResults.map(res => {
      return res === null || res === void 0 ? void 0 : res.componentResult;
    }).filter(a => !!a);
    return {
      artifacts,
      componentsResults: _componentsResults
    };
  }
  getArtifactDirectory() {
    return (0, _path().join)(_builder().CAPSULE_ARTIFACTS_DIR, ARTIFACTS_DIR_NAME);
  }
  getDefaultArtifactDef(nameSuffix) {
    return [{
      name: `app-build-${nameSuffix}`,
      globPatterns: ['**'],
      rootDir: this.getArtifactDirectory()
    }];
  }
}
exports.AppsBuildTask = AppsBuildTask;

//# sourceMappingURL=build.task.js.map