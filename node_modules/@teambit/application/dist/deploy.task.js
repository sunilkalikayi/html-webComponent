"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DeployTask = exports.DEPLOY_TASK = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _application() {
  const data = require("./application.aspect");
  _application = function () {
    return data;
  };
  return data;
}
function _build() {
  const data = require("./build.task");
  _build = function () {
    return data;
  };
  return data;
}
const DEPLOY_TASK = 'deploy_application';
exports.DEPLOY_TASK = DEPLOY_TASK;
class DeployTask {
  constructor(application, builder) {
    this.application = application;
    this.builder = builder;
    (0, _defineProperty2().default)(this, "name", DEPLOY_TASK);
    (0, _defineProperty2().default)(this, "aspectId", _application().ApplicationAspect.id);
    (0, _defineProperty2().default)(this, "location", 'end');
  }
  async execute(context) {
    const apps = this.application.listApps();
    const componentsResults = await (0, _pMapSeries().default)(apps, async app => {
      var _componentResults$_me;
      const aspectId = this.application.getAppAspect(app.name);
      if (!aspectId) return undefined;
      const capsule = context.capsuleNetwork.seedersCapsules.getCapsuleIgnoreVersion(_component().ComponentID.fromString(aspectId));
      if (!capsule || !(capsule !== null && capsule !== void 0 && capsule.component)) return undefined;
      const buildTask = this.getBuildTask(context.previousTasksResults, context.envRuntime.id);
      if (!buildTask) return undefined;
      const componentResults = buildTask.componentsResults.find(res => res.component.id.isEqual(capsule.component.id, {
        ignoreVersion: true
      }));
      /**
       * @guysaar223
       * @ram8
       * TODO: we need to think how to pass private metadata between build pipes, maybe create shared context
       * or create new deploy context on builder
       */
      // @ts-ignore
      const _metadata = (componentResults === null || componentResults === void 0 ? void 0 : (_componentResults$_me = componentResults._metadata) === null || _componentResults$_me === void 0 ? void 0 : _componentResults$_me.deployContext) || {};
      const appDeployContext = Object.assign(context, _metadata, {
        capsule,
        appComponent: capsule.component
      });
      if (!app.deploy) return undefined;
      await app.deploy(appDeployContext);
      return {
        componentResult: {
          component: capsule.component
        }
      };
    });
    const _componentsResults = componentsResults.map(res => {
      return res === null || res === void 0 ? void 0 : res.componentResult;
    }).filter(a => !!a);
    return {
      componentsResults: _componentsResults
    };
  }
  getBuildTask(taskResults, runtime) {
    return taskResults.find(({
      task,
      env
    }) => task.aspectId === _application().ApplicationAspect.id && task.name === _build().BUILD_TASK && env.id === runtime);
  }
}
exports.DeployTask = DeployTask;

//# sourceMappingURL=deploy.task.js.map