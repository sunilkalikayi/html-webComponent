import { Component, ComponentID } from '@teambit/component';
import { Graph, Node, Edge } from '@teambit/graph.cleargraph';
import { Dependency } from '../model/dependency';
import { DuplicateDependency } from '../duplicate-dependency';
export declare const DEPENDENCIES_TYPES: string[];
declare type ComponentNode = Node<Component>;
declare type DependencyEdge = Edge<Dependency>;
export declare class ComponentGraph extends Graph<Component, Dependency> {
    seederIds: ComponentID[];
    constructor(nodes?: ComponentNode[], edges?: DependencyEdge[]);
    protected create(nodes?: ComponentNode[], edges?: DependencyEdge[]): this;
    /**
     * check all the routes from the sources to targets and return the components found during this traversal.
     * e.g.
     * A -> B -> C -> N.
     * A -> E -> N.
     * B -> F -> G.
     * given source: A, targets: N. The results will be: B, C, E
     */
    findIdsFromSourcesToTargets(sources: ComponentID[], targets: ComponentID[]): ComponentID[];
    /**
     * overrides the super class to eliminate non-seeders components
     */
    findCycles(graph?: this): string[][];
    findDuplicateDependencies(): Map<string, DuplicateDependency>;
    buildFromCleargraph(graph: Graph<Component, Dependency>): ComponentGraph;
    runtimeOnly(componentIds: string[]): this;
    private shouldLimitToSeedersOnly;
    private calculateVersionMap;
}
export {};
