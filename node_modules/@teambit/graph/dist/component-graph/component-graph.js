"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEPENDENCIES_TYPES = exports.ComponentGraph = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _graph() {
  const data = require("@teambit/graph.cleargraph");
  _graph = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _duplicateDependency() {
  const data = require("../duplicate-dependency");
  _duplicateDependency = function () {
    return data;
  };
  return data;
}
const DEPENDENCIES_TYPES = ['dependencies', 'devDependencies'];
exports.DEPENDENCIES_TYPES = DEPENDENCIES_TYPES;
class ComponentGraph extends _graph().Graph {
  // component IDs that started the graph. (if from workspace, the .bitmap ids normally)
  constructor(nodes = [], edges = []) {
    super(nodes, edges);
    (0, _defineProperty2().default)(this, "seederIds", []);
  }
  create(nodes = [], edges = []) {
    return new ComponentGraph(nodes, edges);
  }

  /**
   * check all the routes from the sources to targets and return the components found during this traversal.
   * e.g.
   * A -> B -> C -> N.
   * A -> E -> N.
   * B -> F -> G.
   * given source: A, targets: N. The results will be: B, C, E
   */
  findIdsFromSourcesToTargets(sources, targets) {
    const removeVerFromIdStr = idStr => idStr.split('@')[0];
    const sourcesStr = sources.map(s => s.toStringWithoutVersion());
    const targetsStr = targets.map(t => t.toStringWithoutVersion());
    const allFlattened = sources.map(source => this.successors(source.toString())).flat();
    const allFlattenedIds = (0, _lodash().uniq)(allFlattened.map(f => f.id));
    const results = [];
    allFlattenedIds.forEach(id => {
      const idWithNoVer = removeVerFromIdStr(id);
      if (sourcesStr.includes(idWithNoVer) || targetsStr.includes(idWithNoVer)) return;
      const allSuccessors = this.successors(id);
      const allSuccessorsWithNoVersion = allSuccessors.map(s => removeVerFromIdStr(s.id));
      if (allSuccessorsWithNoVersion.find(s => targetsStr.includes(s))) results.push(id);
    });
    const components = this.getNodes(results).map(n => n.attr);
    return components.map(c => c.id);
  }

  /**
   * overrides the super class to eliminate non-seeders components
   */
  findCycles(graph) {
    const cycles = super.findCycles(graph);
    if (!this.shouldLimitToSeedersOnly()) {
      return cycles;
    }
    const seederIdsStr = this.seederIds.map(id => id.toString());
    const cyclesWithSeeders = cycles.filter(cycle => {
      return cycle.some(cycleIdStr => seederIdsStr.includes(cycleIdStr));
    });
    return cyclesWithSeeders;
  }
  findDuplicateDependencies() {
    const versionMap = this.calculateVersionMap();
    const seederIdsNoVersions = this.seederIds.map(id => id.toStringWithoutVersion());
    const duplicateDependencies = new Map();
    for (const [compFullName, versions] of versionMap) {
      if (versions.allVersionNodes.length > 1) {
        const versionSubgraphs = [];
        const notLatestVersions = versions.allVersionNodes.filter(version => version !== versions.latestVersionNode);
        notLatestVersions.forEach(version => {
          const predecessors = this.predecessorsSubgraph(version);
          const immediatePredecessors = this.predecessors(version).map(predecessor => predecessor.id);
          const subGraph = this.buildFromCleargraph(predecessors);
          const versionSubgraph = {
            versionId: version,
            subGraph,
            // TODO: validate that this is working correctly
            immediateDependents: immediatePredecessors
          };
          versionSubgraphs.push(versionSubgraph);
        });
        const isSeeder = seederIdsNoVersions.includes(compFullName);
        const shouldDisplayDueToBeingSeeder = !this.shouldLimitToSeedersOnly() || isSeeder;
        if (shouldDisplayDueToBeingSeeder && versionSubgraphs.length > 0) {
          const duplicateDep = new (_duplicateDependency().DuplicateDependency)(versions.latestVersionNode, versionSubgraphs);
          duplicateDependencies.set(compFullName, duplicateDep);
        }
      }
    }
    return duplicateDependencies;
  }
  buildFromCleargraph(graph) {
    return this.create(graph.nodes, graph.edges);
  }
  runtimeOnly(componentIds) {
    return this.successorsSubgraph(componentIds, {
      edgeFilter: edge => edge.attr.type === 'runtime'
    });
  }
  shouldLimitToSeedersOnly() {
    return this.seederIds.length;
  }
  calculateVersionMap() {
    const versionMap = new Map();
    for (const node of this.nodes) {
      const comp = node.attr;
      const compKey = node.id;
      const compFullName = comp.id._legacy.toStringWithoutVersion();
      if (!versionMap.has(compFullName)) {
        versionMap.set(compFullName, {
          allVersionNodes: [compKey],
          latestVersionNode: compKey
        });
      } else {
        const value = versionMap.get(compFullName);
        if (value) {
          var _this$node;
          if (Object.prototype.hasOwnProperty.call(value, 'allVersionNodes')) {
            value.allVersionNodes.push(compKey);
          }
          const currentComp = comp;
          const latestComp = (_this$node = this.node(value.latestVersionNode)) === null || _this$node === void 0 ? void 0 : _this$node.attr;
          // @todo: this check won't work when the component doesn't have head.
          // it happens when a dependency is needed in an old version (not head). which Bit doesn't fetch the head
          // Version object, and as a result, the `Component.head` is empty.
          // for now it's probably good enough because it's used only for `findDuplicateDependencies`, which only
          // checks the components on the workspace.
          if (currentComp.head && latestComp !== null && latestComp !== void 0 && latestComp.head && new Date(currentComp.head.timestamp) > new Date(latestComp.head.timestamp)) {
            value.latestVersionNode = compKey;
          }
        }
      }
    }
    return versionMap;
  }
}
exports.ComponentGraph = ComponentGraph;

//# sourceMappingURL=component-graph.js.map