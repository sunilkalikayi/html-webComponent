"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.graphSchema = graphSchema;
function _graphqlTag() {
  const data = _interopRequireDefault(require("graphql-tag"));
  _graphqlTag = function () {
    return data;
  };
  return data;
}
function _edgeType() {
  const data = require("./edge-type");
  _edgeType = function () {
    return data;
  };
  return data;
}
const textCmp = new Intl.Collator().compare;
function graphSchema(graphBuilder, componentAspect) {
  return {
    typeDefs: (0, _graphqlTag().default)`
      type ComponentGraph {
        nodes: [ComponentGraphNode]
        edges: [ComponentGraphEdge]
      }

      type ComponentGraphNode {
        id: String
        component: Component
      }

      enum DependencyLifecycleType {
        PEER
        RUNTIME
        DEV
      }

      type ComponentGraphEdge {
        sourceId: String
        targetId: String
        dependencyLifecycleType: DependencyLifecycleType
      }

      extend type Query {
        graph(ids: [String], filter: String): ComponentGraph
      }
    `,
    resolvers: {
      ComponentGraph: {
        nodes: graph => {
          return graph.nodes.map(node => {
            return {
              id: node.id,
              component: node.attr
            };
          }).sort((a, b) => textCmp(a.id, b.id));
        },
        edges: graph => {
          return graph.edges.map(edge => ({
            sourceId: edge.sourceId,
            targetId: edge.targetId,
            dependencyLifecycleType: getDependencyLifecycleType(edge.attr.type)
          })).sort((a, b) => textCmp(a.sourceId, b.sourceId)).sort((a, b) => textCmp(a.targetId, b.targetId));
        }
      },
      Query: {
        graph: async (_parent, {
          ids,
          filter
        }) => {
          const componentsHost = componentAspect.getHost();
          const resolvedIds = ids ? await componentsHost.resolveMultipleComponentIds(ids) : (await componentsHost.list()).map(x => x.id);
          const graph = await graphBuilder.getGraph(resolvedIds);
          if (!graph) return undefined;
          if (filter === 'runtimeOnly') {
            const runtimeGraph = graph.runtimeOnly(resolvedIds.map(x => x.toString()));
            return runtimeGraph;
          }
          return graph;
        }
      }
    }
  };
}
function getDependencyLifecycleType(edgeRawData) {
  if (edgeRawData === 'dev') return _edgeType().EdgeType.dev;
  if (edgeRawData === 'runtime') return _edgeType().EdgeType.runtime;
  return _edgeType().EdgeType.peer;
}

//# sourceMappingURL=graph.graphql.js.map