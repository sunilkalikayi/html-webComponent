"use strict";

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IdGraph = void 0;
exports.bitObjectListToGraph = bitObjectListToGraph;
exports.objectListToGraph = objectListToGraph;
function _graph() {
  const data = require("@teambit/graph.cleargraph");
  _graph = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _traverseVersions() {
  const data = require("@teambit/legacy/dist/scope/component-ops/traverse-versions");
  _traverseVersions = function () {
    return data;
  };
  return data;
}
function _dependency() {
  const data = require("./model/dependency");
  _dependency = function () {
    return data;
  };
  return data;
}
class IdGraph extends _graph().Graph {
  constructor(nodes = [], edges = []) {
    super(nodes, edges);
  }
}
exports.IdGraph = IdGraph;
async function objectListToGraph(objectList) {
  const bitObjectsList = await objectList.toBitObjects();
  return bitObjectListToGraph(bitObjectsList);
}
async function bitObjectListToGraph(bitObjectsList) {
  const exportMetadata = bitObjectsList.getExportMetadata();
  const components = bitObjectsList.getComponents();
  const versions = bitObjectsList.getVersions();
  const nodes = [];
  const edges = [];
  await Promise.all(components.map(async component => {
    const compFromMetadata = exportMetadata === null || exportMetadata === void 0 ? void 0 : exportMetadata.exportVersions.find(c => c.id.isEqualWithoutVersion(component.toBitId()));
    const startFrom = compFromMetadata === null || compFromMetadata === void 0 ? void 0 : compFromMetadata.head;
    const versionsInfo = await (0, _traverseVersions().getAllVersionsInfo)({
      modelComponent: component,
      versionObjects: versions,
      startFrom,
      throws: false
    });
    versionsInfo.forEach(versionInfo => {
      const id = component.toBitId().changeVersion(versionInfo.tag || versionInfo.ref.toString());
      const idStr = id.toString();
      nodes.push(new (_graph().Node)(idStr, id));
      if (!versionInfo.version) {
        return;
      }
      const {
        dependencies,
        devDependencies,
        extensionDependencies
      } = versionInfo.version.depsIdsGroupedByType;
      const addDep = (depId, edge) => {
        const depIdStr = depId.toString();
        nodes.push(new (_graph().Node)(depIdStr, depId));
        edges.push(new (_graph().Edge)(idStr, depIdStr, edge));
      };
      const runTime = new (_dependency().Dependency)('runtime');
      const dev = new (_dependency().Dependency)('dev');
      dependencies.forEach(depId => addDep(depId, runTime));
      [...devDependencies, ...extensionDependencies].forEach(depId => addDep(depId, dev));
    });
  }));
  const uniqNodes = (0, _lodash().uniqBy)(nodes, 'id');
  const idGraph = new IdGraph(uniqNodes, edges);
  return idGraph;
}

//# sourceMappingURL=object-list-to-graph.js.map