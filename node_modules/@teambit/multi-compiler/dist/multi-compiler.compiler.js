"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat-map.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat-map.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MultiCompiler = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _pipelinesModules() {
  const data = require("@teambit/pipelines.modules.merge-component-results");
  _pipelinesModules = function () {
    return data;
  };
  return data;
}
class MultiCompiler {
  constructor(id, compilers, compilerOptions = {}, options = {}) {
    this.id = id;
    this.compilers = compilers;
    this.compilerOptions = compilerOptions;
    this.options = options;
    (0, _defineProperty2().default)(this, "displayName", 'Multi compiler');
    (0, _defineProperty2().default)(this, "shouldCopyNonSupportedFiles", typeof this.compilerOptions.shouldCopyNonSupportedFiles === 'boolean' ? this.compilerOptions.shouldCopyNonSupportedFiles : true);
    (0, _defineProperty2().default)(this, "distDir", 'dist');
  }
  getDistDir() {
    return this.distDir;
  }
  getArtifactDefinition() {
    return [{
      generatedBy: this.id,
      name: this.compilerOptions.artifactName || 'dist',
      globPatterns: this.compilerOptions.distGlobPatterns || [`${this.distDir}/**`, `!${this.distDir}/tsconfig.tsbuildinfo`]
    }];
  }
  getOptions() {
    const defaultOpts = {
      targetExtension: '.js'
    };
    return Object.assign(defaultOpts, this.options);
  }
  displayConfig() {
    return this.compilers.map(compiler => {
      return `${compiler.displayName}\n${compiler.displayConfig}\n`;
    }).join('\n');
  }

  /**
   * the multi-compiler applies all applicable defined compilers on given content.
   */
  transpileFile(fileContent, options) {
    const outputs = this.compilers.reduce((files, compiler) => {
      if (!compiler.transpileFile) {
        return files;
      }
      return files === null || files === void 0 ? void 0 : files.flatMap(file => {
        var _compiler$transpileFi;
        if (!compiler.isFileSupported(file === null || file === void 0 ? void 0 : file.outputPath)) return [file];
        const params = Object.assign({}, options, {
          filePath: file.outputPath
        });
        const compiledContent = (_compiler$transpileFi = compiler.transpileFile) === null || _compiler$transpileFi === void 0 ? void 0 : _compiler$transpileFi.call(compiler, file.outputText, params);
        if (!compiledContent) return null;
        return compiledContent;
      });
    }, [{
      outputText: fileContent,
      outputPath: options.filePath
    }]);
    return outputs;
  }
  async transpileComponent(params) {
    await Promise.all(this.compilers.map(compiler => {
      var _compiler$transpileCo;
      return (_compiler$transpileCo = compiler.transpileComponent) === null || _compiler$transpileCo === void 0 ? void 0 : _compiler$transpileCo.call(compiler, params);
    }));
  }
  async build(context) {
    const builds = await (0, _pMapSeries().default)(this.compilers, async compiler => {
      const buildResult = await compiler.build(context);
      return buildResult.componentsResults;
    });
    return {
      componentsResults: (0, _pipelinesModules().mergeComponentResults)(builds),
      artifacts: this.getArtifactDefinition()
    };
  }
  async preBuild(context) {
    await Promise.all(this.compilers.map(async compiler => {
      if (!compiler.preBuild) return;
      await compiler.preBuild(context);
    }));
  }
  async postBuild(context, taskResults) {
    await Promise.all(this.compilers.map(async compiler => {
      if (!compiler.postBuild) return;
      await compiler.postBuild(context, taskResults);
    }));
  }
  firstMatchedCompiler(filePath) {
    return this.compilers.find(compiler => compiler.isFileSupported(filePath));
  }
  getPreviewComponentRootPath(component) {
    const matchedCompiler = this.compilers.find(compiler => typeof compiler.getPreviewComponentRootPath !== 'undefined');
    if (!matchedCompiler) {
      return '';
    }

    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return matchedCompiler.getPreviewComponentRootPath(component);
  }

  /**
   * given a source file, return its parallel in the dists. e.g. "index.ts" => "dist/index.js"
   * both, the return path and the given path are relative paths.
   */
  getDistPathBySrcPath(srcPath) {
    const matchedCompiler = this.firstMatchedCompiler(srcPath);
    if (!matchedCompiler) {
      return (0, _path().join)(this.distDir, srcPath);
    }
    return matchedCompiler.getDistPathBySrcPath(srcPath);
  }

  /**
   * only supported files matching get compiled. others, are copied to the dist dir.
   */
  isFileSupported(filePath) {
    return !!this.firstMatchedCompiler(filePath);
  }

  /**
   * returns the version of the current compiler instance (e.g. '4.0.1').
   */
  version() {
    return this.compilers.map(compiler => {
      return `${compiler.displayName}@${compiler.version()}`;
    }).join('\n');
  }
}
exports.MultiCompiler = MultiCompiler;

//# sourceMappingURL=multi-compiler.compiler.js.map