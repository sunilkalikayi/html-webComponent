"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UpdateDependenciesMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = require("@teambit/scope");
  _scope = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("@teambit/builder");
  _builder = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _snapping() {
  const data = require("@teambit/snapping");
  _snapping = function () {
    return data;
  };
  return data;
}
function _componentVersion() {
  const data = require("@teambit/component-version");
  _componentVersion = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _semverHelper() {
  const data = require("@teambit/legacy/dist/utils/semver-helper");
  _semverHelper = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _export() {
  const data = require("@teambit/export");
  _export = function () {
    return data;
  };
  return data;
}
function _lanes() {
  const data = require("@teambit/lanes");
  _lanes = function () {
    return data;
  };
  return data;
}
function _config() {
  const data = require("@teambit/legacy/dist/consumer/config");
  _config = function () {
    return data;
  };
  return data;
}
function _updateDependencies() {
  const data = require("./update-dependencies.cmd");
  _updateDependencies = function () {
    return data;
  };
  return data;
}
function _updateDependencies2() {
  const data = require("./update-dependencies.aspect");
  _updateDependencies2 = function () {
    return data;
  };
  return data;
}
class UpdateDependenciesMain {
  constructor(scope, logger, builder, dependencyResolver, onPostUpdateDependenciesSlot, snapping, lanes, exporter) {
    this.scope = scope;
    this.logger = logger;
    this.builder = builder;
    this.dependencyResolver = dependencyResolver;
    this.onPostUpdateDependenciesSlot = onPostUpdateDependenciesSlot;
    this.snapping = snapping;
    this.lanes = lanes;
    this.exporter = exporter;
    (0, _defineProperty2().default)(this, "depsUpdateItems", void 0);
    (0, _defineProperty2().default)(this, "updateDepsOptions", void 0);
    (0, _defineProperty2().default)(this, "laneObj", void 0);
  }

  /**
   * we assume this is running from a new bare scope. so we import everything and then start working.
   * we don't want this to be running from the original scope (like bit-sign). this command tags or
   * snaps the results, a process that takes some time due to the build pipeline. if we start the
   * tag on the original scope, build and then save the tag to the filesystem, we might get another
   * tag during the process and our tag could override it.
   */
  async updateDependenciesVersions(depsUpdateItemsRaw, updateDepsOptions) {
    this.updateDepsOptions = updateDepsOptions;
    await this.validateScopeIsNew();
    await this.setLaneObject();
    await this.importAllMissing(depsUpdateItemsRaw);
    this.depsUpdateItems = await this.parseDevUpdatesItems(depsUpdateItemsRaw);
    await this.updateFutureVersion();
    await this.updateAllDeps();
    this.addLogToComponents();
    if (!updateDepsOptions.simulation) {
      await this.snapping._addFlattenedDependenciesToComponents(this.scope.legacyScope, this.legacyComponents);
    }
    this.addBuildStatus();
    await this.addComponentsToScope();
    await this.updateComponents();
    await (0, _pMapSeries().default)(this.components, component => this.scope.loadComponentsAspect(component));
    const {
      builderDataMap,
      pipeResults
    } = await this.builder.tagListener(this.components, {
      throwOnError: true
    },
    // we might change it later to not throw.
    {
      seedersOnly: true
    });
    const legacyBuildResults = this.scope.builderDataMapToLegacyOnTagResults(builderDataMap);
    this.snapping._updateComponentsByTagResult(this.legacyComponents, legacyBuildResults);
    const publishedPackages = this.snapping._getPublishedPackages(this.legacyComponents);
    const pipeWithError = pipeResults.find(pipe => pipe.hasErrors());
    const buildStatus = pipeWithError ? _constants().BuildStatus.Failed : _constants().BuildStatus.Succeed;
    await this.saveDataIntoLocalScope(buildStatus);
    await this.export();
    await this.triggerOnPostUpdateDependencies();
    return {
      depsUpdateItems: this.depsUpdateItems,
      publishedPackages,
      error: pipeWithError ? pipeWithError.getErrorMessageFormatted() : null
    };
  }
  get legacyComponents() {
    return this.depsUpdateItems.map(d => d.component.state._consumer);
  }
  get components() {
    return this.depsUpdateItems.map(d => d.component);
  }
  registerOnPostUpdateDependencies(fn) {
    this.onPostUpdateDependenciesSlot.register(fn);
  }
  async setLaneObject() {
    if (this.updateDepsOptions.lane) {
      const laneId = _laneId().LaneId.parse(this.updateDepsOptions.lane);
      this.laneObj = await this.lanes.importLaneObject(laneId);
      // this is critical. otherwise, later on, when loading aspects and isolating capsules, we'll try to fetch dists
      // from the original scope instead of the lane-scope.
      this.scope.legacyScope.setCurrentLaneId(laneId);
    }
  }
  async validateScopeIsNew() {
    if (this.updateDepsOptions.skipNewScopeValidation) {
      return;
    }
    const ids = await this.scope.listIds();
    if (ids.length) {
      // it means this scope is a real remote scope with components, not just cache
      throw new Error(`unable to run update-dependencies command on an existing scope "${this.scope.name}".
please create a new scope (bit init --bare) and run it from there.
to bypass this error, use --skip-new-scope-validation flag (not recommended. it could corrupt the components irreversibly)`);
    }
  }
  async triggerOnPostUpdateDependencies() {
    await Promise.all(this.onPostUpdateDependenciesSlot.values().map(fn => fn(this.components))).catch(err => this.logger.error('got an error during on-post-updates hook', err));
  }
  async importAllMissing(depsUpdateItemsRaw) {
    const componentIds = depsUpdateItemsRaw.map(d => _component().ComponentID.fromString(d.componentId));
    const idsToImport = componentIds;
    if (!this.updateDepsOptions.simulation) {
      const dependenciesIds = depsUpdateItemsRaw.map(item => item.dependencies.map(dep => _component().ComponentID.fromString(dep)).map(id => id.changeVersion(_constants().LATEST)));
      idsToImport.push(...(0, _lodash().flatten)(dependenciesIds));
    }
    // do not use cache. for dependencies we must fetch the latest ModelComponent from the remote
    // in order to match the semver later.
    await this.scope.import(idsToImport, {
      useCache: false,
      lane: this.laneObj
    });
  }
  async addComponentsToScope() {
    await (0, _pMapSeries().default)(this.legacyComponents, component => this.snapping._addCompFromScopeToObjects(component, this.laneObj || null));
  }
  async updateComponents() {
    await (0, _pMapSeries().default)(this.depsUpdateItems, async depUpdateItem => {
      const legacyComp = depUpdateItem.component.state._consumer;
      depUpdateItem.component = await this.scope.getFromConsumerComponent(legacyComp);
    });
  }
  addBuildStatus() {
    this.legacyComponents.forEach(c => {
      c.buildStatus = _constants().BuildStatus.Pending;
    });
  }
  addLogToComponents() {
    this.legacyComponents.forEach(component => {
      component.log = {
        username: this.updateDepsOptions.username || 'ci',
        email: this.updateDepsOptions.email || 'ci@bit.dev',
        message: this.updateDepsOptions.message || 'update-dependencies',
        date: Date.now().toString()
      };
    });
  }
  async updateAllDeps() {
    const components = this.depsUpdateItems.map(d => d.component);
    // current bit ids are needed because we might update multiple components that are depend on
    // each other. in which case, we want the dependency version to be the same as the currently
    // tagged/snapped component.
    const currentBitIds = components.map(c => c.id._legacy);
    await (0, _pMapSeries().default)(this.depsUpdateItems, async ({
      component,
      dependencies
    }) => {
      await this.updateDependenciesVersionsOfComponent(component, dependencies, currentBitIds);
      await this.updateDependencyResolver(component);
    });
  }
  async parseDevUpdatesItems(depsUpdateItemsRaw) {
    this.logger.setStatusLine(`loading ${depsUpdateItemsRaw.length} components and their aspects...`);
    return (0, _pMapSeries().default)(depsUpdateItemsRaw, async depUpdateItemRaw => {
      const componentId = _component().ComponentID.fromString(depUpdateItemRaw.componentId);
      const component = await this.scope.load(componentId);
      if (!component) throw new (_scope().ComponentNotFound)(componentId);
      const dependencies = await Promise.all(depUpdateItemRaw.dependencies.map(dep => this.getDependencyWithExactVersion(dep)));
      return {
        component,
        dependencies,
        versionToTag: depUpdateItemRaw.versionToTag
      };
    });
  }
  async getDependencyWithExactVersion(depStr) {
    const compId = _component().ComponentID.fromString(depStr);
    if (this.updateDepsOptions.simulation) {
      // for simulation, we don't have the objects of the dependencies, so don't try to find the
      // exact version, expect the entered version to be okay.
      return compId;
    }
    if ((0, _componentVersion().isHash)(compId.version)) {
      return compId;
    }
    const range = compId.version || '*'; // if not version specified, assume the latest
    const id = compId.changeVersion(undefined);
    const exactVersion = await this.scope.getExactVersionBySemverRange(id, range);
    if (!exactVersion) {
      throw new Error(`unable to find a version that satisfies "${range}" of "${depStr}"`);
    }
    return compId.changeVersion(exactVersion);
  }
  async updateFutureVersion() {
    this.logger.setStatusLine(`updateFutureVersion...`);
    await (0, _pMapSeries().default)(this.depsUpdateItems, async depUpdateItem => {
      const legacyComp = depUpdateItem.component.state._consumer;
      const modelComponent = await this.scope.legacyScope.getModelComponent(legacyComp.id);
      if (this.updateDepsOptions.tag) {
        const {
          releaseType,
          exactVersion
        } = (0, _semverHelper().getValidVersionOrReleaseType)(depUpdateItem.versionToTag || 'patch');
        legacyComp.version = modelComponent.getVersionToAdd(releaseType, exactVersion);
      } else {
        // snap is the default
        legacyComp.version = modelComponent.getSnapToAdd();
      }
    });
  }
  async updateDependencyResolver(component) {
    const dependenciesList = await this.dependencyResolver.extractDepsFromLegacy(component);
    const dependencies = dependenciesList.serialize();
    const extId = _dependencyResolver().DependencyResolverAspect.id;
    const data = {
      dependencies
    };
    const existingExtension = component.state._consumer.extensions.findExtension(extId);
    if (existingExtension) {
      // Only merge top level of extension data
      Object.assign(existingExtension.data, data);
      return;
    }
    const extension = new (_config().ExtensionDataEntry)(undefined, undefined, extId, undefined, data);
    component.state._consumer.extensions.push(extension);
  }
  async updateDependenciesVersionsOfComponent(component, dependencies, currentBitIds) {
    const depsBitIds = dependencies.map(d => d._legacy);
    const updatedIds = _bitId().BitIds.fromArray([...currentBitIds, ...depsBitIds]);
    const componentIdStr = component.id.toString();
    const legacyComponent = component.state._consumer;
    const deps = [...legacyComponent.dependencies.get(), ...legacyComponent.devDependencies.get()];
    const dependenciesList = await this.dependencyResolver.getDependencies(component);
    deps.forEach(dep => {
      const updatedBitId = updatedIds.searchWithoutVersion(dep.id);
      if (updatedBitId) {
        var _dependenciesList$fin, _dependenciesList$fin2;
        const depIdStr = dep.id.toString();
        const packageName = (_dependenciesList$fin = dependenciesList.findDependency(depIdStr)) === null || _dependenciesList$fin === void 0 ? void 0 : (_dependenciesList$fin2 = _dependenciesList$fin.getPackageName) === null || _dependenciesList$fin2 === void 0 ? void 0 : _dependenciesList$fin2.call(_dependenciesList$fin);
        if (!packageName) {
          throw new Error(`unable to find the package-name of "${depIdStr}" dependency inside the dependency-resolver data of "${componentIdStr}"`);
        }
        this.logger.debug(`updating "${componentIdStr}", dependency ${depIdStr} to version ${updatedBitId.version}}`);
        dep.id = updatedBitId;
        dep.packageName = packageName;
      }
    });
    legacyComponent.extensions.forEach(ext => {
      if (!ext.extensionId) return;
      const updatedBitId = updatedIds.searchWithoutVersion(ext.extensionId);
      if (updatedBitId) {
        this.logger.debug(`updating "${componentIdStr}", extension ${ext.extensionId.toString()} to version ${updatedBitId.version}}`);
        ext.extensionId = updatedBitId;
      }
    });
  }
  async saveDataIntoLocalScope(buildStatus) {
    await (0, _pMapSeries().default)(this.legacyComponents, async component => {
      component.buildStatus = buildStatus;
      await this.snapping._enrichComp(component);
    });
    await this.scope.legacyScope.objects.persist();
  }
  async export() {
    const shouldExport = this.updateDepsOptions.push;
    if (!shouldExport) return;
    const ids = _bitId().BitIds.fromArray(this.legacyComponents.map(c => c.id));
    await this.exporter.exportMany({
      scope: this.scope.legacyScope,
      ids,
      idsWithFutureScope: ids,
      laneObject: this.laneObj,
      allVersions: false
    });
  }
  static async provider([cli, scope, loggerMain, builder, dependencyResolver, snapping, lanes, exporter], _, [onPostUpdateDependenciesSlot]) {
    const logger = loggerMain.createLogger(_updateDependencies2().UpdateDependenciesAspect.id);
    const updateDependenciesMain = new UpdateDependenciesMain(scope, logger, builder, dependencyResolver, onPostUpdateDependenciesSlot, snapping, lanes, exporter);
    cli.register(new (_updateDependencies().UpdateDependenciesCmd)(updateDependenciesMain, scope, logger));
    return updateDependenciesMain;
  }
}
exports.UpdateDependenciesMain = UpdateDependenciesMain;
(0, _defineProperty2().default)(UpdateDependenciesMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(UpdateDependenciesMain, "dependencies", [_cli().CLIAspect, _scope().ScopeAspect, _logger().LoggerAspect, _builder().BuilderAspect, _dependencyResolver().DependencyResolverAspect, _snapping().SnappingAspect, _lanes().LanesAspect, _export().ExportAspect]);
(0, _defineProperty2().default)(UpdateDependenciesMain, "slots", [_harmony().Slot.withType()]);
_updateDependencies2().UpdateDependenciesAspect.addRuntime(UpdateDependenciesMain);

//# sourceMappingURL=update-dependencies.main.runtime.js.map