"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UpdateDependenciesCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
class UpdateDependenciesCmd {
  constructor(updateDependenciesMain, scope, logger) {
    this.updateDependenciesMain = updateDependenciesMain;
    this.scope = scope;
    this.logger = logger;
    (0, _defineProperty2().default)(this, "name", 'update-dependencies <data>');
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "description", 'update dependencies for components and tag/snap the results');
    (0, _defineProperty2().default)(this, "extendedDescription", `this command should be running from a new bare scope, it first imports the components it needs and then processes the update.
the input data is a stringified JSON of an array of the following object.
{
  componentId: string; // ids always have scope, so it's safe to parse them from string
  dependencies: string[]; // e.g. [teambit/compiler@1.0.0, teambit/tester@1.0.0]
  versionToTag?: string; // specific version (e.g. '1.0.0') or semver (e.g. 'minor', 'patch')
}
an example of the final data: '[{"componentId":"ci.remote2/comp-b","dependencies":["ci.remote/comp1@0.0.2"]}]'
`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "options", [['', 'tag', 'tag once the build is completed (by default it snaps)'], ['', 'simulation', 'simulation purpose. should never be pushed (otherwise, flattened-deps are invalid)'], ['', 'push', 'export the updated objects to the original scopes once tagged/snapped'], ['', 'message <string>', 'message to be saved as part of the version log'], ['', 'username <string>', 'username to be saved as part of the version log'], ['', 'email <string>', 'email to be saved as part of the version log'], ['', 'lane <lane-id>', 'helps to fetch the components from the lane scope (relevant for --multiple)'], ['', 'skip-new-scope-validation', 'avoid throwing an error when running on a non-new scope']]);
  }
  async report([data], updateDepsOptions) {
    if (updateDepsOptions.push && updateDepsOptions.simulation) {
      throw new Error('you cannot use both --push and --simulation flags');
    }
    const depsUpdateItems = this.parseData(data);
    const results = await this.updateDependenciesMain.updateDependenciesVersions(depsUpdateItems, updateDepsOptions);
    const componentOutput = depUpdateItem => {
      const title = _chalk().default.bold(depUpdateItem.component.id.toString());
      const dependencies = depUpdateItem.dependencies.map(dep => `\t${dep.toString()}`).join('\n');
      return `${title}\n${dependencies}`;
    };
    return `the following ${results.depsUpdateItems.length} component(s) were updated:
${results.depsUpdateItems.map(d => componentOutput(d)).join('\n\n')}`;
  }
  parseData(data) {
    let dataParsed;
    try {
      dataParsed = JSON.parse(data);
    } catch (err) {
      throw new Error(`failed parsing the data entered as JSON. err ${err.message}`);
    }
    if (!Array.isArray(dataParsed)) {
      throw new Error('expect data to be an array');
    }
    dataParsed.forEach(dataItem => {
      if (!dataItem.componentId) throw new Error('expect data item to have "componentId" prop');
      if (!dataItem.dependencies) throw new Error('expect data item to have "dependencies" prop');
    });
    return dataParsed;
  }
}
exports.UpdateDependenciesCmd = UpdateDependenciesCmd;

//# sourceMappingURL=update-dependencies.cmd.js.map