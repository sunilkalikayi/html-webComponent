import { SlotRegistry } from '@teambit/harmony';
import { CLIMain } from '@teambit/cli';
import { LoggerMain, Logger } from '@teambit/logger';
import { ScopeMain } from '@teambit/scope';
import { BuilderMain } from '@teambit/builder';
import { Component, ComponentID } from '@teambit/component';
import { SnappingMain } from '@teambit/snapping';
import ConsumerComponent from '@teambit/legacy/dist/consumer/component';
import { DependencyResolverMain } from '@teambit/dependency-resolver';
import { ExportMain } from '@teambit/export';
import { LanesMain } from '@teambit/lanes';
export declare type UpdateDepsOptions = {
    tag?: boolean;
    simulation?: boolean;
    output?: string;
    message?: string;
    username?: string;
    email?: string;
    push?: boolean;
    lane?: string;
    skipNewScopeValidation?: boolean;
};
export declare type DepUpdateItemRaw = {
    componentId: string;
    dependencies: string[];
    versionToTag?: string;
};
export declare type DepUpdateItem = {
    component: Component;
    dependencies: ComponentID[];
    versionToTag?: string;
};
export declare type UpdateDepsResult = {
    depsUpdateItems: DepUpdateItem[];
    publishedPackages: string[];
    error: string | null;
};
declare type OnPostUpdateDependencies = (components: Component[]) => Promise<void>;
declare type OnPostUpdateDependenciesSlot = SlotRegistry<OnPostUpdateDependencies>;
export declare class UpdateDependenciesMain {
    private scope;
    private logger;
    private builder;
    private dependencyResolver;
    private onPostUpdateDependenciesSlot;
    private snapping;
    private lanes;
    private exporter;
    private depsUpdateItems;
    private updateDepsOptions;
    private laneObj?;
    constructor(scope: ScopeMain, logger: Logger, builder: BuilderMain, dependencyResolver: DependencyResolverMain, onPostUpdateDependenciesSlot: OnPostUpdateDependenciesSlot, snapping: SnappingMain, lanes: LanesMain, exporter: ExportMain);
    /**
     * we assume this is running from a new bare scope. so we import everything and then start working.
     * we don't want this to be running from the original scope (like bit-sign). this command tags or
     * snaps the results, a process that takes some time due to the build pipeline. if we start the
     * tag on the original scope, build and then save the tag to the filesystem, we might get another
     * tag during the process and our tag could override it.
     */
    updateDependenciesVersions(depsUpdateItemsRaw: DepUpdateItemRaw[], updateDepsOptions: UpdateDepsOptions): Promise<UpdateDepsResult>;
    get legacyComponents(): ConsumerComponent[];
    get components(): Component[];
    registerOnPostUpdateDependencies(fn: OnPostUpdateDependencies): void;
    private setLaneObject;
    private validateScopeIsNew;
    private triggerOnPostUpdateDependencies;
    private importAllMissing;
    private addComponentsToScope;
    private updateComponents;
    private addBuildStatus;
    private addLogToComponents;
    private updateAllDeps;
    private parseDevUpdatesItems;
    private getDependencyWithExactVersion;
    private updateFutureVersion;
    private updateDependencyResolver;
    private updateDependenciesVersionsOfComponent;
    private saveDataIntoLocalScope;
    private export;
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: import("@teambit/harmony").Aspect[];
    static slots: ((registerFn: () => string) => SlotRegistry<OnPostUpdateDependenciesSlot>)[];
    static provider([cli, scope, loggerMain, builder, dependencyResolver, snapping, lanes, exporter]: [
        CLIMain,
        ScopeMain,
        LoggerMain,
        BuilderMain,
        DependencyResolverMain,
        SnappingMain,
        LanesMain,
        ExportMain
    ], _: any, [onPostUpdateDependenciesSlot]: [OnPostUpdateDependenciesSlot]): Promise<UpdateDependenciesMain>;
}
export {};
