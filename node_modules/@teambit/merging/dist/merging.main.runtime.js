"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MergingMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _ramda() {
  const data = _interopRequireDefault(require("ramda"));
  _ramda = function () {
    return data;
  };
  return data;
}
function _componentsList() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/components-list"));
  _componentsList = function () {
    return data;
  };
  return data;
}
function _mergeVersion() {
  const data = require("@teambit/legacy/dist/consumer/versions-ops/merge-version");
  _mergeVersion = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _snapping() {
  const data = _interopRequireDefault(require("@teambit/snapping"));
  _snapping = function () {
    return data;
  };
  return data;
}
function _hasWildcard() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/string/has-wildcard"));
  _hasWildcard = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _getDivergeData() {
  const data = require("@teambit/legacy/dist/scope/component-ops/get-diverge-data");
  _getDivergeData = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _repositories() {
  const data = require("@teambit/legacy/dist/scope/repositories");
  _repositories = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@teambit/legacy/dist/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _manyComponentsWriter() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/many-components-writer"));
  _manyComponentsWriter = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _checkoutVersion() {
  const data = require("@teambit/legacy/dist/consumer/versions-ops/checkout-version");
  _checkoutVersion = function () {
    return data;
  };
  return data;
}
function _threeWayMerge() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/versions-ops/merge-version/three-way-merge"));
  _threeWayMerge = function () {
    return data;
  };
  return data;
}
function _noCommonSnap() {
  const data = require("@teambit/legacy/dist/scope/exceptions/no-common-snap");
  _noCommonSnap = function () {
    return data;
  };
  return data;
}
function _checkout() {
  const data = require("@teambit/checkout");
  _checkout = function () {
    return data;
  };
  return data;
}
function _componentId() {
  const data = require("@teambit/component-id");
  _componentId = function () {
    return data;
  };
  return data;
}
function _install() {
  const data = require("@teambit/install");
  _install = function () {
    return data;
  };
  return data;
}
function _mergeCmd() {
  const data = require("./merge-cmd");
  _mergeCmd = function () {
    return data;
  };
  return data;
}
function _merging() {
  const data = require("./merging.aspect");
  _merging = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class MergingMain {
  constructor(workspace, install, snapping, checkout, logger) {
    var _this$workspace;
    this.workspace = workspace;
    this.install = install;
    this.snapping = snapping;
    this.checkout = checkout;
    this.logger = logger;
    (0, _defineProperty2().default)(this, "consumer", void 0);
    this.consumer = (_this$workspace = this.workspace) === null || _this$workspace === void 0 ? void 0 : _this$workspace.consumer;
  }

  /**
   * merge components according to the "values" param.
   * if the first param is a version, then merge the component ids to that version.
   * otherwise, merge from the remote head to the local.
   */
  async merge(values, mergeStrategy, abort, resolve, noSnap, message, build, skipDependencyInstallation) {
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    const consumer = this.workspace.consumer;
    let mergeResults;
    const firstValue = _ramda().default.head(values);
    if (resolve) {
      mergeResults = await this.resolveMerge(values, message, build);
    } else if (abort) {
      mergeResults = await this.abortMerge(values);
    } else if (!_bitId().BitId.isValidVersion(firstValue)) {
      const bitIds = this.getComponentsToMerge(consumer, values);
      // @todo: version could be the lane only or remote/lane
      mergeResults = await this.mergeComponentsFromRemote(consumer, bitIds, mergeStrategy, noSnap, message, build, skipDependencyInstallation);
    } else {
      const version = firstValue;
      const ids = _ramda().default.tail(values);
      const bitIds = this.getComponentsToMerge(consumer, ids);
      mergeResults = await (0, _mergeVersion().mergeVersion)(consumer, version, bitIds, mergeStrategy);
    }
    await consumer.onDestroy();
    return mergeResults;
  }

  /**
   * when user is on main, it merges the remote main components into local.
   * when user is on a lane, it merges the remote lane components into the local lane.
   */
  async mergeComponentsFromRemote(consumer, bitIds, mergeStrategy, noSnap, snapMessage, build, skipDependencyInstallation) {
    const currentLaneId = consumer.getCurrentLaneId();
    const currentLaneObject = await consumer.getCurrentLaneObject();
    const allComponentsStatus = await this.getAllComponentsStatus(bitIds, currentLaneId, currentLaneObject);
    const failedComponents = allComponentsStatus.filter(c => c.unmergedMessage && !c.unmergedLegitimately);
    if (failedComponents.length) {
      const failureMsgs = failedComponents.map(failedComponent => `${_chalk().default.bold(failedComponent.id.toString())} - ${_chalk().default.red(failedComponent.unmergedMessage)}`).join('\n');
      throw new (_bitError().BitError)(`unable to merge due to the following failures:\n${failureMsgs}`);
    }
    return this.mergeSnaps({
      mergeStrategy,
      allComponentsStatus,
      laneId: currentLaneId,
      localLane: currentLaneObject,
      noSnap,
      snapMessage,
      build,
      skipDependencyInstallation
    });
  }

  /**
   * merge multiple components according to the "allComponentsStatus".
   */
  async mergeSnaps({
    mergeStrategy,
    allComponentsStatus,
    laneId,
    localLane,
    noSnap,
    tag,
    snapMessage,
    build,
    skipDependencyInstallation
  }) {
    const consumer = this.workspace.consumer;
    const componentWithConflict = allComponentsStatus.find(component => component.mergeResults && component.mergeResults.hasConflicts);
    if (componentWithConflict && !mergeStrategy) {
      mergeStrategy = await (0, _mergeVersion().getMergeStrategyInteractive)();
    }
    const failedComponents = allComponentsStatus.filter(componentStatus => componentStatus.unmergedMessage).map(componentStatus => ({
      id: componentStatus.id,
      failureMessage: componentStatus.unmergedMessage,
      unchangedLegitimately: componentStatus.unmergedLegitimately
    }));
    const succeededComponents = allComponentsStatus.filter(componentStatus => !componentStatus.unmergedMessage);
    // do not use Promise.all for applyVersion. otherwise, it'll write all components in parallel,
    // which can be an issue when some components are also dependencies of others
    const componentsResults = await (0, _pMapSeries().default)(succeededComponents, async ({
      currentComponent,
      id,
      mergeResults,
      resolvedUnrelated
    }) => {
      const modelComponent = await consumer.scope.getModelComponent(id);
      const updatedLaneId = laneId.isDefault() ? _laneId().LaneId.from(laneId.name, id.scope) : laneId;
      return this.applyVersion({
        currentComponent,
        id,
        mergeResults,
        mergeStrategy,
        remoteHead: modelComponent.getRef(id.version),
        laneId: updatedLaneId,
        localLane,
        resolvedUnrelated
      });
    });
    if (localLane) consumer.scope.objects.add(localLane);
    await consumer.scope.objects.persist(); // persist anyway, if localLane is null it should save all main heads

    await consumer.scope.objects.unmergedComponents.write();
    await consumer.writeBitMap();
    const leftUnresolvedConflicts = componentWithConflict && mergeStrategy === 'manual';
    if (!skipDependencyInstallation && !leftUnresolvedConflicts) {
      try {
        await this.install.install(undefined, {
          dedupe: true,
          updateExisting: false,
          import: false
        });
      } catch (err) {
        this.logger.error(`failed installing packages`, err);
        this.logger.consoleError(`failed installing packages, see the log for full stacktrace. error: ${err.message}`);
      }
    }
    const getSnapOrTagResults = async () => {
      // if one of the component has conflict, don't snap-merge. otherwise, some of the components would be snap-merged
      // and some not. besides the fact that it could by mistake tag dependent, it's a confusing state. better not snap.
      if (noSnap || leftUnresolvedConflicts) {
        return null;
      }
      if (tag) {
        const idsToTag = allComponentsStatus.map(c => c.id);
        const results = await this.tagAllLaneComponent(idsToTag, snapMessage, build);
        if (!results) return null;
        const {
          taggedComponents,
          autoTaggedResults
        } = results;
        return {
          snappedComponents: taggedComponents,
          autoSnappedResults: autoTaggedResults
        };
      }
      return this.snapResolvedComponents(consumer, snapMessage, build);
    };
    let mergeSnapResults = null;
    let mergeSnapError;
    try {
      mergeSnapResults = await getSnapOrTagResults();
    } catch (err) {
      mergeSnapError = err;
    }
    return {
      components: componentsResults,
      failedComponents,
      mergeSnapResults,
      mergeSnapError,
      leftUnresolvedConflicts
    };
  }

  /**
   * this function gets called from two different commands:
   * 1. "bit merge <ids...>", when merging a component from a remote to the local.
   * in this case, the remote and local are on the same lane or both on main.
   * 2. "bit lane merge", when merging from one lane to another.
   * @param id
   * @param localLane
   * @param otherLaneName
   * @param existingOnWorkspaceOnly
   * @returns
   */
  async getComponentMergeStatus(id,
  // the id.version is the version we want to merge to the current component
  localLane,
  // currently checked out lane. if on main, then it's null.
  otherLaneName,
  // the lane name we want to merged to our lane. (can be also "main").
  options) {
    const consumer = this.workspace.consumer;
    const componentStatus = {
      id
    };
    const returnUnmerged = (msg, unmergedLegitimately = false) => {
      componentStatus.unmergedMessage = msg;
      componentStatus.unmergedLegitimately = unmergedLegitimately;
      return componentStatus;
    };
    const modelComponent = await consumer.scope.getModelComponentIfExist(id);
    if (!modelComponent) {
      return returnUnmerged(`component ${id.toString()} is on the lane/main but its objects were not found, please re-import the lane`);
    }
    const unmerged = consumer.scope.objects.unmergedComponents.getEntry(id.name);
    if (unmerged) {
      return returnUnmerged(`component ${id.toStringWithoutVersion()} is in during-merge state a previous merge, please snap/tag it first (or use bit merge --resolve/--abort)`);
    }
    const repo = consumer.scope.objects;
    const version = id.version;
    const otherLaneHead = modelComponent.getRef(version);
    const existingBitMapId = consumer.bitMap.getBitIdIfExist(id, {
      ignoreVersion: true
    });
    const componentOnLane = await modelComponent.loadVersion(version, consumer.scope.objects);
    if (componentOnLane.isRemoved()) {
      return returnUnmerged(`component has been removed`, true);
    }
    const getCurrentId = () => {
      if (existingBitMapId) return existingBitMapId;
      if (localLane) {
        const idOnLane = localLane.getComponent(id);
        if (!idOnLane) return null;
        return idOnLane.id.changeVersion(idOnLane.head.toString());
      }
      // it's on main
      const head = modelComponent.getHeadAsTagIfExist();
      if (head) {
        return id.changeVersion(head);
      }
      return null;
    };
    const currentId = getCurrentId();
    if (!currentId) {
      const divergeData = await (0, _getDivergeData().getDivergeData)({
        repo,
        modelComponent,
        remoteHead: otherLaneHead,
        throws: false
      });
      return {
        currentComponent: null,
        componentFromModel: componentOnLane,
        id,
        mergeResults: null,
        divergeData
      };
    }
    const getCurrentComponent = () => {
      if (existingBitMapId) return consumer.loadComponent(existingBitMapId);
      return consumer.scope.getConsumerComponent(currentId);
    };
    const currentComponent = await getCurrentComponent();
    const isModified = async () => {
      const componentModificationStatus = await consumer.getComponentStatusById(currentComponent.id);
      if (!componentModificationStatus.modified) return false;
      if (!existingBitMapId) return false;
      const baseComponent = await modelComponent.loadVersion(existingBitMapId.version, consumer.scope.objects);
      return options !== null && options !== void 0 && options.ignoreConfigChanges ? consumer.isComponentSourceCodeModified(baseComponent, currentComponent) : true;
    };
    const isComponentModified = await isModified();
    if (isComponentModified) {
      return returnUnmerged(`component is modified, please snap/tag it first`);
    }
    // @todo: is it needed?
    // const laneHeadIsDifferentThanCheckedOut =
    //   localLane && existingBitMapId?.version && modelComponent.laneHeadLocal?.toString() !== existingBitMapId?.version;
    // const localHead = laneHeadIsDifferentThanCheckedOut ? Ref.from(existingBitMapId.version) : null;

    if (!otherLaneHead) {
      throw new Error(`merging: unable finding a hash for the version ${version} of ${id.toString()}`);
    }
    const divergeData = await (0, _getDivergeData().getDivergeData)({
      repo,
      modelComponent,
      remoteHead: otherLaneHead,
      // checkedOutLocalHead: localHead,
      throws: false
    });
    if (divergeData.err) {
      const mainHead = modelComponent.head;
      if (divergeData.err instanceof _noCommonSnap().NoCommonSnap && options !== null && options !== void 0 && options.resolveUnrelated && mainHead) {
        const hasResolvedFromMain = async hashToCompare => {
          const divergeDataFromMain = await (0, _getDivergeData().getDivergeData)({
            repo,
            modelComponent,
            remoteHead: mainHead,
            checkedOutLocalHead: hashToCompare,
            throws: false
          });
          if (!divergeDataFromMain.err) return true;
          return !(divergeDataFromMain.err instanceof _noCommonSnap().NoCommonSnap);
        };
        const hasResolvedLocally = await hasResolvedFromMain(modelComponent.getHeadRegardlessOfLane());
        const hasResolvedRemotely = await hasResolvedFromMain(otherLaneHead);
        if (!hasResolvedLocally && !hasResolvedRemotely) {
          return returnUnmerged(`unable to traverse ${currentComponent.id.toString()} history. the main-head ${mainHead.toString()} doesn't appear in both lanes, it was probably created in each lane separately`);
        }
        const versionToSaveInLane = hasResolvedLocally ? currentComponent.id.version : id.version;
        const resolvedRef = modelComponent.getRef(versionToSaveInLane);
        if (!resolvedRef) throw new Error(`unable to get ref of "${versionToSaveInLane}" for "${id.toString()}"`);
        if ((options === null || options === void 0 ? void 0 : options.resolveUnrelated) === 'theirs') {
          // just override with the model data
          return {
            currentComponent,
            componentFromModel: componentOnLane,
            id,
            mergeResults: null,
            divergeData,
            resolvedUnrelated: {
              strategy: 'theirs',
              head: resolvedRef
            }
          };
        }
        if ((options === null || options === void 0 ? void 0 : options.resolveUnrelated) === 'ours') {
          return {
            currentComponent,
            id,
            mergeResults: null,
            divergeData,
            resolvedUnrelated: {
              strategy: 'ours',
              head: resolvedRef
            }
          };
        }
        throw new Error(`unsupported strategy "${options === null || options === void 0 ? void 0 : options.resolveUnrelated}" of resolve-unrelated. supported strategies are: [ours, theirs]`);
      }
      return returnUnmerged(`unable to traverse ${currentComponent.id.toString()} history. error: ${divergeData.err.message}`);
    }
    if (!divergeData.isDiverged()) {
      if (divergeData.isLocalAhead()) {
        // do nothing!
        return returnUnmerged(`component ${currentComponent.id.toString()} is ahead, nothing to merge`, true);
      }
      if (divergeData.isRemoteAhead()) {
        // just override with the model data
        return {
          currentComponent,
          componentFromModel: componentOnLane,
          id,
          mergeResults: null,
          divergeData
        };
      }
      // we know that localHead and remoteHead are set, so if none of them is ahead they must be equal
      return returnUnmerged(`component ${currentComponent.id.toString()} is already merged`, true);
    }
    const baseSnap = divergeData.commonSnapBeforeDiverge; // must be set when isTrueMerge
    const baseComponent = await modelComponent.loadVersion(baseSnap.toString(), repo);
    const otherComponent = await modelComponent.loadVersion(otherLaneHead.toString(), repo);
    const currentLaneName = (localLane === null || localLane === void 0 ? void 0 : localLane.toLaneId().toString()) || 'main';
    const mergeResults = await (0, _threeWayMerge().default)({
      consumer,
      otherComponent,
      otherLabel: `${otherLaneHead.toString()} (${otherLaneName})`,
      currentComponent,
      currentLabel: `${currentId.version} (${currentLaneName})`,
      baseComponent
    });
    return {
      currentComponent,
      id,
      mergeResults,
      divergeData
    };
  }
  async applyVersion({
    currentComponent,
    id,
    mergeResults,
    mergeStrategy,
    remoteHead,
    laneId,
    localLane,
    resolvedUnrelated
  }) {
    const consumer = this.workspace.consumer;
    let filesStatus = {};
    const unmergedComponent = {
      // @ts-ignore
      id: {
        name: id.name,
        scope: id.scope
      },
      head: remoteHead,
      remote: laneId.scope,
      // @todo: remove. it has been deprecated around 0.0.832
      lane: laneId.name,
      // @todo: remove. it has been deprecated around 0.0.832
      laneId
    };
    id = currentComponent ? currentComponent.id : id;
    const modelComponent = await consumer.scope.getModelComponent(id);
    const handleResolveUnrelated = () => {
      if (!currentComponent) throw new Error('currentComponent must be defined when resolvedUnrelated');
      if (!localLane) throw new Error('localLane must be defined when resolvedUnrelated');
      if (!(resolvedUnrelated !== null && resolvedUnrelated !== void 0 && resolvedUnrelated.head)) throw new Error('resolvedUnrelated must have head prop');
      localLane.addComponent({
        id,
        head: resolvedUnrelated.head
      });
      const head = modelComponent.getRef(currentComponent.id.version);
      if (!head) throw new Error(`unable to get the head for resolved-unrelated ${id.toString()}`);
      unmergedComponent.laneId = localLane.toLaneId();
      unmergedComponent.head = head;
      unmergedComponent.unrelated = true;
      consumer.scope.objects.unmergedComponents.addEntry(unmergedComponent);
      return {
        id,
        filesStatus
      };
    };
    const markAllFilesAsUnchanged = () => {
      if (!currentComponent) throw new Error(`applyVersion expect to get currentComponent for ${id.toString()}`);
      currentComponent.files.forEach(file => {
        filesStatus[(0, _utils().pathNormalizeToLinux)(file.relative)] = _mergeVersion().FileStatus.unchanged;
      });
    };
    if (mergeResults && mergeResults.hasConflicts && mergeStrategy === _mergeVersion().MergeOptions.ours) {
      markAllFilesAsUnchanged();
      consumer.scope.objects.unmergedComponents.addEntry(unmergedComponent);
      return {
        id,
        filesStatus
      };
    }
    if ((resolvedUnrelated === null || resolvedUnrelated === void 0 ? void 0 : resolvedUnrelated.strategy) === 'ours') {
      markAllFilesAsUnchanged();
      return handleResolveUnrelated();
    }
    const remoteId = id.changeVersion(remoteHead.toString());
    const idToLoad = !mergeResults || mergeStrategy === _mergeVersion().MergeOptions.theirs ? remoteId : id;
    const componentWithDependencies = await consumer.loadComponentWithDependenciesFromModel(idToLoad);
    const files = componentWithDependencies.component.files;
    files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      filesStatus[(0, _utils().pathNormalizeToLinux)(file.relative)] = _mergeVersion().FileStatus.updated;
    });
    if (mergeResults) {
      // update files according to the merge results
      const {
        filesStatus: modifiedStatus,
        modifiedFiles
      } = (0, _checkoutVersion().applyModifiedVersion)(files, mergeResults, mergeStrategy);
      componentWithDependencies.component.files = modifiedFiles;
      filesStatus = _objectSpread(_objectSpread({}, filesStatus), modifiedStatus);
    }
    const manyComponentsWriter = new (_manyComponentsWriter().default)({
      consumer,
      componentsWithDependencies: [componentWithDependencies],
      installNpmPackages: false,
      override: true,
      writeConfig: false,
      // @todo: should write if config exists before, needs to figure out how to do it.
      verbose: false // @todo: do we need a flag here?
    });

    await manyComponentsWriter.writeAll();

    // if mergeResults, the head snap is going to be updated on a later phase when snapping with two parents
    // otherwise, update the head of the current lane or main
    if (mergeResults) {
      if (mergeResults.hasConflicts && mergeStrategy === _mergeVersion().MergeOptions.manual) {
        unmergedComponent.unmergedPaths = mergeResults.modifiedFiles.filter(f => f.conflict).map(f => f.filePath);
      }
      consumer.scope.objects.unmergedComponents.addEntry(unmergedComponent);
    } else if (localLane) {
      if (resolvedUnrelated) {
        // must be "theirs"
        return handleResolveUnrelated();
      }
      localLane.addComponent({
        id,
        head: remoteHead
      });
    } else {
      // this is main
      modelComponent.setHead(remoteHead);
      // mark it as local, otherwise, when importing this component from a remote, it'll override it.
      modelComponent.markVersionAsLocal(remoteHead.toString());
      consumer.scope.objects.add(modelComponent);
    }
    return {
      id,
      filesStatus
    };
  }
  async abortMerge(values) {
    const consumer = this.workspace.consumer;
    const ids = await this.getIdsForUnmerged(values);
    const results = await this.checkout.checkout({
      ids,
      reset: true
    });
    ids.forEach(id => consumer.scope.objects.unmergedComponents.removeComponent(id.fullName));
    await consumer.scope.objects.unmergedComponents.write();
    return {
      abortedComponents: results.components
    };
  }
  async resolveMerge(values, snapMessage, build) {
    const ids = await this.getIdsForUnmerged(values);
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const {
      snappedComponents
    } = await this.snapping.snap({
      legacyBitIds: _bitId().BitIds.fromArray(ids.map(id => id._legacy)),
      build,
      message: snapMessage
    });
    return {
      resolvedComponents: snappedComponents
    };
  }
  async getAllComponentsStatus(bitIds, laneId, localLaneObject) {
    const tmp = new (_repositories().Tmp)(this.consumer.scope);
    try {
      const componentsStatus = await Promise.all(bitIds.map(async bitId => {
        const remoteScopeName = laneId.isDefault() ? bitId.scope : laneId.scope;
        const remoteLaneId = _laneId().LaneId.from(laneId.name, remoteScopeName);
        const remoteHead = await this.consumer.scope.objects.remoteLanes.getRef(remoteLaneId, bitId);
        const laneIdStr = remoteLaneId.toString();
        if (!remoteHead) throw new (_bitError().BitError)(`unable to find a remote head of "${bitId.toStringWithoutVersion()}" in "${laneIdStr}"`);
        return this.getComponentMergeStatus(bitId.changeVersion(remoteHead.toString()), localLaneObject, laneIdStr);
      }));
      await tmp.clear();
      return componentsStatus;
    } catch (err) {
      await tmp.clear();
      throw err;
    }
  }
  async snapResolvedComponents(consumer, snapMessage, build) {
    const unmergedComponents = consumer.scope.objects.unmergedComponents.getComponents();
    this.logger.debug(`merge-snaps, snapResolvedComponents, total ${unmergedComponents.length.toString()} components`);
    if (!unmergedComponents.length) return null;
    const ids = _bitId().BitIds.fromArray(unmergedComponents.map(r => new (_bitId().BitId)(r.id)));
    return this.snapping.snap({
      legacyBitIds: ids,
      build,
      message: snapMessage
    });
  }
  async tagAllLaneComponent(idsToTag, tagMessage, build) {
    const ids = idsToTag.map(id => {
      return id.toStringWithoutVersion();
    });
    this.logger.debug(`merge-snaps, tagResolvedComponents, total ${idsToTag.length.toString()} components`);
    return this.snapping.tag({
      ids,
      build,
      message: tagMessage,
      unmodified: true
    });
  }
  async getIdsForUnmerged(idsStr) {
    if (idsStr && idsStr.length) {
      const componentIds = await this.workspace.resolveMultipleComponentIds(idsStr);
      componentIds.forEach(id => {
        const entry = this.workspace.consumer.scope.objects.unmergedComponents.getEntry(id.fullName);
        if (!entry) {
          throw new (_generalError().default)(`unable to merge-resolve ${id.toString()}, it is not marked as unresolved`);
        }
      });
      return componentIds;
    }
    const unresolvedComponents = this.workspace.consumer.scope.objects.unmergedComponents.getComponents();
    if (!unresolvedComponents.length) throw new (_generalError().default)(`all components are resolved already, nothing to do`);
    return unresolvedComponents.map(u => _componentId().ComponentID.fromLegacy(new (_bitId().BitId)(u.id)));
  }
  getComponentsToMerge(consumer, ids) {
    if ((0, _hasWildcard().default)(ids)) {
      const componentsList = new (_componentsList().default)(consumer);
      return componentsList.listComponentsByIdsWithWildcard(ids);
    }
    return ids.map(id => consumer.getParsedId(id));
  }
  static async provider([cli, workspace, snapping, checkout, install, loggerMain]) {
    const logger = loggerMain.createLogger(_merging().MergingAspect.id);
    const merging = new MergingMain(workspace, install, snapping, checkout, logger);
    cli.register(new (_mergeCmd().MergeCmd)(merging));
    return merging;
  }
}
exports.MergingMain = MergingMain;
(0, _defineProperty2().default)(MergingMain, "slots", []);
(0, _defineProperty2().default)(MergingMain, "dependencies", [_cli().CLIAspect, _workspace().default, _snapping().default, _checkout().CheckoutAspect, _install().InstallAspect, _logger().LoggerAspect]);
(0, _defineProperty2().default)(MergingMain, "runtime", _cli().MainRuntime);
_merging().MergingAspect.addRuntime(MergingMain);

//# sourceMappingURL=merging.main.runtime.js.map