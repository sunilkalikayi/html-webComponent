import { CLIMain } from '@teambit/cli';
import { Workspace } from '@teambit/workspace';
import { Consumer } from '@teambit/legacy/dist/consumer';
import { ApplyVersionResults, MergeStrategy } from '@teambit/legacy/dist/consumer/versions-ops/merge-version';
import { SnappingMain } from '@teambit/snapping';
import { BitId } from '@teambit/legacy/dist/bit-id';
import { LaneId } from '@teambit/lane-id';
import { Lane, Version } from '@teambit/legacy/dist/scope/models';
import { Ref } from '@teambit/legacy/dist/scope/objects';
import ConsumerComponent from '@teambit/legacy/dist/consumer/component/consumer-component';
import { Logger, LoggerMain } from '@teambit/logger';
import { MergeResultsThreeWay } from '@teambit/legacy/dist/consumer/versions-ops/merge-version/three-way-merge';
import { CheckoutMain } from '@teambit/checkout';
import { DivergeData } from '@teambit/legacy/dist/scope/component-ops/diverge-data';
import { InstallMain } from '@teambit/install';
declare type ResolveUnrelatedData = {
    strategy: MergeStrategy;
    head: Ref;
};
export declare type ComponentMergeStatus = {
    currentComponent?: ConsumerComponent | null;
    componentFromModel?: Version;
    id: BitId;
    unmergedMessage?: string;
    unmergedLegitimately?: boolean;
    mergeResults?: MergeResultsThreeWay | null;
    divergeData?: DivergeData;
    resolvedUnrelated?: ResolveUnrelatedData;
};
export declare class MergingMain {
    private workspace;
    private install;
    private snapping;
    private checkout;
    private logger;
    private consumer;
    constructor(workspace: Workspace, install: InstallMain, snapping: SnappingMain, checkout: CheckoutMain, logger: Logger);
    /**
     * merge components according to the "values" param.
     * if the first param is a version, then merge the component ids to that version.
     * otherwise, merge from the remote head to the local.
     */
    merge(values: string[], mergeStrategy: MergeStrategy, abort: boolean, resolve: boolean, noSnap: boolean, message: string, build: boolean, skipDependencyInstallation: boolean): Promise<ApplyVersionResults>;
    /**
     * when user is on main, it merges the remote main components into local.
     * when user is on a lane, it merges the remote lane components into the local lane.
     */
    mergeComponentsFromRemote(consumer: Consumer, bitIds: BitId[], mergeStrategy: MergeStrategy, noSnap: boolean, snapMessage: string, build: boolean, skipDependencyInstallation: boolean): Promise<ApplyVersionResults>;
    /**
     * merge multiple components according to the "allComponentsStatus".
     */
    mergeSnaps({ mergeStrategy, allComponentsStatus, laneId, localLane, noSnap, tag, snapMessage, build, skipDependencyInstallation, }: {
        mergeStrategy: MergeStrategy;
        allComponentsStatus: ComponentMergeStatus[];
        laneId: LaneId;
        localLane: Lane | null;
        noSnap: boolean;
        tag?: boolean;
        snapMessage: string;
        build: boolean;
        skipDependencyInstallation?: boolean;
    }): Promise<ApplyVersionResults>;
    /**
     * this function gets called from two different commands:
     * 1. "bit merge <ids...>", when merging a component from a remote to the local.
     * in this case, the remote and local are on the same lane or both on main.
     * 2. "bit lane merge", when merging from one lane to another.
     * @param id
     * @param localLane
     * @param otherLaneName
     * @param existingOnWorkspaceOnly
     * @returns
     */
    getComponentMergeStatus(id: BitId, // the id.version is the version we want to merge to the current component
    localLane: Lane | null, // currently checked out lane. if on main, then it's null.
    otherLaneName: string, // the lane name we want to merged to our lane. (can be also "main").
    options?: {
        resolveUnrelated?: MergeStrategy;
        ignoreConfigChanges?: boolean;
    }): Promise<ComponentMergeStatus>;
    private applyVersion;
    private abortMerge;
    private resolveMerge;
    private getAllComponentsStatus;
    private snapResolvedComponents;
    private tagAllLaneComponent;
    private getIdsForUnmerged;
    private getComponentsToMerge;
    static slots: never[];
    static dependencies: import("@teambit/harmony").Aspect[];
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static provider([cli, workspace, snapping, checkout, install, loggerMain]: [
        CLIMain,
        Workspace,
        SnappingMain,
        CheckoutMain,
        InstallMain,
        LoggerMain
    ]): Promise<MergingMain>;
}
export {};
