"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MergeCmd = void 0;
exports.mergeReport = mergeReport;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _mergeVersion() {
  const data = require("@teambit/legacy/dist/consumer/versions-ops/merge-version");
  _mergeVersion = function () {
    return data;
  };
  return data;
}
function _featureToggle() {
  const data = require("@teambit/legacy/dist/api/consumer/lib/feature-toggle");
  _featureToggle = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
class MergeCmd {
  constructor(merging) {
    this.merging = merging;
    (0, _defineProperty2().default)(this, "name", 'merge [values...]');
    (0, _defineProperty2().default)(this, "description", 'merge changes of different component versions');
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "extendedDescription", `merge changes of different component versions
  \`bit merge <version> [ids...]\` => merge changes of the given version into the checked out version
  \`bit merge [ids...]\` => EXPERIMENTAL. merge changes of the remote head into local, optionally use '--abort' or '--resolve'
  ${(0, _constants().WILDCARD_HELP)('merge 0.0.1')}`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['', 'ours', 'in case of a conflict, override the used version with the current modification'], ['', 'theirs', 'in case of a conflict, override the current modification with the specified version'], ['', 'manual', 'in case of a conflict, leave the files with a conflict state to resolve them manually later'], ['', 'abort', 'EXPERIMENTAL. in case of an unresolved merge, revert to the state before the merge began'], ['', 'resolve', 'EXPERIMENTAL. mark an unresolved merge as resolved and create a new snap with the changes'], ['', 'no-snap', 'EXPERIMENTAL. do not auto snap in case the merge completed without conflicts'], ['', 'build', 'in case of snap during the merge, run the build-pipeline (similar to bit snap --build)'], ['', 'verbose', 'show details of components that were not merged legitimately'], ['', 'skip-dependency-installation', 'do not install packages of the imported components'], ['m', 'message <message>', 'EXPERIMENTAL. override the default message for the auto snap']]);
    (0, _defineProperty2().default)(this, "loader", true);
  }
  async report([values = []], {
    ours = false,
    theirs = false,
    manual = false,
    abort = false,
    resolve = false,
    build = false,
    noSnap = false,
    verbose = false,
    message,
    skipDependencyInstallation = false
  }) {
    build = (0, _featureToggle().isFeatureEnabled)(_featureToggle().BUILD_ON_CI) ? Boolean(build) : true;
    const mergeStrategy = (0, _mergeVersion().getMergeStrategy)(ours, theirs, manual);
    if (abort && resolve) throw new (_bitError().BitError)('unable to use "abort" and "resolve" flags together');
    if (noSnap && message) throw new (_bitError().BitError)('unable to use "noSnap" and "message" flags together');
    const {
      components,
      failedComponents,
      version,
      resolvedComponents,
      abortedComponents,
      mergeSnapResults,
      mergeSnapError
    } = await this.merging.merge(values, mergeStrategy, abort, resolve, noSnap, message, build, skipDependencyInstallation);
    if (resolvedComponents) {
      const title = 'successfully resolved component(s)\n';
      const componentsStr = resolvedComponents.map(c => c.id.toStringWithoutVersion()).join('\n');
      return _chalk().default.underline(title) + _chalk().default.green(componentsStr);
    }
    if (abortedComponents) {
      const title = 'successfully aborted the merge of the following component(s)\n';
      const componentsStr = abortedComponents.map(c => c.id.toStringWithoutVersion()).join('\n');
      return _chalk().default.underline(title) + _chalk().default.green(componentsStr);
    }
    return mergeReport({
      components,
      failedComponents,
      version,
      mergeSnapResults,
      mergeSnapError,
      verbose
    });
  }
}
exports.MergeCmd = MergeCmd;
function mergeReport({
  components,
  failedComponents,
  version,
  mergeSnapResults,
  mergeSnapError,
  leftUnresolvedConflicts,
  verbose
}) {
  const getSuccessOutput = () => {
    if (!components || !components.length) return '';
    // @ts-ignore version is set in case of merge command
    const title = `successfully merged components${version ? `from version ${_chalk().default.bold(version)}` : ''}\n`;
    // @ts-ignore components is set in case of merge command
    return _chalk().default.underline(title) + _chalk().default.green((0, _mergeVersion().applyVersionReport)(components));
  };
  const getConflictSummary = () => {
    if (!components || !components.length || !leftUnresolvedConflicts) return '';
    const title = `\nfiles with conflicts summary\n`;
    const suggestion = `\n\nthe merge process wasn't completed due to the conflicts above. fix them manually and then run "bit install".
once ready, snap/tag the components to complete the merge.`;
    return _chalk().default.underline(title) + (0, _mergeVersion().conflictSummaryReport)(components) + _chalk().default.yellow(suggestion);
  };
  const getSnapsOutput = () => {
    if (mergeSnapError) {
      return `
${_chalk().default.bold('snapping the merged components had failed with the following error, please fix the issues and snap manually')}
${mergeSnapError.message}
`;
    }
    if (!mergeSnapResults || !mergeSnapResults.snappedComponents) return '';
    const {
      snappedComponents,
      autoSnappedResults
    } = mergeSnapResults;
    const outputComponents = comps => {
      return comps.map(component => {
        let componentOutput = `     > ${component.id.toString()}`;
        const autoTag = autoSnappedResults.filter(result => result.triggeredBy.searchWithoutScopeAndVersion(component.id));
        if (autoTag.length) {
          const autoTagComp = autoTag.map(a => a.component.id.toString());
          componentOutput += `\n       ${_constants().AUTO_SNAPPED_MSG}: ${autoTagComp.join(', ')}`;
        }
        return componentOutput;
      }).join('\n');
    };
    return `\n${_chalk().default.underline('merge-snapped components')}\n(${'components that snapped as a result of the merge'})\n${outputComponents(snappedComponents)}\n`;
  };
  const getFailureOutput = () => {
    if (!failedComponents || !failedComponents.length) return '';
    const title = '\nthe merge has been skipped on the following component(s)';
    const body = (0, _lodash().compact)(failedComponents.map(failedComponent => {
      if (!verbose && failedComponent.unchangedLegitimately) return null;
      const color = failedComponent.unchangedLegitimately ? 'white' : 'red';
      return `${_chalk().default.bold(failedComponent.id.toString())} - ${_chalk().default[color](failedComponent.failureMessage)}`;
    })).join('\n');
    if (!body) {
      return `${_chalk().default.bold(`\nthe merge has been skipped on ${failedComponents.length} component(s) legitimately`)}
(use --verbose to list them next time)`;
    }
    return `\n${_chalk().default.underline(title)}\n${body}\n\n`;
  };
  const getSummary = () => {
    const merged = (components === null || components === void 0 ? void 0 : components.length) || 0;
    const unchangedLegitimately = (failedComponents === null || failedComponents === void 0 ? void 0 : failedComponents.filter(f => f.unchangedLegitimately).length) || 0;
    const failedToMerge = (failedComponents === null || failedComponents === void 0 ? void 0 : failedComponents.filter(f => !f.unchangedLegitimately).length) || 0;
    const autoSnapped = ((mergeSnapResults === null || mergeSnapResults === void 0 ? void 0 : mergeSnapResults.snappedComponents.length) || 0) + ((mergeSnapResults === null || mergeSnapResults === void 0 ? void 0 : mergeSnapResults.autoSnappedResults.length) || 0);
    const newLines = '\n\n';
    const title = _chalk().default.bold.underline('Merge Summary');
    const mergedStr = `\nTotal Merged: ${_chalk().default.bold(merged.toString())}`;
    const unchangedLegitimatelyStr = `\nTotal Unchanged: ${_chalk().default.bold(unchangedLegitimately.toString())}`;
    const failedToMergeStr = `\nTotal Failed: ${_chalk().default.bold(failedToMerge.toString())}`;
    const autoSnappedStr = `\nTotal Snapped: ${_chalk().default.bold(autoSnapped.toString())}`;
    return newLines + title + mergedStr + unchangedLegitimatelyStr + failedToMergeStr + autoSnappedStr;
  };
  return getSuccessOutput() + getFailureOutput() + getSnapsOutput() + getConflictSummary() + getSummary();
}

//# sourceMappingURL=merge-cmd.js.map