{"version":3,"names":["MergingMain","constructor","workspace","install","snapping","checkout","logger","consumer","merge","values","mergeStrategy","abort","resolve","noSnap","message","build","skipDependencyInstallation","ConsumerNotFound","mergeResults","firstValue","R","head","resolveMerge","abortMerge","BitId","isValidVersion","bitIds","getComponentsToMerge","mergeComponentsFromRemote","version","ids","tail","mergeVersion","onDestroy","snapMessage","currentLaneId","getCurrentLaneId","currentLaneObject","getCurrentLaneObject","allComponentsStatus","getAllComponentsStatus","failedComponents","filter","c","unmergedMessage","unmergedLegitimately","length","failureMsgs","map","failedComponent","chalk","bold","id","toString","red","join","BitError","mergeSnaps","laneId","localLane","tag","componentWithConflict","find","component","hasConflicts","getMergeStrategyInteractive","componentStatus","failureMessage","unchangedLegitimately","succeededComponents","componentsResults","mapSeries","currentComponent","resolvedUnrelated","modelComponent","scope","getModelComponent","updatedLaneId","isDefault","LaneId","from","name","applyVersion","remoteHead","getRef","objects","add","persist","unmergedComponents","write","writeBitMap","leftUnresolvedConflicts","undefined","dedupe","updateExisting","import","err","error","consoleError","getSnapOrTagResults","idsToTag","results","tagAllLaneComponent","taggedComponents","autoTaggedResults","snappedComponents","autoSnappedResults","snapResolvedComponents","mergeSnapResults","mergeSnapError","components","getComponentMergeStatus","otherLaneName","options","returnUnmerged","msg","getModelComponentIfExist","unmerged","getEntry","toStringWithoutVersion","repo","otherLaneHead","existingBitMapId","bitMap","getBitIdIfExist","ignoreVersion","componentOnLane","loadVersion","isRemoved","getCurrentId","idOnLane","getComponent","changeVersion","getHeadAsTagIfExist","currentId","divergeData","getDivergeData","throws","componentFromModel","getCurrentComponent","loadComponent","getConsumerComponent","isModified","componentModificationStatus","getComponentStatusById","modified","baseComponent","ignoreConfigChanges","isComponentSourceCodeModified","isComponentModified","Error","mainHead","NoCommonSnap","resolveUnrelated","hasResolvedFromMain","hashToCompare","divergeDataFromMain","checkedOutLocalHead","hasResolvedLocally","getHeadRegardlessOfLane","hasResolvedRemotely","versionToSaveInLane","resolvedRef","strategy","isDiverged","isLocalAhead","isRemoteAhead","baseSnap","commonSnapBeforeDiverge","otherComponent","currentLaneName","toLaneId","threeWayMerge","otherLabel","currentLabel","filesStatus","unmergedComponent","remote","lane","handleResolveUnrelated","addComponent","unrelated","addEntry","markAllFilesAsUnchanged","files","forEach","file","pathNormalizeToLinux","relative","FileStatus","unchanged","MergeOptions","ours","remoteId","idToLoad","theirs","componentWithDependencies","loadComponentWithDependenciesFromModel","updated","modifiedStatus","modifiedFiles","applyModifiedVersion","manyComponentsWriter","ManyComponentsWriter","componentsWithDependencies","installNpmPackages","override","writeConfig","verbose","writeAll","manual","unmergedPaths","f","conflict","filePath","setHead","markVersionAsLocal","getIdsForUnmerged","reset","removeComponent","fullName","abortedComponents","snap","legacyBitIds","BitIds","fromArray","_legacy","resolvedComponents","localLaneObject","tmp","Tmp","componentsStatus","Promise","all","bitId","remoteScopeName","remoteLaneId","remoteLanes","laneIdStr","clear","getComponents","debug","r","tagMessage","unmodified","idsStr","componentIds","resolveMultipleComponentIds","entry","GeneralError","unresolvedComponents","u","ComponentID","fromLegacy","hasWildcard","componentsList","ComponentsList","listComponentsByIdsWithWildcard","getParsedId","provider","cli","loggerMain","createLogger","MergingAspect","merging","register","MergeCmd","CLIAspect","WorkspaceAspect","SnappingAspect","CheckoutAspect","InstallAspect","LoggerAspect","MainRuntime","addRuntime"],"sources":["merging.main.runtime.ts"],"sourcesContent":["import { CLIAspect, CLIMain, MainRuntime } from '@teambit/cli';\nimport WorkspaceAspect, { Workspace } from '@teambit/workspace';\nimport R from 'ramda';\nimport { Consumer } from '@teambit/legacy/dist/consumer';\nimport ComponentsList from '@teambit/legacy/dist/consumer/component/components-list';\nimport {\n  ApplyVersionResults,\n  MergeStrategy,\n  mergeVersion,\n  ApplyVersionResult,\n  FailedComponents,\n  FileStatus,\n  getMergeStrategyInteractive,\n  MergeOptions,\n} from '@teambit/legacy/dist/consumer/versions-ops/merge-version';\nimport { ConsumerNotFound } from '@teambit/legacy/dist/consumer/exceptions';\nimport SnappingAspect, { SnappingMain } from '@teambit/snapping';\nimport hasWildcard from '@teambit/legacy/dist/utils/string/has-wildcard';\nimport mapSeries from 'p-map-series';\nimport { BitId, BitIds } from '@teambit/legacy/dist/bit-id';\nimport { BitError } from '@teambit/bit-error';\nimport GeneralError from '@teambit/legacy/dist/error/general-error';\nimport { LaneId } from '@teambit/lane-id';\nimport { AutoTagResult } from '@teambit/legacy/dist/scope/component-ops/auto-tag';\nimport { getDivergeData } from '@teambit/legacy/dist/scope/component-ops/get-diverge-data';\nimport { UnmergedComponent } from '@teambit/legacy/dist/scope/lanes/unmerged-components';\nimport { Lane, Version } from '@teambit/legacy/dist/scope/models';\nimport { Ref } from '@teambit/legacy/dist/scope/objects';\nimport chalk from 'chalk';\nimport { Tmp } from '@teambit/legacy/dist/scope/repositories';\nimport { pathNormalizeToLinux } from '@teambit/legacy/dist/utils';\nimport ManyComponentsWriter from '@teambit/legacy/dist/consumer/component-ops/many-components-writer';\nimport ConsumerComponent from '@teambit/legacy/dist/consumer/component/consumer-component';\nimport { Logger, LoggerAspect, LoggerMain } from '@teambit/logger';\nimport { applyModifiedVersion } from '@teambit/legacy/dist/consumer/versions-ops/checkout-version';\nimport threeWayMerge, {\n  MergeResultsThreeWay,\n} from '@teambit/legacy/dist/consumer/versions-ops/merge-version/three-way-merge';\nimport { NoCommonSnap } from '@teambit/legacy/dist/scope/exceptions/no-common-snap';\nimport { CheckoutAspect, CheckoutMain } from '@teambit/checkout';\nimport { ComponentID } from '@teambit/component-id';\nimport { DivergeData } from '@teambit/legacy/dist/scope/component-ops/diverge-data';\nimport { TagResults } from '@teambit/legacy/dist/api/consumer/lib/tag';\nimport { InstallMain, InstallAspect } from '@teambit/install';\nimport { MergeCmd } from './merge-cmd';\nimport { MergingAspect } from './merging.aspect';\n\ntype ResolveUnrelatedData = { strategy: MergeStrategy; head: Ref };\n\nexport type ComponentMergeStatus = {\n  currentComponent?: ConsumerComponent | null;\n  componentFromModel?: Version;\n  id: BitId;\n  unmergedMessage?: string;\n  unmergedLegitimately?: boolean; // failed to merge but for a legitimate reason, such as, up-to-date\n  mergeResults?: MergeResultsThreeWay | null;\n  divergeData?: DivergeData;\n  resolvedUnrelated?: ResolveUnrelatedData;\n};\n\nexport class MergingMain {\n  private consumer: Consumer;\n  constructor(\n    private workspace: Workspace,\n    private install: InstallMain,\n    private snapping: SnappingMain,\n    private checkout: CheckoutMain,\n    private logger: Logger\n  ) {\n    this.consumer = this.workspace?.consumer;\n  }\n\n  /**\n   * merge components according to the \"values\" param.\n   * if the first param is a version, then merge the component ids to that version.\n   * otherwise, merge from the remote head to the local.\n   */\n  async merge(\n    values: string[],\n    mergeStrategy: MergeStrategy,\n    abort: boolean,\n    resolve: boolean,\n    noSnap: boolean,\n    message: string,\n    build: boolean,\n    skipDependencyInstallation: boolean\n  ): Promise<ApplyVersionResults> {\n    if (!this.workspace) throw new ConsumerNotFound();\n    const consumer: Consumer = this.workspace.consumer;\n    let mergeResults;\n    const firstValue = R.head(values);\n    if (resolve) {\n      mergeResults = await this.resolveMerge(values, message, build);\n    } else if (abort) {\n      mergeResults = await this.abortMerge(values);\n    } else if (!BitId.isValidVersion(firstValue)) {\n      const bitIds = this.getComponentsToMerge(consumer, values);\n      // @todo: version could be the lane only or remote/lane\n      mergeResults = await this.mergeComponentsFromRemote(\n        consumer,\n        bitIds,\n        mergeStrategy,\n        noSnap,\n        message,\n        build,\n        skipDependencyInstallation\n      );\n    } else {\n      const version = firstValue;\n      const ids = R.tail(values);\n      const bitIds = this.getComponentsToMerge(consumer, ids);\n      mergeResults = await mergeVersion(consumer, version, bitIds, mergeStrategy);\n    }\n    await consumer.onDestroy();\n    return mergeResults;\n  }\n\n  /**\n   * when user is on main, it merges the remote main components into local.\n   * when user is on a lane, it merges the remote lane components into the local lane.\n   */\n  async mergeComponentsFromRemote(\n    consumer: Consumer,\n    bitIds: BitId[],\n    mergeStrategy: MergeStrategy,\n    noSnap: boolean,\n    snapMessage: string,\n    build: boolean,\n    skipDependencyInstallation: boolean\n  ): Promise<ApplyVersionResults> {\n    const currentLaneId = consumer.getCurrentLaneId();\n    const currentLaneObject = await consumer.getCurrentLaneObject();\n    const allComponentsStatus = await this.getAllComponentsStatus(bitIds, currentLaneId, currentLaneObject);\n    const failedComponents = allComponentsStatus.filter((c) => c.unmergedMessage && !c.unmergedLegitimately);\n    if (failedComponents.length) {\n      const failureMsgs = failedComponents\n        .map(\n          (failedComponent) =>\n            `${chalk.bold(failedComponent.id.toString())} - ${chalk.red(failedComponent.unmergedMessage as string)}`\n        )\n        .join('\\n');\n      throw new BitError(`unable to merge due to the following failures:\\n${failureMsgs}`);\n    }\n\n    return this.mergeSnaps({\n      mergeStrategy,\n      allComponentsStatus,\n      laneId: currentLaneId,\n      localLane: currentLaneObject,\n      noSnap,\n      snapMessage,\n      build,\n      skipDependencyInstallation,\n    });\n  }\n\n  /**\n   * merge multiple components according to the \"allComponentsStatus\".\n   */\n  async mergeSnaps({\n    mergeStrategy,\n    allComponentsStatus,\n    laneId,\n    localLane,\n    noSnap,\n    tag,\n    snapMessage,\n    build,\n    skipDependencyInstallation,\n  }: {\n    mergeStrategy: MergeStrategy;\n    allComponentsStatus: ComponentMergeStatus[];\n    laneId: LaneId;\n    localLane: Lane | null;\n    noSnap: boolean;\n    tag?: boolean;\n    snapMessage: string;\n    build: boolean;\n    skipDependencyInstallation?: boolean;\n  }): Promise<ApplyVersionResults> {\n    const consumer = this.workspace.consumer;\n    const componentWithConflict = allComponentsStatus.find(\n      (component) => component.mergeResults && component.mergeResults.hasConflicts\n    );\n    if (componentWithConflict && !mergeStrategy) {\n      mergeStrategy = await getMergeStrategyInteractive();\n    }\n    const failedComponents: FailedComponents[] = allComponentsStatus\n      .filter((componentStatus) => componentStatus.unmergedMessage)\n      .map((componentStatus) => ({\n        id: componentStatus.id,\n        failureMessage: componentStatus.unmergedMessage as string,\n        unchangedLegitimately: componentStatus.unmergedLegitimately,\n      }));\n    const succeededComponents = allComponentsStatus.filter((componentStatus) => !componentStatus.unmergedMessage);\n    // do not use Promise.all for applyVersion. otherwise, it'll write all components in parallel,\n    // which can be an issue when some components are also dependencies of others\n    const componentsResults = await mapSeries(\n      succeededComponents,\n      async ({ currentComponent, id, mergeResults, resolvedUnrelated }) => {\n        const modelComponent = await consumer.scope.getModelComponent(id);\n        const updatedLaneId = laneId.isDefault() ? LaneId.from(laneId.name, id.scope as string) : laneId;\n        return this.applyVersion({\n          currentComponent,\n          id,\n          mergeResults,\n          mergeStrategy,\n          remoteHead: modelComponent.getRef(id.version as string) as Ref,\n          laneId: updatedLaneId,\n          localLane,\n          resolvedUnrelated,\n        });\n      }\n    );\n\n    if (localLane) consumer.scope.objects.add(localLane);\n\n    await consumer.scope.objects.persist(); // persist anyway, if localLane is null it should save all main heads\n\n    await consumer.scope.objects.unmergedComponents.write();\n\n    await consumer.writeBitMap();\n\n    const leftUnresolvedConflicts = componentWithConflict && mergeStrategy === 'manual';\n    if (!skipDependencyInstallation && !leftUnresolvedConflicts) {\n      try {\n        await this.install.install(undefined, {\n          dedupe: true,\n          updateExisting: false,\n          import: false,\n        });\n      } catch (err: any) {\n        this.logger.error(`failed installing packages`, err);\n        this.logger.consoleError(`failed installing packages, see the log for full stacktrace. error: ${err.message}`);\n      }\n    }\n\n    const getSnapOrTagResults = async () => {\n      // if one of the component has conflict, don't snap-merge. otherwise, some of the components would be snap-merged\n      // and some not. besides the fact that it could by mistake tag dependent, it's a confusing state. better not snap.\n      if (noSnap || leftUnresolvedConflicts) {\n        return null;\n      }\n      if (tag) {\n        const idsToTag = allComponentsStatus.map((c) => c.id);\n        const results = await this.tagAllLaneComponent(idsToTag, snapMessage, build);\n        if (!results) return null;\n        const { taggedComponents, autoTaggedResults } = results;\n        return { snappedComponents: taggedComponents, autoSnappedResults: autoTaggedResults };\n      }\n      return this.snapResolvedComponents(consumer, snapMessage, build);\n    };\n    let mergeSnapResults: ApplyVersionResults['mergeSnapResults'] = null;\n    let mergeSnapError: Error | undefined;\n    try {\n      mergeSnapResults = await getSnapOrTagResults();\n    } catch (err: any) {\n      mergeSnapError = err;\n    }\n\n    return {\n      components: componentsResults,\n      failedComponents,\n      mergeSnapResults,\n      mergeSnapError,\n      leftUnresolvedConflicts,\n    };\n  }\n\n  /**\n   * this function gets called from two different commands:\n   * 1. \"bit merge <ids...>\", when merging a component from a remote to the local.\n   * in this case, the remote and local are on the same lane or both on main.\n   * 2. \"bit lane merge\", when merging from one lane to another.\n   * @param id\n   * @param localLane\n   * @param otherLaneName\n   * @param existingOnWorkspaceOnly\n   * @returns\n   */\n  async getComponentMergeStatus(\n    id: BitId, // the id.version is the version we want to merge to the current component\n    localLane: Lane | null, // currently checked out lane. if on main, then it's null.\n    otherLaneName: string, // the lane name we want to merged to our lane. (can be also \"main\").\n    options?: { resolveUnrelated?: MergeStrategy; ignoreConfigChanges?: boolean }\n  ): Promise<ComponentMergeStatus> {\n    const consumer = this.workspace.consumer;\n    const componentStatus: ComponentMergeStatus = { id };\n    const returnUnmerged = (msg: string, unmergedLegitimately = false) => {\n      componentStatus.unmergedMessage = msg;\n      componentStatus.unmergedLegitimately = unmergedLegitimately;\n      return componentStatus;\n    };\n    const modelComponent = await consumer.scope.getModelComponentIfExist(id);\n    if (!modelComponent) {\n      return returnUnmerged(\n        `component ${id.toString()} is on the lane/main but its objects were not found, please re-import the lane`\n      );\n    }\n    const unmerged = consumer.scope.objects.unmergedComponents.getEntry(id.name);\n    if (unmerged) {\n      return returnUnmerged(\n        `component ${id.toStringWithoutVersion()} is in during-merge state a previous merge, please snap/tag it first (or use bit merge --resolve/--abort)`\n      );\n    }\n    const repo = consumer.scope.objects;\n    const version = id.version as string;\n    const otherLaneHead = modelComponent.getRef(version);\n    const existingBitMapId = consumer.bitMap.getBitIdIfExist(id, { ignoreVersion: true });\n    const componentOnLane: Version = await modelComponent.loadVersion(version, consumer.scope.objects);\n    if (componentOnLane.isRemoved()) {\n      return returnUnmerged(`component has been removed`, true);\n    }\n    const getCurrentId = () => {\n      if (existingBitMapId) return existingBitMapId;\n      if (localLane) {\n        const idOnLane = localLane.getComponent(id);\n        if (!idOnLane) return null;\n        return idOnLane.id.changeVersion(idOnLane.head.toString());\n      }\n      // it's on main\n      const head = modelComponent.getHeadAsTagIfExist();\n      if (head) {\n        return id.changeVersion(head);\n      }\n      return null;\n    };\n    const currentId = getCurrentId();\n    if (!currentId) {\n      const divergeData = await getDivergeData({ repo, modelComponent, remoteHead: otherLaneHead, throws: false });\n      return { currentComponent: null, componentFromModel: componentOnLane, id, mergeResults: null, divergeData };\n    }\n    const getCurrentComponent = () => {\n      if (existingBitMapId) return consumer.loadComponent(existingBitMapId);\n      return consumer.scope.getConsumerComponent(currentId);\n    };\n    const currentComponent = await getCurrentComponent();\n    const isModified = async () => {\n      const componentModificationStatus = await consumer.getComponentStatusById(currentComponent.id);\n      if (!componentModificationStatus.modified) return false;\n      if (!existingBitMapId) return false;\n      const baseComponent = await modelComponent.loadVersion(\n        existingBitMapId.version as string,\n        consumer.scope.objects\n      );\n      return options?.ignoreConfigChanges\n        ? consumer.isComponentSourceCodeModified(baseComponent, currentComponent)\n        : true;\n    };\n\n    const isComponentModified = await isModified();\n\n    if (isComponentModified) {\n      return returnUnmerged(`component is modified, please snap/tag it first`);\n    }\n    // @todo: is it needed?\n    // const laneHeadIsDifferentThanCheckedOut =\n    //   localLane && existingBitMapId?.version && modelComponent.laneHeadLocal?.toString() !== existingBitMapId?.version;\n    // const localHead = laneHeadIsDifferentThanCheckedOut ? Ref.from(existingBitMapId.version) : null;\n\n    if (!otherLaneHead) {\n      throw new Error(`merging: unable finding a hash for the version ${version} of ${id.toString()}`);\n    }\n    const divergeData = await getDivergeData({\n      repo,\n      modelComponent,\n      remoteHead: otherLaneHead,\n      // checkedOutLocalHead: localHead,\n      throws: false,\n    });\n    if (divergeData.err) {\n      const mainHead = modelComponent.head;\n      if (divergeData.err instanceof NoCommonSnap && options?.resolveUnrelated && mainHead) {\n        const hasResolvedFromMain = async (hashToCompare: Ref | null) => {\n          const divergeDataFromMain = await getDivergeData({\n            repo,\n            modelComponent,\n            remoteHead: mainHead,\n            checkedOutLocalHead: hashToCompare,\n            throws: false,\n          });\n          if (!divergeDataFromMain.err) return true;\n          return !(divergeDataFromMain.err instanceof NoCommonSnap);\n        };\n        const hasResolvedLocally = await hasResolvedFromMain(modelComponent.getHeadRegardlessOfLane() as Ref);\n        const hasResolvedRemotely = await hasResolvedFromMain(otherLaneHead);\n        if (!hasResolvedLocally && !hasResolvedRemotely) {\n          return returnUnmerged(\n            `unable to traverse ${currentComponent.id.toString()} history. the main-head ${mainHead.toString()} doesn't appear in both lanes, it was probably created in each lane separately`\n          );\n        }\n        const versionToSaveInLane = hasResolvedLocally ? currentComponent.id.version : id.version;\n        const resolvedRef = modelComponent.getRef(versionToSaveInLane as string);\n        if (!resolvedRef) throw new Error(`unable to get ref of \"${versionToSaveInLane}\" for \"${id.toString()}\"`);\n        if (options?.resolveUnrelated === 'theirs') {\n          // just override with the model data\n          return {\n            currentComponent,\n            componentFromModel: componentOnLane,\n            id,\n            mergeResults: null,\n            divergeData,\n            resolvedUnrelated: { strategy: 'theirs', head: resolvedRef },\n          };\n        }\n        if (options?.resolveUnrelated === 'ours') {\n          return {\n            currentComponent,\n            id,\n            mergeResults: null,\n            divergeData,\n            resolvedUnrelated: { strategy: 'ours', head: resolvedRef },\n          };\n        }\n        throw new Error(\n          `unsupported strategy \"${options?.resolveUnrelated}\" of resolve-unrelated. supported strategies are: [ours, theirs]`\n        );\n      }\n      return returnUnmerged(\n        `unable to traverse ${currentComponent.id.toString()} history. error: ${divergeData.err.message}`\n      );\n    }\n    if (!divergeData.isDiverged()) {\n      if (divergeData.isLocalAhead()) {\n        // do nothing!\n        return returnUnmerged(`component ${currentComponent.id.toString()} is ahead, nothing to merge`, true);\n      }\n      if (divergeData.isRemoteAhead()) {\n        // just override with the model data\n        return {\n          currentComponent,\n          componentFromModel: componentOnLane,\n          id,\n          mergeResults: null,\n          divergeData,\n        };\n      }\n      // we know that localHead and remoteHead are set, so if none of them is ahead they must be equal\n      return returnUnmerged(`component ${currentComponent.id.toString()} is already merged`, true);\n    }\n    const baseSnap = divergeData.commonSnapBeforeDiverge as Ref; // must be set when isTrueMerge\n    const baseComponent: Version = await modelComponent.loadVersion(baseSnap.toString(), repo);\n    const otherComponent: Version = await modelComponent.loadVersion(otherLaneHead.toString(), repo);\n    const currentLaneName = localLane?.toLaneId().toString() || 'main';\n    const mergeResults = await threeWayMerge({\n      consumer,\n      otherComponent,\n      otherLabel: `${otherLaneHead.toString()} (${otherLaneName})`,\n      currentComponent,\n      currentLabel: `${currentId.version} (${currentLaneName})`,\n      baseComponent,\n    });\n    return { currentComponent, id, mergeResults, divergeData };\n  }\n\n  private async applyVersion({\n    currentComponent,\n    id,\n    mergeResults,\n    mergeStrategy,\n    remoteHead,\n    laneId,\n    localLane,\n    resolvedUnrelated,\n  }: {\n    currentComponent: ConsumerComponent | null | undefined;\n    id: BitId;\n    mergeResults: MergeResultsThreeWay | null | undefined;\n    mergeStrategy: MergeStrategy;\n    remoteHead: Ref;\n    laneId: LaneId;\n    localLane: Lane | null;\n    resolvedUnrelated?: ResolveUnrelatedData;\n  }): Promise<ApplyVersionResult> {\n    const consumer = this.workspace.consumer;\n    let filesStatus = {};\n    const unmergedComponent: UnmergedComponent = {\n      // @ts-ignore\n      id: { name: id.name, scope: id.scope },\n      head: remoteHead,\n      remote: laneId.scope, // @todo: remove. it has been deprecated around 0.0.832\n      lane: laneId.name, // @todo: remove. it has been deprecated around 0.0.832\n      laneId,\n    };\n    id = currentComponent ? currentComponent.id : id;\n\n    const modelComponent = await consumer.scope.getModelComponent(id);\n    const handleResolveUnrelated = () => {\n      if (!currentComponent) throw new Error('currentComponent must be defined when resolvedUnrelated');\n      if (!localLane) throw new Error('localLane must be defined when resolvedUnrelated');\n      if (!resolvedUnrelated?.head) throw new Error('resolvedUnrelated must have head prop');\n      localLane.addComponent({ id, head: resolvedUnrelated.head });\n      const head = modelComponent.getRef(currentComponent.id.version as string);\n      if (!head) throw new Error(`unable to get the head for resolved-unrelated ${id.toString()}`);\n      unmergedComponent.laneId = localLane.toLaneId();\n      unmergedComponent.head = head;\n      unmergedComponent.unrelated = true;\n      consumer.scope.objects.unmergedComponents.addEntry(unmergedComponent);\n      return { id, filesStatus };\n    };\n\n    const markAllFilesAsUnchanged = () => {\n      if (!currentComponent) throw new Error(`applyVersion expect to get currentComponent for ${id.toString()}`);\n      currentComponent.files.forEach((file) => {\n        filesStatus[pathNormalizeToLinux(file.relative)] = FileStatus.unchanged;\n      });\n    };\n    if (mergeResults && mergeResults.hasConflicts && mergeStrategy === MergeOptions.ours) {\n      markAllFilesAsUnchanged();\n      consumer.scope.objects.unmergedComponents.addEntry(unmergedComponent);\n      return { id, filesStatus };\n    }\n    if (resolvedUnrelated?.strategy === 'ours') {\n      markAllFilesAsUnchanged();\n      return handleResolveUnrelated();\n    }\n    const remoteId = id.changeVersion(remoteHead.toString());\n    const idToLoad = !mergeResults || mergeStrategy === MergeOptions.theirs ? remoteId : id;\n    const componentWithDependencies = await consumer.loadComponentWithDependenciesFromModel(idToLoad);\n    const files = componentWithDependencies.component.files;\n    files.forEach((file) => {\n      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!\n      filesStatus[pathNormalizeToLinux(file.relative)] = FileStatus.updated;\n    });\n\n    if (mergeResults) {\n      // update files according to the merge results\n      const { filesStatus: modifiedStatus, modifiedFiles } = applyModifiedVersion(files, mergeResults, mergeStrategy);\n      componentWithDependencies.component.files = modifiedFiles;\n      filesStatus = { ...filesStatus, ...modifiedStatus };\n    }\n\n    const manyComponentsWriter = new ManyComponentsWriter({\n      consumer,\n      componentsWithDependencies: [componentWithDependencies],\n      installNpmPackages: false,\n      override: true,\n      writeConfig: false, // @todo: should write if config exists before, needs to figure out how to do it.\n      verbose: false, // @todo: do we need a flag here?\n    });\n    await manyComponentsWriter.writeAll();\n\n    // if mergeResults, the head snap is going to be updated on a later phase when snapping with two parents\n    // otherwise, update the head of the current lane or main\n    if (mergeResults) {\n      if (mergeResults.hasConflicts && mergeStrategy === MergeOptions.manual) {\n        unmergedComponent.unmergedPaths = mergeResults.modifiedFiles.filter((f) => f.conflict).map((f) => f.filePath);\n      }\n      consumer.scope.objects.unmergedComponents.addEntry(unmergedComponent);\n    } else if (localLane) {\n      if (resolvedUnrelated) {\n        // must be \"theirs\"\n        return handleResolveUnrelated();\n      }\n      localLane.addComponent({ id, head: remoteHead });\n    } else {\n      // this is main\n      modelComponent.setHead(remoteHead);\n      // mark it as local, otherwise, when importing this component from a remote, it'll override it.\n      modelComponent.markVersionAsLocal(remoteHead.toString());\n      consumer.scope.objects.add(modelComponent);\n    }\n\n    return { id, filesStatus };\n  }\n\n  private async abortMerge(values: string[]): Promise<ApplyVersionResults> {\n    const consumer = this.workspace.consumer;\n    const ids = await this.getIdsForUnmerged(values);\n    const results = await this.checkout.checkout({ ids, reset: true });\n    ids.forEach((id) => consumer.scope.objects.unmergedComponents.removeComponent(id.fullName));\n    await consumer.scope.objects.unmergedComponents.write();\n    return { abortedComponents: results.components };\n  }\n\n  private async resolveMerge(values: string[], snapMessage: string, build: boolean): Promise<ApplyVersionResults> {\n    const ids = await this.getIdsForUnmerged(values);\n    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!\n    const { snappedComponents } = await this.snapping.snap({\n      legacyBitIds: BitIds.fromArray(ids.map((id) => id._legacy)),\n      build,\n      message: snapMessage,\n    });\n    return { resolvedComponents: snappedComponents };\n  }\n\n  private async getAllComponentsStatus(\n    bitIds: BitId[],\n    laneId: LaneId,\n    localLaneObject: Lane | null\n  ): Promise<ComponentMergeStatus[]> {\n    const tmp = new Tmp(this.consumer.scope);\n    try {\n      const componentsStatus = await Promise.all(\n        bitIds.map(async (bitId) => {\n          const remoteScopeName = laneId.isDefault() ? bitId.scope : laneId.scope;\n          const remoteLaneId = LaneId.from(laneId.name, remoteScopeName as string);\n          const remoteHead = await this.consumer.scope.objects.remoteLanes.getRef(remoteLaneId, bitId);\n          const laneIdStr = remoteLaneId.toString();\n          if (!remoteHead)\n            throw new BitError(`unable to find a remote head of \"${bitId.toStringWithoutVersion()}\" in \"${laneIdStr}\"`);\n          return this.getComponentMergeStatus(bitId.changeVersion(remoteHead.toString()), localLaneObject, laneIdStr);\n        })\n      );\n      await tmp.clear();\n      return componentsStatus;\n    } catch (err: any) {\n      await tmp.clear();\n      throw err;\n    }\n  }\n\n  private async snapResolvedComponents(\n    consumer: Consumer,\n    snapMessage: string,\n    build: boolean\n  ): Promise<null | { snappedComponents: ConsumerComponent[]; autoSnappedResults: AutoTagResult[] }> {\n    const unmergedComponents = consumer.scope.objects.unmergedComponents.getComponents();\n    this.logger.debug(`merge-snaps, snapResolvedComponents, total ${unmergedComponents.length.toString()} components`);\n    if (!unmergedComponents.length) return null;\n    const ids = BitIds.fromArray(unmergedComponents.map((r) => new BitId(r.id)));\n    return this.snapping.snap({\n      legacyBitIds: ids,\n      build,\n      message: snapMessage,\n    });\n  }\n\n  private async tagAllLaneComponent(idsToTag: BitId[], tagMessage: string, build: boolean): Promise<TagResults | null> {\n    const ids = idsToTag.map((id) => {\n      return id.toStringWithoutVersion();\n    });\n    this.logger.debug(`merge-snaps, tagResolvedComponents, total ${idsToTag.length.toString()} components`);\n    return this.snapping.tag({\n      ids,\n      build,\n      message: tagMessage,\n      unmodified: true,\n    });\n  }\n\n  private async getIdsForUnmerged(idsStr?: string[]): Promise<ComponentID[]> {\n    if (idsStr && idsStr.length) {\n      const componentIds = await this.workspace.resolveMultipleComponentIds(idsStr);\n      componentIds.forEach((id) => {\n        const entry = this.workspace.consumer.scope.objects.unmergedComponents.getEntry(id.fullName);\n        if (!entry) {\n          throw new GeneralError(`unable to merge-resolve ${id.toString()}, it is not marked as unresolved`);\n        }\n      });\n      return componentIds;\n    }\n    const unresolvedComponents = this.workspace.consumer.scope.objects.unmergedComponents.getComponents();\n    if (!unresolvedComponents.length) throw new GeneralError(`all components are resolved already, nothing to do`);\n    return unresolvedComponents.map((u) => ComponentID.fromLegacy(new BitId(u.id)));\n  }\n\n  private getComponentsToMerge(consumer: Consumer, ids: string[]): BitId[] {\n    if (hasWildcard(ids)) {\n      const componentsList = new ComponentsList(consumer);\n      return componentsList.listComponentsByIdsWithWildcard(ids);\n    }\n    return ids.map((id) => consumer.getParsedId(id));\n  }\n\n  static slots = [];\n  static dependencies = [CLIAspect, WorkspaceAspect, SnappingAspect, CheckoutAspect, InstallAspect, LoggerAspect];\n  static runtime = MainRuntime;\n  static async provider([cli, workspace, snapping, checkout, install, loggerMain]: [\n    CLIMain,\n    Workspace,\n    SnappingMain,\n    CheckoutMain,\n    InstallMain,\n    LoggerMain\n  ]) {\n    const logger = loggerMain.createLogger(MergingAspect.id);\n    const merging = new MergingMain(workspace, install, snapping, checkout, logger);\n    cli.register(new MergeCmd(merging));\n    return merging;\n  }\n}\n\nMergingAspect.addRuntime(MergingMain);\n"],"mappings":"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"}