"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InsightManager = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _insightAlreadyExists() {
  const data = _interopRequireDefault(require("./exceptions/insight-already-exists"));
  _insightAlreadyExists = function () {
    return data;
  };
  return data;
}
function _insightNotFound() {
  const data = _interopRequireDefault(require("./exceptions/insight-not-found"));
  _insightNotFound = function () {
    return data;
  };
  return data;
}
class InsightManager {
  /** insights is an insight registry */

  constructor(
  /**
   * array of registered insights
   */
  insights) {
    (0, _defineProperty2().default)(this, "insights", new Map());
    insights.forEach(insight => {
      this.register(insight);
    });
  }

  /**
   * registers a new insight and returns the updated insight registry map
   */
  register(insight) {
    const name = insight.name;
    if (this.insights.has(name)) {
      throw new (_insightAlreadyExists().default)(name);
    }
    this.insights.set(name, insight);
  }
  /**
   * list of all registered insights
   */
  listInsights() {
    return [...this.insights.keys()];
  }

  /**
   * gets a specific insight by its name or undefined if doesn't exist
   */
  getByName(insightName) {
    return this.insights.get(insightName);
  }

  /**
   * deletes a specific insight by its name if exists
   */
  delete(insightName) {
    if (!this.insights.has(insightName)) {
      throw new (_insightNotFound().default)(insightName);
    }
    this.insights.delete(insightName);
  }

  /**
   * execute an array of insights
   *
   */
  async run(insightNames, opts) {
    const res = [];
    // the reason for not using Promise.all here is that the current both insights building the graph.
    // if it happens at the same time, some props are not populated in one of the instances. it obviously
    // should be fixed in the GraphBuilder class. see "todo" there.
    await (0, _pMapSeries().default)(insightNames, async insightName => {
      const insight = this.getByName(insightName);
      if (insight) {
        const insightRes = await insight.run();
        if (!opts.renderData) {
          delete insightRes.renderedData;
        }
        res.push(insightRes);
      }
    });
    return res;
  }

  /**
   * execute all insights in the registry
   *
   */
  async runAll(opts) {
    const allInsightNames = this.listInsights();
    return this.run(allInsightNames, opts);
  }
}
exports.InsightManager = InsightManager;

//# sourceMappingURL=insight-manager.js.map