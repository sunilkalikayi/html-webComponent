"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InsightsMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _graph() {
  const data = require("@teambit/graph");
  _graph = function () {
    return data;
  };
  return data;
}
function _componentIssues() {
  const data = require("@teambit/component-issues");
  _componentIssues = function () {
    return data;
  };
  return data;
}
function _issues() {
  const data = _interopRequireDefault(require("@teambit/issues"));
  _issues = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _insights() {
  const data = require("./insights.aspect");
  _insights = function () {
    return data;
  };
  return data;
}
function _coreInsightsGetter() {
  const data = _interopRequireDefault(require("./core-insights-getter"));
  _coreInsightsGetter = function () {
    return data;
  };
  return data;
}
function _insightManager() {
  const data = require("./insight-manager");
  _insightManager = function () {
    return data;
  };
  return data;
}
function _insights2() {
  const data = _interopRequireDefault(require("./insights.cmd"));
  _insights2 = function () {
    return data;
  };
  return data;
}
class InsightsMain {
  constructor(insightManager) {
    this.insightManager = insightManager;
  }
  async runInsights(names, opts) {
    if (names) {
      let results = [];
      const namesArr = typeof names === 'string' ? [names] : names;
      results = await this.insightManager.run(namesArr, opts);
      return results;
    }
    const results = await this.insightManager.runAll(opts);
    return results;
  }
  listInsights() {
    return this.insightManager.listInsights();
  }
  async addInsightsAsComponentIssues(components, issuesToIgnore) {
    const insightNames = this.listInsights();
    const insights = insightNames.map(name => this.insightManager.getByName(name));
    if (!issuesToIgnore.includes(_componentIssues().IssuesClasses.CircularDependencies.name)) {
      await (0, _pMapSeries().default)(insights, async insight => {
        if (insight && insight.addAsComponentIssue) {
          await insight.addAsComponentIssue(components);
        }
      });
    }
  }
  static async provider([graphBuilder, cli, issues]) {
    // get all insights from registry
    const initialInsights = (0, _coreInsightsGetter().default)(graphBuilder);
    // register all insights in cli
    // TODO - get user-defined insights as well, and use them when instantiating InsightManager and InsightsCmd
    const insightManager = new (_insightManager().InsightManager)(initialInsights);
    const insightsMain = new InsightsMain(insightManager);
    issues.registerAddComponentsIssues(insightsMain.addInsightsAsComponentIssues.bind(insightsMain));
    const insightsCmd = new (_insights2().default)(insightsMain);
    cli.register(insightsCmd);
    return insightsMain;
  }
}
exports.InsightsMain = InsightsMain;
(0, _defineProperty2().default)(InsightsMain, "slots", []);
(0, _defineProperty2().default)(InsightsMain, "dependencies", [_graph().GraphAspect, _cli().CLIAspect, _issues().default]);
(0, _defineProperty2().default)(InsightsMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(InsightsMain, "config", {
  silence: false
});
_insights().InsightsAspect.addRuntime(InsightsMain);

//# sourceMappingURL=insights.main.runtime.js.map