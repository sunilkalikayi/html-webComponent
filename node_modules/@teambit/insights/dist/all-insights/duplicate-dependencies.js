"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.INSIGHT_NAME = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _semver() {
  const data = require("semver");
  _semver = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
/* eslint-disable @typescript-eslint/no-unused-vars */

// import { ComponentID } from '../../../component/component-id';

// import NoDataForInsight from '../exceptions/no-data-for-insight';

const INSIGHT_NAME = 'duplicate dependencies';
exports.INSIGHT_NAME = INSIGHT_NAME;
class DuplicateDependencies {
  constructor(graphBuilder) {
    (0, _defineProperty2().default)(this, "name", INSIGHT_NAME);
    (0, _defineProperty2().default)(this, "description", 'Get all duplicate dependencies in component graph');
    (0, _defineProperty2().default)(this, "graphBuilder", void 0);
    this.graphBuilder = graphBuilder;
  }
  async runInsight() {
    const graph = await this.graphBuilder.getGraph();
    if (!graph) {
      return {
        message: 'No graph found',
        data: undefined
      };
    }
    const duplicates = graph.findDuplicateDependencies();
    const lenDependencies = [...duplicates.keys()].length;
    if (lenDependencies === 1) {
      return {
        message: `Found ${lenDependencies} duplicate dependency.`,
        data: duplicates
      };
    }
    return {
      message: `Found ${lenDependencies} duplicate dependencies.`,
      data: duplicates
    };
  }
  formatData(data) {
    const formatted = [];
    for (const [dependency, depData] of data.entries()) {
      const {
        totalOutdatedDependents,
        dependentsByVersion
      } = this.getDependents(depData.priorVersions);
      formatted.push({
        dependencyId: dependency,
        latestVersion: depData.latestVersionId,
        totalOutdatedDependents: totalOutdatedDependents.toString(),
        dependentsByVersion
      });
    }
    return formatted;
  }
  getDependents(priorVersions) {
    let totalOutdatedDependents = 0;
    const dependentsByVersion = [];
    priorVersions.forEach(pVersion => {
      const dependents = [];
      const version = _component().ComponentID.fromString(pVersion.versionId).version || pVersion.versionId.split('@')[1];
      pVersion.immediateDependents.forEach(dependent => {
        dependents.push({
          id: dependent,
          usedVersion: pVersion.versionId
        });
      });
      dependentsByVersion.push({
        compId: pVersion.versionId,
        version,
        dependents
      });
      totalOutdatedDependents += pVersion.immediateDependents.length;
    });
    dependentsByVersion.sort(this.revreseCompareVersions);
    return {
      totalOutdatedDependents,
      dependentsByVersion
    };
  }
  revreseCompareVersions(v1, v2) {
    try {
      return (0, _semver().rcompare)(v1.version, v2.version);
    } catch (err) {
      // in case one of them is a snap
      return 0;
    }
  }
  stringifyDependents(dependents) {
    const string = dependents.map(dependent => {
      return `- ${dependent.id} => ${dependent.usedVersion}`;
    }).join('\n');
    return string;
  }
  stringifyDependentsByVersion(versions) {
    const string = versions.map(version => {
      return `- ${version.compId} has ${version.dependents.length} dependents`;
    }).join('\n');
    return string;
  }
  renderData(data) {
    const string = data.map(obj => {
      return `\n\nFound ${obj.totalOutdatedDependents} outdated dependents for ${obj.dependencyId}
The latest version is "${obj.latestVersion}"
Outdated dependents:
${this.stringifyDependentsByVersion(obj.dependentsByVersion)}`;
    }).join('\n');
    return string;
  }
  async run() {
    const bareResult = await this.runInsight();
    const formattedData = this.formatData(bareResult.data);
    const renderedData = this.renderData(formattedData);
    const result = {
      metaData: {
        name: this.name,
        description: this.description
      },
      data: formattedData,
      message: bareResult.message,
      renderedData
    };
    if (bareResult.message) {
      result.message = bareResult.message;
    }
    return result;
  }
}
exports.default = DuplicateDependencies;

//# sourceMappingURL=duplicate-dependencies.js.map