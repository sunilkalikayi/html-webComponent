"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateAddAliasesFromPeersTransformer = generateAddAliasesFromPeersTransformer;
exports.generateExposePeersTransformer = generateExposePeersTransformer;
exports.generateExternalsTransformer = generateExternalsTransformer;
function _getExposedRules() {
  const data = require("./get-exposed-rules");
  _getExposedRules = function () {
    return data;
  };
  return data;
}
function _resolvePeer() {
  const data = require("./resolve-peer");
  _resolvePeer = function () {
    return data;
  };
  return data;
}
function _getExternals() {
  const data = require("./get-externals");
  _getExternals = function () {
    return data;
  };
  return data;
}
function generateAddAliasesFromPeersTransformer(peers, logger) {
  return (config, context) => {
    var _context$target;
    const hostRootDir = ((_context$target = context.target) === null || _context$target === void 0 ? void 0 : _context$target.hostRootDir) || context.hostRootDir;
    const peerAliases = peers.reduce((acc, peerName) => {
      // gets the correct module folder of the package.
      // this allows us to resolve internal files, for example:
      // node_modules/react-dom/test-utils
      //
      // we can't use require.resolve() because it resolves to a specific file.
      // for example, if we used "react-dom": require.resolve("react-dom"),
      // it would try to resolve "react-dom/test-utils" as:
      // node_modules/react-dom/index.js/test-utils
      const resolved = (0, _resolvePeer().resolvePeerToDirOrFile)(peerName, logger, hostRootDir);
      // Sometime there are packages that only hold icons for example, so there is no main property in their package.json
      // so they can't be resolved.
      // in such cases do not add them to the aliases.
      // We already log that cases in the resolvePeerToDirOrFile function.
      if (resolved) {
        acc[peerName] = resolved;
      }
      return acc;
    }, {});
    config.addAliases(peerAliases);
    return config;
  };
}

// [dead code] - no longer used
/**
 * Generate a transformer that expose all the peers as global via the expose loader
 * @param peers
 * @returns
 */
function generateExposePeersTransformer(peers, logger) {
  return (config, context) => {
    var _context$target2;
    const hostRootDir = ((_context$target2 = context.target) === null || _context$target2 === void 0 ? void 0 : _context$target2.hostRootDir) || context.hostRootDir;
    const exposedRules = (0, _getExposedRules().getExposedRules)(peers, logger, hostRootDir);
    config.addModuleRules(exposedRules);
    return config;
  };
}

/**
 * Generate a transformer that expose all the peers as global via the expose loader
 * @param peers
 * @returns
 */
function generateExternalsTransformer(depes) {
  return config => {
    const externals = (0, _getExternals().getExternals)(depes);
    config.addExternals(externals);
    return config;
  };
}

//# sourceMappingURL=transformers.js.map