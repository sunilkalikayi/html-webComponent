"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebpackBundler = void 0;
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
class WebpackBundler {
  constructor(
  /**
   * targets to bundle.
   */
  targets,
  /**
   * webpack configuration.
   */
  configs, logger, webpack, metaData) {
    this.targets = targets;
    this.configs = configs;
    this.logger = logger;
    this.webpack = webpack;
    this.metaData = metaData;
  }
  async run() {
    var _this$metaData, _this$metaData2;
    const startTime = Date.now();
    const compilers = this.configs.map(config => this.webpack(config));
    const initiator = (_this$metaData = this.metaData) === null || _this$metaData === void 0 ? void 0 : _this$metaData.initiator;
    const envId = (_this$metaData2 = this.metaData) === null || _this$metaData2 === void 0 ? void 0 : _this$metaData2.envId;
    const initiatorMessage = initiator ? `process initiated by: ${initiator}.` : '';
    const envIdMessage = envId ? `config created by env: ${envId}.` : '';
    const longProcessLogger = this.logger.createLongProcessLogger('running Webpack bundler', compilers.length);
    const componentOutput = await (0, _pMapSeries().default)(compilers, compiler => {
      const components = this.getComponents(compiler.outputPath);
      const componentsLengthMessage = `running on ${components.length} components`;
      const fullMessage = `${initiatorMessage} ${envIdMessage} ${componentsLengthMessage}`;
      const ids = components.map(component => component.id.toString()).join(', ');
      longProcessLogger.logProgress(`${fullMessage}`);
      this.logger.debug(`${fullMessage}\ncomponents ids: ${ids}`);
      return new Promise(resolve => {
        // TODO: split to multiple processes to reduce time and configure concurrent builds.
        // @see https://github.com/trivago/parallel-webpack
        return compiler.run((err, stats) => {
          if (err) {
            this.logger.error('get error from webpack compiler, full error:', err);
            return resolve({
              errors: [`${err.toString()}\n${err.stack}`],
              components
            });
          }
          if (!stats) throw new (_bitError().BitError)('unknown build error');
          // const info = stats.toJson();

          const info = stats.toJson({
            all: false,
            entrypoints: true,
            warnings: true,
            errors: true,
            assets: true,
            chunkGroupAuxiliary: true,
            relatedAssets: true,
            cachedAssets: true
          });
          const assetsMap = this.getAssets(info);
          const entriesAssetsMap = this.getEntriesAssetsMap(info, assetsMap);
          return resolve({
            assets: Object.values(assetsMap),
            assetsByChunkName: info.assetsByChunkName,
            entriesAssetsMap,
            errors: this.getErrors(info),
            outputPath: stats.compilation.outputOptions.path,
            components,
            warnings: info.warnings,
            startTime,
            endTime: Date.now()
          });
        });
      });
    });
    longProcessLogger.end();
    return componentOutput;
  }
  getErrors(stats) {
    if (!stats.errors) return [];
    const fieldsToShow = ['message', 'moduleId', 'moduleName', 'moduleIdentifier', 'loc'];
    return stats.errors.map(webpackError => {
      const lines = fieldsToShow.map(fieldName => {
        if (webpackError[fieldName]) {
          return `${fieldName}: ${webpackError[fieldName]}`;
        }
        return undefined;
      });
      const errorMessage = (0, _lodash().compact)(lines).join('\n');
      return new (_bitError().BitError)(errorMessage);
    });
  }
  getAssets(stats) {
    if (!stats.assets) return {};
    return stats.assets.reduce((acc, asset) => {
      acc[asset.name] = {
        name: asset.name,
        size: asset.size,
        compressedSize: this.getCompressedSize(asset)
      };
      return acc;
    }, {});
  }
  getEntriesAssetsMap(stats, assetsMap) {
    const entriesMap = stats.entrypoints;
    if (!entriesMap || !Object.keys(assetsMap).length) return {};
    Object.entries(entriesMap).forEach(([, entryVal]) => {
      var _entryVal$assets, _entryVal$auxiliaryAs;
      let compressedAssetsSize = 0;
      let compressedAuxiliaryAssetsSize = 0;
      (_entryVal$assets = entryVal.assets) === null || _entryVal$assets === void 0 ? void 0 : _entryVal$assets.forEach(asset => {
        var _assetsMap$asset$name;
        const compressedSize = (_assetsMap$asset$name = assetsMap[asset.name]) === null || _assetsMap$asset$name === void 0 ? void 0 : _assetsMap$asset$name.compressedSize;
        if (compressedSize) {
          // @ts-ignore
          asset.compressedSize = compressedSize;
          compressedAssetsSize += compressedSize;
        }
      });
      (_entryVal$auxiliaryAs = entryVal.auxiliaryAssets) === null || _entryVal$auxiliaryAs === void 0 ? void 0 : _entryVal$auxiliaryAs.forEach(asset => {
        var _assetsMap$asset$name2;
        const compressedSize = (_assetsMap$asset$name2 = assetsMap[asset.name]) === null || _assetsMap$asset$name2 === void 0 ? void 0 : _assetsMap$asset$name2.compressedSize;
        if (compressedSize) {
          // @ts-ignore
          asset.compressedSize = compressedSize;
          compressedAuxiliaryAssetsSize += compressedSize;
        }
      });
      entryVal.compressedAssetsSize = compressedAssetsSize;
      entryVal.compressedAuxiliaryAssetsSize = compressedAuxiliaryAssetsSize;
    });
    return entriesMap;
  }
  getCompressedSize(asset) {
    if (!asset.related || (0, _lodash().isEmpty)(asset.related)) return undefined;
    const gzipped = asset.related.find(relatedAsset => {
      return relatedAsset.type === 'gzipped';
    });
    if (!gzipped) return undefined;
    return gzipped.size;
  }
  getComponents(outputPath) {
    const path = outputPath.substring(0, outputPath.lastIndexOf(_path().sep));
    const target = this.targets.find(targetCandidate => path === targetCandidate.outputPath);
    if (!target) throw new Error(`Could not find component id for path "${path}"`);
    return target.components;
  }
}
exports.WebpackBundler = WebpackBundler;

//# sourceMappingURL=webpack.bundler.js.map