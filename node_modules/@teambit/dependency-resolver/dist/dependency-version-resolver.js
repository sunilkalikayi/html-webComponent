"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DependencyVersionResolver = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pLimit() {
  const data = _interopRequireDefault(require("p-limit"));
  _pLimit = function () {
    return data;
  };
  return data;
}
const DEFAULT_REMOTE_RESOLVE_VERSIONS = {
  fetchToCache: true,
  update: true
};
class DependencyVersionResolver {
  constructor(
  /**
   * package manager instance.
   */
  packageManager, cacheRootDir, networkConcurrency) {
    this.packageManager = packageManager;
    this.cacheRootDir = cacheRootDir;
    (0, _defineProperty2().default)(this, "limitRequests", void 0);
    this.limitRequests = (0, _pLimit().default)(networkConcurrency !== null && networkConcurrency !== void 0 ? networkConcurrency : 16);
  }
  async resolveRemoteVersion(packageName, options) {
    // Make sure to take other default if passed options with only one option
    const calculatedOpts = Object.assign({}, DEFAULT_REMOTE_RESOLVE_VERSIONS, {
      cacheRootDir: this.cacheRootDir
    }, options);
    // TODO: the cache should be probably passed to the package manager constructor not to the install function
    const resolved = this.limitRequests(() => this.packageManager.resolveRemoteVersion(packageName, calculatedOpts));
    return resolved;
  }
}
exports.DependencyVersionResolver = DependencyVersionResolver;

//# sourceMappingURL=dependency-version-resolver.js.map