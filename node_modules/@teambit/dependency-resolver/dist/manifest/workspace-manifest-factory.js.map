{"version":3,"names":["DEFAULT_CREATE_OPTIONS","filterComponentsFromManifests","createManifestForComponentsWithoutDependencies","dedupe","WorkspaceManifestFactory","constructor","dependencyResolver","aspectLoader","createFromComponents","name","version","rootPolicy","rootDir","components","options","optsWithDefaults","Object","assign","hasRootComponents","componentDependenciesMap","buildComponentDependenciesMap","dependencyFilterFn","dedupedDependencies","getEmptyDedupedDependencies","rootDependencies","toManifest","peerDependencies","dedupeDependencies","dependencies","componentsManifestsMap","getComponentsManifests","envPeers","getEnvsPeersPolicy","workspaceManifest","WorkspaceManifest","foundEnvs","component","values","push","envPolicy","peersPolicies","map","policy","peersAutoDetectPolicy","mergedPolicies","PeersAutoDetectPolicy","mergePolices","buildResultsP","packageName","componentIdToPackageName","state","_consumer","depList","getDependencies","componentPolicy","getPolicy","additionalDeps","coreAspectIds","getCoreAspectIds","comp","toTypeArray","compIdWithoutVersion","id","split","isExtension","includes","lifecycle","some","c","isEqual","componentId","pkgName","getPackageName","filterComponents","filterResolvedFromEnv","filter","dep","updateDependenciesVersions","depManifest","toDependenciesManifest","result","Map","length","results","Promise","all","forEach","currResult","set","dependencyList","mergeVariantPolicies","config","extensions","updateDependencyVersion","componentsManifests","has","blankDependencies","devDependencies","get","getVersion","hasVersion","snapToSemver","getComponentEnvPolicy","manifest","ComponentManifest","SemVer","componentsToFilterOut","filtered","ComponentDependency","existingComponent","find","toString","ignoreVersion","_legacy","isEqualWithoutVersion","fromPolicy","value","resolveFromEnv"],"sources":["workspace-manifest-factory.ts"],"sourcesContent":["import { AspectLoaderMain } from '@teambit/aspect-loader';\nimport { Component } from '@teambit/component';\nimport componentIdToPackageName from '@teambit/legacy/dist/utils/bit/component-id-to-package-name';\nimport { SemVer } from 'semver';\nimport { snapToSemver } from '@teambit/component-package-version';\nimport { ComponentDependency, DependencyList, PackageName } from '../dependencies';\nimport { VariantPolicy, WorkspacePolicy, EnvPolicy, PeersAutoDetectPolicy } from '../policy';\n\nimport { DependencyResolverMain } from '../dependency-resolver.main.runtime';\nimport { ComponentsManifestsMap } from '../types';\nimport { ComponentManifest } from './component-manifest';\nimport { dedupeDependencies, DedupedDependencies, getEmptyDedupedDependencies } from './deduping';\nimport { ManifestToJsonOptions, ManifestDependenciesObject } from './manifest';\nimport { updateDependencyVersion } from './update-dependency-version';\nimport { WorkspaceManifest } from './workspace-manifest';\n\nexport type DepsFilterFn = (dependencies: DependencyList) => DependencyList;\n\nexport type ComponentDependenciesMap = Map<PackageName, ManifestDependenciesObject>;\nexport interface WorkspaceManifestToJsonOptions extends ManifestToJsonOptions {\n  includeDir?: boolean;\n}\n\nexport type CreateFromComponentsOptions = {\n  filterComponentsFromManifests: boolean;\n  createManifestForComponentsWithoutDependencies: boolean;\n  dedupe?: boolean;\n  dependencyFilterFn?: DepsFilterFn;\n};\n\nconst DEFAULT_CREATE_OPTIONS: CreateFromComponentsOptions = {\n  filterComponentsFromManifests: true,\n  createManifestForComponentsWithoutDependencies: true,\n  dedupe: true,\n};\nexport class WorkspaceManifestFactory {\n  constructor(private dependencyResolver: DependencyResolverMain, private aspectLoader: AspectLoaderMain) {}\n\n  async createFromComponents(\n    name: string,\n    version: SemVer,\n    rootPolicy: WorkspacePolicy,\n    rootDir: string,\n    components: Component[],\n    options: CreateFromComponentsOptions = DEFAULT_CREATE_OPTIONS\n  ): Promise<WorkspaceManifest> {\n    // Make sure to take other default if passed options with only one option\n    const optsWithDefaults = Object.assign({}, DEFAULT_CREATE_OPTIONS, options);\n    const hasRootComponents = this.dependencyResolver.hasRootComponents();\n    const componentDependenciesMap: ComponentDependenciesMap = await this.buildComponentDependenciesMap(\n      components,\n      optsWithDefaults.filterComponentsFromManifests,\n      rootPolicy,\n      optsWithDefaults.dependencyFilterFn,\n      hasRootComponents\n    );\n    let dedupedDependencies = getEmptyDedupedDependencies();\n    if (hasRootComponents) {\n      dedupedDependencies.rootDependencies = rootPolicy.toManifest();\n      const { peerDependencies } = dedupeDependencies(rootPolicy, componentDependenciesMap, [\n        'peerDependencies',\n      ]).rootDependencies;\n      // We hoist peer dependencies in order for the IDE to work.\n      // For runtime, the peer dependencies are installed inside:\n      // <ws root>/node_module/<comp name>/node_module/<comp name>/node_modules\n      dedupedDependencies.rootDependencies.dependencies = {\n        ...peerDependencies,\n        ...dedupedDependencies.rootDependencies.dependencies,\n      };\n      dedupedDependencies.componentDependenciesMap = componentDependenciesMap;\n    } else if (options.dedupe) {\n      dedupedDependencies = dedupeDependencies(rootPolicy, componentDependenciesMap);\n    } else {\n      dedupedDependencies.rootDependencies = rootPolicy.toManifest();\n      dedupedDependencies.componentDependenciesMap = componentDependenciesMap;\n    }\n    const componentsManifestsMap = await this.getComponentsManifests(\n      dedupedDependencies,\n      components,\n      optsWithDefaults.createManifestForComponentsWithoutDependencies\n    );\n    const envPeers = this.getEnvsPeersPolicy(componentsManifestsMap);\n    const workspaceManifest = new WorkspaceManifest(\n      name,\n      version,\n      dedupedDependencies.rootDependencies,\n      envPeers,\n      rootDir,\n      componentsManifestsMap\n    );\n    return workspaceManifest;\n  }\n\n  private getEnvsPeersPolicy(componentsManifestsMap: ComponentsManifestsMap) {\n    const foundEnvs: EnvPolicy[] = [];\n    for (const component of componentsManifestsMap.values()) {\n      foundEnvs.push(component.envPolicy);\n    }\n    const peersPolicies = foundEnvs.map((policy) => policy.peersAutoDetectPolicy);\n    // TODO: At the moment we are just merge everything, so in case of conflicts one will be taken\n    // TODO: once we have root for each env, we should know to handle it differently\n    const mergedPolicies = PeersAutoDetectPolicy.mergePolices(peersPolicies);\n    return mergedPolicies;\n  }\n\n  /**\n   * Get the components and build a map with the package name (from the component) as key and the dependencies as values\n   *\n   * @param {Component[]} components\n   * @param {boolean} [filterComponentsFromManifests=true] - filter existing components from the dep graphs\n   * @returns\n   */\n  private async buildComponentDependenciesMap(\n    components: Component[],\n    filterComponentsFromManifests = true,\n    rootPolicy: WorkspacePolicy,\n    dependencyFilterFn: DepsFilterFn | undefined,\n    hasRootComponents?: boolean\n  ): Promise<ComponentDependenciesMap> {\n    const buildResultsP = components.map(async (component) => {\n      const packageName = componentIdToPackageName(component.state._consumer);\n      let depList = await this.dependencyResolver.getDependencies(component);\n      const componentPolicy = await this.dependencyResolver.getPolicy(component);\n      const additionalDeps = {};\n      if (hasRootComponents) {\n        const coreAspectIds = this.aspectLoader.getCoreAspectIds();\n        for (const comp of depList.toTypeArray('component') as ComponentDependency[]) {\n          const [compIdWithoutVersion] = comp.id.split('@');\n          if (\n            !comp.isExtension &&\n            !coreAspectIds.includes(compIdWithoutVersion) &&\n            comp.lifecycle === 'runtime' &&\n            components.some((c) => c.id.isEqual(comp.componentId))\n          ) {\n            const pkgName = comp.getPackageName();\n            if (pkgName !== '@teambit/harmony') {\n              additionalDeps[pkgName] = `workspace:*`;\n            }\n          }\n        }\n      }\n      if (filterComponentsFromManifests) {\n        depList = filterComponents(depList, components);\n      }\n      depList = filterResolvedFromEnv(depList, componentPolicy);\n      // Remove bit bin from dep list\n      depList = depList.filter((dep) => dep.id !== '@teambit/legacy');\n      if (dependencyFilterFn) {\n        depList = dependencyFilterFn(depList);\n      }\n      await this.updateDependenciesVersions(component, rootPolicy, depList);\n      const depManifest = depList.toDependenciesManifest();\n      depManifest.dependencies = {\n        ...additionalDeps,\n        ...depManifest.dependencies,\n      };\n\n      return { packageName, depManifest };\n    });\n    const result: ComponentDependenciesMap = new Map();\n\n    if (buildResultsP.length) {\n      const results = await Promise.all(buildResultsP);\n      results.forEach((currResult) => {\n        result.set(currResult.packageName, currResult.depManifest);\n      });\n    }\n\n    return result;\n  }\n\n  private async updateDependenciesVersions(\n    component: Component,\n    rootPolicy: WorkspacePolicy,\n    dependencyList: DependencyList\n  ): Promise<void> {\n    const mergedPolicies = await this.dependencyResolver.mergeVariantPolicies(component.config.extensions);\n    dependencyList.forEach((dep) => {\n      updateDependencyVersion(dep, rootPolicy, mergedPolicies);\n    });\n  }\n\n  /**\n   * Get the components manifests based on the calculated dedupedDependencies\n   *\n   * @param {DedupedDependencies} dedupedDependencies\n   * @param {Component[]} components\n   * @returns {ComponentsManifestsMap}\n   */\n  async getComponentsManifests(\n    dedupedDependencies: DedupedDependencies,\n    components: Component[],\n    createManifestForComponentsWithoutDependencies = true\n  ): Promise<ComponentsManifestsMap> {\n    const componentsManifests: ComponentsManifestsMap = new Map();\n    await Promise.all(\n      components.map(async (component) => {\n        const packageName = componentIdToPackageName(component.state._consumer);\n        if (\n          dedupedDependencies.componentDependenciesMap.has(packageName) ||\n          createManifestForComponentsWithoutDependencies\n        ) {\n          const blankDependencies: ManifestDependenciesObject = {\n            dependencies: {},\n            devDependencies: {},\n            peerDependencies: {},\n          };\n          let dependencies = blankDependencies;\n          if (dedupedDependencies.componentDependenciesMap.has(packageName)) {\n            dependencies = dedupedDependencies.componentDependenciesMap.get(packageName) as ManifestDependenciesObject;\n          }\n\n          const getVersion = (): string => {\n            if (!component.id.hasVersion()) return '0.0.1-new';\n            return snapToSemver(component.id.version as string);\n          };\n\n          const version = getVersion();\n          const envPolicy = await this.dependencyResolver.getComponentEnvPolicy(component);\n          const manifest = new ComponentManifest(packageName, new SemVer(version), dependencies, component, envPolicy);\n          componentsManifests.set(packageName, manifest);\n        }\n      })\n    );\n    return componentsManifests;\n  }\n}\n\nfunction filterComponents(dependencyList: DependencyList, componentsToFilterOut: Component[]): DependencyList {\n  const filtered = dependencyList.filter((dep) => {\n    // Do not filter non components (like packages) dependencies\n    if (!(dep instanceof ComponentDependency)) {\n      return true;\n    }\n    // Remove dependencies which has no version (they are new in the workspace)\n    if (!dep.componentId.hasVersion()) return false;\n    const existingComponent = componentsToFilterOut.find((component) => {\n      // For new components, the component has no version but the dependency id has version 0.0.1\n      if (!component.id.hasVersion()) {\n        return component.id.toString() === dep.componentId.toString({ ignoreVersion: true });\n      }\n      // We are checking against both component.id._legacy and component.state._consumer.id\n      // Because during tag operation, the component.id._legacy has the current version (before the tag)\n      // while the component.state._consumer.id has the upcoming version (the version that will be after the tag)\n      // The dependency in some cases is already updated to the upcoming version\n      return (\n        component.id._legacy.isEqualWithoutVersion(dep.componentId._legacy) ||\n        component.state._consumer.id.isEqualWithoutVersion(dep.componentId._legacy)\n      );\n    });\n    if (existingComponent) return false;\n    return true;\n  });\n  return filtered;\n}\n\n/**\n * Filter deps which should be resolved from the env, we don't want to install them, they will be linked manually later\n * @param dependencyList\n * @param componentPolicy\n */\nfunction filterResolvedFromEnv(dependencyList: DependencyList, componentPolicy: VariantPolicy): DependencyList {\n  const filtered = dependencyList.filter((dep) => {\n    const fromPolicy = componentPolicy.find(dep.id);\n    if (!fromPolicy) {\n      return true;\n    }\n    if (fromPolicy.value.resolveFromEnv) {\n      return false;\n    }\n    return true;\n  });\n  return filtered;\n}\n"],"mappings":"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"}