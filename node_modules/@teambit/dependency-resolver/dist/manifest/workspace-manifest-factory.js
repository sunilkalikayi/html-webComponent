"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkspaceManifestFactory = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/bit/component-id-to-package-name"));
  _componentIdToPackageName = function () {
    return data;
  };
  return data;
}
function _semver() {
  const data = require("semver");
  _semver = function () {
    return data;
  };
  return data;
}
function _componentPackageVersion() {
  const data = require("@teambit/component-package-version");
  _componentPackageVersion = function () {
    return data;
  };
  return data;
}
function _dependencies() {
  const data = require("../dependencies");
  _dependencies = function () {
    return data;
  };
  return data;
}
function _policy() {
  const data = require("../policy");
  _policy = function () {
    return data;
  };
  return data;
}
function _componentManifest() {
  const data = require("./component-manifest");
  _componentManifest = function () {
    return data;
  };
  return data;
}
function _deduping() {
  const data = require("./deduping");
  _deduping = function () {
    return data;
  };
  return data;
}
function _updateDependencyVersion() {
  const data = require("./update-dependency-version");
  _updateDependencyVersion = function () {
    return data;
  };
  return data;
}
function _workspaceManifest() {
  const data = require("./workspace-manifest");
  _workspaceManifest = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const DEFAULT_CREATE_OPTIONS = {
  filterComponentsFromManifests: true,
  createManifestForComponentsWithoutDependencies: true,
  dedupe: true
};
class WorkspaceManifestFactory {
  constructor(dependencyResolver, aspectLoader) {
    this.dependencyResolver = dependencyResolver;
    this.aspectLoader = aspectLoader;
  }
  async createFromComponents(name, version, rootPolicy, rootDir, components, options = DEFAULT_CREATE_OPTIONS) {
    // Make sure to take other default if passed options with only one option
    const optsWithDefaults = Object.assign({}, DEFAULT_CREATE_OPTIONS, options);
    const hasRootComponents = this.dependencyResolver.hasRootComponents();
    const componentDependenciesMap = await this.buildComponentDependenciesMap(components, optsWithDefaults.filterComponentsFromManifests, rootPolicy, optsWithDefaults.dependencyFilterFn, hasRootComponents);
    let dedupedDependencies = (0, _deduping().getEmptyDedupedDependencies)();
    if (hasRootComponents) {
      dedupedDependencies.rootDependencies = rootPolicy.toManifest();
      const {
        peerDependencies
      } = (0, _deduping().dedupeDependencies)(rootPolicy, componentDependenciesMap, ['peerDependencies']).rootDependencies;
      // We hoist peer dependencies in order for the IDE to work.
      // For runtime, the peer dependencies are installed inside:
      // <ws root>/node_module/<comp name>/node_module/<comp name>/node_modules
      dedupedDependencies.rootDependencies.dependencies = _objectSpread(_objectSpread({}, peerDependencies), dedupedDependencies.rootDependencies.dependencies);
      dedupedDependencies.componentDependenciesMap = componentDependenciesMap;
    } else if (options.dedupe) {
      dedupedDependencies = (0, _deduping().dedupeDependencies)(rootPolicy, componentDependenciesMap);
    } else {
      dedupedDependencies.rootDependencies = rootPolicy.toManifest();
      dedupedDependencies.componentDependenciesMap = componentDependenciesMap;
    }
    const componentsManifestsMap = await this.getComponentsManifests(dedupedDependencies, components, optsWithDefaults.createManifestForComponentsWithoutDependencies);
    const envPeers = this.getEnvsPeersPolicy(componentsManifestsMap);
    const workspaceManifest = new (_workspaceManifest().WorkspaceManifest)(name, version, dedupedDependencies.rootDependencies, envPeers, rootDir, componentsManifestsMap);
    return workspaceManifest;
  }
  getEnvsPeersPolicy(componentsManifestsMap) {
    const foundEnvs = [];
    for (const component of componentsManifestsMap.values()) {
      foundEnvs.push(component.envPolicy);
    }
    const peersPolicies = foundEnvs.map(policy => policy.peersAutoDetectPolicy);
    // TODO: At the moment we are just merge everything, so in case of conflicts one will be taken
    // TODO: once we have root for each env, we should know to handle it differently
    const mergedPolicies = _policy().PeersAutoDetectPolicy.mergePolices(peersPolicies);
    return mergedPolicies;
  }

  /**
   * Get the components and build a map with the package name (from the component) as key and the dependencies as values
   *
   * @param {Component[]} components
   * @param {boolean} [filterComponentsFromManifests=true] - filter existing components from the dep graphs
   * @returns
   */
  async buildComponentDependenciesMap(components, filterComponentsFromManifests = true, rootPolicy, dependencyFilterFn, hasRootComponents) {
    const buildResultsP = components.map(async component => {
      const packageName = (0, _componentIdToPackageName().default)(component.state._consumer);
      let depList = await this.dependencyResolver.getDependencies(component);
      const componentPolicy = await this.dependencyResolver.getPolicy(component);
      const additionalDeps = {};
      if (hasRootComponents) {
        const coreAspectIds = this.aspectLoader.getCoreAspectIds();
        for (const comp of depList.toTypeArray('component')) {
          const [compIdWithoutVersion] = comp.id.split('@');
          if (!comp.isExtension && !coreAspectIds.includes(compIdWithoutVersion) && comp.lifecycle === 'runtime' && components.some(c => c.id.isEqual(comp.componentId))) {
            const pkgName = comp.getPackageName();
            if (pkgName !== '@teambit/harmony') {
              additionalDeps[pkgName] = `workspace:*`;
            }
          }
        }
      }
      if (filterComponentsFromManifests) {
        depList = filterComponents(depList, components);
      }
      depList = filterResolvedFromEnv(depList, componentPolicy);
      // Remove bit bin from dep list
      depList = depList.filter(dep => dep.id !== '@teambit/legacy');
      if (dependencyFilterFn) {
        depList = dependencyFilterFn(depList);
      }
      await this.updateDependenciesVersions(component, rootPolicy, depList);
      const depManifest = depList.toDependenciesManifest();
      depManifest.dependencies = _objectSpread(_objectSpread({}, additionalDeps), depManifest.dependencies);
      return {
        packageName,
        depManifest
      };
    });
    const result = new Map();
    if (buildResultsP.length) {
      const results = await Promise.all(buildResultsP);
      results.forEach(currResult => {
        result.set(currResult.packageName, currResult.depManifest);
      });
    }
    return result;
  }
  async updateDependenciesVersions(component, rootPolicy, dependencyList) {
    const mergedPolicies = await this.dependencyResolver.mergeVariantPolicies(component.config.extensions);
    dependencyList.forEach(dep => {
      (0, _updateDependencyVersion().updateDependencyVersion)(dep, rootPolicy, mergedPolicies);
    });
  }

  /**
   * Get the components manifests based on the calculated dedupedDependencies
   *
   * @param {DedupedDependencies} dedupedDependencies
   * @param {Component[]} components
   * @returns {ComponentsManifestsMap}
   */
  async getComponentsManifests(dedupedDependencies, components, createManifestForComponentsWithoutDependencies = true) {
    const componentsManifests = new Map();
    await Promise.all(components.map(async component => {
      const packageName = (0, _componentIdToPackageName().default)(component.state._consumer);
      if (dedupedDependencies.componentDependenciesMap.has(packageName) || createManifestForComponentsWithoutDependencies) {
        const blankDependencies = {
          dependencies: {},
          devDependencies: {},
          peerDependencies: {}
        };
        let dependencies = blankDependencies;
        if (dedupedDependencies.componentDependenciesMap.has(packageName)) {
          dependencies = dedupedDependencies.componentDependenciesMap.get(packageName);
        }
        const getVersion = () => {
          if (!component.id.hasVersion()) return '0.0.1-new';
          return (0, _componentPackageVersion().snapToSemver)(component.id.version);
        };
        const version = getVersion();
        const envPolicy = await this.dependencyResolver.getComponentEnvPolicy(component);
        const manifest = new (_componentManifest().ComponentManifest)(packageName, new (_semver().SemVer)(version), dependencies, component, envPolicy);
        componentsManifests.set(packageName, manifest);
      }
    }));
    return componentsManifests;
  }
}
exports.WorkspaceManifestFactory = WorkspaceManifestFactory;
function filterComponents(dependencyList, componentsToFilterOut) {
  const filtered = dependencyList.filter(dep => {
    // Do not filter non components (like packages) dependencies
    if (!(dep instanceof _dependencies().ComponentDependency)) {
      return true;
    }
    // Remove dependencies which has no version (they are new in the workspace)
    if (!dep.componentId.hasVersion()) return false;
    const existingComponent = componentsToFilterOut.find(component => {
      // For new components, the component has no version but the dependency id has version 0.0.1
      if (!component.id.hasVersion()) {
        return component.id.toString() === dep.componentId.toString({
          ignoreVersion: true
        });
      }
      // We are checking against both component.id._legacy and component.state._consumer.id
      // Because during tag operation, the component.id._legacy has the current version (before the tag)
      // while the component.state._consumer.id has the upcoming version (the version that will be after the tag)
      // The dependency in some cases is already updated to the upcoming version
      return component.id._legacy.isEqualWithoutVersion(dep.componentId._legacy) || component.state._consumer.id.isEqualWithoutVersion(dep.componentId._legacy);
    });
    if (existingComponent) return false;
    return true;
  });
  return filtered;
}

/**
 * Filter deps which should be resolved from the env, we don't want to install them, they will be linked manually later
 * @param dependencyList
 * @param componentPolicy
 */
function filterResolvedFromEnv(dependencyList, componentPolicy) {
  const filtered = dependencyList.filter(dep => {
    const fromPolicy = componentPolicy.find(dep.id);
    if (!fromPolicy) {
      return true;
    }
    if (fromPolicy.value.resolveFromEnv) {
      return false;
    }
    return true;
  });
  return filtered;
}

//# sourceMappingURL=workspace-manifest-factory.js.map