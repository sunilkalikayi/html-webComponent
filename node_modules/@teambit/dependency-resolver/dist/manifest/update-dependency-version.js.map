{"version":3,"names":["updateDependencyVersion","dependency","rootPolicy","variantPolicy","getPackageName","packageName","variantVersion","getDepVersion","lifecycle","variantVersionWithoutMinus","undefined","version","getValidSemverDepVersion","snapToSemver","setVersion"],"sources":["update-dependency-version.ts"],"sourcesContent":["import { snapToSemver } from '@teambit/component-package-version';\nimport { Dependency } from '../dependencies';\nimport { VariantPolicy, WorkspacePolicy } from '../policy';\n\n/**\n * This will create a function that will modify the version of the component dependencies before calling the package manager install\n * It's important for this use case:\n * between 2 bit components we are not allowing a range, only a specific version as dependency\n * therefor, when resolve a component dependency we take the version from the actual installed version in the file system\n * imagine the following case\n * I have in my policy my-dep:0.0.10\n * during installation it is installed (hoisted to the root)\n * now i'm changing it to be ^0.0.11\n * On the next bit install, when I will look at the component deps I'll see it with version 0.0.10 always (that's resolved from the FS)\n * so the version ^0.0.11 will be never installed.\n * For installation purpose we want a different resolve method, we want to take the version from the policies so we will install the correct one\n * this function will get the root deps / policy, and a function to merge the component policies (by the dep resolver extension).\n * it will then search for the dep version in the component policy, than in the workspace policy and take it from there\n * now in the described case, it will be change to ^0.0.11 and will be install correctly\n * then on the next calculation for tagging it will have the installed version\n *\n * @param {Component} component\n * @param {ManifestDependenciesObject} rootDependencies\n * @param {MergeDependenciesFunc} mergeDependenciesFunc\n * @returns {DepVersionModifierFunc}\n */\nexport function updateDependencyVersion(\n  dependency: Dependency,\n  rootPolicy: WorkspacePolicy,\n  variantPolicy: VariantPolicy\n): void {\n  if (dependency.getPackageName) {\n    const packageName = dependency.getPackageName();\n    const variantVersion = variantPolicy.getDepVersion(packageName, dependency.lifecycle);\n    const variantVersionWithoutMinus = variantVersion && variantVersion !== '-' ? variantVersion : undefined;\n    const version =\n      variantVersionWithoutMinus ||\n      rootPolicy.getValidSemverDepVersion(packageName, dependency.lifecycle === 'peer' ? 'peer' : 'runtime') ||\n      snapToSemver(dependency.version) ||\n      '0.0.1-new';\n\n    dependency.setVersion(version);\n  }\n}\n"],"mappings":";;;;;;AAAA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,uBAAuB,CACrCC,UAAsB,EACtBC,UAA2B,EAC3BC,aAA4B,EACtB;EACN,IAAIF,UAAU,CAACG,cAAc,EAAE;IAC7B,MAAMC,WAAW,GAAGJ,UAAU,CAACG,cAAc,EAAE;IAC/C,MAAME,cAAc,GAAGH,aAAa,CAACI,aAAa,CAACF,WAAW,EAAEJ,UAAU,CAACO,SAAS,CAAC;IACrF,MAAMC,0BAA0B,GAAGH,cAAc,IAAIA,cAAc,KAAK,GAAG,GAAGA,cAAc,GAAGI,SAAS;IACxG,MAAMC,OAAO,GACXF,0BAA0B,IAC1BP,UAAU,CAACU,wBAAwB,CAACP,WAAW,EAAEJ,UAAU,CAACO,SAAS,KAAK,MAAM,GAAG,MAAM,GAAG,SAAS,CAAC,IACtG,IAAAK,uCAAY,EAACZ,UAAU,CAACU,OAAO,CAAC,IAChC,WAAW;IAEbV,UAAU,CAACa,UAAU,CAACH,OAAO,CAAC;EAChC;AACF"}