"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeWithRootDeps = mergeWithRootDeps;
function _forEachObjIndexed() {
  const data = _interopRequireDefault(require("ramda/src/forEachObjIndexed"));
  _forEachObjIndexed = function () {
    return data;
  };
  return data;
}
/**
 * This is the third phase of the deduping process
 * It's not exactly part of the dedupe process but its required for the bit install to work properly
 * it will take the deduped dependencies and will add them missing deps from the provided root deps
 * it used for installing deps in the root level before any component use it
 * otherwise they won't be install, and you will need to re-run install after writing the require statement in the code
 *
 * @returns {DedupedDependencies}
 */
function mergeWithRootDeps(rootDependencies, dedupedDependencies) {
  (0, _forEachObjIndexed().default)(mergeSpecificLifeCycleRootDepsToDedupedDependencies(dedupedDependencies), rootDependencies);
  return dedupedDependencies;
}
function mergeSpecificLifeCycleRootDepsToDedupedDependencies(dedupedDependencies) {
  return (deps, depKeyName) => {
    (0, _forEachObjIndexed().default)(mergeRootDepToDedupedDependencies(dedupedDependencies, depKeyName), deps);
  };
}
function mergeRootDepToDedupedDependencies(dedupedDependencies, depKeyName) {
  return (range, depId) => {
    // Do not add it if it's already exist from the components calculation
    if (isDepExistInAnyOfTheRootDedupedDependencies(depId, dedupedDependencies)) return;
    const existingRootDeps = dedupedDependencies.rootDependencies;
    if (existingRootDeps[depKeyName]) {
      // @ts-ignore - for some reason ts thinks it might be undefined
      existingRootDeps[depKeyName][depId] = range.toString();
    } else {
      existingRootDeps[depKeyName] = {
        [depId]: range.toString()
      };
    }
  };
}
function isDepExistInAnyOfTheRootDedupedDependencies(depId, dedupedDependencies) {
  const rootDedupedDeps = dedupedDependencies.rootDependencies;
  return isDepExistInDepObject(depId, rootDedupedDeps.dependencies) || isDepExistInDepObject(depId, rootDedupedDeps.devDependencies) || isDepExistInDepObject(depId, rootDedupedDeps.peerDependencies);
}
function isDepExistInDepObject(depId, depObjectValue = {}) {
  return !!depObjectValue[depId];
}

//# sourceMappingURL=merge-with-root.js.map