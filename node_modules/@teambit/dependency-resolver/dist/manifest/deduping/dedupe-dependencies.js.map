{"version":3,"names":["dedupeDependencies","rootPolicy","componentDependenciesMap","hoistedDepFields","indexedByDepId","indexByDepId","dedupedDependenciesWithoutRootOriginal","hoistDependencies","result","mergeWithRootDeps","toManifest"],"sources":["dedupe-dependencies.ts"],"sourcesContent":["import { ManifestDependenciesKeysNames, ManifestDependenciesObject } from '../manifest';\nimport { WorkspacePolicy } from '../../policy';\nimport { PackageName, SemverVersion } from '../../dependencies';\nimport { ComponentDependenciesMap } from '../workspace-manifest-factory';\nimport { hoistDependencies } from './hoist-dependencies';\nimport { indexByDepId } from './index-by-dep-id';\nimport { mergeWithRootDeps } from './merge-with-root';\n\nexport { getEmptyDedupedDependencies } from './hoist-dependencies';\n\nexport type conflictedComponent = {\n  componentPackageName: PackageName;\n  range: SemverVersion;\n};\n\nexport type DedupedDependenciesPeerConflicts = {\n  packageName: PackageName;\n  conflictedComponents: conflictedComponent[];\n  conflictMessage: string;\n};\n\nexport type DedupedDependenciesIssues = {\n  peerConflicts: DedupedDependenciesPeerConflicts[];\n};\n\nexport type DedupedDependencies = {\n  rootDependencies: ManifestDependenciesObject;\n  componentDependenciesMap: ComponentDependenciesMap;\n  issus?: DedupedDependenciesIssues;\n};\n\n/**\n * Main function to dedupe dependencies\n * It will optimized the dependencies structure to make sure there is minimum duplication of the same dependency (as a result of conflicted versions)\n * it will take everything possible to be defined in the root, and only conflicts in the components\n * it's similar to what happens when you use yarn workspaces\n *\n * @export\n * @returns {DedupedDependencies}\n */\nexport function dedupeDependencies(\n  rootPolicy: WorkspacePolicy,\n  componentDependenciesMap: ComponentDependenciesMap,\n  hoistedDepFields?: ManifestDependenciesKeysNames[]\n): DedupedDependencies {\n  const indexedByDepId = indexByDepId(rootPolicy, componentDependenciesMap, hoistedDepFields);\n  const dedupedDependenciesWithoutRootOriginal = hoistDependencies(indexedByDepId);\n  const result = mergeWithRootDeps(rootPolicy.toManifest(), dedupedDependenciesWithoutRootOriginal);\n  return result;\n}\n"],"mappings":";;;;;;;;;;;;AAIA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,kBAAkB,CAChCC,UAA2B,EAC3BC,wBAAkD,EAClDC,gBAAkD,EAC7B;EACrB,MAAMC,cAAc,GAAG,IAAAC,4BAAY,EAACJ,UAAU,EAAEC,wBAAwB,EAAEC,gBAAgB,CAAC;EAC3F,MAAMG,sCAAsC,GAAG,IAAAC,sCAAiB,EAACH,cAAc,CAAC;EAChF,MAAMI,MAAM,GAAG,IAAAC,kCAAiB,EAACR,UAAU,CAACS,UAAU,EAAE,EAAEJ,sCAAsC,CAAC;EACjG,OAAOE,MAAM;AACf"}