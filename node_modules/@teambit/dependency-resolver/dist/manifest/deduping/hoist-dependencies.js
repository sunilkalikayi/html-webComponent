"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEmptyDedupedDependencies = getEmptyDedupedDependencies;
exports.hoistDependencies = hoistDependencies;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _forEachObjIndexed() {
  const data = _interopRequireDefault(require("ramda/src/forEachObjIndexed"));
  _forEachObjIndexed = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _semver() {
  const data = _interopRequireDefault(require("semver"));
  _semver = function () {
    return data;
  };
  return data;
}
function _semverIntersect() {
  const data = require("semver-intersect");
  _semverIntersect = function () {
    return data;
  };
  return data;
}
function _semverRangeIntersect() {
  const data = require("semver-range-intersect");
  _semverRangeIntersect = function () {
    return data;
  };
  return data;
}
function _componentVersion() {
  const data = require("@teambit/component-version");
  _componentVersion = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../dependencies/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * This is the second phase of the deduping process.
 * It will get the index calculated in the first phase (with dep id as key)
 * and will find the most intersect range for each dep and move it to the root
 * it will also move deps which are both dev deps and runtime deps to be runtime deps
 *
 * @param {PackageNameIndex} depIdIndex
 * @returns {DedupedDependencies}
 */
function hoistDependencies(depIdIndex) {
  const result = getEmptyDedupedDependencies();

  // TODO: handle git urls

  depIdIndex.forEach((indexItem, packageName) => {
    let toContinue;
    toContinue = handlePreserved(result, packageName, indexItem);
    if (!toContinue) return;
    toContinue = addOneOccurrenceToRoot(result, packageName, indexItem.componentItems);
    if (!toContinue) return;
    toContinue = handlePeersOnly(result, packageName, indexItem.componentItems);
    if (!toContinue) return;
    const groupedByRangeOrVersion = groupByRangeOrVersion(indexItem.componentItems);
    if (groupedByRangeOrVersion.versions.length > 0 && groupedByRangeOrVersion.ranges.length === 0) {
      handleExactVersionsOnly(result, packageName, indexItem.componentItems);
    } else if (groupedByRangeOrVersion.versions.length === 0 && groupedByRangeOrVersion.ranges.length > 0) {
      handleRangesOnly(result, packageName, indexItem.componentItems);
    } else {
      handleRangesAndVersions(result, packageName, indexItem.componentItems, groupedByRangeOrVersion);
    }
  });
  return result;
}
function handlePreserved(dedupedDependencies, packageName, indexItem) {
  const preservedVersion = indexItem.metadata.preservedVersion;
  // Not preserved, move on
  if (!preservedVersion) {
    return true;
  }
  const preservedLifecycleType = indexItem.metadata.preservedLifecycleType;
  const keyName = _constants().KEY_NAME_BY_LIFECYCLE_TYPE[preservedLifecycleType || 'dependencies'];
  dedupedDependencies.rootDependencies[keyName][packageName] = preservedVersion;
  const filterFunc = item => {
    // items which are intersect with the preserved version won't needed to be installed nested in the component
    // this in very rare cases might create bugs in case the version are intersects, but the real version in the registry
    // which satisfies the preserved not satisfy the item range.
    // In such case I would expect to get version not exist when coming to install the version in the nested component
    return !!(0, _semverRangeIntersect().intersect)(item.range, preservedVersion);
  };
  indexItem.componentItems.map(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName, filterFunc));
  return false;
}

/**
 * In case there is only one component with a specific dependency,
 * OR
 * all the components have the same version of the dependency
 * add it to the root
 * (it used to check also if it's not peer, but we remove it for bit sign support)
 *
 * @param {DedupedDependencies} dedupedDependencies
 * @param {PackageName} packageName
 * @param {PackageNameIndexComponentItem} indexItem
 */
function addOneOccurrenceToRoot(dedupedDependencies, packageName, indexItems) {
  if (indexItems.length > 1) {
    const uniqVersions = (0, _lodash().uniq)(indexItems.map(item => item.range));
    if (uniqVersions.length > 1) {
      return true;
    }
  }
  const indexItem = indexItems[0];
  // if (indexItem.lifecycleType !== PEER_DEP_LIFECYCLE_TYPE) {
  const keyName = _constants().KEY_NAME_BY_LIFECYCLE_TYPE[indexItem.lifecycleType];
  dedupedDependencies.rootDependencies[keyName][packageName] = indexItem.range;
  return false;
  // }
  // return true;
}

/**
 * Handle a case where the package appear as a peer for all its deponents
 * in that case we won't hoist it to the root, we will only notify about conflicts
 *
 * @param {DedupedDependencies} dedupedDependencies
 * @param {PackageName} packageName
 * @param {PackageNameIndexComponentItem[]} indexItems
 * @returns {boolean}
 */
function handlePeersOnly(dedupedDependencies, packageName, indexItems) {
  const nonPeerItems = indexItems.filter(item => {
    return item.lifecycleType !== _constants().PEER_DEP_LIFECYCLE_TYPE;
  });
  if (nonPeerItems.length > 0) {
    return true;
  }
  const allRanges = indexItems.map(item => item.range);
  const intersected = (0, _semverRangeIntersect().intersect)(...allRanges);
  if (intersected) {
    // Add to peers for each component to make sure we are getting warning from the package manager about missing peers
    indexItems.map(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName));
  } else {
    var _dedupedDependencies$;
    indexItems.map(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName));
    // There are peer version with conflicts, let the user know about it
    const conflictedComponents = indexItems.map(item => {
      return {
        componentPackageName: item.origin,
        range: item.range
      };
    });
    const conflictMessage = `The following components has conflicted peer dependencies: ${conflictedComponents.map(c => c.componentPackageName).join(',')} for the dependency: ${packageName}`;
    const issue = {
      packageName,
      conflictedComponents,
      conflictMessage
    };
    (_dedupedDependencies$ = dedupedDependencies.issus) === null || _dedupedDependencies$ === void 0 ? void 0 : _dedupedDependencies$.peerConflicts.push(issue);
  }
  return false;
}

/**
 * This will handle a case when there is only exact version in the index
 * In such case it will take the most common version and hoist it to the root
 * It will set all the other version in the corresponding components
 * This assume the items has been already checked to contain only exact versions
 *
 * @param {DedupedDependencies} dedupedDependencies
 * @param {PackageName} packageName
 * @param {PackageNameIndexComponentItem[]} indexItems
 */
function handleExactVersionsOnly(dedupedDependencies, packageName, indexItems) {
  const allVersions = indexItems.map(item => item.range);

  // Add most common version to root
  const mostCommonVersion = findMostCommonVersion(allVersions).version;
  const lifeCycleType = getLifecycleType(indexItems);
  const depKeyName = _constants().KEY_NAME_BY_LIFECYCLE_TYPE[lifeCycleType];
  dedupedDependencies.rootDependencies[depKeyName][packageName] = mostCommonVersion;
  const filterFunc = item => {
    if (item.range === mostCommonVersion) return true;
    return false;
  };
  indexItems.forEach(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName, filterFunc));
}

/**
 * This will handle a case when there is only ranges in the index
 * In such case it will search for an intersection with the most components and hoist it to the root
 * It will set all the other ranges in the corresponding components
 * This assume the items has been already checked to contain only ranges
 *
 * @param {DedupedDependencies} dedupedDependencies
 * @param {PackageName} packageName
 * @param {PackageNameIndexComponentItem[]} indexItems
 */
function handleRangesOnly(dedupedDependencies, packageName, indexItems) {
  const rangesVersions = indexItems.map(item => item.range);
  const bestRange = findBestRange(rangesVersions);
  const lifeCycleType = getLifecycleType(indexItems);
  const depKeyName = _constants().KEY_NAME_BY_LIFECYCLE_TYPE[lifeCycleType];
  dedupedDependencies.rootDependencies[depKeyName][packageName] = bestRange.intersectedRange;
  const filterFunc = item => {
    if (bestRange.ranges.includes(item.range)) return true;
    return false;
  };
  indexItems.forEach(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName, filterFunc));
}

/**
 * This will handle a case when there is both ranges and exact versions in the index
 * it will find the best range and see how many components it fits
 * it will find the most common version and see how many components it fits
 * Then it will take the best of them and hoist into the root and put others in the components
 * TODO: this can be improved by adding to the ranges count the satisfying exact versions
 *
 * @param {DedupedDependencies} dedupedDependencies
 * @param {PackageName} packageName
 * @param {PackageNameIndexComponentItem[]} indexItems
 * @param {ItemsGroupedByRangeOrVersion} groups
 */
function handleRangesAndVersions(dedupedDependencies, packageName, indexItems, groups) {
  const allVersions = groups.versions.map(item => item.range);
  const mostCommonVersion = findMostCommonVersion(allVersions);
  // Include versions here since we might have a specific version which match the best version as well
  const rangesVersions = indexItems.map(item => item.range);
  const bestRange = findBestRange(rangesVersions);
  const lifeCycleType = getLifecycleType(indexItems);
  const depKeyName = _constants().KEY_NAME_BY_LIFECYCLE_TYPE[lifeCycleType];
  let filterFunc = item => {
    if (bestRange.ranges.includes(item.range)) return true;
    return false;
  };
  if (bestRange.count < mostCommonVersion.count) {
    dedupedDependencies.rootDependencies[depKeyName][packageName] = mostCommonVersion.version;
    filterFunc = item => {
      if (item.range === mostCommonVersion) return true;
      return false;
    };
  } else {
    dedupedDependencies.rootDependencies[depKeyName][packageName] = bestRange.intersectedRange;
  }
  indexItems.forEach(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName, filterFunc));
}

/**
 * Finding the best range - a range the intersect as many ranges as possible
 * it will work by create all the possible combination of the ranges
 * then try to intersect them based on the number of the ranges (items) and how many times they appear in the original array
 *
 * @param {SemverVersion[]} ranges
 * @returns {BestRange}
 */
function findBestRange(ranges) {
  const result = {
    ranges: [],
    intersectedRange: '0.0.0',
    count: 0
  };
  const sortedByTotal = getSortedRangesCombination(ranges);
  let i = 0;
  // Since it's already sorted by count, once we found match we can stop looping
  while (result.count === 0 && i < sortedByTotal.length) {
    const combinationWithTotal = sortedByTotal[i];
    const intersectedRange = (0, _semverRangeIntersect().intersect)(...combinationWithTotal.combination);
    if (intersectedRange) {
      result.intersectedRange = intersectedRange;
      result.ranges = combinationWithTotal.combination;
      result.count = combinationWithTotal.total;
    } else {
      i += 1;
    }
  }
  return result;
}

// function getSortedVersionsWithTotal(versions: SemverVersion[]): VersionWithTotal[] {
//   const counts = countBy((item) => item)(versions);
//   const uniqVersions = uniq(versions);
//   const versionsWithTotalCount = uniqVersions.map((version) => {
//     return {
//       version,
//       total: counts[version],
//     };
//   });

//   const sortByTotal = sortBy(prop('total'));
//   const sortedByTotal = sortByTotal(versionsWithTotalCount).reverse();
//   return sortedByTotal;
// }

function getSortedRangesCombination(ranges) {
  const counts = (0, _lodash().countBy)(ranges, item => item);
  const uniqRanges = (0, _lodash().uniq)(ranges);
  const rangesCombinations = arrayCombinations(uniqRanges);
  const countMultipleRanges = items => {
    return items.reduce((acc, curr) => {
      return acc + counts[curr];
    }, 0);
  };
  // The count is count of the items and for each item how many times it appear in the original ranges
  // Since there might be same range multiple time in the original ranges array.

  const rangesCombinationsWithTotalCount = rangesCombinations.map(combination => {
    return {
      combination,
      total: countMultipleRanges(combination)
    };
  });
  const sortedByTotal = (0, _lodash().sortBy)(rangesCombinationsWithTotalCount, (0, _lodash().property)('total')).reverse();
  return sortedByTotal;
}

/**
 * Check if a package should be a dev dependency or runtime dependency by checking if it appears as runtime dependency at least once
 *
 * @param {PackageNameIndexComponentItem[]} indexItems
 * @returns {DependencyLifecycleType}
 */
function getLifecycleType(indexItems) {
  let result = _constants().DEV_DEP_LIFECYCLE_TYPE;
  indexItems.forEach(item => {
    if (item.lifecycleType === _constants().RUNTIME_DEP_LIFECYCLE_TYPE) {
      result = _constants().RUNTIME_DEP_LIFECYCLE_TYPE;
    }
  });
  return result;
}

/**
 * Find the version that appears the most
 *
 * @param {SemverVersion[]} versions
 * @returns {MostCommonVersion}
 */
function findMostCommonVersion(versions) {
  const counts = (0, _lodash().countBy)(versions, item => item);
  const result = {
    version: '0.0.0',
    count: 0
  };
  (0, _forEachObjIndexed().default)((count, version) => {
    if (count > result.count) {
      result.version = version;
      result.count = count;
    }
  }, counts);
  return result;
}

/**
 * A wrapper function used to be passed to map on index items and add it to a component dependency in the deduped dependencies if it's filter function return false
 *
 * @param {DedupedDependencies} dedupedDependencies
 * @param {PackageName} packageName
 * @param {(item: PackageNameIndexComponentItem) => boolean} [filterFunc]
 * @returns
 */
function addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName, filterFunc) {
  return indexItem => {
    if (filterFunc && typeof filterFunc === 'function') {
      const toFilter = filterFunc(indexItem);
      if (toFilter) return;
    }
    let compEntry = dedupedDependencies.componentDependenciesMap.get(indexItem.origin);
    const depKeyName = _constants().KEY_NAME_BY_LIFECYCLE_TYPE[indexItem.lifecycleType];
    if (!compEntry) {
      compEntry = {
        dependencies: {},
        devDependencies: {},
        peerDependencies: {}
      };
    }
    compEntry[depKeyName] = _objectSpread(_objectSpread({}, compEntry[depKeyName]), {}, {
      [packageName]: indexItem.range
    });
    dedupedDependencies.componentDependenciesMap.set(indexItem.origin, compEntry);
  };
}

/**
 * Get an array of index items and group them to items with ranges and items with exact version
 *
 * @param {PackageNameIndexComponentItem[]} indexItems
 * @returns {ItemsGroupedByRangeOrVersion}
 */
function groupByRangeOrVersion(indexItems) {
  const result = {
    ranges: [],
    versions: []
  };
  indexItems.forEach(item => {
    const validRange = _semver().default.validRange(item.range);
    if (!validRange && !(0, _componentVersion().isHash)(item.range)) {
      throw new Error(`fatal: the version "${item.range}" originated from a dependent "${item.origin}" is invalid semver range and not a hash`);
    }
    if (!validRange && (0, _componentVersion().isHash)(item.range)) {
      result.versions.push(item);
      return;
    }
    // parseRange does not support `*` as version
    // `*` does not affect resulted version, it might be just ignored
    if (validRange === '*') {
      // to prevent empty `result.ranges`, it needs to be pushed
      result.ranges.push(item);
      return;
    }
    const parsed = (0, _semverIntersect().parseRange)(validRange);
    if (parsed.condition === '=') {
      result.versions.push(item);
      return;
    }
    result.ranges.push(item);
  });
  return result;
}

// Taken from https://web.archive.org/web/20140418004051/http://dzone.com/snippets/calculate-all-combinations
/**
 * Return all combinations of array items. for example:
 * arrayCombinations([1,2]) == [[1], [2], [1,2]];
 *
 * @param {Array<T>} array
 * @returns {Array<T[]>}
 */
function arrayCombinations(array) {
  const fn = function (n, src, got, all) {
    if (n === 0) {
      if (got.length > 0) {
        all[all.length] = got;
      }
      return;
    }
    // eslint-disable-next-line
    for (let j = 0; j < src.length; j++) {
      fn(n - 1, src.slice(j + 1), got.concat([src[j]]), all);
    }
  };
  const all = [];
  // eslint-disable-next-line
  for (let i = 0; i < array.length; i++) {
    fn(i, array, [], all);
  }
  all.push(array);
  return all;
}
function getEmptyDedupedDependencies() {
  const result = {
    rootDependencies: {
      dependencies: {},
      devDependencies: {},
      peerDependencies: {}
    },
    componentDependenciesMap: new Map(),
    issus: {
      peerConflicts: []
    }
  };
  return result;
}

//# sourceMappingURL=hoist-dependencies.js.map