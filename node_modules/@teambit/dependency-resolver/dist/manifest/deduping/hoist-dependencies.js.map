{"version":3,"names":["hoistDependencies","depIdIndex","result","getEmptyDedupedDependencies","forEach","indexItem","packageName","toContinue","handlePreserved","addOneOccurrenceToRoot","componentItems","handlePeersOnly","groupedByRangeOrVersion","groupByRangeOrVersion","versions","length","ranges","handleExactVersionsOnly","handleRangesOnly","handleRangesAndVersions","dedupedDependencies","preservedVersion","metadata","preservedLifecycleType","keyName","KEY_NAME_BY_LIFECYCLE_TYPE","rootDependencies","filterFunc","item","intersect","range","map","addToComponentDependenciesMapInDeduped","indexItems","uniqVersions","uniq","lifecycleType","nonPeerItems","filter","PEER_DEP_LIFECYCLE_TYPE","allRanges","intersected","conflictedComponents","componentPackageName","origin","conflictMessage","c","join","issue","issus","peerConflicts","push","allVersions","mostCommonVersion","findMostCommonVersion","version","lifeCycleType","getLifecycleType","depKeyName","rangesVersions","bestRange","findBestRange","intersectedRange","includes","groups","count","sortedByTotal","getSortedRangesCombination","i","combinationWithTotal","combination","total","counts","countBy","uniqRanges","rangesCombinations","arrayCombinations","countMultipleRanges","items","reduce","acc","curr","rangesCombinationsWithTotalCount","sortBy","property","reverse","DEV_DEP_LIFECYCLE_TYPE","RUNTIME_DEP_LIFECYCLE_TYPE","forEachObjIndexed","toFilter","compEntry","componentDependenciesMap","get","dependencies","devDependencies","peerDependencies","set","validRange","semver","isHash","Error","parsed","parseRange","condition","array","fn","n","src","got","all","j","slice","concat","Map"],"sources":["hoist-dependencies.ts"],"sourcesContent":["import forEachObjIndexed from 'ramda/src/forEachObjIndexed';\nimport { countBy, property, sortBy, uniq } from 'lodash';\nimport semver from 'semver';\nimport { parseRange } from 'semver-intersect';\nimport { intersect } from 'semver-range-intersect';\nimport { isHash } from '@teambit/component-version';\n\nimport {\n  DEV_DEP_LIFECYCLE_TYPE,\n  KEY_NAME_BY_LIFECYCLE_TYPE,\n  PEER_DEP_LIFECYCLE_TYPE,\n  RUNTIME_DEP_LIFECYCLE_TYPE,\n} from '../../dependencies/constants';\nimport { DependencyLifecycleType, SemverVersion, PackageName } from '../../dependencies';\nimport { DedupedDependencies, DedupedDependenciesPeerConflicts } from './dedupe-dependencies';\nimport { PackageNameIndex, PackageNameIndexItem, PackageNameIndexComponentItem } from './index-by-dep-id';\n\ntype ItemsGroupedByRangeOrVersion = {\n  ranges: PackageNameIndexComponentItem[];\n  versions: PackageNameIndexComponentItem[];\n};\n\ntype MostCommonVersion = {\n  version: SemverVersion;\n  count: number;\n};\n\ntype BestRange = {\n  count: number;\n  ranges: SemverVersion[];\n  intersectedRange: SemverVersion;\n};\n\ntype CombinationWithTotal = {\n  combination: SemverVersion[];\n  total: number;\n};\n\n/**\n * This is the second phase of the deduping process.\n * It will get the index calculated in the first phase (with dep id as key)\n * and will find the most intersect range for each dep and move it to the root\n * it will also move deps which are both dev deps and runtime deps to be runtime deps\n *\n * @param {PackageNameIndex} depIdIndex\n * @returns {DedupedDependencies}\n */\nexport function hoistDependencies(depIdIndex: PackageNameIndex): DedupedDependencies {\n  const result: DedupedDependencies = getEmptyDedupedDependencies();\n\n  // TODO: handle git urls\n\n  depIdIndex.forEach((indexItem, packageName) => {\n    let toContinue;\n    toContinue = handlePreserved(result, packageName, indexItem);\n    if (!toContinue) return;\n    toContinue = addOneOccurrenceToRoot(result, packageName, indexItem.componentItems);\n    if (!toContinue) return;\n    toContinue = handlePeersOnly(result, packageName, indexItem.componentItems);\n    if (!toContinue) return;\n    const groupedByRangeOrVersion = groupByRangeOrVersion(indexItem.componentItems);\n    if (groupedByRangeOrVersion.versions.length > 0 && groupedByRangeOrVersion.ranges.length === 0) {\n      handleExactVersionsOnly(result, packageName, indexItem.componentItems);\n    } else if (groupedByRangeOrVersion.versions.length === 0 && groupedByRangeOrVersion.ranges.length > 0) {\n      handleRangesOnly(result, packageName, indexItem.componentItems);\n    } else {\n      handleRangesAndVersions(result, packageName, indexItem.componentItems, groupedByRangeOrVersion);\n    }\n  });\n\n  return result;\n}\n\nfunction handlePreserved(\n  dedupedDependencies: DedupedDependencies,\n  packageName: PackageName,\n  indexItem: PackageNameIndexItem\n): boolean {\n  const preservedVersion = indexItem.metadata.preservedVersion;\n  // Not preserved, move on\n  if (!preservedVersion) {\n    return true;\n  }\n\n  const preservedLifecycleType = indexItem.metadata.preservedLifecycleType;\n\n  const keyName = KEY_NAME_BY_LIFECYCLE_TYPE[preservedLifecycleType || 'dependencies'];\n  dedupedDependencies.rootDependencies[keyName][packageName] = preservedVersion;\n\n  const filterFunc = (item: PackageNameIndexComponentItem) => {\n    // items which are intersect with the preserved version won't needed to be installed nested in the component\n    // this in very rare cases might create bugs in case the version are intersects, but the real version in the registry\n    // which satisfies the preserved not satisfy the item range.\n    // In such case I would expect to get version not exist when coming to install the version in the nested component\n    return !!intersect(item.range, preservedVersion);\n  };\n\n  indexItem.componentItems.map(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName, filterFunc));\n  return false;\n}\n\n/**\n * In case there is only one component with a specific dependency,\n * OR\n * all the components have the same version of the dependency\n * add it to the root\n * (it used to check also if it's not peer, but we remove it for bit sign support)\n *\n * @param {DedupedDependencies} dedupedDependencies\n * @param {PackageName} packageName\n * @param {PackageNameIndexComponentItem} indexItem\n */\nfunction addOneOccurrenceToRoot(\n  dedupedDependencies: DedupedDependencies,\n  packageName: PackageName,\n  indexItems: PackageNameIndexComponentItem[]\n): boolean {\n  if (indexItems.length > 1) {\n    const uniqVersions = uniq(indexItems.map((item) => item.range));\n    if (uniqVersions.length > 1) {\n      return true;\n    }\n  }\n  const indexItem = indexItems[0];\n  // if (indexItem.lifecycleType !== PEER_DEP_LIFECYCLE_TYPE) {\n  const keyName = KEY_NAME_BY_LIFECYCLE_TYPE[indexItem.lifecycleType];\n  dedupedDependencies.rootDependencies[keyName][packageName] = indexItem.range;\n  return false;\n  // }\n  // return true;\n}\n\n/**\n * Handle a case where the package appear as a peer for all its deponents\n * in that case we won't hoist it to the root, we will only notify about conflicts\n *\n * @param {DedupedDependencies} dedupedDependencies\n * @param {PackageName} packageName\n * @param {PackageNameIndexComponentItem[]} indexItems\n * @returns {boolean}\n */\nfunction handlePeersOnly(\n  dedupedDependencies: DedupedDependencies,\n  packageName: PackageName,\n  indexItems: PackageNameIndexComponentItem[]\n): boolean {\n  const nonPeerItems = indexItems.filter((item) => {\n    return item.lifecycleType !== PEER_DEP_LIFECYCLE_TYPE;\n  });\n  if (nonPeerItems.length > 0) {\n    return true;\n  }\n  const allRanges = indexItems.map((item) => item.range);\n  const intersected = intersect(...allRanges);\n  if (intersected) {\n    // Add to peers for each component to make sure we are getting warning from the package manager about missing peers\n    indexItems.map(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName));\n  } else {\n    indexItems.map(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName));\n    // There are peer version with conflicts, let the user know about it\n    const conflictedComponents = indexItems.map((item) => {\n      return {\n        componentPackageName: item.origin,\n        range: item.range,\n      };\n    });\n    const conflictMessage = `The following components has conflicted peer dependencies: ${conflictedComponents\n      .map((c) => c.componentPackageName)\n      .join(',')} for the dependency: ${packageName}`;\n    const issue: DedupedDependenciesPeerConflicts = {\n      packageName,\n      conflictedComponents,\n      conflictMessage,\n    };\n    dedupedDependencies.issus?.peerConflicts.push(issue);\n  }\n  return false;\n}\n\n/**\n * This will handle a case when there is only exact version in the index\n * In such case it will take the most common version and hoist it to the root\n * It will set all the other version in the corresponding components\n * This assume the items has been already checked to contain only exact versions\n *\n * @param {DedupedDependencies} dedupedDependencies\n * @param {PackageName} packageName\n * @param {PackageNameIndexComponentItem[]} indexItems\n */\nfunction handleExactVersionsOnly(\n  dedupedDependencies: DedupedDependencies,\n  packageName: PackageName,\n  indexItems: PackageNameIndexComponentItem[]\n): void {\n  const allVersions = indexItems.map((item) => item.range);\n\n  // Add most common version to root\n  const mostCommonVersion = findMostCommonVersion(allVersions).version;\n  const lifeCycleType = getLifecycleType(indexItems);\n  const depKeyName = KEY_NAME_BY_LIFECYCLE_TYPE[lifeCycleType];\n  dedupedDependencies.rootDependencies[depKeyName][packageName] = mostCommonVersion;\n\n  const filterFunc = (item) => {\n    if (item.range === mostCommonVersion) return true;\n    return false;\n  };\n\n  indexItems.forEach(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName, filterFunc));\n}\n\n/**\n * This will handle a case when there is only ranges in the index\n * In such case it will search for an intersection with the most components and hoist it to the root\n * It will set all the other ranges in the corresponding components\n * This assume the items has been already checked to contain only ranges\n *\n * @param {DedupedDependencies} dedupedDependencies\n * @param {PackageName} packageName\n * @param {PackageNameIndexComponentItem[]} indexItems\n */\nfunction handleRangesOnly(\n  dedupedDependencies: DedupedDependencies,\n  packageName: PackageName,\n  indexItems: PackageNameIndexComponentItem[]\n): void {\n  const rangesVersions = indexItems.map((item) => item.range);\n  const bestRange = findBestRange(rangesVersions);\n  const lifeCycleType = getLifecycleType(indexItems);\n  const depKeyName = KEY_NAME_BY_LIFECYCLE_TYPE[lifeCycleType];\n  dedupedDependencies.rootDependencies[depKeyName][packageName] = bestRange.intersectedRange;\n\n  const filterFunc = (item) => {\n    if (bestRange.ranges.includes(item.range)) return true;\n    return false;\n  };\n\n  indexItems.forEach(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName, filterFunc));\n}\n\n/**\n * This will handle a case when there is both ranges and exact versions in the index\n * it will find the best range and see how many components it fits\n * it will find the most common version and see how many components it fits\n * Then it will take the best of them and hoist into the root and put others in the components\n * TODO: this can be improved by adding to the ranges count the satisfying exact versions\n *\n * @param {DedupedDependencies} dedupedDependencies\n * @param {PackageName} packageName\n * @param {PackageNameIndexComponentItem[]} indexItems\n * @param {ItemsGroupedByRangeOrVersion} groups\n */\nfunction handleRangesAndVersions(\n  dedupedDependencies: DedupedDependencies,\n  packageName: PackageName,\n  indexItems: PackageNameIndexComponentItem[],\n  groups: ItemsGroupedByRangeOrVersion\n): void {\n  const allVersions = groups.versions.map((item) => item.range);\n  const mostCommonVersion = findMostCommonVersion(allVersions);\n  // Include versions here since we might have a specific version which match the best version as well\n  const rangesVersions = indexItems.map((item) => item.range);\n  const bestRange = findBestRange(rangesVersions);\n  const lifeCycleType = getLifecycleType(indexItems);\n  const depKeyName = KEY_NAME_BY_LIFECYCLE_TYPE[lifeCycleType];\n\n  let filterFunc = (item) => {\n    if (bestRange.ranges.includes(item.range)) return true;\n    return false;\n  };\n\n  if (bestRange.count < mostCommonVersion.count) {\n    dedupedDependencies.rootDependencies[depKeyName][packageName] = mostCommonVersion.version;\n    filterFunc = (item) => {\n      if (item.range === mostCommonVersion) return true;\n      return false;\n    };\n  } else {\n    dedupedDependencies.rootDependencies[depKeyName][packageName] = bestRange.intersectedRange;\n  }\n  indexItems.forEach(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName, filterFunc));\n}\n\n/**\n * Finding the best range - a range the intersect as many ranges as possible\n * it will work by create all the possible combination of the ranges\n * then try to intersect them based on the number of the ranges (items) and how many times they appear in the original array\n *\n * @param {SemverVersion[]} ranges\n * @returns {BestRange}\n */\nfunction findBestRange(ranges: SemverVersion[]): BestRange {\n  const result: BestRange = {\n    ranges: [],\n    intersectedRange: '0.0.0',\n    count: 0,\n  };\n\n  const sortedByTotal = getSortedRangesCombination(ranges);\n  let i = 0;\n  // Since it's already sorted by count, once we found match we can stop looping\n  while (result.count === 0 && i < sortedByTotal.length) {\n    const combinationWithTotal = sortedByTotal[i];\n    const intersectedRange = intersect(...combinationWithTotal.combination);\n    if (intersectedRange) {\n      result.intersectedRange = intersectedRange;\n      result.ranges = combinationWithTotal.combination;\n      result.count = combinationWithTotal.total;\n    } else {\n      i += 1;\n    }\n  }\n  return result;\n}\n\n// function getSortedVersionsWithTotal(versions: SemverVersion[]): VersionWithTotal[] {\n//   const counts = countBy((item) => item)(versions);\n//   const uniqVersions = uniq(versions);\n//   const versionsWithTotalCount = uniqVersions.map((version) => {\n//     return {\n//       version,\n//       total: counts[version],\n//     };\n//   });\n\n//   const sortByTotal = sortBy(prop('total'));\n//   const sortedByTotal = sortByTotal(versionsWithTotalCount).reverse();\n//   return sortedByTotal;\n// }\n\nfunction getSortedRangesCombination(ranges: SemverVersion[]): CombinationWithTotal[] {\n  const counts = countBy(ranges, (item) => item);\n  const uniqRanges = uniq(ranges);\n  const rangesCombinations = arrayCombinations<SemverVersion>(uniqRanges);\n  const countMultipleRanges = (items: SemverVersion[]): number => {\n    return items.reduce((acc, curr) => {\n      return acc + counts[curr];\n    }, 0);\n  };\n  // The count is count of the items and for each item how many times it appear in the original ranges\n  // Since there might be same range multiple time in the original ranges array.\n\n  const rangesCombinationsWithTotalCount = rangesCombinations.map((combination) => {\n    return {\n      combination,\n      total: countMultipleRanges(combination),\n    };\n  });\n\n  const sortedByTotal = sortBy(rangesCombinationsWithTotalCount, property('total')).reverse();\n  return sortedByTotal;\n}\n\n/**\n * Check if a package should be a dev dependency or runtime dependency by checking if it appears as runtime dependency at least once\n *\n * @param {PackageNameIndexComponentItem[]} indexItems\n * @returns {DependencyLifecycleType}\n */\nfunction getLifecycleType(indexItems: PackageNameIndexComponentItem[]): DependencyLifecycleType {\n  let result: DependencyLifecycleType = DEV_DEP_LIFECYCLE_TYPE;\n  indexItems.forEach((item) => {\n    if (item.lifecycleType === RUNTIME_DEP_LIFECYCLE_TYPE) {\n      result = RUNTIME_DEP_LIFECYCLE_TYPE;\n    }\n  });\n  return result;\n}\n\n/**\n * Find the version that appears the most\n *\n * @param {SemverVersion[]} versions\n * @returns {MostCommonVersion}\n */\nfunction findMostCommonVersion(versions: SemverVersion[]): MostCommonVersion {\n  const counts = countBy(versions, (item) => item);\n  const result: MostCommonVersion = {\n    version: '0.0.0',\n    count: 0,\n  };\n  forEachObjIndexed((count, version) => {\n    if (count > result.count) {\n      result.version = version;\n      result.count = count;\n    }\n  }, counts);\n  return result;\n}\n\n/**\n * A wrapper function used to be passed to map on index items and add it to a component dependency in the deduped dependencies if it's filter function return false\n *\n * @param {DedupedDependencies} dedupedDependencies\n * @param {PackageName} packageName\n * @param {(item: PackageNameIndexComponentItem) => boolean} [filterFunc]\n * @returns\n */\nfunction addToComponentDependenciesMapInDeduped(\n  dedupedDependencies: DedupedDependencies,\n  packageName: PackageName,\n  filterFunc?: (item: PackageNameIndexComponentItem) => boolean\n) {\n  return (indexItem: PackageNameIndexComponentItem) => {\n    if (filterFunc && typeof filterFunc === 'function') {\n      const toFilter = filterFunc(indexItem);\n      if (toFilter) return;\n    }\n    let compEntry = dedupedDependencies.componentDependenciesMap.get(indexItem.origin);\n    const depKeyName = KEY_NAME_BY_LIFECYCLE_TYPE[indexItem.lifecycleType];\n    if (!compEntry) {\n      compEntry = {\n        dependencies: {},\n        devDependencies: {},\n        peerDependencies: {},\n      };\n    }\n    compEntry[depKeyName] = {\n      ...compEntry[depKeyName],\n      [packageName]: indexItem.range,\n    };\n    dedupedDependencies.componentDependenciesMap.set(indexItem.origin, compEntry);\n  };\n}\n\n/**\n * Get an array of index items and group them to items with ranges and items with exact version\n *\n * @param {PackageNameIndexComponentItem[]} indexItems\n * @returns {ItemsGroupedByRangeOrVersion}\n */\nfunction groupByRangeOrVersion(indexItems: PackageNameIndexComponentItem[]): ItemsGroupedByRangeOrVersion {\n  const result: ItemsGroupedByRangeOrVersion = {\n    ranges: [],\n    versions: [],\n  };\n  indexItems.forEach((item) => {\n    const validRange = semver.validRange(item.range);\n    if (!validRange && !isHash(item.range)) {\n      throw new Error(\n        `fatal: the version \"${item.range}\" originated from a dependent \"${item.origin}\" is invalid semver range and not a hash`\n      );\n    }\n    if (!validRange && isHash(item.range)) {\n      result.versions.push(item);\n      return;\n    }\n    // parseRange does not support `*` as version\n    // `*` does not affect resulted version, it might be just ignored\n    if (validRange === '*') {\n      // to prevent empty `result.ranges`, it needs to be pushed\n      result.ranges.push(item);\n      return;\n    }\n    const parsed = parseRange(validRange);\n    if (parsed.condition === '=') {\n      result.versions.push(item);\n      return;\n    }\n    result.ranges.push(item);\n  });\n  return result;\n}\n\n// Taken from https://web.archive.org/web/20140418004051/http://dzone.com/snippets/calculate-all-combinations\n/**\n * Return all combinations of array items. for example:\n * arrayCombinations([1,2]) == [[1], [2], [1,2]];\n *\n * @param {Array<T>} array\n * @returns {Array<T[]>}\n */\nfunction arrayCombinations<T>(array: Array<T>): Array<T[]> {\n  const fn = function (n, src, got, all) {\n    if (n === 0) {\n      if (got.length > 0) {\n        all[all.length] = got;\n      }\n      return;\n    }\n    // eslint-disable-next-line\n    for (let j = 0; j < src.length; j++) {\n      fn(n - 1, src.slice(j + 1), got.concat([src[j]]), all);\n    }\n  };\n  const all: Array<T[]> = [];\n  // eslint-disable-next-line\n  for (let i = 0; i < array.length; i++) {\n    fn(i, array, [], all);\n  }\n  all.push(array);\n  return all;\n}\n\nexport function getEmptyDedupedDependencies(): DedupedDependencies {\n  const result: DedupedDependencies = {\n    rootDependencies: {\n      dependencies: {},\n      devDependencies: {},\n      peerDependencies: {},\n    },\n    componentDependenciesMap: new Map(),\n    issus: {\n      peerConflicts: [],\n    },\n  };\n  return result;\n}\n"],"mappings":"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"}