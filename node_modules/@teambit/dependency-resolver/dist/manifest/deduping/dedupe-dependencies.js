"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dedupeDependencies = dedupeDependencies;
Object.defineProperty(exports, "getEmptyDedupedDependencies", {
  enumerable: true,
  get: function () {
    return _hoistDependencies().getEmptyDedupedDependencies;
  }
});
function _hoistDependencies() {
  const data = require("./hoist-dependencies");
  _hoistDependencies = function () {
    return data;
  };
  return data;
}
function _indexByDepId() {
  const data = require("./index-by-dep-id");
  _indexByDepId = function () {
    return data;
  };
  return data;
}
function _mergeWithRoot() {
  const data = require("./merge-with-root");
  _mergeWithRoot = function () {
    return data;
  };
  return data;
}
/**
 * Main function to dedupe dependencies
 * It will optimized the dependencies structure to make sure there is minimum duplication of the same dependency (as a result of conflicted versions)
 * it will take everything possible to be defined in the root, and only conflicts in the components
 * it's similar to what happens when you use yarn workspaces
 *
 * @export
 * @returns {DedupedDependencies}
 */
function dedupeDependencies(rootPolicy, componentDependenciesMap, hoistedDepFields) {
  const indexedByDepId = (0, _indexByDepId().indexByDepId)(rootPolicy, componentDependenciesMap, hoistedDepFields);
  const dedupedDependenciesWithoutRootOriginal = (0, _hoistDependencies().hoistDependencies)(indexedByDepId);
  const result = (0, _mergeWithRoot().mergeWithRootDeps)(rootPolicy.toManifest(), dedupedDependenciesWithoutRootOriginal);
  return result;
}

//# sourceMappingURL=dedupe-dependencies.js.map