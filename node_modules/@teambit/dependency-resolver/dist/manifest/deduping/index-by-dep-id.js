"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.indexByDepId = indexByDepId;
function _forEachObjIndexed() {
  const data = _interopRequireDefault(require("ramda/src/forEachObjIndexed"));
  _forEachObjIndexed = function () {
    return data;
  };
  return data;
}
function _pick() {
  const data = _interopRequireDefault(require("ramda/src/pick"));
  _pick = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../dependencies/constants");
  _constants = function () {
    return data;
  };
  return data;
}
/**
 * This will get the map of dependencies for each component and will create a new index with the dependencyId (package name) as key
 * and all components / ranges as value
 * It used as a pre processing as part of the deduping process
 *
 * @param {ComponentDependenciesMap} componentDependenciesMap
 * @returns {PackageNameIndex}
 */
function indexByDepId(rootPolicy, componentDependenciesMap, hoistedDepFields) {
  const result = new Map();
  componentDependenciesMap.forEach((depsObject, compPackageName) => {
    if (hoistedDepFields) {
      depsObject = (0, _pick().default)(hoistedDepFields, depsObject);
    }
    (0, _forEachObjIndexed().default)(addSpecificLifeCycleDepsToIndex(result, compPackageName), depsObject);
  });
  addPreservedFromRoot(result, rootPolicy);
  return result;
}
function addPreservedFromRoot(index, rootPolicy) {
  const preserved = rootPolicy.filter(entry => !!entry.value.preserve);
  preserved.forEach(entry => {
    const metadata = {
      preservedVersion: entry.value.version,
      preservedLifecycleType: entry.lifecycleType
    };
    setMetadataToExistingIndexItem(index, entry.dependencyId, metadata);
  });
}
function setMetadataToExistingIndexItem(index, depId, metadata) {
  const existingItem = index.get(depId);
  // only change existing items
  if (existingItem) {
    existingItem.metadata = metadata;
  }
}

/**
 * Mutate the index and add all deps from specific lifecycle type to the index
 *
 * @param {PackageNameIndex} index
 * @param {PackageName} origin
 * @returns
 */
function addSpecificLifeCycleDepsToIndex(index, origin) {
  return (deps, depKeyName) => {
    const lifecycleType = _constants().LIFECYCLE_TYPE_BY_KEY_NAME[depKeyName];
    (0, _forEachObjIndexed().default)(addComponentDepToDepIdIndex(index, origin, lifecycleType), deps);
  };
}

/**
 * Mutate the index and add specific package into it
 *
 * @param {PackageNameIndex} index
 * @param {PackageName} origin
 * @param {DependencyLifecycleType} lifecycleType
 * @returns
 */
function addComponentDepToDepIdIndex(index, origin, lifecycleType) {
  return (range, depId) => {
    var _index$get;
    const componentItem = {
      origin,
      range,
      lifecycleType
    };
    if (!index.has(depId)) {
      const item = {
        componentItems: [componentItem],
        metadata: {}
      };
      index.set(depId, item);
      return;
    }
    (_index$get = index.get(depId)) === null || _index$get === void 0 ? void 0 : _index$get.componentItems.push(componentItem);
  };
}

//# sourceMappingURL=index-by-dep-id.js.map