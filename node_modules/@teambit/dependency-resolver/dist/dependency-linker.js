"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DependencyLinker = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _isBuiltinModule() {
  const data = _interopRequireDefault(require("is-builtin-module"));
  _isBuiltinModule = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _resolveFrom() {
  const data = _interopRequireDefault(require("resolve-from"));
  _resolveFrom = function () {
    return data;
  };
  return data;
}
function _link() {
  const data = require("@teambit/legacy/dist/api/consumer/lib/link");
  _link = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@teambit/legacy/dist/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/bit/component-id-to-package-name"));
  _componentIdToPackageName = function () {
    return data;
  };
  return data;
}
function _symlink() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/links/symlink"));
  _symlink = function () {
    return data;
  };
  return data;
}
function _aspectLoader() {
  const data = require("@teambit/aspect-loader");
  _aspectLoader = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const DEFAULT_LINKING_OPTIONS = {
  legacyLink: true,
  rewire: false,
  linkTeambitBit: true,
  linkCoreAspects: true,
  linkDepsResolvedFromEnv: true,
  linkNestedDepsInNM: true
};
class DependencyLinker {
  constructor(dependencyResolver, aspectLoader, componentAspect, envs, logger, rootDir, linkingOptions) {
    this.dependencyResolver = dependencyResolver;
    this.aspectLoader = aspectLoader;
    this.componentAspect = componentAspect;
    this.envs = envs;
    this.logger = logger;
    this.rootDir = rootDir;
    this.linkingOptions = linkingOptions;
  }
  async link(rootDir, rootPolicy, componentDirectoryMap, options = {}) {
    this.logger.setStatusLine('linking components');
    this.logger.debug('linking components with options', (0, _lodash().omit)(options, ['consumer']));
    let result = {};
    const finalRootDir = rootDir || this.rootDir;
    const linkingOpts = Object.assign({}, DEFAULT_LINKING_OPTIONS, this.linkingOptions || {}, options || {});
    if (!finalRootDir) {
      throw new (_exceptions().RootDirNotDefined)();
    }
    if (options.linkToDir) {
      const components = componentDirectoryMap.toArray().map(([component]) => component);
      const linkToDirResults = await this.linkToDir(finalRootDir, options.linkToDir, components);
      result.linkToDirResults = linkToDirResults;
      return result;
    }
    if (linkingOpts.legacyLink) {
      var _linkingOpts$rewire;
      const bitIds = componentDirectoryMap.toArray().map(([component]) => component.id._legacy);
      if (!linkingOpts.consumer) throw new Error(`the consumer is needed to legacy-link`);
      const legacyResults = await (0, _link().link)(linkingOpts.consumer, bitIds, (_linkingOpts$rewire = linkingOpts.rewire) !== null && _linkingOpts$rewire !== void 0 ? _linkingOpts$rewire : false);
      result.legacyLinkResults = legacyResults.linksResults;
      result.legacyLinkCodemodResults = legacyResults.codemodResults;
    }

    // Link deps which should be linked to the env
    if (linkingOpts.linkDepsResolvedFromEnv) {
      result.resolvedFromEnvLinks = await this.linkDepsResolvedFromEnv(componentDirectoryMap);
    }
    if (linkingOpts.linkNestedDepsInNM) {
      result.nestedDepsInNmLinks = this.addSymlinkFromComponentDirNMToWorkspaceDirNM(finalRootDir, componentDirectoryMap);
    }

    // We remove the version since it used in order to check if it's core aspects, and the core aspects arrived from aspect loader without versions
    const componentIds = [];
    componentDirectoryMap.map((_dir, comp) => {
      componentIds.push(comp.id);
      return undefined;
    });
    result = _objectSpread(_objectSpread({}, result), await this.linkCoreAspectsAndLegacy(rootDir, componentIds, linkingOpts));
    this.logger.consoleSuccess('linking components');
    return result;
  }
  async linkCoreAspectsAndLegacy(rootDir, componentIds = [], options = {}) {
    const result = {};
    const componentIdsWithoutVersions = [];
    componentIds.map(id => {
      componentIdsWithoutVersions.push(id.toString({
        ignoreVersion: true
      }));
      return undefined;
    });
    const finalRootDir = rootDir || this.rootDir;
    if (!finalRootDir) {
      throw new (_exceptions().RootDirNotDefined)();
    }
    const linkingOpts = Object.assign({}, DEFAULT_LINKING_OPTIONS, this.linkingOptions || {}, options || {});
    if (linkingOpts.linkTeambitBit && !this.isBitRepoWorkspace(finalRootDir)) {
      const bitLink = await this.linkBitAspectIfNotExist(_path().default.join(finalRootDir, 'node_modules'), componentIdsWithoutVersions);
      result.teambitBitLink = bitLink;
    }
    if (linkingOpts.linkCoreAspects && !this.isBitRepoWorkspace(finalRootDir)) {
      const hasLocalInstallation = !linkingOpts.linkTeambitBit;
      const coreAspectsLinks = await this.linkNonExistingCoreAspects(_path().default.join(finalRootDir, 'node_modules'), componentIdsWithoutVersions, hasLocalInstallation);
      result.coreAspectsLinks = coreAspectsLinks;
    }
    const teambitLegacyLink = this.linkTeambitLegacy(finalRootDir);
    result.teambitLegacyLink = teambitLegacyLink;
    const harmonyLink = this.linkHarmony(finalRootDir);
    result.harmonyLink = harmonyLink;
    return result;
  }
  async linkToDir(rootDir, targetDir, components) {
    const results = components.map(component => {
      const componentPackageName = (0, _componentIdToPackageName().default)(component.state._consumer);
      return {
        componentId: component.id.toString(),
        linksDetail: {
          from: _path().default.join(rootDir, 'node_modules', componentPackageName),
          to: _path().default.join(targetDir, 'node_modules', componentPackageName)
        }
      };
    });
    results.forEach(({
      componentId,
      linksDetail
    }) => {
      (0, _utils().createSymlinkOrCopy)(linksDetail.from, linksDetail.to, componentId);
    });
    return results;
  }

  /**
   * Add symlinks from the node_modules in the component's root-dir to the workspace node_modules
   * of the component. e.g.
   * <ws-root>/node_modules/comp1/node_modules/<dep> -> <ws-root>/components/comp1/node_modules/<dep>
   * This is needed because the component is compiled into the dist folder at <ws-root>/node_modules/comp1/dist,
   * so the files in the dist folder need to find the right dependencies of comp1.
   */
  addSymlinkFromComponentDirNMToWorkspaceDirNM(rootDir, componentDirectoryMap) {
    const rootNodeModules = _path().default.join(rootDir, 'node_modules');
    const getPackagesFoldersToLink = (dir, parent) => {
      const folders = _fsExtra().default.readdirSync(dir, {
        withFileTypes: true
      }).filter(dirent => {
        if (dirent.name.startsWith('.')) {
          return false;
        }
        return dirent.isDirectory() || dirent.isSymbolicLink();
      }).map(dirent => {
        const dirPath = _path().default.join(dir, dirent.name);
        const moduleName = parent ? `${parent}/${dirent.name}` : dirent.name;
        // If we have a folder with a name of built in module (like events)
        // the resolve from will resolve it from the core, so it will return something like 'events'
        // instead of the path.
        // adding a '/' at the end solve this
        const moduleNameToResolve = (0, _isBuiltinModule().default)(moduleName) ? `${moduleName}/` : moduleName;
        // This is a scoped package, need to go inside
        if (dirent.name.startsWith('@')) {
          return getPackagesFoldersToLink(dirPath, dirent.name);
        }
        if (dirent.isSymbolicLink()) {
          const resolvedModuleFrom = resolveModuleFromDir(dir, moduleNameToResolve);
          if (!resolvedModuleFrom) {
            return {
              moduleName,
              path: dirPath
            };
          }
          return {
            origPath: dirPath,
            moduleName,
            path: resolveModuleDirFromFile(resolvedModuleFrom, moduleName)
          };
        }
        return {
          moduleName,
          path: dirPath
        };
      });
      return (0, _lodash().flatten)(folders);
    };
    const linksOfAllComponents = componentDirectoryMap.toArray().map(([component, dir]) => {
      const compDirNM = _path().default.join(dir, 'node_modules');
      if (!_fsExtra().default.existsSync(compDirNM)) return undefined;
      // TODO: support modules with scoped packages (start with @) - we need to make this logic 2 levels

      const componentPackageName = (0, _componentIdToPackageName().default)(component.state._consumer);
      const innerNMofComponentInNM = _path().default.join(rootNodeModules, componentPackageName);
      // If the folder itself is a symlink, do not try to symlink inside it
      if (isPathSymlink(innerNMofComponentInNM)) {
        return undefined;
      }
      const packagesFoldersToLink = getPackagesFoldersToLink(compDirNM);
      _fsExtra().default.ensureDirSync(innerNMofComponentInNM);
      const oneComponentLinks = packagesFoldersToLink.map(folderEntry => {
        const linkTarget = _path().default.join(innerNMofComponentInNM, 'node_modules', folderEntry === null || folderEntry === void 0 ? void 0 : folderEntry.moduleName);
        const linkSrc = folderEntry.path;
        // This works as well, consider using it instead
        // const linkSrc = folderEntry.origPath || folderEntry.path;
        const origPath = folderEntry.origPath ? `(${folderEntry.origPath})` : '';
        const linkDetail = {
          from: `${linkSrc} ${origPath}`,
          to: linkTarget
        };
        const linkTargetParent = _path().default.resolve(linkTarget, '..');
        const relativeSrc = _path().default.relative(linkTargetParent, linkSrc);
        const symlink = new (_symlink().default)(relativeSrc, linkTarget, component.id._legacy, false);
        this.logger.info(`linking nested dependency ${folderEntry.moduleName} for component ${component}. link src: ${linkSrc} link target: ${linkTarget}`);
        symlink.write();
        return linkDetail;
      });
      const filteredLinks = (0, _lodash().compact)(oneComponentLinks);
      return {
        componentId: component.id.toString(),
        linksDetail: filteredLinks
      };
    });
    const filteredLinks = (0, _lodash().compact)(linksOfAllComponents);
    return filteredLinks;
  }
  async linkDepsResolvedFromEnv(componentDirectoryMap) {
    const componentsNeedLinks = [];
    const componentsNeedLinksP = componentDirectoryMap.toArray().map(async ([component, dir]) => {
      const policy = await this.dependencyResolver.getPolicy(component);
      const resolvedFromEnv = policy.getResolvedFromEnv();
      // Nothing should be resolved from env, do nothing
      if (!resolvedFromEnv.length) {
        return;
      }
      const env = this.envs.getEnv(component);
      const componentNeedLink = {
        component,
        dir,
        env,
        resolvedFromEnv
      };
      componentsNeedLinks.push(componentNeedLink);
    });
    await Promise.all(componentsNeedLinksP);
    // Stop if there are not components needs to be linked
    if (!componentsNeedLinks || !componentsNeedLinks.length) return [];
    const envsStringIds = componentsNeedLinks.map(obj => obj.env.id);
    const uniqEnvIds = (0, _lodash().uniq)(envsStringIds);
    const host = this.componentAspect.getHost();
    const resolvedEnvIds = await host.resolveMultipleComponentIds(uniqEnvIds);
    const resolvedAspects = await host.resolveAspects(undefined, resolvedEnvIds);
    const resolvedAspectsIndex = resolvedAspects.reduce((acc, curr) => {
      if (curr.getId) {
        acc[curr.getId] = curr;
      }
      return acc;
    }, {});
    const allLinksP = componentsNeedLinks.map(async entry => {
      const oneComponentLinksP = entry.resolvedFromEnv.entries.map(async depEntry => {
        const linkTarget = _path().default.join(entry.dir, 'node_modules', depEntry.dependencyId);
        const envDir = resolvedAspectsIndex[entry.env.id].aspectPath;
        const resolvedModule = resolveModuleFromDir(envDir, depEntry.dependencyId);
        if (!resolvedModule) {
          this.logger.console(`could not resolve ${depEntry.dependencyId} from env directory ${envDir}`);
          return undefined;
        }
        const linkSrc = resolveModuleDirFromFile(resolvedModule, depEntry.dependencyId);
        const linkDetail = {
          from: linkSrc,
          to: linkTarget
        };
        _fsExtra().default.removeSync(linkTarget);
        this.logger.info(`linking dependency ${depEntry.dependencyId} from env directory ${envDir}. link src: ${linkSrc} link target: ${linkTarget}`);
        (0, _utils().createSymlinkOrCopy)(linkSrc, linkTarget);
        return linkDetail;
      });
      const oneComponentLinks = await Promise.all(oneComponentLinksP);
      const filteredLinks = (0, _lodash().compact)(oneComponentLinks);
      const depsLinkedToEnvResult = {
        componentId: entry.component.id.toString(),
        linksDetail: filteredLinks
      };
      return depsLinkedToEnvResult;
    });
    return Promise.all(allLinksP);
  }
  async linkBitAspectIfNotExist(dir, componentIds) {
    if (!this.aspectLoader.mainAspect) return undefined;
    const mainAspectId = this.aspectLoader.mainAspect.id;
    const existing = componentIds.find(id => {
      return id === mainAspectId;
    });
    if (existing) {
      return undefined;
    }
    const linkDetail = await this.linkBit(dir);
    if (!linkDetail) return undefined;
    return {
      aspectId: mainAspectId,
      linkDetail
    };
  }
  async linkBit(dir) {
    if (!this.aspectLoader.mainAspect.packageName) {
      throw new (_exceptions().MainAspectNotLinkable)();
    }
    const target = _path().default.join(dir, this.aspectLoader.mainAspect.packageName);
    const shouldSymlink = this.removeSymlinkTarget(target);
    if (!shouldSymlink) return undefined;
    const src = this.aspectLoader.mainAspect.path;
    await _fsExtra().default.ensureDir(_path().default.dirname(target));
    (0, _utils().createSymlinkOrCopy)(src, target);
    return {
      from: src,
      to: target
    };
  }
  async linkCoreAspects(dir) {
    const coreAspectsIds = this.aspectLoader.getCoreAspectIds();
    const coreAspectsIdsWithoutMain = coreAspectsIds.filter(id => id !== this.aspectLoader.mainAspect.id);
    return coreAspectsIdsWithoutMain.map(id => {
      return this.linkCoreAspect(dir, id, (0, _aspectLoader().getCoreAspectName)(id), (0, _aspectLoader().getCoreAspectPackageName)(id));
    });
  }
  async linkNonExistingCoreAspects(dir, componentIds, hasLocalInstallation = false) {
    const coreAspectsIds = this.aspectLoader.getCoreAspectIds();
    const filtered = coreAspectsIds.filter(aspectId => {
      var _this$aspectLoader$ma;
      // Remove bit aspect
      if (aspectId === ((_this$aspectLoader$ma = this.aspectLoader.mainAspect) === null || _this$aspectLoader$ma === void 0 ? void 0 : _this$aspectLoader$ma.id)) {
        return false;
      }
      // TODO: use the aspect id once default scope is resolved and the component dir map has the id with scope
      const name = (0, _aspectLoader().getCoreAspectName)(aspectId);
      const existing = componentIds.find(componentId => {
        return componentId === name || componentId === aspectId;
      });
      if (existing) {
        return false;
      }
      return true;
    });
    this.logger.debug(`linkNonExistingCoreAspects: linking the following core aspects ${filtered.join()}`);
    const results = filtered.map(id => {
      return this.linkCoreAspect(dir, id, (0, _aspectLoader().getCoreAspectName)(id), (0, _aspectLoader().getCoreAspectPackageName)(id), hasLocalInstallation);
    });
    return (0, _lodash().compact)(results);
  }
  isBitRepoWorkspace(dir) {
    var _this$aspectLoader$ma2;
    // A special condition to not link core aspects in bit workspace itself
    if ((_this$aspectLoader$ma2 = this.aspectLoader.mainAspect) !== null && _this$aspectLoader$ma2 !== void 0 && _this$aspectLoader$ma2.path.startsWith(dir)) {
      return true;
    }
    return false;
  }
  linkCoreAspect(dir, id, name, packageName, hasLocalInstallation = false) {
    if (!this.aspectLoader.mainAspect) return undefined;
    if (!this.aspectLoader.mainAspect.packageName) {
      throw new (_exceptions().MainAspectNotLinkable)();
    }
    const mainAspectPath = _path().default.join(dir, this.aspectLoader.mainAspect.packageName);
    let aspectDir = _path().default.join(mainAspectPath, 'dist', name);
    const target = _path().default.join(dir, packageName);
    const shouldSymlink = this.removeSymlinkTarget(target, hasLocalInstallation);
    if (!shouldSymlink) return undefined;
    const isAspectDirExist = _fsExtra().default.pathExistsSync(aspectDir);
    if (!isAspectDirExist) {
      this.logger.debug(`linkCoreAspect: aspectDir ${aspectDir} does not exist, linking it to ${target}`);
      aspectDir = (0, _aspectLoader().getAspectDir)(id);
      (0, _utils().createSymlinkOrCopy)(aspectDir, target);
      return {
        aspectId: id,
        linkDetail: {
          from: aspectDir,
          to: target
        }
      };
    }
    try {
      // eslint-disable-next-line global-require, import/no-dynamic-require
      const module = require(aspectDir);
      const aspectPath = _path().default.resolve(_path().default.join(module.path, '..', '..'));
      // in this case we want the symlinks to be relative links
      // Using the fs module to make sure it is relative to the target
      if (_fsExtra().default.existsSync(target)) {
        this.logger.debug(`linkCoreAspect: aspectPath ${aspectPath} skip linking`);
        return undefined;
      }
      this.logger.debug(`linkCoreAspect: linking aspectPath ${aspectPath} to ${target}`);
      (0, _utils().createSymlinkOrCopy)(aspectPath, target);
      return {
        aspectId: id,
        linkDetail: {
          from: aspectPath,
          to: target
        }
      };
    } catch (err) {
      throw new (_exceptions().CoreAspectLinkError)(id, err);
    }
  }

  /**
   * returns true if it's safe to symlink it later.
   */
  removeSymlinkTarget(targetPath, hasLocalInstallation = false) {
    // TODO: change to fs.lstatSync(dest, {throwIfNoEntry: false});
    // TODO: this requires to upgrade node to v15.3.0 to have the throwIfNoEntry property (maybe upgrade fs-extra will work as well)
    // TODO: we don't use fs.pathExistsSync since it will return false in case the dest is a symlink which will result error on write
    let targetStat;
    try {
      targetStat = _fsExtra().default.lstatSync(targetPath);
      // eslint-disable-next-line no-empty
    } catch (e) {}
    if (targetStat && !hasLocalInstallation) {
      // Do not override links created by other means
      if (!targetStat.isSymbolicLink()) {
        this.logger.debug(`removing link target, target ${targetPath} already exist. skipping it`);
        return false;
      }
      // it's a symlink, remove is as it might point to an older version
      _fsExtra().default.removeSync(targetPath);
      return true;
    }
    return true;
  }
  linkNonAspectCorePackages(rootDir, name, packageName = `@teambit/${name}`, skipExisting = false) {
    if (!this.aspectLoader.mainAspect) return undefined;
    if (!this.aspectLoader.mainAspect.packageName) {
      throw new (_exceptions().MainAspectNotLinkable)();
    }
    const mainAspectPath = _path().default.join(rootDir, this.aspectLoader.mainAspect.packageName);
    const distDir = _path().default.join(mainAspectPath, 'dist', name);
    const target = _path().default.join(rootDir, 'node_modules', packageName);
    const isTargetExisting = _fsExtra().default.pathExistsSync(target);
    if (skipExisting && isTargetExisting) {
      return undefined;
    }
    const shouldSymlink = this.removeSymlinkTarget(target);
    if (!shouldSymlink) return undefined;
    const isDistDirExist = _fsExtra().default.pathExistsSync(distDir);
    if (!isDistDirExist) {
      const newDir = getDistDirForDevEnv(packageName);
      (0, _utils().createSymlinkOrCopy)(newDir, target);
      return {
        from: newDir,
        to: target
      };
    }
    try {
      // eslint-disable-next-line global-require, import/no-dynamic-require
      const module = require(distDir);
      const resolvedPath = _path().default.resolve(_path().default.join(module.path, '..', '..'));
      // in this case we want the symlinks to be relative links
      // Using the fs module to make sure it is relative to the target
      if (_fsExtra().default.existsSync(target)) {
        return undefined;
      }
      (0, _utils().createSymlinkOrCopy)(resolvedPath, target);
      return {
        from: resolvedPath,
        to: target
      };
    } catch (err) {
      throw new (_exceptions().NonAspectCorePackageLinkError)(err, packageName);
    }
  }
  linkHarmony(rootDir) {
    const name = 'harmony';
    return this.linkNonAspectCorePackages(rootDir, name);
  }
  linkTeambitLegacy(rootDir) {
    const name = 'legacy';
    return this.linkNonAspectCorePackages(rootDir, name);
  }
}

/**
 * When running dev env (bd) we need to get the harmony/legacy folder from the node_modules of the clone
 */
exports.DependencyLinker = DependencyLinker;
function getDistDirForDevEnv(packageName) {
  let moduleDirectory = require.resolve(packageName);
  let dirPath;
  if (moduleDirectory.includes(packageName)) {
    dirPath = _path().default.join(moduleDirectory, '../..'); // to remove the "index.js" at the end
  } else {
    // This is usually required for the @teambit/legacy, as we re inside the nm so we can't find it in the other way
    const nmDir = __dirname.substring(0, __dirname.indexOf('@teambit'));
    dirPath = _path().default.join(nmDir, packageName);
    moduleDirectory = require.resolve(packageName, {
      paths: [nmDir]
    });
  }
  if (!_fsExtra().default.existsSync(dirPath)) {
    throw new (_bitError().BitError)(`unable to find ${packageName} in ${dirPath}`);
  }
  return dirPath;
}

// TODO: extract to new component
function resolveModuleFromDir(fromDir, moduleId, silent = true) {
  if (silent) {
    return _resolveFrom().default.silent(fromDir, moduleId);
  }
  return (0, _resolveFrom().default)(fromDir, moduleId);
}

// TODO: extract to new component
function resolveModuleDirFromFile(resolvedModulePath, moduleId) {
  const NM = 'node_modules';
  if (resolvedModulePath.includes(NM)) {
    return _path().default.join(resolvedModulePath.slice(0, resolvedModulePath.lastIndexOf(NM) + NM.length), moduleId);
  }
  const [start, end] = resolvedModulePath.split('@');
  if (!end) return _path().default.basename(resolvedModulePath);
  const versionStr = (0, _lodash().head)(end.split('/'));
  return `${start}@${versionStr}`;
}
function isPathSymlink(folderPath) {
  // TODO: change to fs.lstatSync(dest, {throwIfNoEntry: false}); once upgrade fs-extra
  try {
    const stat = _fsExtra().default.lstatSync(folderPath);
    return stat.isSymbolicLink();
  } catch (e) {
    return undefined;
  }
}

//# sourceMappingURL=dependency-linker.js.map