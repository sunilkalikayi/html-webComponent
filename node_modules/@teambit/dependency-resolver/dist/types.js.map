{"version":3,"names":[],"sources":["types.ts"],"sourcesContent":["import { ComponentConfig, ComponentFS } from '@teambit/component';\nimport { PathLinux } from '@teambit/legacy/dist/utils/path';\n\nimport { ComponentManifest } from './manifest/component-manifest';\nimport { PackageName } from './dependencies';\n\nexport type RegistryName = string;\n\nexport type Registry = {\n  uri: string;\n  alwaysAuth: boolean;\n  authHeaderValue?: string;\n  originalAuthType: string;\n  originalAuthValue: string;\n};\n\nexport type RegistriesMap = Record<RegistryName, Registry>;\n\n// Exact format TBD\nexport interface RawComponentState {\n  filesystem: ComponentFS;\n  config: ComponentConfig;\n}\n\n/**\n * Import Specifier data.\n * For example, `import foo from './bar' `, \"foo\" is the import-specifier and is default.\n * Conversely, `import { foo } from './bar' `, here, \"foo\" is non-default.\n */\nexport type Specifier = {\n  isDefault: boolean;\n  name: string;\n};\n\n/**\n * ImportSpecifier are used to generate links from component to its dependencies.\n * For example, a component might have a dependency: \"import { foo } from './bar' \", when a link is generated, we use\n * the import-specifier name, which is \"foo\" to generate the link correctly.\n */\nexport type ImportSpecifier = {\n  mainFile: Specifier;\n  linkFile?: Specifier; // relevant only when the dependency is a link file (e.g. index.js which import and export the variable from other file)\n};\n\n/**\n * a dependency component may have multiple files that are required from the parent component, each\n * one of the files has its RelativePath instance.\n *\n * For example:\n * main component: \"foo\" => foo.js => `const isString = require('../utils/is-string'); const isArray = require('../utils/is-array');\n * dependency: \"utils\" => utils/is-string.js, utils/is-array.js\n * In this example, the component \"foo\" has one dependency \"utils\" with two RelativePaths.\n * one for utils/is-string.js file and the second for utils/is-array.js file\n */\nexport type RelativePath = {\n  sourceRelativePath: PathLinux; // location of the link file\n  destinationRelativePath: PathLinux; // destination written inside the link file\n  importSpecifiers?: ImportSpecifier[];\n  isCustomResolveUsed?: boolean; // custom resolve can be configured on consumer bit.json file in resolveModules attribute\n  importSource?: string; // available when isCustomResolveUsed=true, contains the import path. e.g. \"import x from 'src/utils'\", importSource is 'src/utils'.\n};\n\n/**\n * A definition of one dependency statement in a file\n * For example `import('something')` or require('something')\n */\ninterface FileDependencyDefinition {\n  // The path itself as appear in the source code (what inside the () for example)\n  // This can be a module path like 'my-package' or relative (for legacy support)\n  dependencyPath: string;\n  // Used for legacy support\n  relativePaths?: RelativePath[];\n  // Used for statements like `import type {x} from 'y'\n  isType?: boolean;\n}\n\nexport type FileDependenciesDefinition = FileDependencyDefinition[];\n\nexport type ComponentsManifestsMap = Map<PackageName, ComponentManifest>;\n"],"mappings":""}