"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NPM_REGISTRY = exports.DependencyResolverMain = exports.BIT_DEV_REGISTRY = exports.BIT_CLOUD_REGISTRY = void 0;
Object.defineProperty(exports, "NetworkConfig", {
  enumerable: true,
  get: function () {
    return _http().NetworkConfig;
  }
});
Object.defineProperty(exports, "ProxyConfig", {
  enumerable: true,
  get: function () {
    return _http().ProxyConfig;
  }
});
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = _interopRequireDefault(require("@teambit/component"));
  _component = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _config() {
  const data = require("@teambit/config");
  _config = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = require("@teambit/envs");
  _envs = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = require("@teambit/graphql");
  _graphql = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/legacy/dist/consumer/component/dependencies/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/bit/component-id-to-package-name"));
  _componentIdToPackageName = function () {
    return data;
  };
  return data;
}
function _detectorHook() {
  const data = require("@teambit/legacy/dist/consumer/component/dependencies/files-dependency-builder/detector-hook");
  _detectorHook = function () {
    return data;
  };
  return data;
}
function _http() {
  const data = require("@teambit/legacy/dist/scope/network/http");
  _http = function () {
    return data;
  };
  return data;
}
function _component2() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component"));
  _component2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");
  _legacyBitId = function () {
    return data;
  };
  return data;
}
function _network() {
  const data = require("@pnpm/network.ca-file");
  _network = function () {
    return data;
  };
  return data;
}
function _semver() {
  const data = _interopRequireWildcard(require("semver"));
  _semver = function () {
    return data;
  };
  return data;
}
function _aspectLoader() {
  const data = _interopRequireDefault(require("@teambit/aspect-loader"));
  _aspectLoader = function () {
    return data;
  };
  return data;
}
function _globalConfig() {
  const data = _interopRequireDefault(require("@teambit/global-config"));
  _globalConfig = function () {
    return data;
  };
  return data;
}
function _registry() {
  const data = require("./registry");
  _registry = function () {
    return data;
  };
  return data;
}
function _applyUpdates() {
  const data = require("./apply-updates");
  _applyUpdates = function () {
    return data;
  };
  return data;
}
function _constants2() {
  const data = require("./dependencies/constants");
  _constants2 = function () {
    return data;
  };
  return data;
}
function _dependencyInstaller() {
  const data = require("./dependency-installer");
  _dependencyInstaller = function () {
    return data;
  };
  return data;
}
function _dependencyResolver2() {
  const data = require("./dependency-resolver.aspect");
  _dependencyResolver2 = function () {
    return data;
  };
  return data;
}
function _dependencyVersionResolver() {
  const data = require("./dependency-version-resolver");
  _dependencyVersionResolver = function () {
    return data;
  };
  return data;
}
function _dependencyLinker() {
  const data = require("./dependency-linker");
  _dependencyLinker = function () {
    return data;
  };
  return data;
}
function _getAllPolicyPkgs() {
  const data = require("./get-all-policy-pkgs");
  _getAllPolicyPkgs = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _manifest() {
  const data = require("./manifest");
  _manifest = function () {
    return data;
  };
  return data;
}
function _policy() {
  const data = require("./policy");
  _policy = function () {
    return data;
  };
  return data;
}
function _dependencies() {
  const data = require("./dependencies");
  _dependencies = function () {
    return data;
  };
  return data;
}
function _showFragments() {
  const data = require("./show-fragments");
  _showFragments = function () {
    return data;
  };
  return data;
}
function _dependencyResolver3() {
  const data = require("./dependency-resolver.graphql");
  _dependencyResolver3 = function () {
    return data;
  };
  return data;
}
function _dependencies2() {
  const data = require("./dependencies.service");
  _dependencies2 = function () {
    return data;
  };
  return data;
}
function _envPolicy() {
  const data = require("./policy/env-policy");
  _envPolicy = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * @deprecated use BIT_CLOUD_REGISTRY instead
 */
const BIT_DEV_REGISTRY = 'https://node.bit.dev/';
exports.BIT_DEV_REGISTRY = BIT_DEV_REGISTRY;
const BIT_CLOUD_REGISTRY = 'https://node.bit.cloud/';
exports.BIT_CLOUD_REGISTRY = BIT_CLOUD_REGISTRY;
const NPM_REGISTRY = 'https://registry.npmjs.org/';
exports.NPM_REGISTRY = NPM_REGISTRY;
const defaultLinkingOptions = {
  legacyLink: true,
  linkTeambitBit: true,
  linkCoreAspects: true
};
const defaultCreateFromComponentsOptions = {
  filterComponentsFromManifests: true,
  createManifestForComponentsWithoutDependencies: true
};
class DependencyResolverMain {
  constructor(
  /**
   * Dependency resolver  extension configuration.
   */
  config,
  /**
   * Registry for changes by other extensions.
   */
  rootPolicyRegistry,
  /**
   * Registry for changes by other extensions.
   */
  policiesRegistry,
  /**
   * envs extension.
   */
  envs, logger, configAspect, aspectLoader, globalConfig,
  /**
   * component aspect.
   */
  componentAspect, packageManagerSlot, dependencyFactorySlot, preInstallSlot, postInstallSlot) {
    this.config = config;
    this.rootPolicyRegistry = rootPolicyRegistry;
    this.policiesRegistry = policiesRegistry;
    this.envs = envs;
    this.logger = logger;
    this.configAspect = configAspect;
    this.aspectLoader = aspectLoader;
    this.globalConfig = globalConfig;
    this.componentAspect = componentAspect;
    this.packageManagerSlot = packageManagerSlot;
    this.dependencyFactorySlot = dependencyFactorySlot;
    this.preInstallSlot = preInstallSlot;
    this.postInstallSlot = postInstallSlot;
  }

  /**
   * This function is a temporary workaround for installation in capsules with pnpm.
   * Currently pnpm breaks the root node_modules inside the capsule because it removes deps from it.
   * Install runs several times in the same capsule and pnpm removes deps from the previous runs.
   *
   * This workaround unfortunately also breaks pnpm on angular projects. Because dedupe doesn't work properly.
   * To fix this issue we'll either have to switch to root components or try to change pnpm code.
   *
   * Here is the PR where initially dedupe was turned off for pnpm: https://github.com/teambit/bit/pull/5410
   */
  supportsDedupingOnExistingRoot() {
    var _packageManager$suppo;
    const packageManager = this.packageManagerSlot.get(this.config.packageManager);
    return (packageManager === null || packageManager === void 0 ? void 0 : (_packageManager$suppo = packageManager.supportsDedupingOnExistingRoot) === null || _packageManager$suppo === void 0 ? void 0 : _packageManager$suppo.call(packageManager)) === true && !this.hasRootComponents();
  }
  hasRootComponents() {
    return Boolean(this.config.rootComponents);
  }
  linkCoreAspects() {
    var _this$config$linkCore;
    return (_this$config$linkCore = this.config.linkCoreAspects) !== null && _this$config$linkCore !== void 0 ? _this$config$linkCore : DependencyResolverMain.defaultConfig.linkCoreAspects;
  }

  /**
   * register a new package manager to the dependency resolver.
   */
  registerPackageManager(packageManager) {
    this.packageManagerSlot.register(packageManager);
  }
  registerDependencyFactories(factories) {
    this.dependencyFactorySlot.register(factories);
  }
  registerPreInstallSubscribers(subscribers) {
    this.preInstallSlot.register(subscribers);
  }
  registerPostInstallSubscribers(subscribers) {
    this.postInstallSlot.register(subscribers);
  }
  getSavePrefix() {
    return this.config.savePrefix || '';
  }
  getVersionWithSavePrefix(version, overridePrefix) {
    const prefix = overridePrefix || this.getSavePrefix();
    const versionWithPrefix = `${prefix}${version}`;
    if (!_semver().default.validRange(versionWithPrefix)) {
      throw new (_exceptions().InvalidVersionWithPrefix)(versionWithPrefix);
    }
    return versionWithPrefix;
  }
  async getPolicy(component) {
    const entry = component.state.aspects.get(_dependencyResolver2().DependencyResolverAspect.id);
    const factory = new (_policy().VariantPolicyFactory)();
    if (!entry) {
      return factory.getEmpty();
    }
    const serializedPolicy = (0, _lodash().get)(entry, ['data', 'policy'], []);
    return factory.parse(serializedPolicy);
  }

  /**
   * This function called on component load in order to calculate the dependencies based on the legacy (consumer) component
   * and write them to the dependencyResolver data.
   * Do not use this function for other purpose.
   * If you want to get the component dependencies call getDependencies (which will give you the dependencies from the data itself)
   * TODO: once we switch deps resolver <> workspace relation we should make it private
   * TODO: once we switch deps resolver <> workspace relation we should remove the resolveId func here
   * @param component
   */
  async extractDepsFromLegacy(component, policy) {
    const componentPolicy = policy || (await this.getPolicy(component));
    const legacyComponent = component.state._consumer;
    const listFactory = this.getDependencyListFactory();
    const dependencyList = await listFactory.fromLegacyComponent(legacyComponent);
    dependencyList.forEach(dep => {
      const found = componentPolicy.find(dep.id);
      // if no policy found, the dependency was auto-resolved from the source code
      dep.source = (found === null || found === void 0 ? void 0 : found.source) || 'auto';
    });
    return dependencyList;
  }
  getDependencyListFactory() {
    const factories = this.dependencyFactorySlot.values().flat();
    const factoriesMap = factories.reduce((acc, factory) => {
      acc[factory.type] = factory;
      return acc;
    }, {});
    const listFactory = new (_dependencies().DependencyListFactory)(factoriesMap);
    return listFactory;
  }

  /**
   * Main function to get the dependency list of a given component
   * @param component
   */
  async getDependencies(component) {
    var _entry$data;
    const entry = component.get(_dependencyResolver2().DependencyResolverAspect.id);
    if (!entry) {
      return _dependencies().DependencyList.fromArray([]);
    }
    const serializedDependencies = (entry === null || entry === void 0 ? void 0 : (_entry$data = entry.data) === null || _entry$data === void 0 ? void 0 : _entry$data.dependencies) || [];
    return this.getDependenciesFromSerializedDependencies(serializedDependencies);
  }
  async getDependenciesFromSerializedDependencies(dependencies) {
    if (!dependencies.length) {
      return _dependencies().DependencyList.fromArray([]);
    }
    const listFactory = this.getDependencyListFactory();
    const deps = await listFactory.fromSerializedDependencies(dependencies);
    return deps;
  }

  /**
   * Getting the merged workspace policy (from dep resolver config and others like root package.json)
   * @returns
   */
  getWorkspacePolicy() {
    const policyFromConfig = this.getWorkspacePolicyFromConfig();
    const externalPolicies = this.rootPolicyRegistry.toArray().map(([, policy]) => policy);
    return this.mergeWorkspacePolices([policyFromConfig, ...externalPolicies]);
  }

  /**
   * Getting the workspace policy as defined in the workspace.jsonc in the dependencyResolver aspect
   * This will not take into account packages that defined in the package.json of the root for example
   * in most cases you should use getWorkspacePolicy
   * @returns
   */
  getWorkspacePolicyFromConfig() {
    const factory = new (_policy().WorkspacePolicyFactory)();
    return factory.fromConfigObject(this.config.policy);
  }
  getWorkspacePolicyFromPackageJson(packageJson) {
    const factory = new (_policy().WorkspacePolicyFactory)();
    return factory.fromPackageJson(packageJson);
  }
  mergeWorkspacePolices(polices) {
    return _policy().WorkspacePolicy.mergePolices(polices);
  }

  /**
   * Create a workspace manifest
   * The term workspace here is not the same as "bit workspace" but a workspace that represent a shared root
   * for installation of many components (sometime it might point to the workspace path)
   * in other case it can be for example the capsules root dir
   *
   * @param {string} [name=ROOT_NAME]
   * @param {SemVer} [version=new SemVer('1.0.0')]
   * @param {ManifestDependenciesObject} dependencies
   * @param {string} rootDir
   * @param {Component[]} components
   * @param {CreateFromComponentsOptions} [options={
   *       filterComponentsFromManifests: true,
   *       createManifestForComponentsWithoutDependencies: true,
   *     }]
   * @returns {WorkspaceManifest}
   * @memberof DependencyResolverMain
   */
  async getWorkspaceManifest(name = _constants2().ROOT_NAME, version = new (_semver().SemVer)('1.0.0'), rootPolicy, rootDir, components, options = defaultCreateFromComponentsOptions) {
    this.logger.setStatusLine('deduping dependencies for installation');
    const concreteOpts = _objectSpread(_objectSpread({}, defaultCreateFromComponentsOptions), options);
    const workspaceManifestFactory = new (_manifest().WorkspaceManifestFactory)(this, this.aspectLoader);
    const res = await workspaceManifestFactory.createFromComponents(name, version, rootPolicy, rootDir, components, concreteOpts);
    this.logger.consoleSuccess();
    return res;
  }

  /**
   * get the package name of a component.
   */
  getPackageName(component) {
    return (0, _componentIdToPackageName().default)(component.state._consumer);
  }

  /*
   * Returns the location where the component is installed with its peer dependencies
   * This is used in cases you want to actually run the components and make sure all the dependencies (especially peers) are resolved correctly
   */
  getRuntimeModulePath(component) {
    const modulePath = this.getModulePath(component);
    if (!this.hasRootComponents()) {
      return modulePath;
    }
    const pkgName = this.getPackageName(component);
    return (0, _path().join)(modulePath, 'node_modules', pkgName);
  }

  /**
   * returns the package path in the /node_modules/ folder
   * In case you call this in order to run the code from the path, please refer to the `getRuntimeModulePath` API
   */
  getModulePath(component) {
    const pkgName = this.getPackageName(component);
    const relativePath = (0, _path().join)('node_modules', pkgName);
    return relativePath;
  }

  /**
   * get a component dependency installer.
   */
  getInstaller(options = {}) {
    const packageManagerName = options.packageManager || this.config.packageManager;
    const packageManager = this.packageManagerSlot.get(packageManagerName);
    const cacheRootDir = options.cacheRootDirectory || this.globalConfig.getSync(_constants().CFG_PACKAGE_MANAGER_CACHE);
    if (!packageManager) {
      throw new (_exceptions().PackageManagerNotFound)(this.config.packageManager);
    }
    if (cacheRootDir && !_fsExtra().default.pathExistsSync(cacheRootDir)) {
      this.logger.debug(`creating package manager cache dir at ${cacheRootDir}`);
      _fsExtra().default.ensureDirSync(cacheRootDir);
    }
    const preInstallSubscribers = this.getPreInstallSubscribers();
    const postInstallSubscribers = this.getPostInstallSubscribers();
    // TODO: we should somehow pass the cache root dir to the package manager constructor
    return new (_dependencyInstaller().DependencyInstaller)(packageManager, this.aspectLoader, this.logger, this, options.rootDir, cacheRootDir, preInstallSubscribers, postInstallSubscribers, this.config.nodeLinker, this.config.packageImportMethod, this.config.sideEffectsCache, this.config.nodeVersion, this.config.engineStrict, this.config.peerDependencyRules);
  }
  getPreInstallSubscribers() {
    return this.preInstallSlot.values().flat();
  }
  getPostInstallSubscribers() {
    return this.postInstallSlot.values().flat();
  }

  /**
   * get a component dependency linker.
   */
  getLinker(options = {}) {
    const linkingOptions = Object.assign({}, defaultLinkingOptions, (options === null || options === void 0 ? void 0 : options.linkingOptions) || {});
    // TODO: we should somehow pass the cache root dir to the package manager constructor
    return new (_dependencyLinker().DependencyLinker)(this, this.aspectLoader, this.componentAspect, this.envs, this.logger, options.rootDir, linkingOptions);
  }
  getPackageManagerName() {
    return this.config.packageManager;
  }
  async getVersionResolver(options = {}) {
    const packageManager = this.packageManagerSlot.get(this.config.packageManager);
    const cacheRootDir = options.cacheRootDirectory || this.globalConfig.getSync(_constants().CFG_PACKAGE_MANAGER_CACHE);
    if (!packageManager) {
      throw new (_exceptions().PackageManagerNotFound)(this.config.packageManager);
    }
    if (cacheRootDir && !_fsExtra().default.pathExistsSync(cacheRootDir)) {
      this.logger.debug(`creating package manager cache dir at ${cacheRootDir}`);
      _fsExtra().default.ensureDirSync(cacheRootDir);
    }
    const {
      networkConcurrency
    } = await this.getNetworkConfig();
    // TODO: we should somehow pass the cache root dir to the package manager constructor
    return new (_dependencyVersionResolver().DependencyVersionResolver)(packageManager, cacheRootDir, networkConcurrency);
  }

  /**
   * return the system configured package manager. by default pnpm.
   */
  getSystemPackageManager() {
    const defaultPm = 'teambit.dependencies/pnpm';
    const packageManager = this.packageManagerSlot.get(defaultPm);
    if (!packageManager) throw new Error(`default package manager: ${defaultPm} was not found`);
    return packageManager;
  }
  async getProxyConfig() {
    const proxyConfigFromDepResolverConfig = this.getProxyConfigFromDepResolverConfig();
    let httpProxy = proxyConfigFromDepResolverConfig.httpProxy;
    let httpsProxy = proxyConfigFromDepResolverConfig.httpsProxy;

    // Take config from the aspect config if defined
    if (httpProxy || httpsProxy) {
      this.logger.debug(`proxy config taken from the dep resolver config. proxy: ${httpProxy} httpsProxy: ${httpsProxy}`);
      return proxyConfigFromDepResolverConfig;
    }

    // Take config from the package manager (npmrc) config if defined
    const proxyConfigFromPackageManager = await this.getProxyConfigFromPackageManager();
    if (proxyConfigFromPackageManager !== null && proxyConfigFromPackageManager !== void 0 && proxyConfigFromPackageManager.httpProxy || proxyConfigFromPackageManager !== null && proxyConfigFromPackageManager !== void 0 && proxyConfigFromPackageManager.httpsProxy) {
      this.logger.debug(`proxy config taken from the package manager config (npmrc). proxy: ${proxyConfigFromPackageManager.httpProxy} httpsProxy: ${proxyConfigFromPackageManager.httpsProxy}`);
      return proxyConfigFromPackageManager;
    }

    // Take config from global bit config
    const proxyConfigFromGlobalConfig = await this.getProxyConfigFromGlobalConfig();
    httpProxy = proxyConfigFromGlobalConfig.httpProxy;
    httpsProxy = proxyConfigFromGlobalConfig.httpsProxy;
    if (httpProxy || httpsProxy) {
      this.logger.debug(`proxy config taken from the global bit config. proxy: ${httpProxy} httpsProxy: ${httpsProxy}`);
      return proxyConfigFromGlobalConfig;
    }
    return {};
  }
  getProxyConfigFromDepResolverConfig() {
    return {
      httpProxy: this.config.proxy,
      httpsProxy: this.config.httpsProxy || this.config.proxy,
      noProxy: this.config.noProxy
    };
  }
  async getNetworkConfig() {
    const networkConfig = _objectSpread(_objectSpread(_objectSpread({}, await this.getNetworkConfigFromGlobalConfig()), await this.getNetworkConfigFromPackageManager()), this.getNetworkConfigFromDepResolverConfig());
    this.logger.debug(`the next network configuration is used in dependency-resolver: ${JSON.stringify(_objectSpread(_objectSpread({}, networkConfig), {}, {
      key: networkConfig.key ? 'set' : 'not set' // this is sensitive information, we should not log it
    }), null, 2)}`);
    return networkConfig;
  }
  async getNetworkConfigFromGlobalConfig() {
    const globalNetworkConfig = await _http().Http.getNetworkConfig();
    if (!globalNetworkConfig.ca && globalNetworkConfig.cafile) {
      globalNetworkConfig.ca = (0, _network().readCAFileSync)(globalNetworkConfig.cafile);
    }
    return globalNetworkConfig;
  }
  getNetworkConfigFromDepResolverConfig() {
    const config = (0, _lodash().pick)(this.config, ['fetchTimeout', 'fetchRetries', 'fetchRetryFactor', 'fetchRetryMintimeout', 'fetchRetryMaxtimeout', 'maxSockets', 'networkConcurrency', 'key', 'cert', 'ca', 'cafile']);
    if (this.config.strictSsl != null) {
      config.strictSSL = typeof this.config.strictSsl === 'string' ? this.config.strictSsl.toLowerCase() === 'true' : this.config.strictSsl;
    }
    return config;
  }
  async getNetworkConfigFromPackageManager() {
    const packageManager = this.packageManagerSlot.get(this.config.packageManager);
    let networkConfigFromPackageManager = {};
    if (typeof (packageManager === null || packageManager === void 0 ? void 0 : packageManager.getNetworkConfig) === 'function') {
      networkConfigFromPackageManager = await (packageManager === null || packageManager === void 0 ? void 0 : packageManager.getNetworkConfig());
    } else {
      const systemPm = this.getSystemPackageManager();
      if (!systemPm.getNetworkConfig) throw new Error('system package manager must implement `getNetworkConfig()`');
      networkConfigFromPackageManager = await systemPm.getNetworkConfig();
    }
    return networkConfigFromPackageManager;
  }
  async getProxyConfigFromPackageManager() {
    const packageManager = this.packageManagerSlot.get(this.config.packageManager);
    let proxyConfigFromPackageManager = {};
    if (packageManager !== null && packageManager !== void 0 && packageManager.getProxyConfig && typeof (packageManager === null || packageManager === void 0 ? void 0 : packageManager.getProxyConfig) === 'function') {
      proxyConfigFromPackageManager = await (packageManager === null || packageManager === void 0 ? void 0 : packageManager.getProxyConfig());
    } else {
      const systemPm = this.getSystemPackageManager();
      if (!systemPm.getProxyConfig) throw new Error('system package manager must implement `getProxyConfig()`');
      proxyConfigFromPackageManager = await systemPm.getProxyConfig();
    }
    return proxyConfigFromPackageManager;
  }
  getProxyConfigFromGlobalConfig() {
    return _http().Http.getProxyConfig();
  }

  /**
   * Return the peer dependencies and their ranges that may be installed
   * without causing unmet peer dependency issues in some of the dependencies.
   */
  async getMissingPeerDependencies(rootDir, rootPolicy, componentDirectoryMap, options) {
    var _peerDependencyIssues;
    this.logger.setStatusLine('finding missing peer dependencies');
    const packageManager = this.packageManagerSlot.get(this.config.packageManager);
    let peerDependencyIssues;
    const installer = this.getInstaller();
    const manifests = await installer.getComponentManifests(_objectSpread(_objectSpread({}, options), {}, {
      componentDirectoryMap,
      rootPolicy,
      rootDir
    }));
    if (packageManager !== null && packageManager !== void 0 && packageManager.getPeerDependencyIssues && typeof (packageManager === null || packageManager === void 0 ? void 0 : packageManager.getPeerDependencyIssues) === 'function') {
      peerDependencyIssues = await (packageManager === null || packageManager === void 0 ? void 0 : packageManager.getPeerDependencyIssues(rootDir, manifests, options));
    } else {
      const systemPm = this.getSystemPackageManager();
      if (!systemPm.getPeerDependencyIssues) throw new Error('system package manager must implement `getPeerDependencyIssues()`');
      peerDependencyIssues = await (systemPm === null || systemPm === void 0 ? void 0 : systemPm.getPeerDependencyIssues(rootDir, manifests, options));
    }
    this.logger.consoleSuccess();
    return (_peerDependencyIssues = peerDependencyIssues['.']) === null || _peerDependencyIssues === void 0 ? void 0 : _peerDependencyIssues.intersections;
  }
  async getRegistries() {
    var _this$config$installF;
    const packageManager = this.packageManagerSlot.get(this.config.packageManager);
    let registries;
    if (packageManager !== null && packageManager !== void 0 && packageManager.getRegistries && typeof (packageManager === null || packageManager === void 0 ? void 0 : packageManager.getRegistries) === 'function') {
      registries = await (packageManager === null || packageManager === void 0 ? void 0 : packageManager.getRegistries());
    } else {
      const systemPm = this.getSystemPackageManager();
      if (!systemPm.getRegistries) throw new Error('system package manager must implement `getRegistries()`');
      registries = await systemPm.getRegistries();
    }
    const bitScope = registries.scopes.bit;
    const getDefaultBitRegistry = () => {
      const bitRegistry = (bitScope === null || bitScope === void 0 ? void 0 : bitScope.uri) || BIT_DEV_REGISTRY;
      const {
        bitOriginalAuthType,
        bitAuthHeaderValue,
        bitOriginalAuthValue
      } = this.getBitAuthConfig(bitScope);
      const alwaysAuth = bitAuthHeaderValue !== undefined;
      const bitDefaultRegistry = new (_registry().Registry)(bitRegistry, alwaysAuth, bitAuthHeaderValue, bitOriginalAuthType, bitOriginalAuthValue);
      return bitDefaultRegistry;
    };
    const bitDefaultRegistry = getDefaultBitRegistry();
    const installFromBitDevRegistry = (_this$config$installF = this.config.installFromBitDevRegistry) !== null && _this$config$installF !== void 0 ? _this$config$installF : true;

    // Override default registry to use bit registry in case npmjs is the default - bit registry will proxy it
    // We check also NPM_REGISTRY.startsWith because the uri might not have the trailing / we have in NPM_REGISTRY
    if (installFromBitDevRegistry && (!registries.defaultRegistry.uri || registries.defaultRegistry.uri === NPM_REGISTRY || NPM_REGISTRY.startsWith(registries.defaultRegistry.uri))) {
      // TODO: this will not handle cases where you have token for private npm registries stored on npmjs
      // it should be handled by somehow in such case (default is npmjs and there is token for default) by sending the token of npmjs to the registry
      // (for example by setting some special header in the request)
      // then in the registry server it should be use it when proxies
      registries = registries.setDefaultRegistry(bitDefaultRegistry);
    }
    // Make sure @bit scope is register with alwaysAuth
    if (!bitScope || bitScope && !bitScope.alwaysAuth) {
      registries = registries.updateScopedRegistry('bit', bitDefaultRegistry);
    }
    registries = this.addAuthToScopedBitRegistries(registries, bitScope);
    return registries;
  }

  /**
   * This will mutate any registry which point to BIT_DEV_REGISTRY to have the auth config from the @bit scoped registry or from the user.token in bit's config
   */
  addAuthToScopedBitRegistries(registries, bitScopeRegistry) {
    const {
      bitOriginalAuthType,
      bitAuthHeaderValue,
      bitOriginalAuthValue
    } = this.getBitAuthConfig(bitScopeRegistry);
    const alwaysAuth = bitAuthHeaderValue !== undefined;
    let updatedRegistries = registries;
    Object.entries(registries.scopes).map(([name, registry]) => {
      if (!registry.authHeaderValue && BIT_DEV_REGISTRY.includes(registry.uri)) {
        const registryWithAuth = new (_registry().Registry)(registry.uri, alwaysAuth, bitAuthHeaderValue, bitOriginalAuthType, bitOriginalAuthValue);
        updatedRegistries = updatedRegistries.updateScopedRegistry(name, registryWithAuth);
      }
      return updatedRegistries;
    });
    return updatedRegistries;
  }
  getBitAuthConfig(bitScopeRegistry) {
    const bitGlobalConfigToken = this.globalConfig.getSync(_constants().CFG_USER_TOKEN_KEY);
    let bitAuthHeaderValue = bitScopeRegistry === null || bitScopeRegistry === void 0 ? void 0 : bitScopeRegistry.authHeaderValue;
    let bitOriginalAuthType = bitScopeRegistry === null || bitScopeRegistry === void 0 ? void 0 : bitScopeRegistry.originalAuthType;
    let bitOriginalAuthValue = bitScopeRegistry === null || bitScopeRegistry === void 0 ? void 0 : bitScopeRegistry.originalAuthValue;

    // In case there is no auth configuration in the npmrc, but there is token in bit config, take it from the config
    if ((!bitScopeRegistry || !bitScopeRegistry.authHeaderValue) && bitGlobalConfigToken) {
      bitOriginalAuthType = 'authToken';
      bitAuthHeaderValue = `Bearer ${bitGlobalConfigToken}`;
      bitOriginalAuthValue = bitGlobalConfigToken;
    }
    return {
      bitOriginalAuthType,
      bitAuthHeaderValue,
      bitOriginalAuthValue
    };
  }
  get packageManagerName() {
    return this.config.packageManager;
  }
  addToRootPolicy(entries, options) {
    const workspacePolicy = this.getWorkspacePolicyFromConfig();
    entries.forEach(entry => workspacePolicy.add(entry, options));
    this.updateConfigPolicy(workspacePolicy);
    return workspacePolicy;
  }
  removeFromRootPolicy(dependencyIds) {
    const workspacePolicy = this.getWorkspacePolicyFromConfig();
    const workspacePolicyUpdated = workspacePolicy.remove(dependencyIds);
    this.updateConfigPolicy(workspacePolicyUpdated);
  }
  updateConfigPolicy(workspacePolicy) {
    const workspacePolicyObject = workspacePolicy.toConfigObject();
    this.config.policy = workspacePolicyObject;
    this.configAspect.setExtension(_dependencyResolver2().DependencyResolverAspect.id, this.config, {
      overrideExisting: true,
      ignoreVersion: true
    });
  }
  async persistConfig(workspaceDir) {
    var _this$configAspect$wo;
    return (_this$configAspect$wo = this.configAspect.workspaceConfig) === null || _this$configAspect$wo === void 0 ? void 0 : _this$configAspect$wo.write({
      dir: workspaceDir
    });
  }

  /**
   * register new dependencies policies
   */
  registerDependenciesPolicies(policy) {
    return this.policiesRegistry.register(policy);
  }

  /**
   * register new dependencies policies
   */
  registerRootPolicy(policy) {
    return this.rootPolicyRegistry.register(policy);
  }
  async getComponentEnvPolicyFromExtension(configuredExtensions) {
    const env = this.envs.calculateEnvFromExtensions(configuredExtensions).env;
    return this.getComponentEnvPolicyFromEnv(env);
  }
  async getEnvPolicyFromEnvLegacyId(id) {
    const envDef = await this.envs.getEnvDefinitionByLegacyId(id);
    if (!envDef) return undefined;
    const env = envDef.env;
    return this.getComponentEnvPolicyFromEnv(env);
  }
  async getComponentEnvPolicy(component) {
    const env = this.envs.getEnv(component).env;
    return this.getComponentEnvPolicyFromEnv(env);
  }
  async getComponentEnvPolicyFromEnv(env) {
    if (env.getDependencies && typeof env.getDependencies === 'function') {
      const policiesFromEnvConfig = await env.getDependencies();
      if (policiesFromEnvConfig) {
        const allPoliciesFromEnv = new (_envPolicy().EnvPolicyFactory)().fromConfigObject(policiesFromEnvConfig);
        return allPoliciesFromEnv;
      }
    }
    return new (_envPolicy().EnvPolicyFactory)().getEmpty();
  }

  /**
   * Get a list of peer dependencies applied from an env
   * This will merge different peers list like:
   * 1. peerDependencies from the getDependencies
   * 2. peers from getDependencies
   * 3. getAdditionalHostDependencies
   * @param env
   */
  async getPeerDependenciesListFromEnv(env) {
    const envPolicy = await this.getComponentEnvPolicyFromEnv(env);
    const peers = (0, _lodash().uniq)(envPolicy.peersAutoDetectPolicy.names.concat(envPolicy.variantPolicy.byLifecycleType('peer').names));
    let additionalHostDeps = [];
    if (env.getAdditionalHostDependencies && typeof env.getAdditionalHostDependencies === 'function') {
      additionalHostDeps = await env.getAdditionalHostDependencies();
    }
    return (0, _lodash().uniq)(peers.concat(additionalHostDeps));
  }

  /**
   * Merge the dependencies provided by:
   * 1. envs configured in the component - via dependencies method
   * 2. extensions that registered to the registerDependencyPolicy slot (and configured for the component)
   * 3. props defined by the user (they are the strongest one)
   * @param configuredExtensions
   */
  async mergeVariantPolicies(configuredExtensions) {
    var _await$this$getCompon;
    const variantPolicyFactory = new (_policy().VariantPolicyFactory)();
    let policiesFromSlots = variantPolicyFactory.getEmpty();
    let policiesFromConfig = variantPolicyFactory.getEmpty();
    const policiesFromEnv = (_await$this$getCompon = await this.getComponentEnvPolicyFromExtension(configuredExtensions)) === null || _await$this$getCompon === void 0 ? void 0 : _await$this$getCompon.variantPolicy;
    const configuredIds = configuredExtensions.ids;
    const policiesTuples = this.policiesRegistry.toArray();
    configuredIds.forEach(extId => {
      // TODO: change this way of search, once we have workspace as dep-resolver dependency
      // we can use something like:
      // const resolvedId = this.workspace.resolveComponentId(extId)
      // const currentPolicy = this.policiesRegistry.get(resolvedId.toString());
      // Only get props from configured extensions on this specific component
      const policyTupleToApply = policiesTuples.find(([policyRegistrar]) => {
        return policyRegistrar === extId || policyRegistrar.includes(extId);
      });
      if (policyTupleToApply && policyTupleToApply[1]) {
        const currentPolicy = variantPolicyFactory.fromConfigObject(policyTupleToApply[1], 'slots');
        policiesFromSlots = _policy().VariantPolicy.mergePolices([policiesFromSlots, currentPolicy]);
      }
    });
    const currentExtension = configuredExtensions.findExtension(_dependencyResolver2().DependencyResolverAspect.id);
    const currentConfig = currentExtension === null || currentExtension === void 0 ? void 0 : currentExtension.config;
    if (currentConfig && currentConfig.policy) {
      policiesFromConfig = variantPolicyFactory.fromConfigObject(currentConfig.policy, 'config');
    }
    const result = _policy().VariantPolicy.mergePolices([policiesFromEnv, policiesFromSlots, policiesFromConfig]);
    return result;
  }
  updateDepsOnLegacyTag(component, idTransformer) {
    const entry = component.extensions.findCoreExtension(_dependencyResolver2().DependencyResolverAspect.id);
    if (!entry) {
      return component;
    }
    const dependencies = (0, _lodash().get)(entry, ['data', 'dependencies'], []);
    dependencies.forEach(dep => {
      if (dep.__type === _dependencies().COMPONENT_DEP_TYPE) {
        const depId = new (_legacyBitId().BitId)(dep.componentId);
        const newDepId = idTransformer(depId);
        dep.componentId = (newDepId || depId).serialize();
        dep.id = (newDepId || depId).toString();
        dep.version = (newDepId || depId).version;
      }
    });
    return component;
  }
  updateDepsOnLegacyExport(version, idTransformer) {
    const entry = version.extensions.findCoreExtension(_dependencyResolver2().DependencyResolverAspect.id);
    if (!entry) {
      return version;
    }
    const dependencies = (0, _lodash().get)(entry, ['data', 'dependencies'], []);
    dependencies.forEach(dep => {
      if (dep.__type === _dependencies().COMPONENT_DEP_TYPE) {
        const depId = new (_legacyBitId().BitId)(dep.componentId);
        const newDepId = idTransformer(depId);
        dep.componentId = (newDepId || depId).serialize();
        dep.id = (newDepId || depId).toString();
      }
    });
    return version;
  }

  /**
   * Register a new dependency detector. Detectors allow to extend Bit's dependency detection
   * mechanism to support new file extensions and types.
   */
  registerDetector(detector) {
    _detectorHook().DetectorHook.hooks.push(detector);
    return this;
  }

  /**
   * This function registered to the onLoadRequireableExtensionSlot of the aspect-loader
   * Update the aspect / manifest deps versions in the runtimes (recursively)
   * This function mutate the manifest directly as otherwise it becomes very complicated
   * TODO: think if this funciton should be here as it about dependencies, or on the aspect loader
   * (as it's aware of the internal structure of aspects)
   * Maybe only register the dep resolution part to the aspect loader
   * at the moment it here for simplify the process
   * @param requireableExtension
   * @param manifest
   * @returns
   */
  async onLoadRequireableExtensionSubscriber(requireableExtension, manifest) {
    const parentComponent = requireableExtension.component;
    return this.resolveRequireableExtensionManifestDepsVersionsRecursively(parentComponent, manifest);
  }

  /**
   * Update the aspect / manifest deps versions in the runtimes (recursively)
   * @param parentComponent
   * @param manifest
   */
  async resolveRequireableExtensionManifestDepsVersionsRecursively(
  // Allow getting here string for lazy load the component
  // we only want to load the component in case there are deps to resolve
  parentComponent, manifest) {
    // Not resolve it immediately for performance sake
    let resolvedParentComponent;
    let resolvedParentDeps;
    const updateDirectDepsVersions = deps => {
      return (0, _pMapSeries().default)(deps, async dep => {
        var _resolvedDep$id;
        // Nothing to update (this shouldn't happen ever)
        if (!dep.id) return;
        // In case of core aspect, do not update the version, as it's loaded to harmony without version
        if (this.aspectLoader.isCoreAspect(dep.id)) return;
        // Lazily get the parent component
        if (typeof parentComponent === 'string') {
          const parentComponentId = await this.componentAspect.getHost().resolveComponentId(parentComponent);
          resolvedParentComponent = await this.componentAspect.getHost().get(parentComponentId);
        } else {
          // it's of type component;
          resolvedParentComponent = parentComponent;
        }
        if (!resolvedParentComponent) {
          this.logger.error(`could not resolve the component ${parentComponent} during manifest deps resolution. it shouldn't happen`);
          return;
        }
        // Lazily get the dependencies
        resolvedParentDeps = resolvedParentDeps || (await this.getDependencies(resolvedParentComponent));
        const resolvedDep = resolvedParentDeps.findDependency(dep.id, {
          ignoreVersion: true
        });
        dep.id = (_resolvedDep$id = resolvedDep === null || resolvedDep === void 0 ? void 0 : resolvedDep.id) !== null && _resolvedDep$id !== void 0 ? _resolvedDep$id : dep.id;
        await this.resolveRequireableExtensionManifestDepsVersionsRecursively(dep.id, dep);
      });
    };
    if (manifest.dependencies) {
      manifest.dependencies = manifest.dependencies.map(dep => this.aspectLoader.cloneManifest(dep));
      await updateDirectDepsVersions(manifest.dependencies);
    }
    // @ts-ignore
    if (manifest !== null && manifest !== void 0 && manifest._runtimes) {
      // @ts-ignore
      await (0, _pMapSeries().default)(manifest === null || manifest === void 0 ? void 0 : manifest._runtimes, async runtime => {
        if (runtime.dependencies) {
          runtime.dependencies = runtime.dependencies.map(dep => this.aspectLoader.cloneManifest(dep));
          await updateDirectDepsVersions(runtime.dependencies);
        }
      });
    }
    return manifest;
  }

  /**
   * Return a list of outdated policy dependencies.
   */
  async getOutdatedPkgsFromPolicies({
    rootDir,
    variantPoliciesByPatterns,
    componentPoliciesById,
    components
  }) {
    const componentModelVersions = (await Promise.all(components.map(async component => {
      const depList = await this.getDependencies(component);
      return depList.filter(dep => typeof dep.getPackageName === 'function' && dep.version !== 'latest' && !dep['isExtension'] &&
      // eslint-disable-line
      dep.lifecycle !== 'peer').map(dep => ({
        name: dep.getPackageName(),
        // eslint-disable-line
        version: dep.version,
        componentId: component.id.toString(),
        lifecycleType: dep.lifecycle
      }));
    }))).flat();
    const allPkgs = (0, _getAllPolicyPkgs().getAllPolicyPkgs)({
      rootPolicy: this.getWorkspacePolicyFromConfig(),
      variantPoliciesByPatterns,
      componentPoliciesById,
      componentModelVersions
    });
    return this.getOutdatedPkgs(rootDir, allPkgs);
  }

  /**
   * Accepts a list of package dependency policies and returns a list of outdated policies extended with their "latestRange"
   */
  async getOutdatedPkgs(rootDir, pkgs) {
    this.logger.setStatusLine('checking the latest versions of dependencies');
    const resolver = await this.getVersionResolver();
    const resolve = async spec => (await resolver.resolveRemoteVersion(spec, {
      rootDir
    })).version;
    const outdatedPkgs = (await Promise.all(pkgs.map(async pkg => {
      const latestVersion = await resolve(`${pkg.name}@latest`);
      return _objectSpread(_objectSpread({}, pkg), {}, {
        latestRange: latestVersion ? repeatPrefix(pkg.currentRange, latestVersion) : null
      });
    }))).filter(({
      latestRange,
      currentRange
    }) => latestRange != null && latestRange !== currentRange);
    this.logger.consoleSuccess();
    return outdatedPkgs;
  }

  /**
   * Update the specified packages to their latest versions in all policies;
   * root polcies, variant pocilicies, and component configuration policies (component.json).
   */
  applyUpdates(outdatedPkgs, options) {
    const {
      updatedVariants,
      updatedComponents,
      updatedWorkspacePolicyEntries
    } = (0, _applyUpdates().applyUpdates)(outdatedPkgs, {
      variantPoliciesByPatterns: options.variantPoliciesByPatterns,
      componentPoliciesById: options.componentPoliciesById
    });
    this.addToRootPolicy(updatedWorkspacePolicyEntries, {
      updateExisting: true
    });
    return {
      updatedVariants,
      updatedComponents
    };
  }
  static async provider([envs, loggerExt, configMain, aspectLoader, componentAspect, graphql, globalConfig], config, [rootPolicyRegistry, policiesRegistry, packageManagerSlot, dependencyFactorySlot, preInstallSlot, postInstallSlot]) {
    // const packageManager = new PackageManagerLegacy(config.packageManager, logger);
    const logger = loggerExt.createLogger(_dependencyResolver2().DependencyResolverAspect.id);
    const dependencyResolver = new DependencyResolverMain(config, rootPolicyRegistry, policiesRegistry, envs, logger, configMain, aspectLoader, globalConfig, componentAspect, packageManagerSlot, dependencyFactorySlot, preInstallSlot, postInstallSlot);
    componentAspect.registerShowFragments([new (_showFragments().DependenciesFragment)(dependencyResolver), new (_showFragments().DevDependenciesFragment)(dependencyResolver), new (_showFragments().PeerDependenciesFragment)(dependencyResolver)]);
    // TODO: solve this generics issue and remove the ts-ignore
    // @ts-ignore
    dependencyResolver.registerDependencyFactories([new (_dependencies().ComponentDependencyFactory)(componentAspect)]);
    _dependencyResolver().DependencyResolver.getDepResolverAspectName = () => _dependencyResolver2().DependencyResolverAspect.id;
    _component2().default.registerOnComponentOverridesLoading(_dependencyResolver2().DependencyResolverAspect.id, async configuredExtensions => {
      const policy = await dependencyResolver.mergeVariantPolicies(configuredExtensions);
      return policy.toLegacyDepsOverrides();
    });
    _dependencyResolver().DependencyResolver.registerWorkspacePolicyGetter(() => {
      const workspacePolicy = dependencyResolver.getWorkspacePolicy();
      return workspacePolicy.toManifest();
    });
    _dependencyResolver().DependencyResolver.registerHarmonyEnvPeersPolicyForComponentGetter(async configuredExtensions => {
      const envPolicy = await dependencyResolver.getComponentEnvPolicyFromExtension(configuredExtensions);
      return envPolicy.peersAutoDetectPolicy.toNameSupportedRangeMap();
    });
    _dependencyResolver().DependencyResolver.registerHarmonyEnvPeersPolicyForEnvItselfGetter(async id => {
      const envPolicy = await dependencyResolver.getEnvPolicyFromEnvLegacyId(id);
      if (!envPolicy) return undefined;
      return envPolicy.peersAutoDetectPolicy.toVersionManifest();
    });
    aspectLoader.registerOnLoadRequireableExtensionSlot(dependencyResolver.onLoadRequireableExtensionSubscriber.bind(dependencyResolver));
    graphql.register((0, _dependencyResolver3().dependencyResolverSchema)(dependencyResolver));
    envs.registerService(new (_dependencies2().DependenciesService)());
    return dependencyResolver;
  }
  getEmptyDepsObject() {
    return {
      dependencies: {},
      devDependencies: {},
      peerDependencies: {}
    };
  }

  /**
   * Returns a list of target locations where that given component was hard linked to.
   *
   * @param rootDir - The root directory of the workspace
   * @param componentDir - Relative path to the component's directory
   * @param packageName - The injected component's packageName
   */
  async getInjectedDirs(rootDir, componentDir, packageName) {
    const packageManager = this.packageManagerSlot.get(this.config.packageManager);
    if (typeof (packageManager === null || packageManager === void 0 ? void 0 : packageManager.getInjectedDirs) === 'function') {
      return packageManager.getInjectedDirs(rootDir, componentDir, packageName);
    }
    return [];
  }
}
exports.DependencyResolverMain = DependencyResolverMain;
(0, _defineProperty2().default)(DependencyResolverMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(DependencyResolverMain, "dependencies", [_envs().EnvsAspect, _logger().LoggerAspect, _config().ConfigAspect, _aspectLoader().default, _component().default, _graphql().GraphqlAspect, _globalConfig().default]);
(0, _defineProperty2().default)(DependencyResolverMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(DependencyResolverMain, "defaultConfig", {
  /**
   * default package manager.
   */
  packageManager: 'teambit.dependencies/pnpm',
  policy: {},
  linkCoreAspects: true
});
_dependencyResolver2().DependencyResolverAspect.addRuntime(DependencyResolverMain);
function repeatPrefix(originalSpec, newVersion) {
  switch (originalSpec[0]) {
    case '~':
    case '^':
      return `${originalSpec[0]}${newVersion}`;
    default:
      return newVersion;
  }
}

//# sourceMappingURL=dependency-resolver.main.runtime.js.map