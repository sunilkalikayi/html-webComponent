"use strict";

require("core-js/modules/es.array.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PeersAutoDetectPolicy = void 0;
function _utils() {
  const data = require("@teambit/legacy/dist/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
class PeersAutoDetectPolicy {
  constructor(_policiesEntries) {
    this._policiesEntries = _policiesEntries;
    this._policiesEntries = uniqEntries(_policiesEntries);
  }
  get entries() {
    return this._policiesEntries;
  }
  get length() {
    return this.entries.length;
  }
  get names() {
    return this.entries.map(e => e.name);
  }
  find(name) {
    const matchedEntry = this.entries.find(entry => entry.name === name);
    return matchedEntry;
  }
  sortByName() {
    const sorted = (0, _lodash().sortBy)(this.entries, ['name']);
    return new PeersAutoDetectPolicy(sorted);
  }

  /**
   * Return a hash of all the peers names and their version
   * This useful when you want to compare 2 envs
   */
  hashNameVersion() {
    const sorted = this.sortByName();
    const toHash = sorted.entries.map(({
      name,
      version
    }) => `${name}::${version}`).join(':::');
    return (0, _utils().sha1)(toHash);
  }
  filter(predicate) {
    const filtered = this.entries.filter(predicate);
    return new PeersAutoDetectPolicy(filtered);
  }
  getDepVersion(depId) {
    const entry = this.find(depId);
    if (!entry) {
      return undefined;
    }
    return entry.version;
  }
  getDepSupportedRange(depId) {
    const entry = this.find(depId);
    if (!entry) {
      return undefined;
    }
    return entry.supportedRange;
  }
  toNameSupportedRangeMap() {
    return this.entries.reduce((acc, entry) => {
      acc[entry.name] = entry.supportedRange;
      return acc;
    }, {});
  }
  toVersionManifest() {
    return this.entries.reduce((acc, entry) => {
      acc[entry.name] = entry.version;
      return acc;
    }, {});
  }
  static mergePolices(policies) {
    let allEntries = [];
    allEntries = policies.reduce((acc, curr) => {
      return acc.concat(curr.entries);
    }, allEntries);
    // We reverse it to make sure the latest policy will be stronger in case of conflict
    allEntries = allEntries.reverse();
    return new PeersAutoDetectPolicy(allEntries);
  }
}
exports.PeersAutoDetectPolicy = PeersAutoDetectPolicy;
function uniqEntries(entries) {
  const uniq = (0, _lodash().uniqWith)(entries, (entry1, entry2) => {
    return entry1.name === entry2.name;
  });
  return uniq;
}

//# sourceMappingURL=peers-auto-detect-policy.js.map