"use strict";

require("core-js/modules/es.array.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkspacePolicy = void 0;
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@teambit/legacy/dist/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _componentPackageVersion() {
  const data = require("@teambit/component-package-version");
  _componentPackageVersion = function () {
    return data;
  };
  return data;
}
function _dependencies() {
  const data = require("../../dependencies");
  _dependencies = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
class WorkspacePolicy {
  constructor(_policiesEntries) {
    this._policiesEntries = _policiesEntries;
    this._policiesEntries = uniqEntries(_policiesEntries);
  }
  get entries() {
    return this._policiesEntries;
  }
  add(entry, options) {
    const defaultOptions = {
      updateExisting: false
    };
    const calculatedOpts = Object.assign({}, defaultOptions, options);
    const existing = this.find(entry.dependencyId);
    if (existing) {
      if (!calculatedOpts.updateExisting) {
        throw new (_exceptions().EntryAlreadyExist)(entry);
      }
      this.remove([entry.dependencyId]);
    }
    this._policiesEntries.push(entry);
  }
  forEach(predicate) {
    this.entries.forEach(predicate);
  }
  filter(predicate) {
    const filtered = this.entries.filter(predicate);
    return new WorkspacePolicy(filtered);
  }
  find(depId, lifecycleType) {
    const matchedEntry = this.entries.find(entry => {
      const idEqual = entry.dependencyId === depId;
      const lifecycleEqual = lifecycleType ? entry.lifecycleType === lifecycleType : true;
      return idEqual && lifecycleEqual;
    });
    return matchedEntry;
  }
  remove(depIds) {
    const entries = this.entries.filter(entry => {
      return !depIds.includes(entry.dependencyId);
    });
    return new WorkspacePolicy(entries);
  }
  getDepVersion(depId, lifecycleType) {
    const entry = this.find(depId, lifecycleType);
    if (!entry) {
      return undefined;
    }
    return entry.value.version;
  }
  getValidSemverDepVersion(depId, lifecycleType) {
    const version = this.getDepVersion(depId, lifecycleType);
    if (!version) return undefined;
    return (0, _componentPackageVersion().snapToSemver)(version);
  }
  toConfigObject() {
    const res = {
      dependencies: {},
      peerDependencies: {}
    };
    this._policiesEntries.reduce((acc, entry) => {
      const keyName = _dependencies().KEY_NAME_BY_LIFECYCLE_TYPE[entry.lifecycleType];
      const value = entry.value.preserve ? entry.value : entry.value.version;
      acc[keyName][entry.dependencyId] = value;
      return acc;
    }, res);
    if (res.dependencies) {
      res.dependencies = (0, _utils().sortObject)(res.dependencies);
    }
    if (res.peerDependencies) {
      res.peerDependencies = (0, _utils().sortObject)(res.peerDependencies);
    }
    return res;
  }

  /**
   * Create an object ready for package manager installation
   * this is similar to "toConfigObject" but it will make the value of a specific dep always a string (the version / url)
   */
  toManifest() {
    const res = {
      dependencies: {},
      peerDependencies: {}
    };
    this._policiesEntries.reduce((acc, entry) => {
      const keyName = _dependencies().KEY_NAME_BY_LIFECYCLE_TYPE[entry.lifecycleType];
      acc[keyName][entry.dependencyId] = (0, _componentPackageVersion().snapToSemver)(entry.value.version);
      return acc;
    }, res);
    return res;
  }
  byLifecycleType(lifecycleType) {
    const filtered = this._policiesEntries.filter(entry => entry.lifecycleType === lifecycleType);
    return new WorkspacePolicy(filtered);
  }
  static mergePolices(policies) {
    let allEntries = [];
    allEntries = policies.reduce((acc, curr) => {
      return acc.concat(curr.entries);
    }, allEntries);
    // We reverse it to make sure the latest policy will be stronger in case of conflict
    allEntries = allEntries.reverse();
    return new WorkspacePolicy(allEntries);
  }
}
exports.WorkspacePolicy = WorkspacePolicy;
function uniqEntries(entries) {
  const uniq = (0, _lodash().uniqWith)(entries, (entry1, entry2) => {
    return entry1.dependencyId === entry2.dependencyId && entry1.lifecycleType === entry2.lifecycleType;
  });
  return uniq;
}

//# sourceMappingURL=workspace-policy.js.map