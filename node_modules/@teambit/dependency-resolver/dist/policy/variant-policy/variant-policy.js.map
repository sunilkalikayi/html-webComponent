{"version":3,"names":["VariantPolicy","constructor","_policiesEntries","uniqEntries","entries","names","map","e","dependencyId","length","find","depId","lifecycleType","matchedEntry","entry","idEqual","lifecycleEqual","byLifecycleType","filtered","filter","sortByName","sorted","sortBy","hashNameVersion","toHash","value","version","join","sha1","predicate","getResolvedFromEnv","dep","resolveFromEnv","getDepVersion","undefined","getValidSemverDepVersion","snapToSemver","serialize","toConfigObject","res","dependencies","devDependencies","peerDependencies","reduce","acc","keyName","KEY_NAME_BY_LIFECYCLE_TYPE","toLegacyDepsOverrides","mergePolices","policies","allEntries","curr","concat","reverse","uniq","uniqWith","entry1","entry2"],"sources":["variant-policy.ts"],"sourcesContent":["import { sha1 } from '@teambit/legacy/dist/utils';\nimport { sortBy, uniqWith } from 'lodash';\nimport { snapToSemver } from '@teambit/component-package-version';\nimport { DependenciesOverridesData } from '@teambit/legacy/dist/consumer/config/component-overrides';\nimport { Policy, PolicyConfigKeys, PolicyEntry, SemverVersion } from '../policy';\nimport { DependencyLifecycleType, KEY_NAME_BY_LIFECYCLE_TYPE } from '../../dependencies';\n\nexport type VariantPolicyConfigObject = Partial<Record<keyof PolicyConfigKeys, VariantPolicyLifecycleConfigObject>>;\n\ntype VariantPolicyLifecycleConfigObject = {\n  [dependencyId: string]: VariantPolicyConfigEntryValue;\n};\n\nexport type VariantPolicyConfigEntryValue = VariantPolicyEntryValue | VariantPolicyEntryVersion;\n\n/**\n * Allowed values are valid semver values, git urls, fs path.\n */\nexport type VariantPolicyEntryVersion = SemverVersion;\n\nexport type VariantPolicyEntryValue = {\n  version: VariantPolicyEntryVersion;\n  resolveFromEnv?: boolean;\n};\n\nexport type DependencySource = 'auto' | 'env' | 'slots' | 'config';\n\nexport type VariantPolicyEntry = PolicyEntry & {\n  value: VariantPolicyEntryValue;\n  source?: DependencySource; // determines where the dependency was resolved from, e.g. from its env, or config\n};\n\nexport type SerializedVariantPolicyEntry = VariantPolicyEntry;\nexport type SerializedVariantPolicy = SerializedVariantPolicyEntry[];\n\nexport class VariantPolicy implements Policy<VariantPolicyConfigObject> {\n  constructor(private _policiesEntries: VariantPolicyEntry[]) {\n    this._policiesEntries = uniqEntries(_policiesEntries);\n  }\n\n  get entries(): VariantPolicyEntry[] {\n    return this._policiesEntries;\n  }\n\n  get names(): string[] {\n    return this.entries.map((e) => e.dependencyId);\n  }\n\n  get length(): number {\n    return this.entries.length;\n  }\n\n  find(depId: string, lifecycleType?: DependencyLifecycleType): VariantPolicyEntry | undefined {\n    const matchedEntry = this.entries.find((entry) => {\n      const idEqual = entry.dependencyId === depId;\n      const lifecycleEqual = lifecycleType ? entry.lifecycleType === lifecycleType : true;\n      return idEqual && lifecycleEqual;\n    });\n    return matchedEntry;\n  }\n\n  byLifecycleType(lifecycleType: DependencyLifecycleType): VariantPolicy {\n    const filtered = this._policiesEntries.filter((entry) => entry.lifecycleType === lifecycleType);\n    return new VariantPolicy(filtered);\n  }\n\n  sortByName(): VariantPolicy {\n    const sorted = sortBy(this.entries, ['dependencyId']);\n    return new VariantPolicy(sorted);\n  }\n\n  /**\n   * Return a hash of all the peers names and their version\n   * This useful when you want to compare 2 envs\n   */\n  hashNameVersion(): string {\n    const sorted = this.sortByName();\n    const toHash = sorted.entries.map(({ dependencyId, value }) => `${dependencyId}::${value.version}`).join(':::');\n    return sha1(toHash);\n  }\n\n  filter(predicate: (dep: VariantPolicyEntry, index?: number) => boolean): VariantPolicy {\n    const filtered = this.entries.filter(predicate);\n    return new VariantPolicy(filtered);\n  }\n\n  /**\n   * Filter only deps which should be resolved from the env\n   */\n  getResolvedFromEnv() {\n    return this.filter((dep) => {\n      return !!dep.value.resolveFromEnv;\n    });\n  }\n\n  getDepVersion(depId: string, lifecycleType?: DependencyLifecycleType): VariantPolicyEntryVersion | undefined {\n    const entry = this.find(depId, lifecycleType);\n    if (!entry) {\n      return undefined;\n    }\n    return entry.value.version;\n  }\n\n  getValidSemverDepVersion(\n    depId: string,\n    lifecycleType?: DependencyLifecycleType\n  ): VariantPolicyEntryVersion | undefined {\n    const version = this.getDepVersion(depId, lifecycleType);\n    if (!version) return undefined;\n    return snapToSemver(version);\n  }\n\n  serialize(): SerializedVariantPolicy {\n    return this.entries;\n  }\n\n  toConfigObject(): VariantPolicyConfigObject {\n    const res: VariantPolicyConfigObject = {\n      dependencies: {},\n      devDependencies: {},\n      peerDependencies: {},\n    };\n    this._policiesEntries.reduce((acc, entry) => {\n      const keyName = KEY_NAME_BY_LIFECYCLE_TYPE[entry.lifecycleType];\n      const value = entry.value.resolveFromEnv ? entry.value : entry.value.version;\n      acc[keyName][entry.dependencyId] = value;\n      return acc;\n    }, res);\n    return res;\n  }\n\n  toLegacyDepsOverrides(): DependenciesOverridesData {\n    const res: DependenciesOverridesData = {\n      dependencies: {},\n      devDependencies: {},\n      peerDependencies: {},\n    };\n    this._policiesEntries.reduce((acc, entry) => {\n      const keyName = KEY_NAME_BY_LIFECYCLE_TYPE[entry.lifecycleType];\n      acc[keyName][entry.dependencyId] = entry.value.version;\n      return acc;\n    }, res);\n    return res;\n  }\n\n  static mergePolices(policies: VariantPolicy[]): VariantPolicy {\n    let allEntries: VariantPolicyEntry[] = [];\n    allEntries = policies.reduce((acc, curr) => {\n      return acc.concat(curr.entries);\n    }, allEntries);\n    // We reverse it to make sure the latest policy will be stronger in case of conflict\n    allEntries = allEntries.reverse();\n    return new VariantPolicy(allEntries);\n  }\n}\n\nfunction uniqEntries(entries: Array<VariantPolicyEntry>): Array<VariantPolicyEntry> {\n  const uniq = uniqWith(entries, (entry1: VariantPolicyEntry, entry2: VariantPolicyEntry) => {\n    return entry1.dependencyId === entry2.dependencyId && entry1.lifecycleType === entry2.lifecycleType;\n  });\n  return uniq;\n}\n"],"mappings":";;;;;;;AAAA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAGA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AA8BO,MAAMA,aAAa,CAA8C;EACtEC,WAAW,CAASC,gBAAsC,EAAE;IAAA,KAAxCA,gBAAsC,GAAtCA,gBAAsC;IACxD,IAAI,CAACA,gBAAgB,GAAGC,WAAW,CAACD,gBAAgB,CAAC;EACvD;EAEA,IAAIE,OAAO,GAAyB;IAClC,OAAO,IAAI,CAACF,gBAAgB;EAC9B;EAEA,IAAIG,KAAK,GAAa;IACpB,OAAO,IAAI,CAACD,OAAO,CAACE,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACC,YAAY,CAAC;EAChD;EAEA,IAAIC,MAAM,GAAW;IACnB,OAAO,IAAI,CAACL,OAAO,CAACK,MAAM;EAC5B;EAEAC,IAAI,CAACC,KAAa,EAAEC,aAAuC,EAAkC;IAC3F,MAAMC,YAAY,GAAG,IAAI,CAACT,OAAO,CAACM,IAAI,CAAEI,KAAK,IAAK;MAChD,MAAMC,OAAO,GAAGD,KAAK,CAACN,YAAY,KAAKG,KAAK;MAC5C,MAAMK,cAAc,GAAGJ,aAAa,GAAGE,KAAK,CAACF,aAAa,KAAKA,aAAa,GAAG,IAAI;MACnF,OAAOG,OAAO,IAAIC,cAAc;IAClC,CAAC,CAAC;IACF,OAAOH,YAAY;EACrB;EAEAI,eAAe,CAACL,aAAsC,EAAiB;IACrE,MAAMM,QAAQ,GAAG,IAAI,CAAChB,gBAAgB,CAACiB,MAAM,CAAEL,KAAK,IAAKA,KAAK,CAACF,aAAa,KAAKA,aAAa,CAAC;IAC/F,OAAO,IAAIZ,aAAa,CAACkB,QAAQ,CAAC;EACpC;EAEAE,UAAU,GAAkB;IAC1B,MAAMC,MAAM,GAAG,IAAAC,gBAAM,EAAC,IAAI,CAAClB,OAAO,EAAE,CAAC,cAAc,CAAC,CAAC;IACrD,OAAO,IAAIJ,aAAa,CAACqB,MAAM,CAAC;EAClC;;EAEA;AACF;AACA;AACA;EACEE,eAAe,GAAW;IACxB,MAAMF,MAAM,GAAG,IAAI,CAACD,UAAU,EAAE;IAChC,MAAMI,MAAM,GAAGH,MAAM,CAACjB,OAAO,CAACE,GAAG,CAAC,CAAC;MAAEE,YAAY;MAAEiB;IAAM,CAAC,KAAM,GAAEjB,YAAa,KAAIiB,KAAK,CAACC,OAAQ,EAAC,CAAC,CAACC,IAAI,CAAC,KAAK,CAAC;IAC/G,OAAO,IAAAC,aAAI,EAACJ,MAAM,CAAC;EACrB;EAEAL,MAAM,CAACU,SAA+D,EAAiB;IACrF,MAAMX,QAAQ,GAAG,IAAI,CAACd,OAAO,CAACe,MAAM,CAACU,SAAS,CAAC;IAC/C,OAAO,IAAI7B,aAAa,CAACkB,QAAQ,CAAC;EACpC;;EAEA;AACF;AACA;EACEY,kBAAkB,GAAG;IACnB,OAAO,IAAI,CAACX,MAAM,CAAEY,GAAG,IAAK;MAC1B,OAAO,CAAC,CAACA,GAAG,CAACN,KAAK,CAACO,cAAc;IACnC,CAAC,CAAC;EACJ;EAEAC,aAAa,CAACtB,KAAa,EAAEC,aAAuC,EAAyC;IAC3G,MAAME,KAAK,GAAG,IAAI,CAACJ,IAAI,CAACC,KAAK,EAAEC,aAAa,CAAC;IAC7C,IAAI,CAACE,KAAK,EAAE;MACV,OAAOoB,SAAS;IAClB;IACA,OAAOpB,KAAK,CAACW,KAAK,CAACC,OAAO;EAC5B;EAEAS,wBAAwB,CACtBxB,KAAa,EACbC,aAAuC,EACA;IACvC,MAAMc,OAAO,GAAG,IAAI,CAACO,aAAa,CAACtB,KAAK,EAAEC,aAAa,CAAC;IACxD,IAAI,CAACc,OAAO,EAAE,OAAOQ,SAAS;IAC9B,OAAO,IAAAE,uCAAY,EAACV,OAAO,CAAC;EAC9B;EAEAW,SAAS,GAA4B;IACnC,OAAO,IAAI,CAACjC,OAAO;EACrB;EAEAkC,cAAc,GAA8B;IAC1C,MAAMC,GAA8B,GAAG;MACrCC,YAAY,EAAE,CAAC,CAAC;MAChBC,eAAe,EAAE,CAAC,CAAC;MACnBC,gBAAgB,EAAE,CAAC;IACrB,CAAC;IACD,IAAI,CAACxC,gBAAgB,CAACyC,MAAM,CAAC,CAACC,GAAG,EAAE9B,KAAK,KAAK;MAC3C,MAAM+B,OAAO,GAAGC,0CAA0B,CAAChC,KAAK,CAACF,aAAa,CAAC;MAC/D,MAAMa,KAAK,GAAGX,KAAK,CAACW,KAAK,CAACO,cAAc,GAAGlB,KAAK,CAACW,KAAK,GAAGX,KAAK,CAACW,KAAK,CAACC,OAAO;MAC5EkB,GAAG,CAACC,OAAO,CAAC,CAAC/B,KAAK,CAACN,YAAY,CAAC,GAAGiB,KAAK;MACxC,OAAOmB,GAAG;IACZ,CAAC,EAAEL,GAAG,CAAC;IACP,OAAOA,GAAG;EACZ;EAEAQ,qBAAqB,GAA8B;IACjD,MAAMR,GAA8B,GAAG;MACrCC,YAAY,EAAE,CAAC,CAAC;MAChBC,eAAe,EAAE,CAAC,CAAC;MACnBC,gBAAgB,EAAE,CAAC;IACrB,CAAC;IACD,IAAI,CAACxC,gBAAgB,CAACyC,MAAM,CAAC,CAACC,GAAG,EAAE9B,KAAK,KAAK;MAC3C,MAAM+B,OAAO,GAAGC,0CAA0B,CAAChC,KAAK,CAACF,aAAa,CAAC;MAC/DgC,GAAG,CAACC,OAAO,CAAC,CAAC/B,KAAK,CAACN,YAAY,CAAC,GAAGM,KAAK,CAACW,KAAK,CAACC,OAAO;MACtD,OAAOkB,GAAG;IACZ,CAAC,EAAEL,GAAG,CAAC;IACP,OAAOA,GAAG;EACZ;EAEA,OAAOS,YAAY,CAACC,QAAyB,EAAiB;IAC5D,IAAIC,UAAgC,GAAG,EAAE;IACzCA,UAAU,GAAGD,QAAQ,CAACN,MAAM,CAAC,CAACC,GAAG,EAAEO,IAAI,KAAK;MAC1C,OAAOP,GAAG,CAACQ,MAAM,CAACD,IAAI,CAAC/C,OAAO,CAAC;IACjC,CAAC,EAAE8C,UAAU,CAAC;IACd;IACAA,UAAU,GAAGA,UAAU,CAACG,OAAO,EAAE;IACjC,OAAO,IAAIrD,aAAa,CAACkD,UAAU,CAAC;EACtC;AACF;AAAC;AAED,SAAS/C,WAAW,CAACC,OAAkC,EAA6B;EAClF,MAAMkD,IAAI,GAAG,IAAAC,kBAAQ,EAACnD,OAAO,EAAE,CAACoD,MAA0B,EAAEC,MAA0B,KAAK;IACzF,OAAOD,MAAM,CAAChD,YAAY,KAAKiD,MAAM,CAACjD,YAAY,IAAIgD,MAAM,CAAC5C,aAAa,KAAK6C,MAAM,CAAC7C,aAAa;EACrG,CAAC,CAAC;EACF,OAAO0C,IAAI;AACb"}