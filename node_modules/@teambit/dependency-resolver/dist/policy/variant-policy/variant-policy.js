"use strict";

require("core-js/modules/es.array.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VariantPolicy = void 0;
function _utils() {
  const data = require("@teambit/legacy/dist/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _componentPackageVersion() {
  const data = require("@teambit/component-package-version");
  _componentPackageVersion = function () {
    return data;
  };
  return data;
}
function _dependencies() {
  const data = require("../../dependencies");
  _dependencies = function () {
    return data;
  };
  return data;
}
class VariantPolicy {
  constructor(_policiesEntries) {
    this._policiesEntries = _policiesEntries;
    this._policiesEntries = uniqEntries(_policiesEntries);
  }
  get entries() {
    return this._policiesEntries;
  }
  get names() {
    return this.entries.map(e => e.dependencyId);
  }
  get length() {
    return this.entries.length;
  }
  find(depId, lifecycleType) {
    const matchedEntry = this.entries.find(entry => {
      const idEqual = entry.dependencyId === depId;
      const lifecycleEqual = lifecycleType ? entry.lifecycleType === lifecycleType : true;
      return idEqual && lifecycleEqual;
    });
    return matchedEntry;
  }
  byLifecycleType(lifecycleType) {
    const filtered = this._policiesEntries.filter(entry => entry.lifecycleType === lifecycleType);
    return new VariantPolicy(filtered);
  }
  sortByName() {
    const sorted = (0, _lodash().sortBy)(this.entries, ['dependencyId']);
    return new VariantPolicy(sorted);
  }

  /**
   * Return a hash of all the peers names and their version
   * This useful when you want to compare 2 envs
   */
  hashNameVersion() {
    const sorted = this.sortByName();
    const toHash = sorted.entries.map(({
      dependencyId,
      value
    }) => `${dependencyId}::${value.version}`).join(':::');
    return (0, _utils().sha1)(toHash);
  }
  filter(predicate) {
    const filtered = this.entries.filter(predicate);
    return new VariantPolicy(filtered);
  }

  /**
   * Filter only deps which should be resolved from the env
   */
  getResolvedFromEnv() {
    return this.filter(dep => {
      return !!dep.value.resolveFromEnv;
    });
  }
  getDepVersion(depId, lifecycleType) {
    const entry = this.find(depId, lifecycleType);
    if (!entry) {
      return undefined;
    }
    return entry.value.version;
  }
  getValidSemverDepVersion(depId, lifecycleType) {
    const version = this.getDepVersion(depId, lifecycleType);
    if (!version) return undefined;
    return (0, _componentPackageVersion().snapToSemver)(version);
  }
  serialize() {
    return this.entries;
  }
  toConfigObject() {
    const res = {
      dependencies: {},
      devDependencies: {},
      peerDependencies: {}
    };
    this._policiesEntries.reduce((acc, entry) => {
      const keyName = _dependencies().KEY_NAME_BY_LIFECYCLE_TYPE[entry.lifecycleType];
      const value = entry.value.resolveFromEnv ? entry.value : entry.value.version;
      acc[keyName][entry.dependencyId] = value;
      return acc;
    }, res);
    return res;
  }
  toLegacyDepsOverrides() {
    const res = {
      dependencies: {},
      devDependencies: {},
      peerDependencies: {}
    };
    this._policiesEntries.reduce((acc, entry) => {
      const keyName = _dependencies().KEY_NAME_BY_LIFECYCLE_TYPE[entry.lifecycleType];
      acc[keyName][entry.dependencyId] = entry.value.version;
      return acc;
    }, res);
    return res;
  }
  static mergePolices(policies) {
    let allEntries = [];
    allEntries = policies.reduce((acc, curr) => {
      return acc.concat(curr.entries);
    }, allEntries);
    // We reverse it to make sure the latest policy will be stronger in case of conflict
    allEntries = allEntries.reverse();
    return new VariantPolicy(allEntries);
  }
}
exports.VariantPolicy = VariantPolicy;
function uniqEntries(entries) {
  const uniq = (0, _lodash().uniqWith)(entries, (entry1, entry2) => {
    return entry1.dependencyId === entry2.dependencyId && entry1.lifecycleType === entry2.lifecycleType;
  });
  return uniq;
}

//# sourceMappingURL=variant-policy.js.map