import { Component, ComponentMap, ComponentMain, IComponent } from '@teambit/component';
import type { ConfigMain } from '@teambit/config';
import { DependenciesEnv, EnvsMain } from '@teambit/envs';
import { SlotRegistry, ExtensionManifest, Aspect } from '@teambit/harmony';
import { RequireableComponent } from '@teambit/harmony.modules.requireable-component';
import type { LoggerMain } from '@teambit/logger';
import { GraphqlMain } from '@teambit/graphql';
import { Logger } from '@teambit/logger';
import { ExtensionDataList } from '@teambit/legacy/dist/consumer/config/extension-data';
import { ProxyConfig, NetworkConfig } from '@teambit/legacy/dist/scope/network/http';
import { onTagIdTransformer } from '@teambit/snapping';
import { Version as VersionModel } from '@teambit/legacy/dist/scope/models';
import LegacyComponent from '@teambit/legacy/dist/consumer/component';
import { BitId } from '@teambit/legacy-bit-id';
import { PeerDependencyRules } from '@pnpm/types';
import semver from 'semver';
import { AspectLoaderMain } from '@teambit/aspect-loader';
import { GlobalConfigMain } from '@teambit/global-config';
import { Registries } from './registry';
import { DependencyInstaller, PreInstallSubscriberList, PostInstallSubscriberList } from './dependency-installer';
import { DependencyVersionResolver } from './dependency-version-resolver';
import { DependencyLinker, LinkingOptions } from './dependency-linker';
import { OutdatedPkg } from './get-all-policy-pkgs';
import { CreateFromComponentsOptions, WorkspaceManifest, ManifestDependenciesObject } from './manifest';
import { WorkspacePolicyConfigObject, VariantPolicyConfigObject, WorkspacePolicy, VariantPolicy, WorkspacePolicyAddEntryOptions, WorkspacePolicyEntry } from './policy';
import { PackageImportMethod, PackageManager, PackageManagerGetPeerDependencyIssuesOptions } from './package-manager';
import { DependencyFactory, DependencyList } from './dependencies';
import { DependencyDetector } from './dependency-detector';
import { EnvPolicy } from './policy/env-policy';
/**
 * @deprecated use BIT_CLOUD_REGISTRY instead
 */
export declare const BIT_DEV_REGISTRY = "https://node.bit.dev/";
export declare const BIT_CLOUD_REGISTRY = "https://node.bit.cloud/";
export declare const NPM_REGISTRY = "https://registry.npmjs.org/";
export { ProxyConfig, NetworkConfig } from '@teambit/legacy/dist/scope/network/http';
export interface DependencyResolverWorkspaceConfig {
    policy: WorkspacePolicyConfigObject;
    /**
     * choose the package manager for Bit to use. you can choose between 'npm', 'yarn', 'pnpm'
     * and 'librarian'. our recommendation is use 'librarian' which reduces package duplicates
     * and totally removes the need of a 'node_modules' directory in your project.
     */
    packageManager: string;
    /**
     * A proxy server for out going network requests by the package manager
     * Used for both http and https requests (unless the httpsProxy is defined)
     */
    proxy?: string;
    /**
     * A proxy server for outgoing https requests by the package manager (fallback to proxy server if not defined)
     * Use this in case you want different proxy for http and https requests.
     */
    httpsProxy?: string;
    /**
     * A path to a file containing one or multiple Certificate Authority signing certificates.
     * allows for multiple CA's, as well as for the CA information to be stored in a file on disk.
     */
    ca?: string;
    /**
     * Whether or not to do SSL key validation when making requests to the registry via https
     */
    strictSsl?: string;
    /**
     * A client certificate to pass when accessing the registry. Values should be in PEM format (Windows calls it "Base-64 encoded X.509 (.CER)") with newlines replaced by the string "\n". For example:
     * cert="-----BEGIN CERTIFICATE-----\nXXXX\nXXXX\n-----END CERTIFICATE-----"
     * It is not the path to a certificate file (and there is no "certfile" option).
     */
    cert?: string;
    /**
     * A client key to pass when accessing the registry. Values should be in PEM format with newlines replaced by the string "\n". For example:
     * key="-----BEGIN PRIVATE KEY-----\nXXXX\nXXXX\n-----END PRIVATE KEY-----"
     * It is not the path to a key file (and there is no "keyfile" option).
     */
    key?: string;
    /**
     * A comma-separated string of domain extensions that a proxy should not be used for.
     */
    noProxy?: string;
    /**
     * The IP address of the local interface to use when making connections to the npm registry.
     */
    localAddress?: string;
    /**
     * How many times to retry if Bit fails to fetch from the registry.
     */
    fetchRetries?: number;
    fetchRetryFactor?: number;
    fetchRetryMintimeout?: number;
    fetchRetryMaxtimeout?: number;
    fetchTimeout?: number;
    maxSockets?: number;
    networkConcurrency?: number;
    savePrefix?: string;
    installFromBitDevRegistry?: boolean;
    packageManagerArgs?: string[];
    overrides?: Record<string, string>;
    /**
     * This is similar to overrides, but will only affect installation in capsules.
     * In case overrides is configured and this not, the regular overrides will affect capsules as well.
     * in case both configured, capsulesOverrides will be used for capsules, and overrides will affect the workspace.
     */
    capsulesOverrides?: Record<string, string>;
    nodeLinker?: 'hoisted' | 'isolated';
    packageImportMethod?: PackageImportMethod;
    sideEffectsCache?: boolean;
    rootComponents?: boolean;
    nodeVersion?: string;
    engineStrict?: boolean;
    peerDependencyRules?: PeerDependencyRules;
    linkCoreAspects?: boolean;
}
export interface DependencyResolverVariantConfig {
    policy: VariantPolicyConfigObject;
}
export declare type RootPolicyRegistry = SlotRegistry<WorkspacePolicy>;
export declare type PoliciesRegistry = SlotRegistry<VariantPolicyConfigObject>;
export declare type PackageManagerSlot = SlotRegistry<PackageManager>;
export declare type DependencyFactorySlot = SlotRegistry<DependencyFactory[]>;
export declare type PreInstallSlot = SlotRegistry<PreInstallSubscriberList>;
export declare type PostInstallSlot = SlotRegistry<PostInstallSubscriberList>;
export declare type MergeDependenciesFunc = (configuredExtensions: ExtensionDataList) => Promise<VariantPolicyConfigObject>;
export declare type GetInstallerOptions = {
    rootDir?: string;
    packageManager?: string;
    cacheRootDirectory?: string;
};
export declare type GetLinkerOptions = {
    rootDir?: string;
    linkingOptions?: LinkingOptions;
};
export declare type GetVersionResolverOptions = {
    cacheRootDirectory?: string;
};
declare type OnExportIdTransformer = (id: BitId) => BitId;
export declare class DependencyResolverMain {
    /**
     * Dependency resolver  extension configuration.
     */
    readonly config: DependencyResolverWorkspaceConfig;
    /**
     * Registry for changes by other extensions.
     */
    private rootPolicyRegistry;
    /**
     * Registry for changes by other extensions.
     */
    private policiesRegistry;
    /**
     * envs extension.
     */
    private envs;
    private logger;
    private configAspect;
    private aspectLoader;
    private globalConfig;
    /**
     * component aspect.
     */
    readonly componentAspect: ComponentMain;
    private packageManagerSlot;
    private dependencyFactorySlot;
    private preInstallSlot;
    private postInstallSlot;
    constructor(
    /**
     * Dependency resolver  extension configuration.
     */
    config: DependencyResolverWorkspaceConfig, 
    /**
     * Registry for changes by other extensions.
     */
    rootPolicyRegistry: RootPolicyRegistry, 
    /**
     * Registry for changes by other extensions.
     */
    policiesRegistry: PoliciesRegistry, 
    /**
     * envs extension.
     */
    envs: EnvsMain, logger: Logger, configAspect: ConfigMain, aspectLoader: AspectLoaderMain, globalConfig: GlobalConfigMain, 
    /**
     * component aspect.
     */
    componentAspect: ComponentMain, packageManagerSlot: PackageManagerSlot, dependencyFactorySlot: DependencyFactorySlot, preInstallSlot: PreInstallSlot, postInstallSlot: PostInstallSlot);
    /**
     * This function is a temporary workaround for installation in capsules with pnpm.
     * Currently pnpm breaks the root node_modules inside the capsule because it removes deps from it.
     * Install runs several times in the same capsule and pnpm removes deps from the previous runs.
     *
     * This workaround unfortunately also breaks pnpm on angular projects. Because dedupe doesn't work properly.
     * To fix this issue we'll either have to switch to root components or try to change pnpm code.
     *
     * Here is the PR where initially dedupe was turned off for pnpm: https://github.com/teambit/bit/pull/5410
     */
    supportsDedupingOnExistingRoot(): boolean;
    hasRootComponents(): boolean;
    linkCoreAspects(): boolean;
    /**
     * register a new package manager to the dependency resolver.
     */
    registerPackageManager(packageManager: PackageManager): void;
    registerDependencyFactories(factories: DependencyFactory[]): void;
    registerPreInstallSubscribers(subscribers: PreInstallSubscriberList): void;
    registerPostInstallSubscribers(subscribers: PreInstallSubscriberList): void;
    getSavePrefix(): string;
    getVersionWithSavePrefix(version: string, overridePrefix?: string): string;
    getPolicy(component: Component): Promise<VariantPolicy>;
    /**
     * This function called on component load in order to calculate the dependencies based on the legacy (consumer) component
     * and write them to the dependencyResolver data.
     * Do not use this function for other purpose.
     * If you want to get the component dependencies call getDependencies (which will give you the dependencies from the data itself)
     * TODO: once we switch deps resolver <> workspace relation we should make it private
     * TODO: once we switch deps resolver <> workspace relation we should remove the resolveId func here
     * @param component
     */
    extractDepsFromLegacy(component: Component, policy?: VariantPolicy): Promise<DependencyList>;
    private getDependencyListFactory;
    /**
     * Main function to get the dependency list of a given component
     * @param component
     */
    getDependencies(component: IComponent): Promise<DependencyList>;
    private getDependenciesFromSerializedDependencies;
    /**
     * Getting the merged workspace policy (from dep resolver config and others like root package.json)
     * @returns
     */
    getWorkspacePolicy(): WorkspacePolicy;
    /**
     * Getting the workspace policy as defined in the workspace.jsonc in the dependencyResolver aspect
     * This will not take into account packages that defined in the package.json of the root for example
     * in most cases you should use getWorkspacePolicy
     * @returns
     */
    getWorkspacePolicyFromConfig(): WorkspacePolicy;
    getWorkspacePolicyFromPackageJson(packageJson: Record<string, any>): WorkspacePolicy;
    mergeWorkspacePolices(polices: WorkspacePolicy[]): WorkspacePolicy;
    /**
     * Create a workspace manifest
     * The term workspace here is not the same as "bit workspace" but a workspace that represent a shared root
     * for installation of many components (sometime it might point to the workspace path)
     * in other case it can be for example the capsules root dir
     *
     * @param {string} [name=ROOT_NAME]
     * @param {SemVer} [version=new SemVer('1.0.0')]
     * @param {ManifestDependenciesObject} dependencies
     * @param {string} rootDir
     * @param {Component[]} components
     * @param {CreateFromComponentsOptions} [options={
     *       filterComponentsFromManifests: true,
     *       createManifestForComponentsWithoutDependencies: true,
     *     }]
     * @returns {WorkspaceManifest}
     * @memberof DependencyResolverMain
     */
    getWorkspaceManifest(name: string | undefined, version: semver.SemVer | undefined, rootPolicy: WorkspacePolicy, rootDir: string, components: Component[], options?: CreateFromComponentsOptions): Promise<WorkspaceManifest>;
    /**
     * get the package name of a component.
     */
    getPackageName(component: Component): string;
    getRuntimeModulePath(component: Component): string;
    /**
     * returns the package path in the /node_modules/ folder
     * In case you call this in order to run the code from the path, please refer to the `getRuntimeModulePath` API
     */
    getModulePath(component: Component): string;
    /**
     * get a component dependency installer.
     */
    getInstaller(options?: GetInstallerOptions): DependencyInstaller;
    private getPreInstallSubscribers;
    private getPostInstallSubscribers;
    /**
     * get a component dependency linker.
     */
    getLinker(options?: GetLinkerOptions): DependencyLinker;
    getPackageManagerName(): string;
    getVersionResolver(options?: GetVersionResolverOptions): Promise<DependencyVersionResolver>;
    /**
     * return the system configured package manager. by default pnpm.
     */
    getSystemPackageManager(): PackageManager;
    getProxyConfig(): Promise<ProxyConfig>;
    private getProxyConfigFromDepResolverConfig;
    getNetworkConfig(): Promise<NetworkConfig>;
    private getNetworkConfigFromGlobalConfig;
    private getNetworkConfigFromDepResolverConfig;
    private getNetworkConfigFromPackageManager;
    private getProxyConfigFromPackageManager;
    private getProxyConfigFromGlobalConfig;
    /**
     * Return the peer dependencies and their ranges that may be installed
     * without causing unmet peer dependency issues in some of the dependencies.
     */
    getMissingPeerDependencies(rootDir: string, rootPolicy: WorkspacePolicy, componentDirectoryMap: ComponentMap<string>, options: PackageManagerGetPeerDependencyIssuesOptions): Promise<Record<string, string>>;
    getRegistries(): Promise<Registries>;
    /**
     * This will mutate any registry which point to BIT_DEV_REGISTRY to have the auth config from the @bit scoped registry or from the user.token in bit's config
     */
    private addAuthToScopedBitRegistries;
    private getBitAuthConfig;
    get packageManagerName(): string;
    addToRootPolicy(entries: WorkspacePolicyEntry[], options?: WorkspacePolicyAddEntryOptions): WorkspacePolicy;
    removeFromRootPolicy(dependencyIds: string[]): void;
    private updateConfigPolicy;
    persistConfig(workspaceDir?: string): Promise<void | undefined>;
    /**
     * register new dependencies policies
     */
    registerDependenciesPolicies(policy: VariantPolicyConfigObject): void;
    /**
     * register new dependencies policies
     */
    registerRootPolicy(policy: WorkspacePolicy): void;
    getComponentEnvPolicyFromExtension(configuredExtensions: ExtensionDataList): Promise<EnvPolicy>;
    getEnvPolicyFromEnvLegacyId(id: BitId): Promise<EnvPolicy | undefined>;
    getComponentEnvPolicy(component: Component): Promise<EnvPolicy>;
    getComponentEnvPolicyFromEnv(env: DependenciesEnv): Promise<EnvPolicy>;
    /**
     * Get a list of peer dependencies applied from an env
     * This will merge different peers list like:
     * 1. peerDependencies from the getDependencies
     * 2. peers from getDependencies
     * 3. getAdditionalHostDependencies
     * @param env
     */
    getPeerDependenciesListFromEnv(env: DependenciesEnv): Promise<string[]>;
    /**
     * Merge the dependencies provided by:
     * 1. envs configured in the component - via dependencies method
     * 2. extensions that registered to the registerDependencyPolicy slot (and configured for the component)
     * 3. props defined by the user (they are the strongest one)
     * @param configuredExtensions
     */
    mergeVariantPolicies(configuredExtensions: ExtensionDataList): Promise<VariantPolicy>;
    updateDepsOnLegacyTag(component: LegacyComponent, idTransformer: onTagIdTransformer): LegacyComponent;
    updateDepsOnLegacyExport(version: VersionModel, idTransformer: OnExportIdTransformer): VersionModel;
    /**
     * Register a new dependency detector. Detectors allow to extend Bit's dependency detection
     * mechanism to support new file extensions and types.
     */
    registerDetector(detector: DependencyDetector): this;
    /**
     * This function registered to the onLoadRequireableExtensionSlot of the aspect-loader
     * Update the aspect / manifest deps versions in the runtimes (recursively)
     * This function mutate the manifest directly as otherwise it becomes very complicated
     * TODO: think if this funciton should be here as it about dependencies, or on the aspect loader
     * (as it's aware of the internal structure of aspects)
     * Maybe only register the dep resolution part to the aspect loader
     * at the moment it here for simplify the process
     * @param requireableExtension
     * @param manifest
     * @returns
     */
    onLoadRequireableExtensionSubscriber(requireableExtension: RequireableComponent, manifest: ExtensionManifest | Aspect): Promise<ExtensionManifest | Aspect>;
    /**
     * Update the aspect / manifest deps versions in the runtimes (recursively)
     * @param parentComponent
     * @param manifest
     */
    private resolveRequireableExtensionManifestDepsVersionsRecursively;
    /**
     * Return a list of outdated policy dependencies.
     */
    getOutdatedPkgsFromPolicies({ rootDir, variantPoliciesByPatterns, componentPoliciesById, components, }: {
        rootDir: string;
        variantPoliciesByPatterns: Record<string, VariantPolicyConfigObject>;
        componentPoliciesById: Record<string, any>;
        components: Component[];
    }): Promise<OutdatedPkg[]>;
    /**
     * Accepts a list of package dependency policies and returns a list of outdated policies extended with their "latestRange"
     */
    getOutdatedPkgs<T>(rootDir: string, pkgs: Array<{
        name: string;
        currentRange: string;
    } & T>): Promise<Array<{
        name: string;
        currentRange: string;
        latestRange: string;
    } & T>>;
    /**
     * Update the specified packages to their latest versions in all policies;
     * root polcies, variant pocilicies, and component configuration policies (component.json).
     */
    applyUpdates(outdatedPkgs: Array<Omit<OutdatedPkg, 'currentRange'>>, options: {
        variantPoliciesByPatterns: Record<string, any>;
        componentPoliciesById: Record<string, any>;
    }): {
        updatedVariants: string[];
        updatedComponents: string[];
    };
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: Aspect[];
    static slots: (((registerFn: () => string) => SlotRegistry<WorkspacePolicy>) | ((registerFn: () => string) => SlotRegistry<Partial<Record<keyof import("./policy").PolicyConfigKeys, {
        [dependencyId: string]: import("./policy/variant-policy/variant-policy").VariantPolicyConfigEntryValue;
    }>>>) | ((registerFn: () => string) => SlotRegistry<PackageManager>) | ((registerFn: () => string) => SlotRegistry<RegExp>) | ((registerFn: () => string) => SlotRegistry<DependencyFactory>) | ((registerFn: () => string) => SlotRegistry<PreInstallSubscriberList>) | ((registerFn: () => string) => SlotRegistry<DependencyDetector>))[];
    static defaultConfig: DependencyResolverWorkspaceConfig & Required<Pick<DependencyResolverWorkspaceConfig, 'linkCoreAspects'>>;
    static provider([envs, loggerExt, configMain, aspectLoader, componentAspect, graphql, globalConfig]: [
        EnvsMain,
        LoggerMain,
        ConfigMain,
        AspectLoaderMain,
        ComponentMain,
        GraphqlMain,
        GlobalConfigMain
    ], config: DependencyResolverWorkspaceConfig, [rootPolicyRegistry, policiesRegistry, packageManagerSlot, dependencyFactorySlot, preInstallSlot, postInstallSlot,]: [
        RootPolicyRegistry,
        PoliciesRegistry,
        PackageManagerSlot,
        DependencyFactorySlot,
        PreInstallSlot,
        PostInstallSlot
    ]): Promise<DependencyResolverMain>;
    getEmptyDepsObject(): ManifestDependenciesObject;
    /**
     * Returns a list of target locations where that given component was hard linked to.
     *
     * @param rootDir - The root directory of the workspace
     * @param componentDir - Relative path to the component's directory
     * @param packageName - The injected component's packageName
     */
    getInjectedDirs(rootDir: string, componentDir: string, packageName: string): Promise<string[]>;
}
