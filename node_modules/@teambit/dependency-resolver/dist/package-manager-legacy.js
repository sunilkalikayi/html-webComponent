"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _child_process() {
  const data = require("@teambit/legacy/dist/utils/child_process");
  _child_process = function () {
    return data;
  };
  return data;
}
function _createSymlinkOrCopy() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/fs/create-symlink-or-copy"));
  _createSymlinkOrCopy = function () {
    return data;
  };
  return data;
}
function _events() {
  const data = require("events");
  _events = function () {
    return data;
  };
  return data;
}
function _execa() {
  const data = _interopRequireDefault(require("execa"));
  _execa = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireWildcard(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/* eslint-disable no-empty */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-non-null-assertion */

class PackageManager {
  constructor(packageManagerName, logger) {
    this.packageManagerName = packageManagerName;
    this.logger = logger;
    (0, _defineProperty2().default)(this, "emitter", new (_events().EventEmitter)());
  }
  get name() {
    return this.packageManagerName;
  }
  async checkIfFileExistsInCapsule(capsule, file) {
    const pathToFile = (0, _path().join)(capsule.wrkDir, file);
    try {
      await capsule.fs.promises.access(pathToFile);
      return true;
    } catch (e) {}
    return false;
  }
  async removeLockFilesInCapsule(capsule) {
    async function safeUnlink(toRemove) {
      try {
        await capsule.fs.promises.unlink((0, _path().join)(capsule.wrkDir, toRemove));
      } catch (e) {}
    }
    await safeUnlink('yarn.lock');
    await safeUnlink('package-lock.json');
  }
  async capsulesInstall(capsules, opts = {}) {
    const packageManager = this.packageManagerName;
    const longProcessLogger = this.logger.createLongProcessLogger('installing capsules', capsules.length);
    if (packageManager === 'npm' || packageManager === 'yarn' || packageManager === 'pnpm') {
      // Don't run them in parallel (Promise.all), the package-manager doesn't handle it well.
      await (0, _pMapSeries().default)(capsules, async capsule => {
        const componentId = capsule.component.id.toString();
        longProcessLogger.logProgress(componentId);
        // TODO: remove this hack once harmony supports ownExtensionName
        const execOptions = {
          cwd: capsule.wrkDir
        };
        const getExecCall = () => {
          switch (packageManager) {
            case 'npm':
              return (0, _execa().default)('npm', ['install', '--no-package-lock'], execOptions);
            case 'yarn':
              return (0, _execa().default)('yarn', [], execOptions);
            case 'pnpm':
              return (0, _execa().default)('pnpm', ['install'], execOptions);
            default:
              throw new Error(`unsupported package manager ${packageManager}`);
          }
        };
        const installProc = getExecCall();
        this.logger.info(`${componentId}, ${packageManager === 'npm' ? '$ npm install --no-package-lock' : '$ yarn'}`); // TODO: better
        installProc.stdout.on('data', d => this.logger.info(`${componentId}, ${d.toString()}`));
        installProc.stderr.on('data', d => this.logger.warn(`${componentId}, ${d.toString()}`));
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        installProc.on('error', e => {
          console.log('error:', e); // eslint-disable-line no-console
          this.logger.error(`${componentId}, ${e}`);
        });
        await installProc;
        linkBitLegacyInCapsule(capsule);
      });
    } else {
      throw new Error(`unsupported package manager ${packageManager}`);
    }
    longProcessLogger.end();
    return null;
  }
  async runInstallInFolder(folder, opts = {}) {
    const packageManager = this.packageManagerName;
    if (packageManager === 'yarn') {
      const child = (0, _execa().default)('yarn', [], {
        cwd: folder,
        stdio: 'pipe'
      });
      (0, _child_process().pipeOutput)(child);
      await child;
      return;
    }
    if (packageManager === 'npm') {
      const child = (0, _execa().default)('npm', ['install'], {
        cwd: folder,
        stdio: 'pipe'
      });
      this.logger.info(`${folder} $ npm install`);
      await new Promise((resolve, reject) => {
        // @ts-ignore
        child.stdout.on('data', d => this.logger.info(`${folder} ${d.toString()}`));
        // @ts-ignore
        child.stderr.on('data', d => this.logger.warn(`${folder} ${d.toString()}`));
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        child.on('error', e => {
          reject(e);
        });
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        child.on('close', exitStatus => {
          if (exitStatus) {
            reject(new Error(`${folder}`));
          } else {
            resolve(null);
          }
        });
      });
      return;
    }
    throw new Error(`unsupported package manager ${packageManager}`);
  }
}
exports.default = PackageManager;
function linkBitLegacyInCapsule(capsule) {
  const bitLegacyPath = _path().default.join(capsule.wrkDir, './node_modules/@teambit/legacy');
  const getLocalBitLegacyPath = () => {
    const pathOutsideNodeModules = _path().default.join(__dirname, '../..');
    if (pathOutsideNodeModules.endsWith(`${_path().default.sep}dist`)) {
      return pathOutsideNodeModules;
    }
    throw new Error('unable to link @teambit/legacy to the capsule, the location of @teambit/legacy is unknown');
  };
  const localBitLegacyPath = getLocalBitLegacyPath();
  // if there are no deps, sometimes the node_modules folder is not created
  // and we need it in order to perform the linking
  try {
    capsule.fs.mkdirSync('node_modules');
  } catch (e) {
    // fail silently - we only need to create it if it doesn't already exist
  }
  // we use fs directly here rather than the capsule.fs because there are some edge cases
  // that the capusle fs does not deal with well (eg. identifying and deleting
  // a symlink rather than the what the symlink links to)
  _fsExtra().default.removeSync(bitLegacyPath);
  (0, _createSymlinkOrCopy().default)(localBitLegacyPath, bitLegacyPath);
}

//# sourceMappingURL=package-manager-legacy.js.map