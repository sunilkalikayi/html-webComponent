import { AspectLoaderMain } from '@teambit/aspect-loader';
import { ComponentMap } from '@teambit/component';
import { DependencyResolverMain } from '@teambit/dependency-resolver';
import { Logger } from '@teambit/logger';
import { PeerDependencyRules, ProjectManifest } from '@pnpm/types';
import { PackageManager, PackageManagerInstallOptions, PackageImportMethod } from './package-manager';
import { WorkspacePolicy } from './policy';
export declare type InstallArgs = {
    rootDir: string | undefined;
    rootPolicy: WorkspacePolicy;
    componentDirectoryMap: ComponentMap<string>;
    options: InstallOptions;
    packageManagerOptions: PackageManagerInstallOptions;
};
export declare type InstallOptions = {
    installTeambitBit: boolean;
    packageManagerConfigRootDir?: string;
};
export declare type GetComponentManifestsOptions = {
    componentDirectoryMap: ComponentMap<string>;
    rootPolicy: WorkspacePolicy;
    rootDir: string;
} & Pick<PackageManagerInstallOptions, 'dedupe' | 'dependencyFilterFn' | 'copyPeerToRuntimeOnComponents' | 'copyPeerToRuntimeOnRoot' | 'installPeersFromEnvs'>;
export declare type PreInstallSubscriber = (installer: DependencyInstaller, installArgs: InstallArgs) => Promise<void>;
export declare type PreInstallSubscriberList = Array<PreInstallSubscriber>;
export declare type PostInstallSubscriber = (installer: DependencyInstaller, installArgs: InstallArgs) => Promise<void>;
export declare type PostInstallSubscriberList = Array<PostInstallSubscriber>;
export declare class DependencyInstaller {
    /**
     * package manager instance.
     */
    private packageManager;
    private aspectLoader;
    private logger;
    private dependencyResolver;
    private rootDir?;
    private cacheRootDir?;
    private preInstallSubscriberList?;
    private postInstallSubscriberList?;
    private nodeLinker?;
    private packageImportMethod?;
    private sideEffectsCache?;
    private nodeVersion?;
    private engineStrict?;
    private peerDependencyRules?;
    constructor(
    /**
     * package manager instance.
     */
    packageManager: PackageManager, aspectLoader: AspectLoaderMain, logger: Logger, dependencyResolver: DependencyResolverMain, rootDir?: string | undefined, cacheRootDir?: string | undefined, preInstallSubscriberList?: PreInstallSubscriberList | undefined, postInstallSubscriberList?: PostInstallSubscriberList | undefined, nodeLinker?: "hoisted" | "isolated" | undefined, packageImportMethod?: PackageImportMethod | undefined, sideEffectsCache?: boolean | undefined, nodeVersion?: string | undefined, engineStrict?: boolean | undefined, peerDependencyRules?: PeerDependencyRules | undefined);
    install(rootDir: string | undefined, rootPolicy: WorkspacePolicy, componentDirectoryMap: ComponentMap<string>, options?: InstallOptions, packageManagerOptions?: PackageManagerInstallOptions): Promise<ComponentMap<string>>;
    installComponents(rootDir: string | undefined, manifests: Record<string, ProjectManifest>, rootPolicy: WorkspacePolicy, componentDirectoryMap: ComponentMap<string>, options?: InstallOptions, packageManagerOptions?: PackageManagerInstallOptions): Promise<ComponentMap<string>>;
    /**
     * Compute all the component manifests (a.k.a. package.json files) that should be passed to the package manager
     * in order to install the dependencies.
     */
    getComponentManifests({ componentDirectoryMap, rootPolicy, rootDir, dedupe, dependencyFilterFn, copyPeerToRuntimeOnComponents, copyPeerToRuntimeOnRoot, installPeersFromEnvs, }: GetComponentManifestsOptions): Promise<Record<string, ProjectManifest>>;
    private cleanCompsNodeModules;
    private runPrePostSubscribers;
}
