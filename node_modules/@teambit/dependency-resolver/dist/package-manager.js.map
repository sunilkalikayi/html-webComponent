{"version":3,"names":[],"sources":["package-manager.ts"],"sourcesContent":["import { PeerDependencyIssuesByProjects } from '@pnpm/core';\nimport { PeerDependencyRules, ProjectManifest } from '@pnpm/types';\nimport { ComponentMap } from '@teambit/component';\nimport { Registries } from './registry';\nimport { DepsFilterFn } from './manifest';\nimport { NetworkConfig, ProxyConfig } from './dependency-resolver.main.runtime';\n\nexport { PeerDependencyIssuesByProjects };\n\nexport type PackageImportMethod = 'auto' | 'hardlink' | 'copy' | 'clone';\n\nexport type PackageManagerInstallOptions = {\n  cacheRootDir?: string;\n  /**\n   * decide whether to dedup dependencies.\n   */\n  dedupe?: boolean;\n\n  copyPeerToRuntimeOnRoot?: boolean;\n\n  copyPeerToRuntimeOnComponents?: boolean;\n\n  installPeersFromEnvs?: boolean;\n\n  dependencyFilterFn?: DepsFilterFn;\n\n  overrides?: Record<string, string>;\n\n  nodeLinker?: 'hoisted' | 'isolated';\n\n  packageManagerConfigRootDir?: string;\n\n  packageImportMethod?: PackageImportMethod;\n\n  rootComponents?: boolean;\n\n  rootComponentsForCapsules?: boolean;\n\n  useNesting?: boolean;\n\n  keepExistingModulesDir?: boolean;\n\n  sideEffectsCache?: boolean;\n\n  engineStrict?: boolean;\n\n  nodeVersion?: string;\n\n  peerDependencyRules?: PeerDependencyRules;\n};\n\nexport type PackageManagerGetPeerDependencyIssuesOptions = PackageManagerInstallOptions;\n\nexport type ResolvedPackageVersion = {\n  packageName: string;\n  version: string | null;\n  isSemver: boolean;\n  resolvedVia?: string;\n};\n\nexport type PackageManagerResolveRemoteVersionOptions = {\n  rootDir: string;\n  cacheRootDir?: string;\n  packageManagerConfigRootDir?: string;\n  // fetchToCache?: boolean;\n  // update?: boolean;\n};\n\nexport interface InstallationContext {\n  rootDir: string;\n  manifests: Record<string, ProjectManifest>;\n  componentDirectoryMap: ComponentMap<string>;\n}\n\nexport interface PackageManager {\n  /**\n   * install dependencies\n   * @param componentDirectoryMap\n   */\n  install(context: InstallationContext, options: PackageManagerInstallOptions): Promise<void>;\n\n  resolveRemoteVersion(\n    packageName: string,\n    options: PackageManagerResolveRemoteVersionOptions\n  ): Promise<ResolvedPackageVersion>;\n\n  getPeerDependencyIssues?(\n    rootDir: string,\n    manifests: Record<string, ProjectManifest>,\n    options: PackageManagerGetPeerDependencyIssuesOptions\n  ): Promise<PeerDependencyIssuesByProjects>;\n\n  getInjectedDirs?(rootDir: string, componentDir: string, packageName: string): Promise<string[]>;\n\n  getRegistries?(): Promise<Registries>;\n\n  getProxyConfig?(): Promise<ProxyConfig>;\n\n  getNetworkConfig?(): Promise<NetworkConfig>;\n\n  /**\n   * Specify if the package manager can be run with deduping on existing worksapce (which already contains root dependencies)\n   * again, with a different context.\n   * If the package manager is not capable of doing so, we want to disable the deduping.\n   */\n  supportsDedupingOnExistingRoot?: () => boolean;\n}\n"],"mappings":";;;;;;;;;;;AAAA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA"}