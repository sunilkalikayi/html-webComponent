"use strict";

require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DependencyList = void 0;
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("./constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _componentDependency() {
  const data = require("./component-dependency");
  _componentDependency = function () {
    return data;
  };
  return data;
}
class DependencyList {
  constructor(_dependencies) {
    this._dependencies = _dependencies;
    this._dependencies = uniqDeps(_dependencies);
  }
  // constructor(private _dependencies: Dependency[]){}

  get dependencies() {
    return this._dependencies;
  }
  sort() {
    const sorted = this.dependencies.sort((a, b) => {
      if (a.id < b.id) {
        return -1;
      }
      if (a.id > b.id) {
        return 1;
      }
      return 0;
    });
    return new DependencyList(sorted);
  }

  /**
   * @param componentIdStr complete string include the scope and the version
   */
  findDependency(componentIdStr, opts = {}) {
    const ignoreVersion = opts.ignoreVersion;
    if (!ignoreVersion) {
      return this.dependencies.find(dep => dep.id === componentIdStr);
    }
    const componentIdStrWithoutVersion = removeVersion(componentIdStr);
    return this.dependencies.find(dep => removeVersion(dep.id) === componentIdStrWithoutVersion);
  }
  findByPkgNameOrCompId(id, version) {
    const found = this.dependencies.find(dep => {
      var _dep$getPackageName;
      return dep.id === id || ((_dep$getPackageName = dep.getPackageName) === null || _dep$getPackageName === void 0 ? void 0 : _dep$getPackageName.call(dep)) === id;
    });
    if (!found) return undefined;
    if (version) {
      return found.version === version ? found : undefined;
    }
    return found;
  }
  forEach(predicate) {
    this.dependencies.forEach(predicate);
  }
  map(predicate) {
    return this.dependencies.map(predicate);
  }
  filter(predicate) {
    const filtered = this.dependencies.filter(predicate);
    return DependencyList.fromArray(filtered);
  }
  toTypeArray(typeName) {
    const list = this.dependencies.filter(dep => dep.type === typeName);
    return list;
  }
  byTypeName(typeName) {
    const filtered = this.dependencies.filter(dep => dep.type === typeName);
    return DependencyList.fromArray(filtered);
  }
  byLifecycle(lifecycle) {
    const filtered = this.dependencies.filter(dep => dep.lifecycle === lifecycle);
    return DependencyList.fromArray(filtered);
  }
  serialize() {
    const serialized = this.dependencies.map(dep => {
      return dep.serialize();
    });
    return serialized;
  }
  getComponentDependencies() {
    return this.dependencies.filter(dep => dep instanceof _componentDependency().ComponentDependency);
  }
  toDependenciesManifest() {
    const manifest = {
      dependencies: {},
      devDependencies: {},
      peerDependencies: {}
    };
    this.forEach(dep => {
      const keyName = _constants().KEY_NAME_BY_LIFECYCLE_TYPE[dep.lifecycle];
      const entry = dep.toManifest();
      if (entry) {
        manifest[keyName][entry.packageName] = entry.version;
      }
    });
    return manifest;
  }
  static merge(lists) {
    const res = [];
    const deps = lists.reduce((acc, curr) => {
      acc = acc.concat(curr.dependencies);
      return acc;
    }, res);
    return new DependencyList(deps);
  }
  static fromArray(dependencies) {
    return new DependencyList(dependencies);
  }
}
exports.DependencyList = DependencyList;
function uniqDeps(dependencies) {
  const uniq = (0, _lodash().uniqBy)(dependencies, (0, _lodash().property)('id'));
  return uniq;
}
function removeVersion(id) {
  if (id.startsWith('@')) return id.split('@')[1]; // scoped package
  return id.split('@')[0];
}

//# sourceMappingURL=dependency-list.js.map