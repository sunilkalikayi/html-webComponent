{"version":3,"names":["DependencyListFactory","constructor","factories","fromSerializedDependencies","serializedDependencies","dependencies","mapSeries","serializedDependency","type","__type","factory","UnknownDepType","dependency","parse","DependencyList","fromLegacyComponent","legacyComponent","lists","Object","values","missingDepsFromModel","getMissingDependenciesByComponentFromModel","push","merge","missingPackages","flatten","issues","getIssue","IssuesClasses","MissingPackagesDependenciesOnFs","data","componentFromModel","length","fromArray","depListFromModel","getDependenciesFromLegacyModelComponent","filteredDepList","filter","dep","packageName","getPackageName","includes","entry","extensions","findCoreExtension","DependencyResolverAspect","id","get"],"sources":["dependency-list-factory.ts"],"sourcesContent":["import mapSeries from 'p-map-series';\nimport { get, flatten } from 'lodash';\nimport LegacyComponent from '@teambit/legacy/dist/consumer/component';\nimport { IssuesClasses } from '@teambit/component-issues';\nimport { DependencyFactory } from './dependency-factory';\nimport { SerializedDependency } from './dependency';\nimport { DependencyList } from './dependency-list';\nimport { UnknownDepType } from './exceptions';\nimport { DependencyResolverAspect } from '../dependency-resolver.aspect';\n\nexport class DependencyListFactory {\n  constructor(private factories: Record<string, DependencyFactory>) {}\n\n  async fromSerializedDependencies(serializedDependencies: SerializedDependency[]): Promise<DependencyList> {\n    const dependencies = await mapSeries(serializedDependencies, async (serializedDependency) => {\n      const type = serializedDependency.__type;\n      const factory = this.factories[type];\n      if (!factory) {\n        throw new UnknownDepType(type);\n      }\n      const dependency = await factory.parse(serializedDependency);\n      return dependency;\n    });\n    return new DependencyList(dependencies);\n  }\n\n  async fromLegacyComponent(legacyComponent: LegacyComponent): Promise<DependencyList> {\n    const lists = await mapSeries(Object.values(this.factories), async (factory) => {\n      if (factory.fromLegacyComponent && typeof factory.fromLegacyComponent === 'function') {\n        return factory.fromLegacyComponent(legacyComponent);\n      }\n      return new DependencyList([]);\n    });\n\n    // This is an important step, see comment for the function to better understand\n    const missingDepsFromModel = await this.getMissingDependenciesByComponentFromModel(legacyComponent);\n    lists.push(missingDepsFromModel);\n    return DependencyList.merge(lists);\n  }\n\n  /**\n   * Some time after importing component (for example), there are required dependencies which are not installed yet, they will consider as missing.\n   * since the installer it self used the calculated deps for installing we need them to be listed as well.\n   * what we do here, is to add deps from the model in case they considered as missing deps in the fs\n   * we don't want just to add all of them since some of them might be removed by the user in the fs (in the source code).\n   * by intersect the missing deps (deps which are still required in source code) with the deps from model we have a list of deps with all the required\n   * data of them\n   * @param legacyComponent\n   */\n  private async getMissingDependenciesByComponentFromModel(legacyComponent: LegacyComponent): Promise<DependencyList> {\n    const missingPackages: string[] = flatten(\n      Object.values(legacyComponent.issues?.getIssue(IssuesClasses.MissingPackagesDependenciesOnFs)?.data || {})\n    );\n    const componentFromModel = legacyComponent.componentFromModel;\n    if (!missingPackages || !missingPackages.length || !componentFromModel) {\n      return DependencyList.fromArray([]);\n    }\n    // All deps defined in model\n    const depListFromModel = await this.getDependenciesFromLegacyModelComponent(componentFromModel);\n    // Only deps from model which are also required in the current component on fs (currently missing)\n    const filteredDepList = depListFromModel.filter((dep) => {\n      const packageName = dep.getPackageName?.();\n      if (!packageName) {\n        return false;\n      }\n      return missingPackages.includes(packageName);\n    });\n    return filteredDepList;\n  }\n\n  /**\n   * Get dependencies based on the component from model attached to the legacy (consumer component)\n   * @param legacyComponent\n   */\n  private async getDependenciesFromLegacyModelComponent(legacyComponent: LegacyComponent): Promise<DependencyList> {\n    const entry = legacyComponent.extensions.findCoreExtension(DependencyResolverAspect.id);\n    if (!entry) {\n      return DependencyList.fromArray([]);\n    }\n    const serializedDependencies: SerializedDependency[] = get(entry, ['data', 'dependencies'], []);\n    return this.fromSerializedDependencies(serializedDependencies);\n  }\n}\n"],"mappings":"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"}