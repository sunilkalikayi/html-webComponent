"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DependencyListFactory = void 0;
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _componentIssues() {
  const data = require("@teambit/component-issues");
  _componentIssues = function () {
    return data;
  };
  return data;
}
function _dependencyList() {
  const data = require("./dependency-list");
  _dependencyList = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("../dependency-resolver.aspect");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
class DependencyListFactory {
  constructor(factories) {
    this.factories = factories;
  }
  async fromSerializedDependencies(serializedDependencies) {
    const dependencies = await (0, _pMapSeries().default)(serializedDependencies, async serializedDependency => {
      const type = serializedDependency.__type;
      const factory = this.factories[type];
      if (!factory) {
        throw new (_exceptions().UnknownDepType)(type);
      }
      const dependency = await factory.parse(serializedDependency);
      return dependency;
    });
    return new (_dependencyList().DependencyList)(dependencies);
  }
  async fromLegacyComponent(legacyComponent) {
    const lists = await (0, _pMapSeries().default)(Object.values(this.factories), async factory => {
      if (factory.fromLegacyComponent && typeof factory.fromLegacyComponent === 'function') {
        return factory.fromLegacyComponent(legacyComponent);
      }
      return new (_dependencyList().DependencyList)([]);
    });

    // This is an important step, see comment for the function to better understand
    const missingDepsFromModel = await this.getMissingDependenciesByComponentFromModel(legacyComponent);
    lists.push(missingDepsFromModel);
    return _dependencyList().DependencyList.merge(lists);
  }

  /**
   * Some time after importing component (for example), there are required dependencies which are not installed yet, they will consider as missing.
   * since the installer it self used the calculated deps for installing we need them to be listed as well.
   * what we do here, is to add deps from the model in case they considered as missing deps in the fs
   * we don't want just to add all of them since some of them might be removed by the user in the fs (in the source code).
   * by intersect the missing deps (deps which are still required in source code) with the deps from model we have a list of deps with all the required
   * data of them
   * @param legacyComponent
   */
  async getMissingDependenciesByComponentFromModel(legacyComponent) {
    var _legacyComponent$issu, _legacyComponent$issu2;
    const missingPackages = (0, _lodash().flatten)(Object.values(((_legacyComponent$issu = legacyComponent.issues) === null || _legacyComponent$issu === void 0 ? void 0 : (_legacyComponent$issu2 = _legacyComponent$issu.getIssue(_componentIssues().IssuesClasses.MissingPackagesDependenciesOnFs)) === null || _legacyComponent$issu2 === void 0 ? void 0 : _legacyComponent$issu2.data) || {}));
    const componentFromModel = legacyComponent.componentFromModel;
    if (!missingPackages || !missingPackages.length || !componentFromModel) {
      return _dependencyList().DependencyList.fromArray([]);
    }
    // All deps defined in model
    const depListFromModel = await this.getDependenciesFromLegacyModelComponent(componentFromModel);
    // Only deps from model which are also required in the current component on fs (currently missing)
    const filteredDepList = depListFromModel.filter(dep => {
      var _dep$getPackageName;
      const packageName = (_dep$getPackageName = dep.getPackageName) === null || _dep$getPackageName === void 0 ? void 0 : _dep$getPackageName.call(dep);
      if (!packageName) {
        return false;
      }
      return missingPackages.includes(packageName);
    });
    return filteredDepList;
  }

  /**
   * Get dependencies based on the component from model attached to the legacy (consumer component)
   * @param legacyComponent
   */
  async getDependenciesFromLegacyModelComponent(legacyComponent) {
    const entry = legacyComponent.extensions.findCoreExtension(_dependencyResolver().DependencyResolverAspect.id);
    if (!entry) {
      return _dependencyList().DependencyList.fromArray([]);
    }
    const serializedDependencies = (0, _lodash().get)(entry, ['data', 'dependencies'], []);
    return this.fromSerializedDependencies(serializedDependencies);
  }
}
exports.DependencyListFactory = DependencyListFactory;

//# sourceMappingURL=dependency-list-factory.js.map