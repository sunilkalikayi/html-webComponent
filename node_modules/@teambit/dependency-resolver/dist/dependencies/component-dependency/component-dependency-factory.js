"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ComponentDependencyFactory = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _componentId() {
  const data = require("@teambit/component-id");
  _componentId = function () {
    return data;
  };
  return data;
}
function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/bit/component-id-to-package-name"));
  _componentIdToPackageName = function () {
    return data;
  };
  return data;
}
function _componentDependency() {
  const data = require("./component-dependency");
  _componentDependency = function () {
    return data;
  };
  return data;
}
function _dependencyList() {
  const data = require("../dependency-list");
  _dependencyList = function () {
    return data;
  };
  return data;
}
// TODO: think about where is the right place to put this
// export class ComponentDependencyFactory implements DependencyFactory<ComponentDependency, SerializedComponentDependency> {
//   parse(serialized: SerializedComponentDependency) {
//     const id = ComponentID.fromObject(serialized.componentId);
//     return new ComponentDependency(id, serialized.id, serialized.version, serialized.type, serialized.lifecycle as DependencyLifecycleType);
//   }
// }

class ComponentDependencyFactory {
  constructor(componentAspect) {
    this.componentAspect = componentAspect;
    (0, _defineProperty2().default)(this, "type", void 0);
    this.type = _componentDependency().TYPE;
  }

  // TODO: solve this generics issue and remove the ts-ignore
  // @ts-ignore
  async parse(serialized) {
    let id;
    if (serialized.componentId.scope) {
      // @ts-ignore - ts is saying scope is possibly missing, but just checked it is defined
      id = _componentId().ComponentID.fromObject(serialized.componentId);
    } else {
      id = await this.componentAspect.getHost().resolveComponentId(serialized.id);
    }
    return new (_componentDependency().ComponentDependency)(id, serialized.isExtension, serialized.packageName, serialized.id, serialized.version, serialized.lifecycle, serialized.source);
  }
  async fromLegacyComponent(legacyComponent) {
    const runtimeDeps = await (0, _pMapSeries().default)(legacyComponent.dependencies.get(), dep => this.transformLegacyComponentDepToSerializedDependency(dep, 'runtime'));
    const devDeps = await (0, _pMapSeries().default)(legacyComponent.devDependencies.get(), dep => this.transformLegacyComponentDepToSerializedDependency(dep, 'dev'));
    const extensionDeps = await (0, _pMapSeries().default)(legacyComponent.extensions, extension => this.transformLegacyComponentExtensionToSerializedDependency(extension, 'dev'));
    const filteredExtensionDeps = (0, _lodash().compact)(extensionDeps);
    const serializedComponentDeps = [...runtimeDeps, ...devDeps, ...filteredExtensionDeps];
    const componentDeps = await (0, _pMapSeries().default)(serializedComponentDeps, dep => this.parse(dep));
    const dependencyList = new (_dependencyList().DependencyList)(componentDeps);
    return dependencyList;
  }
  async transformLegacyComponentDepToSerializedDependency(legacyDep, lifecycle) {
    let packageName = legacyDep.packageName || '';
    if (!packageName) {
      const host = this.componentAspect.getHost();
      const id = await host.resolveComponentId(legacyDep.id);
      const depComponent = await host.get(id);
      if (depComponent) {
        packageName = (0, _componentIdToPackageName().default)(depComponent.state._consumer);
      }
    }
    return {
      id: legacyDep.id.toString(),
      isExtension: false,
      packageName,
      componentId: legacyDep.id.serialize(),
      version: legacyDep.id.getVersion().toString(),
      __type: _componentDependency().TYPE,
      lifecycle
    };
  }
  async transformLegacyComponentExtensionToSerializedDependency(extension, lifecycle) {
    if (!extension.extensionId) {
      return undefined;
    }
    const host = this.componentAspect.getHost();
    const id = await host.resolveComponentId(extension.extensionId);
    const extComponent = await host.get(id);
    let packageName = '';
    if (extComponent) {
      packageName = (0, _componentIdToPackageName().default)(extComponent.state._consumer);
    }
    return {
      id: extension.extensionId.toString(),
      isExtension: true,
      packageName,
      componentId: extension.extensionId.serialize(),
      version: extension.extensionId.getVersion().toString(),
      __type: _componentDependency().TYPE,
      lifecycle
    };
  }
}
exports.ComponentDependencyFactory = ComponentDependencyFactory;

//# sourceMappingURL=component-dependency-factory.js.map