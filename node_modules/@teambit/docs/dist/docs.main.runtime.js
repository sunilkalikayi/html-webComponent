"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DocsMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _compiler() {
  const data = require("@teambit/compiler");
  _compiler = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _pkg() {
  const data = require("@teambit/pkg");
  _pkg = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = require("@teambit/graphql");
  _graphql = function () {
    return data;
  };
  return data;
}
function _preview() {
  const data = require("@teambit/preview");
  _preview = function () {
    return data;
  };
  return data;
}
function _devFiles() {
  const data = _interopRequireDefault(require("@teambit/dev-files"));
  _devFiles = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = require("@teambit/workspace");
  _workspace = function () {
    return data;
  };
  return data;
}
function _docsEntities() {
  const data = require("@teambit/docs.entities.doc");
  _docsEntities = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = require("@teambit/envs");
  _envs = function () {
    return data;
  };
  return data;
}
function _docs() {
  const data = require("./docs.aspect");
  _docs = function () {
    return data;
  };
  return data;
}
function _docs2() {
  const data = require("./docs.preview-definition");
  _docs2 = function () {
    return data;
  };
  return data;
}
function _docs3() {
  const data = require("./docs.graphql");
  _docs3 = function () {
    return data;
  };
  return data;
}
function _defaultDocReader() {
  const data = require("./default-doc-reader");
  _defaultDocReader = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
/**
 * the component documentation extension.
 */
class DocsMain {
  constructor(patterns,
  /**
   * envs extension.
   */
  preview, pkg, compiler, workspace, logger, devFiles, envs, docPropSlot, docReaderSlot) {
    this.patterns = patterns;
    this.preview = preview;
    this.pkg = pkg;
    this.compiler = compiler;
    this.workspace = workspace;
    this.logger = logger;
    this.devFiles = devFiles;
    this.envs = envs;
    this.docPropSlot = docPropSlot;
    this.docReaderSlot = docReaderSlot;
  }

  /**
   * returns an array of doc file paths for a set of components.
   */
  getDocsMap(components) {
    return _component().ComponentMap.as(components, component => {
      return this.getDocsFiles(component);
    });
  }
  getDocsFiles(component) {
    const devFiles = this.devFiles.computeDevFiles(component);
    const docFiles = devFiles.get(_docs().DocsAspect.id);
    return component.state.filesystem.files.filter(file => docFiles.includes(file.relative));
  }

  /**
   * compute the description of the component from its source code and docs file.
   */
  async getDescription(component) {
    var _consumerComponent$do;
    const componentDoc = this.getDoc(component);
    const desc = componentDoc === null || componentDoc === void 0 ? void 0 : componentDoc.description;
    if (desc) return desc;
    const consumerComponent = component.state._consumer;
    const fromJsDocs = (_consumerComponent$do = consumerComponent.docs) === null || _consumerComponent$do === void 0 ? void 0 : _consumerComponent$do.find(doc => doc.description);
    return (fromJsDocs === null || fromJsDocs === void 0 ? void 0 : fromJsDocs.description) || '';
  }
  async getTemplate(env) {
    return env.getDocsTemplate();
  }
  getDocReader(extension) {
    return this.docReaderSlot.values().find(docReader => docReader.isFormatSupported(extension));
  }

  /**
   * compute a doc for a component.
   */
  async computeDoc(component) {
    const docFiles = this.getDocsFiles(component);
    if (docFiles.length) {
      // currently taking the the first docs file found with an abstract. (we support only one)
      const docFile = docFiles[0];
      try {
        const docReader = this.getDocReader(docFile.extname);
        if (!docReader) throw new (_exceptions().FileExtensionNotSupported)(docFile.relative, docFile.extname);
        const doc = await docReader.read(docFile.relative, docFile.contents, component);
        return doc;
      } catch (err) {
        // it's ok to fail here.
        this.logger.debug(`docs.main.runtime.computeDoc caught an error: ${err.message}`);
        return null;
      }
    }
    return null;
  }
  getDoc(component) {
    var _component$get, _component$get$data;
    const docData = (_component$get = component.get(_docs().DocsAspect.id)) === null || _component$get === void 0 ? void 0 : (_component$get$data = _component$get.data) === null || _component$get$data === void 0 ? void 0 : _component$get$data.doc;
    if (!docData) return null;
    return new (_docsEntities().Doc)(docData.filePath, new (_docsEntities().DocPropList)(docData.props));
  }
  getPatterns() {
    return this.patterns;
  }
  getComponentDevPatterns(component) {
    const env = this.envs.calculateEnv(component).env;
    const componentEnvDocsDevPatterns = env.getDocsDevPatterns ? env.getDocsDevPatterns(component) : [];
    const componentPatterns = componentEnvDocsDevPatterns.concat(this.getPatterns());
    return componentPatterns;
  }
  getDevPatternToRegister() {
    return this.getComponentDevPatterns.bind(this);
  }
  /**
   * register a new doc reader. this allows to support further
   * documentation file formats.
   */
  registerDocReader(docReader) {
    this.docReaderSlot.register(docReader);
    return this;
  }
  static async provider([preview, graphql, workspace, pkg, compiler, loggerAspect, devFiles, envs], config, [docPropSlot, docReaderSlot]) {
    const logger = loggerAspect.createLogger(_docs().DocsAspect.id);
    const docs = new DocsMain(config.patterns, preview, pkg, compiler, workspace, logger, devFiles, envs, docPropSlot, docReaderSlot);
    docs.registerDocReader(new (_defaultDocReader().DefaultDocReader)(pkg, compiler, workspace));
    devFiles.registerDevPattern(docs.getDevPatternToRegister());
    if (workspace) {
      workspace.onComponentLoad(async (component, opts) => {
        if ((opts === null || opts === void 0 ? void 0 : opts.loadDocs) === false) return undefined;
        const doc = await docs.computeDoc(component);
        return {
          doc: doc === null || doc === void 0 ? void 0 : doc.toObject()
        };
      });
    }
    graphql.register((0, _docs3().docsSchema)(docs));
    preview.registerDefinition(new (_docs2().DocsPreviewDefinition)(docs));
    return docs;
  }
}
exports.DocsMain = DocsMain;
(0, _defineProperty2().default)(DocsMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(DocsMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(DocsMain, "dependencies", [_preview().PreviewAspect, _graphql().GraphqlAspect, _workspace().WorkspaceAspect, _pkg().PkgAspect, _compiler().CompilerAspect, _logger().LoggerAspect, _devFiles().default, _envs().EnvsAspect]);
(0, _defineProperty2().default)(DocsMain, "defaultConfig", {
  patterns: ['**/*.docs.*']
});
_docs().DocsAspect.addRuntime(DocsMain);

//# sourceMappingURL=docs.main.runtime.js.map