import { AspectLoaderMain } from '@teambit/aspect-loader';
import { Component, ComponentID } from '@teambit/component';
import type { ComponentMain, ComponentFactory } from '@teambit/component';
import { GraphMain } from '@teambit/graph';
import { DependencyResolverMain, LinkingOptions } from '@teambit/dependency-resolver';
import { Logger, LoggerMain } from '@teambit/logger';
import { BitIds } from '@teambit/legacy/dist/bit-id';
import LegacyScope from '@teambit/legacy/dist/scope/scope';
import { GlobalConfigMain } from '@teambit/global-config';
import { PathOsBasedAbsolute } from '@teambit/legacy/dist/utils/path';
import { Scope } from '@teambit/legacy/dist/scope';
import DataToPersist from '@teambit/legacy/dist/consumer/component/sources/data-to-persist';
import { Capsule } from './capsule';
import { Network } from './network';
export declare type ListResults = {
    workspace: string;
    capsules: string[];
};
export declare type IsolateComponentsInstallOptions = {
    installPackages?: boolean;
    dedupe?: boolean;
    copyPeerToRuntimeOnComponents?: boolean;
    copyPeerToRuntimeOnRoot?: boolean;
    installPeersFromEnvs?: boolean;
    installTeambitBit?: boolean;
    packageManagerConfigRootDir?: string;
    useNesting?: boolean;
};
declare type CreateGraphOptions = {
    /**
     * include components that exists in nested hosts. for example include components that exist in scope but not in the workspace
     */
    includeFromNestedHosts?: boolean;
    /**
     * Force specific host to get the component from.
     */
    host?: ComponentFactory;
};
export declare type IsolateComponentsOptions = CreateGraphOptions & {
    name?: string;
    /**
     * absolute path to put all the capsules dirs inside.
     */
    rootBaseDir?: string;
    /**
     * the capsule root-dir based on a *hash* of this baseDir, not on the baseDir itself.
     * A folder with this hash as its name will be created in the rootBaseDir
     * By default this value will be the host path
     */
    baseDir?: string;
    /**
     * create a new capsule with a random string attached to the path suffix
     */
    alwaysNew?: boolean;
    /**
     * installation options
     */
    installOptions?: IsolateComponentsInstallOptions;
    linkingOptions?: LinkingOptions;
    /**
     * delete the capsule rootDir first. it makes sure that the isolation process starts fresh with
     * no previous capsules. for build and tag this is true.
     */
    emptyRootDir?: boolean;
    /**
     * skip the reproduction of the capsule in case it exists.
     */
    skipIfExists?: boolean;
    /**
     * get existing capsule without doing any changes, no writes, no installations.
     */
    getExistingAsIs?: boolean;
    /**
     * place the package-manager cache on the capsule-root
     */
    cachePackagesOnCapsulesRoot?: boolean;
    /**
     * do not build graph with all dependencies. isolate the seeders only.
     */
    seedersOnly?: boolean;
    /**
     * Force specific host to get the component from.
     */
    host?: ComponentFactory;
    packageManagerConfigRootDir?: string;
};
export declare class IsolatorMain {
    private dependencyResolver;
    private logger;
    private componentAspect;
    private graph;
    private globalConfig;
    private aspectLoader;
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: import("@teambit/harmony").Aspect[];
    static defaultConfig: {};
    _componentsPackagesVersionCache: {
        [idStr: string]: string;
    };
    static provider([dependencyResolver, loggerExtension, componentAspect, graphMain, globalConfig, aspectLoader]: [
        DependencyResolverMain,
        LoggerMain,
        ComponentMain,
        GraphMain,
        GlobalConfigMain,
        AspectLoaderMain
    ]): Promise<IsolatorMain>;
    constructor(dependencyResolver: DependencyResolverMain, logger: Logger, componentAspect: ComponentMain, graph: GraphMain, globalConfig: GlobalConfigMain, aspectLoader: AspectLoaderMain);
    isolateComponents(seeders: ComponentID[], opts?: IsolateComponentsOptions, legacyScope?: LegacyScope): Promise<Network>;
    private createGraph;
    /**
     *
     * @param originalCapsule the capsule that contains the original component
     * @param newBaseDir relative path. (it will be saved inside `this.getRootDirOfAllCapsules()`. the final path of the capsule will be getRootDirOfAllCapsules() + newBaseDir + filenameify(component.id))
     * @returns a new capsule with the same content of the original capsule but with a new baseDir and all packages
     * installed in the newBaseDir.
     */
    cloneCapsule(originalCapsule: Capsule, newBaseDir: string): Promise<Capsule>;
    /**
     * Create capsules for the provided components
     * do not use this outside directly, use isolate components which build the entire network
     * @param components
     * @param opts
     * @param legacyScope
     */
    private createCapsules;
    private installInCapsules;
    private linkInCapsules;
    private getCapsulesWithModifiedPackageJson;
    private writeComponentsInCapsules;
    private getWorkspacePeersOnlyPolicy;
    private toComponentMap;
    list(workspacePath: string): Promise<ListResults>;
    getCapsulesRootDir(baseDir: string, rootBaseDir?: string): PathOsBasedAbsolute;
    deleteCapsules(capsuleBaseDir: string | null): Promise<string>;
    private createCapsulesFromComponents;
    private getRootDirOfAllCapsules;
    private wereDependenciesInPackageJsonChanged;
    private getCapsulesPreviousPackageJson;
    private updateWithCurrentPackageJsonData;
    private getCurrentPackageJson;
    populateComponentsFilesToWriteForCapsule(component: Component, ids: BitIds, legacyScope?: Scope): Promise<DataToPersist>;
    private preparePackageJsonToWrite;
    /**
     * currently, it writes all artifacts.
     * later, this responsibility might move to pkg extension, which could write only artifacts
     * that are set in package.json.files[], to have a similar structure of a package.
     */
    private getArtifacts;
}
export {};
