"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _anyFs() {
  const data = require("@teambit/any-fs");
  _anyFs = function () {
    return data;
  };
  return data;
}
function _execa() {
  const data = _interopRequireDefault(require("execa"));
  _execa = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _containerExec() {
  const data = _interopRequireDefault(require("./container-exec"));
  _containerExec = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const debug = require('debug')('fs-container');
class FsContainer {
  constructor(wrkDir) {
    this.wrkDir = wrkDir;
    (0, _defineProperty2().default)(this, "id", 'FS Container');
    (0, _defineProperty2().default)(this, "fs", new (_anyFs().NodeFS)(this.wrkDir));
  }

  // TODO: do we need this?
  getPath() {
    return this.wrkDir;
  }
  composePath(pathToCompose) {
    return path().join(this.getPath(), pathToCompose);
  }
  outputFile(file, data, options) {
    const filePath = this.composePath(file);
    debug(`writing file on ${filePath}`);
    return _fsExtra().default.outputFile(filePath, data, options);
  }
  removePath(dir) {
    const pathToRemove = this.composePath(dir);
    return _fsExtra().default.remove(pathToRemove);
  }
  async symlink(src, dest) {
    const srcPath = this.composePath(src);
    const destPath = this.composePath(dest);
    await _fsExtra().default.ensureDir(path().dirname(destPath));
    return _fsExtra().default.ensureSymlink(srcPath, destPath);
  }
  async exec(execOptions, exec = new (_containerExec().default)()) {
    var _subprocessP$stderr, _subprocessP$stdout;
    const cwd = execOptions.cwd ? this.composePath(execOptions.cwd) : this.getPath();
    debug(`executing the following command: ${execOptions.command.join(' ')}, on cwd: ${cwd}`);
    const subprocessP = _execa().default.command(execOptions.command.join(' '), {
      shell: true,
      cwd,
      stdio: ['ipc']
    });

    // @TODO: FIX! This probably causes errors ad the promise is not handled properly!
    // eslint-disable-next-line @typescript-eslint/no-floating-promises
    subprocessP.on('message', function (msg) {
      exec.emit('message', msg);
    });
    /* eslint-disable @typescript-eslint/no-non-null-assertion */
    (_subprocessP$stderr = subprocessP.stderr) === null || _subprocessP$stderr === void 0 ? void 0 : _subprocessP$stderr.pipe(exec.stderr);
    (_subprocessP$stdout = subprocessP.stdout) === null || _subprocessP$stdout === void 0 ? void 0 : _subprocessP$stdout.pipe(exec.stdout);
    ['close', 'exit'].forEach(function (eventName) {
      // @TODO: FIX! This probably causes errors ad the promise is not handled properly!
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      subprocessP.on(eventName, function (statusCode) {
        exec.setStatus(statusCode);
      });
    });
    return exec;
  }
  async execP(execOptions) {
    let hasError = false;
    const exec = await this.exec(execOptions);
    return new Promise((resolve, reject) => {
      exec.stdout.on('error', () => {
        hasError = true;
      });
      exec.on('close', () => {
        if (hasError) reject(exec.stderr.getContents(exec.stderr.size).toString());
        resolve(exec.stdout.getContents(exec.stdout.size).toString());
      });
    });
  }
  async terminal() {
    const cwd = this.getPath();
    return _execa().default.command(process.env.SHELL || '/bin/zsh', {
      cwd,
      stdio: 'inherit'
    });
  }
  start() {
    return _fsExtra().default.ensureDir(this.wrkDir);
  }
  // @ts-ignore
  async inspect() {
    // todo: probably not needed for this container
  }
  async pause() {
    // do nothing
  }
  async resume() {
    // do nothing
  }
  // eslint-disable-next-line
  stop(ttl) {
    return _fsExtra().default.remove(this.wrkDir);
  }
  async destroy() {
    await this.stop();
  }
  log() {
    throw new Error('Method not implemented.');
  }
  on(event, fn) {
    return fn(event);
    // throw new Error('Method not implemented.');
  }
}
exports.default = FsContainer;

//# sourceMappingURL=container.js.map