{"version":3,"names":["DEFAULT_ISOLATE_INSTALL_OPTIONS","installPackages","dedupe","installPeersFromEnvs","copyPeerToRuntimeOnComponents","copyPeerToRuntimeOnRoot","IsolatorMain","provider","dependencyResolver","loggerExtension","componentAspect","graphMain","globalConfig","aspectLoader","logger","createLogger","IsolatorAspect","id","isolator","constructor","graph","isolateComponents","seeders","opts","legacyScope","host","getHost","debug","join","JSON","stringify","Object","assign","name","createGraphOpts","pick","componentsToIsolate","seedersOnly","getMany","createGraph","length","seedersWithVersions","map","seeder","_legacy","hasVersion","comp","find","component","isEqual","ignoreVersion","Error","toString","baseDir","path","capsuleList","createCapsules","capsuleDir","getCapsulesRootDir","rootBaseDir","Network","getGraphOpts","getGraph","successorsSubgraph","compsAndDeps","nodes","node","attr","existingCompsP","c","existing","includeFromNestedHosts","hasIdNested","hasId","undefined","existingComps","Promise","all","compact","cloneCapsule","originalCapsule","newBaseDir","network","clonedCapsule","seedersCapsules","fs","copy","components","installOptions","useNesting","hasRootComponents","emptyRootDir","supportsDedupingOnExistingRoot","config","capsulesDir","emptyDir","capsules","createCapsulesFromComponents","allCapsuleList","CapsuleList","fromArray","getExistingAsIs","skipIfExists","existingCapsules","filter","capsule","existsSync","capsulesWithPackagesData","getCapsulesPreviousPackageJson","writeComponentsInCapsules","updateWithCurrentPackageJsonData","cachePackagesOnCapsulesRoot","linkingOptions","newCapsuleList","installInCapsules","linkInCapsules","rootDir","forEach","capsuleWithPackageData","currentPackageJson","writeFileSync","PACKAGE_JSON","isolateInstallOptions","installer","getInstaller","cacheRootDirectory","peerOnlyPolicy","getWorkspacePeersOnlyPolicy","installTeambitBit","packageManagerConfigRootDir","packageManagerInstallOptions","overrides","capsulesOverrides","rootComponentsForCapsules","keepExistingModulesDir","install","toComponentMap","linker","getLinker","capsulesWithModifiedPackageJson","getCapsulesWithModifiedPackageJson","link","legacyLink","linkNestedDepsInNM","symlinkOnCapsuleRoot","symlinkDependenciesToCapsules","coreAspectIds","getCoreAspectIds","coreAspectCapsules","compIdWithoutVersion","split","includes","symlinkBitLegacyToCapsules","packageJsonHasChanged","wereDependenciesInPackageJsonChanged","modifiedComps","unmodifiedComps","isModified","buildStatus","push","legacyUnmodifiedComps","state","_consumer","clone","legacyModifiedComps","legacyComponents","importMultipleDistsArtifacts","allIds","BitIds","getCapsule","scope","dataToPersist","populateComponentsFilesToWriteForCapsule","persistAllToCapsule","keepExistingCapsule","workspacePolicy","getWorkspacePolicy","byLifecycleType","tuples","ComponentMap","create","list","workspacePath","workspaceCapsuleFolder","readdir","capsuleFullPaths","workspace","e","code","capsulesRootBaseDir","getRootDirOfAllCapsules","hash","deleteCapsules","capsuleBaseDir","dirToDelete","remove","Capsule","createFromComponent","getGlobalCapsulesBaseDir","previousPackageJson","DEPENDENCIES_FIELDS","some","field","equals","packageJsonPath","previousPackageJsonRaw","promises","readFile","encoding","parse","packageJson","getCurrentPackageJson","found","packageJsonObject","currentVersion","getComponentPackageVersion","getComponentDepsManifest","dependencies","manifest","devDependencies","compDeps","toTypeArray","dep","depCapsule","componentId","version","snapToSemver","keyName","KEY_NAME_BY_LIFECYCLE_TYPE","lifecycle","entry","toManifest","packageName","deps","getDependencies","PackageJsonFile","loadFromCapsuleSync","addDependencies","packageJsonFile","addDevDependencies","addOrUpdateProperty","ids","legacyComp","DataToPersist","clonedFiles","files","file","writeToPath","updatePaths","newBase","removePath","RemovePath","addFile","preparePackageJsonToWrite","semver","inc","PackageJsonTransformer","applyTransformers","valuesToMerge","componentOverridesPackageJsonData","mergePackageJsonObject","toVinylFile","artifacts","getArtifacts","addManyFiles","bitDir","ignoreBitDependencies","getBitDependencies","reduce","acc","depId","Array","isArray","searchWithoutVersion","packageDependency","componentIdToPackageName","isDependency","bitDependencies","getAllIds","bitDevDependencies","bitExtensionDependencies","extensions","extensionsBitIds","main","pathNormalizeToLinux","mainFile","extensionsNamesForArtifacts","artifactsFiles","flatten","extName","getArtifactFilesByExtension","artifactsVinylFlattened","artifactFiles","ArtifactFiles","deserializeArtifactFiles","vinylFiles","getVinylsAndImportIfMissing","artifactsDir","writtenPath","a","MainRuntime","DependencyResolverAspect","LoggerAspect","ComponentAspect","GraphAspect","GlobalConfigAspect","AspectLoaderAspect","addRuntime"],"sources":["isolator.main.runtime.ts"],"sourcesContent":["import { MainRuntime } from '@teambit/cli';\nimport semver from 'semver';\nimport { compact, flatten, pick } from 'lodash';\nimport { AspectLoaderMain, AspectLoaderAspect } from '@teambit/aspect-loader';\nimport { Component, ComponentMap, ComponentAspect, ComponentID } from '@teambit/component';\nimport type { ComponentMain, ComponentFactory } from '@teambit/component';\nimport { getComponentPackageVersion, snapToSemver } from '@teambit/component-package-version';\nimport { GraphAspect, GraphMain } from '@teambit/graph';\nimport {\n  DependencyResolverAspect,\n  DependencyResolverMain,\n  LinkingOptions,\n  WorkspacePolicy,\n  InstallOptions,\n  DependencyList,\n  ComponentDependency,\n  KEY_NAME_BY_LIFECYCLE_TYPE,\n  PackageManagerInstallOptions,\n} from '@teambit/dependency-resolver';\nimport { Logger, LoggerAspect, LoggerMain } from '@teambit/logger';\nimport { BitId, BitIds } from '@teambit/legacy/dist/bit-id';\nimport LegacyScope from '@teambit/legacy/dist/scope/scope';\nimport GlobalConfigAspect, { GlobalConfigMain } from '@teambit/global-config';\nimport { DEPENDENCIES_FIELDS, PACKAGE_JSON } from '@teambit/legacy/dist/constants';\nimport ConsumerComponent from '@teambit/legacy/dist/consumer/component';\nimport PackageJsonFile from '@teambit/legacy/dist/consumer/component/package-json-file';\nimport {\n  ArtifactFiles,\n  deserializeArtifactFiles,\n  getArtifactFilesByExtension,\n  importMultipleDistsArtifacts,\n} from '@teambit/legacy/dist/consumer/component/sources/artifact-files';\nimport { pathNormalizeToLinux, PathOsBasedAbsolute } from '@teambit/legacy/dist/utils/path';\nimport { Scope } from '@teambit/legacy/dist/scope';\nimport fs from 'fs-extra';\nimport hash from 'object-hash';\nimport path from 'path';\nimport equals from 'ramda/src/equals';\nimport DataToPersist from '@teambit/legacy/dist/consumer/component/sources/data-to-persist';\nimport RemovePath from '@teambit/legacy/dist/consumer/component/sources/remove-path';\nimport { PackageJsonTransformer } from '@teambit/legacy/dist/consumer/component/package-json-transformer';\nimport { AbstractVinyl } from '@teambit/legacy/dist/consumer/component/sources';\nimport { ArtifactVinyl } from '@teambit/legacy/dist/consumer/component/sources/artifact';\nimport componentIdToPackageName from '@teambit/legacy/dist/utils/bit/component-id-to-package-name';\nimport { Capsule } from './capsule';\nimport CapsuleList from './capsule-list';\nimport { IsolatorAspect } from './isolator.aspect';\nimport { symlinkBitLegacyToCapsules } from './symlink-bit-legacy-to-capsules';\nimport { symlinkOnCapsuleRoot, symlinkDependenciesToCapsules } from './symlink-dependencies-to-capsules';\nimport { Network } from './network';\n\nexport type ListResults = {\n  workspace: string;\n  capsules: string[];\n};\n\nexport type IsolateComponentsInstallOptions = {\n  installPackages?: boolean; // default: true\n  // TODO: add back when depResolver.getInstaller support it\n  // packageManager?: string;\n  dedupe?: boolean;\n  copyPeerToRuntimeOnComponents?: boolean;\n  copyPeerToRuntimeOnRoot?: boolean;\n  installPeersFromEnvs?: boolean;\n  installTeambitBit?: boolean;\n  packageManagerConfigRootDir?: string;\n  // When set to true, the newly added components will be grouped inside one directory.\n  // This is useful for scope aspect capsules, which are installed in stages.\n  useNesting?: boolean;\n};\n\ntype CreateGraphOptions = {\n  /**\n   * include components that exists in nested hosts. for example include components that exist in scope but not in the workspace\n   */\n  includeFromNestedHosts?: boolean;\n\n  /**\n   * Force specific host to get the component from.\n   */\n  host?: ComponentFactory;\n};\n\nexport type IsolateComponentsOptions = CreateGraphOptions & {\n  name?: string;\n  /**\n   * absolute path to put all the capsules dirs inside.\n   */\n  rootBaseDir?: string;\n\n  /**\n   * the capsule root-dir based on a *hash* of this baseDir, not on the baseDir itself.\n   * A folder with this hash as its name will be created in the rootBaseDir\n   * By default this value will be the host path\n   */\n  baseDir?: string;\n\n  /**\n   * create a new capsule with a random string attached to the path suffix\n   */\n  alwaysNew?: boolean;\n\n  /**\n   * installation options\n   */\n  installOptions?: IsolateComponentsInstallOptions;\n\n  linkingOptions?: LinkingOptions;\n\n  /**\n   * delete the capsule rootDir first. it makes sure that the isolation process starts fresh with\n   * no previous capsules. for build and tag this is true.\n   */\n  emptyRootDir?: boolean;\n\n  /**\n   * skip the reproduction of the capsule in case it exists.\n   */\n  skipIfExists?: boolean;\n\n  /**\n   * get existing capsule without doing any changes, no writes, no installations.\n   */\n  getExistingAsIs?: boolean;\n\n  /**\n   * place the package-manager cache on the capsule-root\n   */\n  cachePackagesOnCapsulesRoot?: boolean;\n\n  /**\n   * do not build graph with all dependencies. isolate the seeders only.\n   */\n  seedersOnly?: boolean;\n\n  /**\n   * Force specific host to get the component from.\n   */\n  host?: ComponentFactory;\n\n  packageManagerConfigRootDir?: string;\n};\n\ntype CapsulePackageJsonData = {\n  capsule: Capsule;\n  currentPackageJson?: Record<string, any>;\n  previousPackageJson: Record<string, any> | null;\n};\n\nconst DEFAULT_ISOLATE_INSTALL_OPTIONS: IsolateComponentsInstallOptions = {\n  installPackages: true,\n  dedupe: true,\n  installPeersFromEnvs: true,\n  copyPeerToRuntimeOnComponents: false,\n  copyPeerToRuntimeOnRoot: true,\n};\n\nexport class IsolatorMain {\n  static runtime = MainRuntime;\n  static dependencies = [\n    DependencyResolverAspect,\n    LoggerAspect,\n    ComponentAspect,\n    GraphAspect,\n    GlobalConfigAspect,\n    AspectLoaderAspect,\n  ];\n  static defaultConfig = {};\n  _componentsPackagesVersionCache: { [idStr: string]: string } = {}; // cache packages versions of components\n\n  static async provider([dependencyResolver, loggerExtension, componentAspect, graphMain, globalConfig, aspectLoader]: [\n    DependencyResolverMain,\n    LoggerMain,\n    ComponentMain,\n    GraphMain,\n    GlobalConfigMain,\n    AspectLoaderMain\n  ]): Promise<IsolatorMain> {\n    const logger = loggerExtension.createLogger(IsolatorAspect.id);\n    const isolator = new IsolatorMain(\n      dependencyResolver,\n      logger,\n      componentAspect,\n      graphMain,\n      globalConfig,\n      aspectLoader\n    );\n    return isolator;\n  }\n  constructor(\n    private dependencyResolver: DependencyResolverMain,\n    private logger: Logger,\n    private componentAspect: ComponentMain,\n    private graph: GraphMain,\n    private globalConfig: GlobalConfigMain,\n    private aspectLoader: AspectLoaderMain\n  ) {}\n\n  // TODO: the legacy scope used for the component writer, which then decide if it need to write the artifacts and dists\n  // TODO: we should think of another way to provide it (maybe a new opts) then take the scope internally from the host\n  async isolateComponents(\n    seeders: ComponentID[],\n    opts: IsolateComponentsOptions = {},\n    legacyScope?: LegacyScope\n  ): Promise<Network> {\n    const host = this.componentAspect.getHost();\n    this.logger.debug(\n      `isolateComponents, ${seeders.join(', ')}. opts: ${JSON.stringify(\n        Object.assign({}, opts, { host: opts.host?.name })\n      )}`\n    );\n    const createGraphOpts = pick(opts, ['includeFromNestedHosts', 'host']);\n    const componentsToIsolate = opts.seedersOnly\n      ? await host.getMany(seeders)\n      : await this.createGraph(seeders, createGraphOpts);\n    this.logger.debug(`isolateComponents, total componentsToIsolate: ${componentsToIsolate.length}`);\n    const seedersWithVersions = seeders.map((seeder) => {\n      if (seeder._legacy.hasVersion()) return seeder;\n      const comp = componentsToIsolate.find((component) => component.id.isEqual(seeder, { ignoreVersion: true }));\n      if (!comp) throw new Error(`unable to find seeder ${seeder.toString()} in componentsToIsolate`);\n      return comp.id;\n    });\n    opts.baseDir = opts.baseDir || host.path;\n    const capsuleList = await this.createCapsules(componentsToIsolate, opts, legacyScope);\n    const capsuleDir = this.getCapsulesRootDir(opts.baseDir, opts.rootBaseDir);\n    this.logger.debug(\n      `creating network with base dir: ${opts.baseDir}, rootBaseDir: ${opts.rootBaseDir}. final capsule-dir: ${capsuleDir}. capsuleList: ${capsuleList.length}`\n    );\n    return new Network(capsuleList, seedersWithVersions, capsuleDir);\n  }\n\n  private async createGraph(seeders: ComponentID[], opts: CreateGraphOptions = {}): Promise<Component[]> {\n    const host = this.componentAspect.getHost();\n    const getGraphOpts = pick(opts, ['host']);\n    const graph = await this.graph.getGraph(seeders, getGraphOpts);\n    const successorsSubgraph = graph.successorsSubgraph(seeders.map((id) => id.toString()));\n    const compsAndDeps = successorsSubgraph.nodes.map((node) => node.attr);\n    // do not ignore the version here. a component might be in .bitmap with one version and\n    // installed as a package with another version. we don't want them both.\n    const existingCompsP = compsAndDeps.map(async (c) => {\n      let existing;\n      if (opts.includeFromNestedHosts) {\n        existing = await host.hasIdNested(c.id, true);\n      } else {\n        existing = await host.hasId(c.id);\n      }\n      if (existing) return c;\n      return undefined;\n    });\n    const existingComps = await Promise.all(existingCompsP);\n    return compact(existingComps);\n  }\n\n  /**\n   *\n   * @param originalCapsule the capsule that contains the original component\n   * @param newBaseDir relative path. (it will be saved inside `this.getRootDirOfAllCapsules()`. the final path of the capsule will be getRootDirOfAllCapsules() + newBaseDir + filenameify(component.id))\n   * @returns a new capsule with the same content of the original capsule but with a new baseDir and all packages\n   * installed in the newBaseDir.\n   */\n  async cloneCapsule(originalCapsule: Capsule, newBaseDir: string): Promise<Capsule> {\n    const network = await this.isolateComponents([originalCapsule.component.id], { baseDir: newBaseDir });\n    const clonedCapsule = network.seedersCapsules[0];\n    await fs.copy(originalCapsule.path, clonedCapsule.path);\n    return clonedCapsule;\n  }\n\n  /**\n   * Create capsules for the provided components\n   * do not use this outside directly, use isolate components which build the entire network\n   * @param components\n   * @param opts\n   * @param legacyScope\n   */\n  private async createCapsules(\n    components: Component[],\n    opts: IsolateComponentsOptions,\n    legacyScope?: Scope\n  ): Promise<CapsuleList> {\n    this.logger.debug(`createCapsules, ${components.length} components`);\n    const installOptions = {\n      ...DEFAULT_ISOLATE_INSTALL_OPTIONS,\n      ...opts.installOptions,\n      useNesting: this.dependencyResolver.hasRootComponents() && opts.installOptions?.useNesting,\n    };\n    if (!opts.emptyRootDir) {\n      installOptions.dedupe = installOptions.dedupe && this.dependencyResolver.supportsDedupingOnExistingRoot();\n    }\n    const config = { installPackages: true, ...opts };\n    const capsulesDir = this.getCapsulesRootDir(opts.baseDir as string, opts.rootBaseDir);\n    if (opts.emptyRootDir) {\n      await fs.emptyDir(capsulesDir);\n    }\n    let capsules = await this.createCapsulesFromComponents(components, capsulesDir, config);\n    const allCapsuleList = CapsuleList.fromArray(capsules);\n    let capsuleList = allCapsuleList;\n    if (opts.getExistingAsIs) {\n      return capsuleList;\n    }\n\n    if (opts.skipIfExists) {\n      if (!installOptions.useNesting) {\n        const existingCapsules = CapsuleList.fromArray(\n          capsuleList.filter((capsule) => capsule.fs.existsSync('package.json'))\n        );\n\n        if (existingCapsules.length === capsuleList.length) return existingCapsules;\n      } else {\n        capsules = capsules.filter((capsule) => !capsule.fs.existsSync('package.json'));\n        capsuleList = CapsuleList.fromArray(capsules);\n      }\n    }\n    const capsulesWithPackagesData = await this.getCapsulesPreviousPackageJson(capsules);\n\n    await this.writeComponentsInCapsules(components, capsuleList, legacyScope);\n    await this.updateWithCurrentPackageJsonData(capsulesWithPackagesData, capsuleList);\n    if (installOptions.installPackages) {\n      const cachePackagesOnCapsulesRoot = opts.cachePackagesOnCapsulesRoot ?? false;\n      const linkingOptions = opts.linkingOptions ?? {};\n      if (installOptions.useNesting) {\n        await Promise.all(\n          capsuleList.map(async (capsule) => {\n            const newCapsuleList = CapsuleList.fromArray([capsule]);\n            await this.installInCapsules(capsule.path, newCapsuleList, installOptions, cachePackagesOnCapsulesRoot);\n            await this.linkInCapsules(capsulesDir, newCapsuleList, capsulesWithPackagesData, linkingOptions);\n          })\n        );\n      } else {\n        // When nesting is used, the first component (which is the entry component) is installed in the root\n        // and all other components (which are the dependencies of the entry component) are installed in\n        // a subdirectory.\n        const rootDir = installOptions?.useNesting ? capsuleList[0].path : capsulesDir;\n        await this.installInCapsules(rootDir, capsuleList, installOptions, cachePackagesOnCapsulesRoot);\n        await this.linkInCapsules(capsulesDir, capsuleList, capsulesWithPackagesData, linkingOptions);\n      }\n    }\n\n    // rewrite the package-json with the component dependencies in it. the original package.json\n    // that was written before, didn't have these dependencies in order for the package-manager to\n    // be able to install them without crushing when the versions don't exist yet\n    capsulesWithPackagesData.forEach((capsuleWithPackageData) => {\n      const { currentPackageJson, capsule } = capsuleWithPackageData;\n      if (!currentPackageJson)\n        throw new Error(\n          `isolator.createCapsules, unable to find currentPackageJson for ${capsule.component.id.toString()}`\n        );\n      capsuleWithPackageData.capsule.fs.writeFileSync(PACKAGE_JSON, JSON.stringify(currentPackageJson, null, 2));\n    });\n\n    return allCapsuleList;\n  }\n\n  private async installInCapsules(\n    capsulesDir: string,\n    capsuleList: CapsuleList,\n    isolateInstallOptions: IsolateComponentsInstallOptions,\n    cachePackagesOnCapsulesRoot?: boolean\n  ) {\n    const installer = this.dependencyResolver.getInstaller({\n      rootDir: capsulesDir,\n      cacheRootDirectory: cachePackagesOnCapsulesRoot ? capsulesDir : undefined,\n    });\n    // When using isolator we don't want to use the policy defined in the workspace directly,\n    // we only want to instal deps from components and the peer from the workspace\n\n    const peerOnlyPolicy = this.getWorkspacePeersOnlyPolicy();\n    const installOptions: InstallOptions = {\n      installTeambitBit: !!isolateInstallOptions.installTeambitBit,\n      packageManagerConfigRootDir: isolateInstallOptions.packageManagerConfigRootDir,\n    };\n\n    const packageManagerInstallOptions: PackageManagerInstallOptions = {\n      dedupe: isolateInstallOptions.dedupe,\n      copyPeerToRuntimeOnComponents: isolateInstallOptions.copyPeerToRuntimeOnComponents,\n      copyPeerToRuntimeOnRoot: isolateInstallOptions.copyPeerToRuntimeOnRoot,\n      installPeersFromEnvs: isolateInstallOptions.installPeersFromEnvs,\n      overrides: this.dependencyResolver.config.capsulesOverrides || this.dependencyResolver.config.overrides,\n      rootComponentsForCapsules: this.dependencyResolver.hasRootComponents(),\n      useNesting: isolateInstallOptions.useNesting,\n      keepExistingModulesDir: this.dependencyResolver.hasRootComponents(),\n    };\n    await installer.install(\n      capsulesDir,\n      peerOnlyPolicy,\n      this.toComponentMap(capsuleList),\n      installOptions,\n      packageManagerInstallOptions\n    );\n  }\n\n  private async linkInCapsules(\n    capsulesDir: string,\n    capsuleList: CapsuleList,\n    capsulesWithPackagesData: CapsulePackageJsonData[],\n    linkingOptions: LinkingOptions\n  ) {\n    const linker = this.dependencyResolver.getLinker({\n      rootDir: capsulesDir,\n      linkingOptions,\n    });\n    const peerOnlyPolicy = this.getWorkspacePeersOnlyPolicy();\n    const capsulesWithModifiedPackageJson = this.getCapsulesWithModifiedPackageJson(capsulesWithPackagesData);\n    await linker.link(capsulesDir, peerOnlyPolicy, this.toComponentMap(capsuleList), {\n      ...linkingOptions,\n      legacyLink: false,\n      linkNestedDepsInNM: !this.dependencyResolver.hasRootComponents() && linkingOptions.linkNestedDepsInNM,\n    });\n    if (!this.dependencyResolver.hasRootComponents()) {\n      await symlinkOnCapsuleRoot(capsuleList, this.logger, capsulesDir);\n      await symlinkDependenciesToCapsules(capsulesWithModifiedPackageJson, capsuleList, this.logger);\n    } else {\n      const coreAspectIds = this.aspectLoader.getCoreAspectIds();\n      const coreAspectCapsules = CapsuleList.fromArray(\n        capsuleList.filter((capsule) => {\n          const [compIdWithoutVersion] = capsule.component.id.toString().split('@');\n          return coreAspectIds.includes(compIdWithoutVersion);\n        })\n      );\n      await symlinkOnCapsuleRoot(coreAspectCapsules, this.logger, capsulesDir);\n    }\n    // TODO: this is a hack to have access to the bit bin project in order to access core extensions from user extension\n    // TODO: remove this after exporting core extensions as components\n    await symlinkBitLegacyToCapsules(capsulesWithModifiedPackageJson, this.logger);\n    // await copyBitLegacyToCapsuleRoot(capsulesDir, this.logger);\n  }\n\n  private getCapsulesWithModifiedPackageJson(capsulesWithPackagesData: CapsulePackageJsonData[]) {\n    const capsulesWithModifiedPackageJson: Capsule[] = capsulesWithPackagesData\n      .filter((capsuleWithPackageData) => {\n        const packageJsonHasChanged = this.wereDependenciesInPackageJsonChanged(capsuleWithPackageData);\n        // @todo: when a component is tagged, it changes all package-json of its dependents, but it\n        // should not trigger any \"npm install\" because they dependencies are symlinked by us\n        return packageJsonHasChanged;\n      })\n      .map((capsuleWithPackageData) => capsuleWithPackageData.capsule);\n    return capsulesWithModifiedPackageJson;\n  }\n\n  private async writeComponentsInCapsules(components: Component[], capsuleList: CapsuleList, legacyScope?: Scope) {\n    const modifiedComps: Component[] = [];\n    const unmodifiedComps: Component[] = [];\n    await Promise.all(\n      components.map(async (component) => {\n        const isModified = await component.isModified();\n        if (!isModified && component.buildStatus === 'succeed') {\n          // the \"component.buildStatus\" check is important for \"bit sign\" when on lane to not go to the original scope\n          unmodifiedComps.push(component);\n        } else {\n          modifiedComps.push(component);\n        }\n      })\n    );\n    const legacyUnmodifiedComps = unmodifiedComps.map((component) => component.state._consumer.clone());\n    const legacyModifiedComps = modifiedComps.map((component) => component.state._consumer.clone());\n    const legacyComponents = [...legacyUnmodifiedComps, ...legacyModifiedComps];\n    if (legacyScope && unmodifiedComps.length) await importMultipleDistsArtifacts(legacyScope, legacyUnmodifiedComps);\n    const allIds = BitIds.fromArray(legacyComponents.map((c) => c.id));\n    await Promise.all(\n      components.map(async (component) => {\n        const capsule = capsuleList.getCapsule(component.id);\n        if (!capsule) return;\n        const scope = (await component.isModified()) ? undefined : legacyScope;\n        const dataToPersist = await this.populateComponentsFilesToWriteForCapsule(component, allIds, scope);\n        await dataToPersist.persistAllToCapsule(capsule, { keepExistingCapsule: true });\n      })\n    );\n  }\n\n  private getWorkspacePeersOnlyPolicy(): WorkspacePolicy {\n    const workspacePolicy = this.dependencyResolver.getWorkspacePolicy();\n    const peerOnlyPolicy = workspacePolicy.byLifecycleType('peer');\n    return peerOnlyPolicy;\n  }\n\n  private toComponentMap(capsuleList: CapsuleList): ComponentMap<string> {\n    const tuples: [Component, string][] = capsuleList.map((capsule) => {\n      return [capsule.component, capsule.path];\n    });\n\n    return ComponentMap.create(tuples);\n  }\n\n  async list(workspacePath: string): Promise<ListResults> {\n    try {\n      const workspaceCapsuleFolder = this.getCapsulesRootDir(workspacePath);\n      const capsules = await fs.readdir(workspaceCapsuleFolder);\n      const capsuleFullPaths = capsules.map((c) => path.join(workspaceCapsuleFolder, c));\n      return {\n        workspace: workspacePath,\n        capsules: capsuleFullPaths,\n      };\n    } catch (e: any) {\n      if (e.code === 'ENOENT') {\n        return { workspace: workspacePath, capsules: [] };\n      }\n      throw e;\n    }\n  }\n\n  getCapsulesRootDir(baseDir: string, rootBaseDir?: string): PathOsBasedAbsolute {\n    const capsulesRootBaseDir = rootBaseDir || this.getRootDirOfAllCapsules();\n    return path.join(capsulesRootBaseDir, hash(baseDir));\n  }\n\n  async deleteCapsules(capsuleBaseDir: string | null): Promise<string> {\n    const dirToDelete = capsuleBaseDir ? this.getCapsulesRootDir(capsuleBaseDir) : this.getRootDirOfAllCapsules();\n    await fs.remove(dirToDelete);\n    return dirToDelete;\n  }\n\n  private async createCapsulesFromComponents(\n    components: Component[],\n    baseDir: string,\n    opts: IsolateComponentsOptions\n  ): Promise<Capsule[]> {\n    this.logger.debug(`createCapsulesFromComponents: ${components.length} components`);\n    const capsules: Capsule[] = await Promise.all(\n      components.map((component: Component) => {\n        return Capsule.createFromComponent(component, baseDir, opts);\n      })\n    );\n    return capsules;\n  }\n\n  private getRootDirOfAllCapsules(): string {\n    return this.globalConfig.getGlobalCapsulesBaseDir();\n  }\n\n  private wereDependenciesInPackageJsonChanged(capsuleWithPackageData: CapsulePackageJsonData): boolean {\n    const { previousPackageJson, currentPackageJson } = capsuleWithPackageData;\n    if (!previousPackageJson) return true;\n    // @ts-ignore at this point, currentPackageJson is set\n    return DEPENDENCIES_FIELDS.some((field) => !equals(previousPackageJson[field], currentPackageJson[field]));\n  }\n\n  private async getCapsulesPreviousPackageJson(capsules: Capsule[]): Promise<CapsulePackageJsonData[]> {\n    return Promise.all(\n      capsules.map(async (capsule) => {\n        const packageJsonPath = path.join(capsule.path, 'package.json');\n        let previousPackageJson: any = null;\n        try {\n          const previousPackageJsonRaw = await capsule.fs.promises.readFile(packageJsonPath, { encoding: 'utf8' });\n          previousPackageJson = JSON.parse(previousPackageJsonRaw);\n        } catch (e: any) {\n          // package-json doesn't exist in the capsule, that's fine, it'll be considered as a cache miss\n        }\n        return {\n          capsule,\n          previousPackageJson,\n        };\n      })\n    );\n  }\n\n  private async updateWithCurrentPackageJsonData(\n    capsulesWithPackagesData: CapsulePackageJsonData[],\n    capsules: CapsuleList\n  ) {\n    return Promise.all(\n      capsules.map(async (capsule) => {\n        const packageJson = await this.getCurrentPackageJson(capsule, capsules);\n        const found = capsulesWithPackagesData.filter((c) => c.capsule.component.id.isEqual(capsule.component.id));\n        if (!found.length) throw new Error(`updateWithCurrentPackageJsonData unable to find ${capsule.component.id}`);\n        if (found.length > 1)\n          throw new Error(\n            `updateWithCurrentPackageJsonData found duplicate capsules: ${capsule.component.id.toString()}\"\"`\n          );\n        found[0].currentPackageJson = packageJson.packageJsonObject;\n      })\n    );\n  }\n\n  private async getCurrentPackageJson(capsule: Capsule, capsules: CapsuleList): Promise<PackageJsonFile> {\n    const component: Component = capsule.component;\n    const currentVersion = getComponentPackageVersion(component);\n    const getComponentDepsManifest = async (dependencies: DependencyList) => {\n      const manifest = {\n        dependencies: {},\n        devDependencies: {},\n      };\n      const compDeps = dependencies.toTypeArray<ComponentDependency>('component');\n      const promises = compDeps.map(async (dep) => {\n        const depCapsule = capsules.getCapsule(dep.componentId);\n        let version = dep.version;\n        if (depCapsule) {\n          version = getComponentPackageVersion(depCapsule?.component);\n        } else {\n          version = snapToSemver(version);\n        }\n        const keyName = KEY_NAME_BY_LIFECYCLE_TYPE[dep.lifecycle];\n        const entry = dep.toManifest();\n        if (entry) {\n          manifest[keyName][entry.packageName] = version;\n        }\n      });\n      await Promise.all(promises);\n      return manifest;\n    };\n    const deps = await this.dependencyResolver.getDependencies(component);\n    const manifest = await getComponentDepsManifest(deps);\n\n    // component.packageJsonFile is not available here. we don't mutate the component object for capsules.\n    // also, don't use `PackageJsonFile.createFromComponent`, as it looses the intermediate changes\n    // such as postInstall scripts for custom-module-resolution.\n    const packageJson = PackageJsonFile.loadFromCapsuleSync(capsule.path);\n\n    const addDependencies = (packageJsonFile: PackageJsonFile) => {\n      packageJsonFile.addDependencies(manifest.dependencies);\n      packageJsonFile.addDevDependencies(manifest.devDependencies);\n    };\n    addDependencies(packageJson);\n    packageJson.addOrUpdateProperty('version', currentVersion);\n    return packageJson;\n  }\n\n  async populateComponentsFilesToWriteForCapsule(\n    component: Component,\n    ids: BitIds,\n    legacyScope?: Scope\n  ): Promise<DataToPersist> {\n    const legacyComp: ConsumerComponent = component.state._consumer;\n    const dataToPersist = new DataToPersist();\n    const clonedFiles = legacyComp.files.map((file) => file.clone());\n    const writeToPath = '.';\n    clonedFiles.forEach((file) => file.updatePaths({ newBase: writeToPath }));\n    dataToPersist.removePath(new RemovePath(writeToPath));\n    clonedFiles.map((file) => dataToPersist.addFile(file));\n    const packageJson = this.preparePackageJsonToWrite(\n      component,\n      writeToPath,\n      ids // this.ignoreBitDependencies,\n    );\n    if (!legacyComp.id.hasVersion()) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      packageJson.addOrUpdateProperty('version', semver.inc(legacyComp.version!, 'prerelease') || '0.0.1-0');\n    }\n    await PackageJsonTransformer.applyTransformers(legacyComp, packageJson);\n    const valuesToMerge = legacyComp.overrides.componentOverridesPackageJsonData;\n    packageJson.mergePackageJsonObject(valuesToMerge);\n    dataToPersist.addFile(packageJson.toVinylFile());\n    const artifacts = await this.getArtifacts(legacyComp, legacyScope);\n    dataToPersist.addManyFiles(artifacts);\n    return dataToPersist;\n  }\n\n  private preparePackageJsonToWrite(\n    component: Component,\n    bitDir: string,\n    ignoreBitDependencies: BitIds | boolean = true\n  ): PackageJsonFile {\n    const legacyComp: ConsumerComponent = component.state._consumer;\n    this.logger.debug(`package-json.preparePackageJsonToWrite. bitDir ${bitDir}.`);\n    const getBitDependencies = (dependencies: BitIds) => {\n      if (ignoreBitDependencies === true) return {};\n      return dependencies.reduce((acc, depId: BitId) => {\n        if (Array.isArray(ignoreBitDependencies) && ignoreBitDependencies.searchWithoutVersion(depId)) return acc;\n        const packageDependency = depId.version;\n        const packageName = componentIdToPackageName({\n          ...legacyComp,\n          id: depId,\n          isDependency: true,\n        });\n        acc[packageName] = packageDependency;\n        return acc;\n      }, {});\n    };\n    const bitDependencies = getBitDependencies(legacyComp.dependencies.getAllIds());\n    const bitDevDependencies = getBitDependencies(legacyComp.devDependencies.getAllIds());\n    const bitExtensionDependencies = getBitDependencies(legacyComp.extensions.extensionsBitIds);\n    const packageJson = PackageJsonFile.createFromComponent(bitDir, legacyComp, true);\n    const main = pathNormalizeToLinux(legacyComp.mainFile);\n    packageJson.addOrUpdateProperty('main', main);\n    const addDependencies = (packageJsonFile: PackageJsonFile) => {\n      packageJsonFile.addDependencies(bitDependencies);\n      packageJsonFile.addDevDependencies({\n        ...bitDevDependencies,\n        ...bitExtensionDependencies,\n      });\n    };\n    addDependencies(packageJson);\n    const currentVersion = getComponentPackageVersion(component);\n    packageJson.addOrUpdateProperty('version', currentVersion);\n\n    return packageJson;\n  }\n\n  /**\n   * currently, it writes all artifacts.\n   * later, this responsibility might move to pkg extension, which could write only artifacts\n   * that are set in package.json.files[], to have a similar structure of a package.\n   */\n  private async getArtifacts(component: ConsumerComponent, legacyScope?: Scope): Promise<AbstractVinyl[]> {\n    if (!legacyScope) {\n      // when capsules are written via the workspace, do not write artifacts, they get created by\n      // build-pipeline. when capsules are written via the scope, we do need the dists.\n      return [];\n    }\n    if (component.buildStatus !== 'succeed') {\n      // this is important for \"bit sign\" when on lane to not go to the original scope\n      return [];\n    }\n    const extensionsNamesForArtifacts = ['teambit.compilation/compiler'];\n    const artifactsFiles = flatten(\n      extensionsNamesForArtifacts.map((extName) => getArtifactFilesByExtension(component.extensions, extName))\n    );\n    const artifactsVinylFlattened: ArtifactVinyl[] = [];\n    await Promise.all(\n      artifactsFiles.map(async (artifactFiles) => {\n        if (!artifactFiles) return;\n        if (!(artifactFiles instanceof ArtifactFiles)) {\n          artifactFiles = deserializeArtifactFiles(artifactFiles);\n        }\n        // fyi, if this is coming from the isolator aspect, it is optimized to import all at once.\n        // see artifact-files.importMultipleDistsArtifacts().\n        const vinylFiles = await artifactFiles.getVinylsAndImportIfMissing(component.id, legacyScope);\n        artifactsVinylFlattened.push(...vinylFiles);\n      })\n    );\n    const artifactsDir = component.writtenPath;\n    if (artifactsDir) {\n      artifactsVinylFlattened.forEach((a) => a.updatePaths({ newBase: artifactsDir }));\n    }\n    return artifactsVinylFlattened;\n  }\n}\n\nIsolatorAspect.addRuntime(IsolatorMain);\n"],"mappings":"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"}