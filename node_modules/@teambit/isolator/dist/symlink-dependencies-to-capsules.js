"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.symlinkDependenciesToCapsules = symlinkDependenciesToCapsules;
exports.symlinkOnCapsuleRoot = symlinkOnCapsuleRoot;
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _symlink() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/links/symlink"));
  _symlink = function () {
    return data;
  };
  return data;
}
function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/bit/component-id-to-package-name"));
  _componentIdToPackageName = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
async function symlinkDependenciesToCapsules(capsules, capsuleList, logger) {
  logger.debug(`symlinkDependenciesToCapsules, ${capsules.length} capsules`);
  await Promise.all(capsules.map(capsule => {
    return symlinkComponent(capsule.component.state._consumer, capsuleList, logger);
  }));
}
async function symlinkOnCapsuleRoot(capsuleList, logger, capsuleRoot) {
  const modulesPath = _path().default.join(capsuleRoot, 'node_modules');
  const symlinks = capsuleList.map(capsule => {
    const packageName = (0, _componentIdToPackageName().default)(capsule.component.state._consumer);
    const dest = _path().default.join(modulesPath, packageName);
    const src = _path().default.relative(_path().default.resolve(dest, '..'), capsule.path);
    return new (_symlink().default)(src, dest, capsule.component.id._legacy);
  });
  await Promise.all(symlinks.map(symlink => symlink.write()));
}
async function symlinkComponent(component, capsuleList, logger) {
  const componentCapsule = capsuleList.getCapsuleIgnoreScopeAndVersion(new (_component().ComponentID)(component.id));
  if (!componentCapsule) throw new Error(`unable to find the capsule for ${component.id.toString()}`);
  const allDeps = component.getAllDependenciesIds();
  const symlinks = allDeps.map(depId => {
    // TODO: this is dangerous - we might have 2 capsules for the same component with different version, then we might link to the wrong place
    const devCapsule = capsuleList.getCapsuleIgnoreScopeAndVersion(new (_component().ComponentID)(depId));
    if (!devCapsule) {
      // happens when a dependency is not in the workspace. (it gets installed via the package manager)
      logger.debug(`symlinkComponentToCapsule: unable to find the capsule for ${depId.toStringWithoutVersion()}. skipping`);
      return null;
    }
    const packageName = (0, _componentIdToPackageName().default)(devCapsule.component.state._consumer);
    const devCapsulePath = devCapsule.path;
    // @todo: this is a hack, the capsule should be the one responsible to symlink, this works only for FS capsules.
    const dest = _path().default.join(componentCapsule.path, 'node_modules', packageName);
    // use relative symlink in capsules to make it really isolated from the machine fs
    const src = _path().default.relative(_path().default.resolve(dest, '..'), devCapsulePath);
    return new (_symlink().default)(src, dest, component.id);
  });
  await Promise.all(symlinks.map(symlink => symlink && symlink.write()));
}

//# sourceMappingURL=symlink-dependencies-to-capsules.js.map