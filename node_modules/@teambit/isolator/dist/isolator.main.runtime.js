"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IsolatorMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _semver() {
  const data = _interopRequireDefault(require("semver"));
  _semver = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _aspectLoader() {
  const data = require("@teambit/aspect-loader");
  _aspectLoader = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _componentPackageVersion() {
  const data = require("@teambit/component-package-version");
  _componentPackageVersion = function () {
    return data;
  };
  return data;
}
function _graph() {
  const data = require("@teambit/graph");
  _graph = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _globalConfig() {
  const data = _interopRequireDefault(require("@teambit/global-config"));
  _globalConfig = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _packageJsonFile() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/package-json-file"));
  _packageJsonFile = function () {
    return data;
  };
  return data;
}
function _artifactFiles() {
  const data = require("@teambit/legacy/dist/consumer/component/sources/artifact-files");
  _artifactFiles = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("@teambit/legacy/dist/utils/path");
  _path = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _objectHash() {
  const data = _interopRequireDefault(require("object-hash"));
  _objectHash = function () {
    return data;
  };
  return data;
}
function _path2() {
  const data = _interopRequireDefault(require("path"));
  _path2 = function () {
    return data;
  };
  return data;
}
function _equals() {
  const data = _interopRequireDefault(require("ramda/src/equals"));
  _equals = function () {
    return data;
  };
  return data;
}
function _dataToPersist() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/sources/data-to-persist"));
  _dataToPersist = function () {
    return data;
  };
  return data;
}
function _removePath() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/sources/remove-path"));
  _removePath = function () {
    return data;
  };
  return data;
}
function _packageJsonTransformer() {
  const data = require("@teambit/legacy/dist/consumer/component/package-json-transformer");
  _packageJsonTransformer = function () {
    return data;
  };
  return data;
}
function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/bit/component-id-to-package-name"));
  _componentIdToPackageName = function () {
    return data;
  };
  return data;
}
function _capsule() {
  const data = require("./capsule");
  _capsule = function () {
    return data;
  };
  return data;
}
function _capsuleList() {
  const data = _interopRequireDefault(require("./capsule-list"));
  _capsuleList = function () {
    return data;
  };
  return data;
}
function _isolator() {
  const data = require("./isolator.aspect");
  _isolator = function () {
    return data;
  };
  return data;
}
function _symlinkBitLegacyToCapsules() {
  const data = require("./symlink-bit-legacy-to-capsules");
  _symlinkBitLegacyToCapsules = function () {
    return data;
  };
  return data;
}
function _symlinkDependenciesToCapsules() {
  const data = require("./symlink-dependencies-to-capsules");
  _symlinkDependenciesToCapsules = function () {
    return data;
  };
  return data;
}
function _network() {
  const data = require("./network");
  _network = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const DEFAULT_ISOLATE_INSTALL_OPTIONS = {
  installPackages: true,
  dedupe: true,
  installPeersFromEnvs: true,
  copyPeerToRuntimeOnComponents: false,
  copyPeerToRuntimeOnRoot: true
};
class IsolatorMain {
  // cache packages versions of components

  static async provider([dependencyResolver, loggerExtension, componentAspect, graphMain, globalConfig, aspectLoader]) {
    const logger = loggerExtension.createLogger(_isolator().IsolatorAspect.id);
    const isolator = new IsolatorMain(dependencyResolver, logger, componentAspect, graphMain, globalConfig, aspectLoader);
    return isolator;
  }
  constructor(dependencyResolver, logger, componentAspect, graph, globalConfig, aspectLoader) {
    this.dependencyResolver = dependencyResolver;
    this.logger = logger;
    this.componentAspect = componentAspect;
    this.graph = graph;
    this.globalConfig = globalConfig;
    this.aspectLoader = aspectLoader;
    (0, _defineProperty2().default)(this, "_componentsPackagesVersionCache", {});
  }

  // TODO: the legacy scope used for the component writer, which then decide if it need to write the artifacts and dists
  // TODO: we should think of another way to provide it (maybe a new opts) then take the scope internally from the host
  async isolateComponents(seeders, opts = {}, legacyScope) {
    var _opts$host;
    const host = this.componentAspect.getHost();
    this.logger.debug(`isolateComponents, ${seeders.join(', ')}. opts: ${JSON.stringify(Object.assign({}, opts, {
      host: (_opts$host = opts.host) === null || _opts$host === void 0 ? void 0 : _opts$host.name
    }))}`);
    const createGraphOpts = (0, _lodash().pick)(opts, ['includeFromNestedHosts', 'host']);
    const componentsToIsolate = opts.seedersOnly ? await host.getMany(seeders) : await this.createGraph(seeders, createGraphOpts);
    this.logger.debug(`isolateComponents, total componentsToIsolate: ${componentsToIsolate.length}`);
    const seedersWithVersions = seeders.map(seeder => {
      if (seeder._legacy.hasVersion()) return seeder;
      const comp = componentsToIsolate.find(component => component.id.isEqual(seeder, {
        ignoreVersion: true
      }));
      if (!comp) throw new Error(`unable to find seeder ${seeder.toString()} in componentsToIsolate`);
      return comp.id;
    });
    opts.baseDir = opts.baseDir || host.path;
    const capsuleList = await this.createCapsules(componentsToIsolate, opts, legacyScope);
    const capsuleDir = this.getCapsulesRootDir(opts.baseDir, opts.rootBaseDir);
    this.logger.debug(`creating network with base dir: ${opts.baseDir}, rootBaseDir: ${opts.rootBaseDir}. final capsule-dir: ${capsuleDir}. capsuleList: ${capsuleList.length}`);
    return new (_network().Network)(capsuleList, seedersWithVersions, capsuleDir);
  }
  async createGraph(seeders, opts = {}) {
    const host = this.componentAspect.getHost();
    const getGraphOpts = (0, _lodash().pick)(opts, ['host']);
    const graph = await this.graph.getGraph(seeders, getGraphOpts);
    const successorsSubgraph = graph.successorsSubgraph(seeders.map(id => id.toString()));
    const compsAndDeps = successorsSubgraph.nodes.map(node => node.attr);
    // do not ignore the version here. a component might be in .bitmap with one version and
    // installed as a package with another version. we don't want them both.
    const existingCompsP = compsAndDeps.map(async c => {
      let existing;
      if (opts.includeFromNestedHosts) {
        existing = await host.hasIdNested(c.id, true);
      } else {
        existing = await host.hasId(c.id);
      }
      if (existing) return c;
      return undefined;
    });
    const existingComps = await Promise.all(existingCompsP);
    return (0, _lodash().compact)(existingComps);
  }

  /**
   *
   * @param originalCapsule the capsule that contains the original component
   * @param newBaseDir relative path. (it will be saved inside `this.getRootDirOfAllCapsules()`. the final path of the capsule will be getRootDirOfAllCapsules() + newBaseDir + filenameify(component.id))
   * @returns a new capsule with the same content of the original capsule but with a new baseDir and all packages
   * installed in the newBaseDir.
   */
  async cloneCapsule(originalCapsule, newBaseDir) {
    const network = await this.isolateComponents([originalCapsule.component.id], {
      baseDir: newBaseDir
    });
    const clonedCapsule = network.seedersCapsules[0];
    await _fsExtra().default.copy(originalCapsule.path, clonedCapsule.path);
    return clonedCapsule;
  }

  /**
   * Create capsules for the provided components
   * do not use this outside directly, use isolate components which build the entire network
   * @param components
   * @param opts
   * @param legacyScope
   */
  async createCapsules(components, opts, legacyScope) {
    var _opts$installOptions;
    this.logger.debug(`createCapsules, ${components.length} components`);
    const installOptions = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_ISOLATE_INSTALL_OPTIONS), opts.installOptions), {}, {
      useNesting: this.dependencyResolver.hasRootComponents() && ((_opts$installOptions = opts.installOptions) === null || _opts$installOptions === void 0 ? void 0 : _opts$installOptions.useNesting)
    });
    if (!opts.emptyRootDir) {
      installOptions.dedupe = installOptions.dedupe && this.dependencyResolver.supportsDedupingOnExistingRoot();
    }
    const config = _objectSpread({
      installPackages: true
    }, opts);
    const capsulesDir = this.getCapsulesRootDir(opts.baseDir, opts.rootBaseDir);
    if (opts.emptyRootDir) {
      await _fsExtra().default.emptyDir(capsulesDir);
    }
    let capsules = await this.createCapsulesFromComponents(components, capsulesDir, config);
    const allCapsuleList = _capsuleList().default.fromArray(capsules);
    let capsuleList = allCapsuleList;
    if (opts.getExistingAsIs) {
      return capsuleList;
    }
    if (opts.skipIfExists) {
      if (!installOptions.useNesting) {
        const existingCapsules = _capsuleList().default.fromArray(capsuleList.filter(capsule => capsule.fs.existsSync('package.json')));
        if (existingCapsules.length === capsuleList.length) return existingCapsules;
      } else {
        capsules = capsules.filter(capsule => !capsule.fs.existsSync('package.json'));
        capsuleList = _capsuleList().default.fromArray(capsules);
      }
    }
    const capsulesWithPackagesData = await this.getCapsulesPreviousPackageJson(capsules);
    await this.writeComponentsInCapsules(components, capsuleList, legacyScope);
    await this.updateWithCurrentPackageJsonData(capsulesWithPackagesData, capsuleList);
    if (installOptions.installPackages) {
      var _opts$cachePackagesOn, _opts$linkingOptions;
      const cachePackagesOnCapsulesRoot = (_opts$cachePackagesOn = opts.cachePackagesOnCapsulesRoot) !== null && _opts$cachePackagesOn !== void 0 ? _opts$cachePackagesOn : false;
      const linkingOptions = (_opts$linkingOptions = opts.linkingOptions) !== null && _opts$linkingOptions !== void 0 ? _opts$linkingOptions : {};
      if (installOptions.useNesting) {
        await Promise.all(capsuleList.map(async capsule => {
          const newCapsuleList = _capsuleList().default.fromArray([capsule]);
          await this.installInCapsules(capsule.path, newCapsuleList, installOptions, cachePackagesOnCapsulesRoot);
          await this.linkInCapsules(capsulesDir, newCapsuleList, capsulesWithPackagesData, linkingOptions);
        }));
      } else {
        // When nesting is used, the first component (which is the entry component) is installed in the root
        // and all other components (which are the dependencies of the entry component) are installed in
        // a subdirectory.
        const rootDir = installOptions !== null && installOptions !== void 0 && installOptions.useNesting ? capsuleList[0].path : capsulesDir;
        await this.installInCapsules(rootDir, capsuleList, installOptions, cachePackagesOnCapsulesRoot);
        await this.linkInCapsules(capsulesDir, capsuleList, capsulesWithPackagesData, linkingOptions);
      }
    }

    // rewrite the package-json with the component dependencies in it. the original package.json
    // that was written before, didn't have these dependencies in order for the package-manager to
    // be able to install them without crushing when the versions don't exist yet
    capsulesWithPackagesData.forEach(capsuleWithPackageData => {
      const {
        currentPackageJson,
        capsule
      } = capsuleWithPackageData;
      if (!currentPackageJson) throw new Error(`isolator.createCapsules, unable to find currentPackageJson for ${capsule.component.id.toString()}`);
      capsuleWithPackageData.capsule.fs.writeFileSync(_constants().PACKAGE_JSON, JSON.stringify(currentPackageJson, null, 2));
    });
    return allCapsuleList;
  }
  async installInCapsules(capsulesDir, capsuleList, isolateInstallOptions, cachePackagesOnCapsulesRoot) {
    const installer = this.dependencyResolver.getInstaller({
      rootDir: capsulesDir,
      cacheRootDirectory: cachePackagesOnCapsulesRoot ? capsulesDir : undefined
    });
    // When using isolator we don't want to use the policy defined in the workspace directly,
    // we only want to instal deps from components and the peer from the workspace

    const peerOnlyPolicy = this.getWorkspacePeersOnlyPolicy();
    const installOptions = {
      installTeambitBit: !!isolateInstallOptions.installTeambitBit,
      packageManagerConfigRootDir: isolateInstallOptions.packageManagerConfigRootDir
    };
    const packageManagerInstallOptions = {
      dedupe: isolateInstallOptions.dedupe,
      copyPeerToRuntimeOnComponents: isolateInstallOptions.copyPeerToRuntimeOnComponents,
      copyPeerToRuntimeOnRoot: isolateInstallOptions.copyPeerToRuntimeOnRoot,
      installPeersFromEnvs: isolateInstallOptions.installPeersFromEnvs,
      overrides: this.dependencyResolver.config.capsulesOverrides || this.dependencyResolver.config.overrides,
      rootComponentsForCapsules: this.dependencyResolver.hasRootComponents(),
      useNesting: isolateInstallOptions.useNesting,
      keepExistingModulesDir: this.dependencyResolver.hasRootComponents()
    };
    await installer.install(capsulesDir, peerOnlyPolicy, this.toComponentMap(capsuleList), installOptions, packageManagerInstallOptions);
  }
  async linkInCapsules(capsulesDir, capsuleList, capsulesWithPackagesData, linkingOptions) {
    const linker = this.dependencyResolver.getLinker({
      rootDir: capsulesDir,
      linkingOptions
    });
    const peerOnlyPolicy = this.getWorkspacePeersOnlyPolicy();
    const capsulesWithModifiedPackageJson = this.getCapsulesWithModifiedPackageJson(capsulesWithPackagesData);
    await linker.link(capsulesDir, peerOnlyPolicy, this.toComponentMap(capsuleList), _objectSpread(_objectSpread({}, linkingOptions), {}, {
      legacyLink: false,
      linkNestedDepsInNM: !this.dependencyResolver.hasRootComponents() && linkingOptions.linkNestedDepsInNM
    }));
    if (!this.dependencyResolver.hasRootComponents()) {
      await (0, _symlinkDependenciesToCapsules().symlinkOnCapsuleRoot)(capsuleList, this.logger, capsulesDir);
      await (0, _symlinkDependenciesToCapsules().symlinkDependenciesToCapsules)(capsulesWithModifiedPackageJson, capsuleList, this.logger);
    } else {
      const coreAspectIds = this.aspectLoader.getCoreAspectIds();
      const coreAspectCapsules = _capsuleList().default.fromArray(capsuleList.filter(capsule => {
        const [compIdWithoutVersion] = capsule.component.id.toString().split('@');
        return coreAspectIds.includes(compIdWithoutVersion);
      }));
      await (0, _symlinkDependenciesToCapsules().symlinkOnCapsuleRoot)(coreAspectCapsules, this.logger, capsulesDir);
    }
    // TODO: this is a hack to have access to the bit bin project in order to access core extensions from user extension
    // TODO: remove this after exporting core extensions as components
    await (0, _symlinkBitLegacyToCapsules().symlinkBitLegacyToCapsules)(capsulesWithModifiedPackageJson, this.logger);
    // await copyBitLegacyToCapsuleRoot(capsulesDir, this.logger);
  }

  getCapsulesWithModifiedPackageJson(capsulesWithPackagesData) {
    const capsulesWithModifiedPackageJson = capsulesWithPackagesData.filter(capsuleWithPackageData => {
      const packageJsonHasChanged = this.wereDependenciesInPackageJsonChanged(capsuleWithPackageData);
      // @todo: when a component is tagged, it changes all package-json of its dependents, but it
      // should not trigger any "npm install" because they dependencies are symlinked by us
      return packageJsonHasChanged;
    }).map(capsuleWithPackageData => capsuleWithPackageData.capsule);
    return capsulesWithModifiedPackageJson;
  }
  async writeComponentsInCapsules(components, capsuleList, legacyScope) {
    const modifiedComps = [];
    const unmodifiedComps = [];
    await Promise.all(components.map(async component => {
      const isModified = await component.isModified();
      if (!isModified && component.buildStatus === 'succeed') {
        // the "component.buildStatus" check is important for "bit sign" when on lane to not go to the original scope
        unmodifiedComps.push(component);
      } else {
        modifiedComps.push(component);
      }
    }));
    const legacyUnmodifiedComps = unmodifiedComps.map(component => component.state._consumer.clone());
    const legacyModifiedComps = modifiedComps.map(component => component.state._consumer.clone());
    const legacyComponents = [...legacyUnmodifiedComps, ...legacyModifiedComps];
    if (legacyScope && unmodifiedComps.length) await (0, _artifactFiles().importMultipleDistsArtifacts)(legacyScope, legacyUnmodifiedComps);
    const allIds = _bitId().BitIds.fromArray(legacyComponents.map(c => c.id));
    await Promise.all(components.map(async component => {
      const capsule = capsuleList.getCapsule(component.id);
      if (!capsule) return;
      const scope = (await component.isModified()) ? undefined : legacyScope;
      const dataToPersist = await this.populateComponentsFilesToWriteForCapsule(component, allIds, scope);
      await dataToPersist.persistAllToCapsule(capsule, {
        keepExistingCapsule: true
      });
    }));
  }
  getWorkspacePeersOnlyPolicy() {
    const workspacePolicy = this.dependencyResolver.getWorkspacePolicy();
    const peerOnlyPolicy = workspacePolicy.byLifecycleType('peer');
    return peerOnlyPolicy;
  }
  toComponentMap(capsuleList) {
    const tuples = capsuleList.map(capsule => {
      return [capsule.component, capsule.path];
    });
    return _component().ComponentMap.create(tuples);
  }
  async list(workspacePath) {
    try {
      const workspaceCapsuleFolder = this.getCapsulesRootDir(workspacePath);
      const capsules = await _fsExtra().default.readdir(workspaceCapsuleFolder);
      const capsuleFullPaths = capsules.map(c => _path2().default.join(workspaceCapsuleFolder, c));
      return {
        workspace: workspacePath,
        capsules: capsuleFullPaths
      };
    } catch (e) {
      if (e.code === 'ENOENT') {
        return {
          workspace: workspacePath,
          capsules: []
        };
      }
      throw e;
    }
  }
  getCapsulesRootDir(baseDir, rootBaseDir) {
    const capsulesRootBaseDir = rootBaseDir || this.getRootDirOfAllCapsules();
    return _path2().default.join(capsulesRootBaseDir, (0, _objectHash().default)(baseDir));
  }
  async deleteCapsules(capsuleBaseDir) {
    const dirToDelete = capsuleBaseDir ? this.getCapsulesRootDir(capsuleBaseDir) : this.getRootDirOfAllCapsules();
    await _fsExtra().default.remove(dirToDelete);
    return dirToDelete;
  }
  async createCapsulesFromComponents(components, baseDir, opts) {
    this.logger.debug(`createCapsulesFromComponents: ${components.length} components`);
    const capsules = await Promise.all(components.map(component => {
      return _capsule().Capsule.createFromComponent(component, baseDir, opts);
    }));
    return capsules;
  }
  getRootDirOfAllCapsules() {
    return this.globalConfig.getGlobalCapsulesBaseDir();
  }
  wereDependenciesInPackageJsonChanged(capsuleWithPackageData) {
    const {
      previousPackageJson,
      currentPackageJson
    } = capsuleWithPackageData;
    if (!previousPackageJson) return true;
    // @ts-ignore at this point, currentPackageJson is set
    return _constants().DEPENDENCIES_FIELDS.some(field => !(0, _equals().default)(previousPackageJson[field], currentPackageJson[field]));
  }
  async getCapsulesPreviousPackageJson(capsules) {
    return Promise.all(capsules.map(async capsule => {
      const packageJsonPath = _path2().default.join(capsule.path, 'package.json');
      let previousPackageJson = null;
      try {
        const previousPackageJsonRaw = await capsule.fs.promises.readFile(packageJsonPath, {
          encoding: 'utf8'
        });
        previousPackageJson = JSON.parse(previousPackageJsonRaw);
      } catch (e) {
        // package-json doesn't exist in the capsule, that's fine, it'll be considered as a cache miss
      }
      return {
        capsule,
        previousPackageJson
      };
    }));
  }
  async updateWithCurrentPackageJsonData(capsulesWithPackagesData, capsules) {
    return Promise.all(capsules.map(async capsule => {
      const packageJson = await this.getCurrentPackageJson(capsule, capsules);
      const found = capsulesWithPackagesData.filter(c => c.capsule.component.id.isEqual(capsule.component.id));
      if (!found.length) throw new Error(`updateWithCurrentPackageJsonData unable to find ${capsule.component.id}`);
      if (found.length > 1) throw new Error(`updateWithCurrentPackageJsonData found duplicate capsules: ${capsule.component.id.toString()}""`);
      found[0].currentPackageJson = packageJson.packageJsonObject;
    }));
  }
  async getCurrentPackageJson(capsule, capsules) {
    const component = capsule.component;
    const currentVersion = (0, _componentPackageVersion().getComponentPackageVersion)(component);
    const getComponentDepsManifest = async dependencies => {
      const manifest = {
        dependencies: {},
        devDependencies: {}
      };
      const compDeps = dependencies.toTypeArray('component');
      const promises = compDeps.map(async dep => {
        const depCapsule = capsules.getCapsule(dep.componentId);
        let version = dep.version;
        if (depCapsule) {
          version = (0, _componentPackageVersion().getComponentPackageVersion)(depCapsule === null || depCapsule === void 0 ? void 0 : depCapsule.component);
        } else {
          version = (0, _componentPackageVersion().snapToSemver)(version);
        }
        const keyName = _dependencyResolver().KEY_NAME_BY_LIFECYCLE_TYPE[dep.lifecycle];
        const entry = dep.toManifest();
        if (entry) {
          manifest[keyName][entry.packageName] = version;
        }
      });
      await Promise.all(promises);
      return manifest;
    };
    const deps = await this.dependencyResolver.getDependencies(component);
    const manifest = await getComponentDepsManifest(deps);

    // component.packageJsonFile is not available here. we don't mutate the component object for capsules.
    // also, don't use `PackageJsonFile.createFromComponent`, as it looses the intermediate changes
    // such as postInstall scripts for custom-module-resolution.
    const packageJson = _packageJsonFile().default.loadFromCapsuleSync(capsule.path);
    const addDependencies = packageJsonFile => {
      packageJsonFile.addDependencies(manifest.dependencies);
      packageJsonFile.addDevDependencies(manifest.devDependencies);
    };
    addDependencies(packageJson);
    packageJson.addOrUpdateProperty('version', currentVersion);
    return packageJson;
  }
  async populateComponentsFilesToWriteForCapsule(component, ids, legacyScope) {
    const legacyComp = component.state._consumer;
    const dataToPersist = new (_dataToPersist().default)();
    const clonedFiles = legacyComp.files.map(file => file.clone());
    const writeToPath = '.';
    clonedFiles.forEach(file => file.updatePaths({
      newBase: writeToPath
    }));
    dataToPersist.removePath(new (_removePath().default)(writeToPath));
    clonedFiles.map(file => dataToPersist.addFile(file));
    const packageJson = this.preparePackageJsonToWrite(component, writeToPath, ids // this.ignoreBitDependencies,
    );

    if (!legacyComp.id.hasVersion()) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      packageJson.addOrUpdateProperty('version', _semver().default.inc(legacyComp.version, 'prerelease') || '0.0.1-0');
    }
    await _packageJsonTransformer().PackageJsonTransformer.applyTransformers(legacyComp, packageJson);
    const valuesToMerge = legacyComp.overrides.componentOverridesPackageJsonData;
    packageJson.mergePackageJsonObject(valuesToMerge);
    dataToPersist.addFile(packageJson.toVinylFile());
    const artifacts = await this.getArtifacts(legacyComp, legacyScope);
    dataToPersist.addManyFiles(artifacts);
    return dataToPersist;
  }
  preparePackageJsonToWrite(component, bitDir, ignoreBitDependencies = true) {
    const legacyComp = component.state._consumer;
    this.logger.debug(`package-json.preparePackageJsonToWrite. bitDir ${bitDir}.`);
    const getBitDependencies = dependencies => {
      if (ignoreBitDependencies === true) return {};
      return dependencies.reduce((acc, depId) => {
        if (Array.isArray(ignoreBitDependencies) && ignoreBitDependencies.searchWithoutVersion(depId)) return acc;
        const packageDependency = depId.version;
        const packageName = (0, _componentIdToPackageName().default)(_objectSpread(_objectSpread({}, legacyComp), {}, {
          id: depId,
          isDependency: true
        }));
        acc[packageName] = packageDependency;
        return acc;
      }, {});
    };
    const bitDependencies = getBitDependencies(legacyComp.dependencies.getAllIds());
    const bitDevDependencies = getBitDependencies(legacyComp.devDependencies.getAllIds());
    const bitExtensionDependencies = getBitDependencies(legacyComp.extensions.extensionsBitIds);
    const packageJson = _packageJsonFile().default.createFromComponent(bitDir, legacyComp, true);
    const main = (0, _path().pathNormalizeToLinux)(legacyComp.mainFile);
    packageJson.addOrUpdateProperty('main', main);
    const addDependencies = packageJsonFile => {
      packageJsonFile.addDependencies(bitDependencies);
      packageJsonFile.addDevDependencies(_objectSpread(_objectSpread({}, bitDevDependencies), bitExtensionDependencies));
    };
    addDependencies(packageJson);
    const currentVersion = (0, _componentPackageVersion().getComponentPackageVersion)(component);
    packageJson.addOrUpdateProperty('version', currentVersion);
    return packageJson;
  }

  /**
   * currently, it writes all artifacts.
   * later, this responsibility might move to pkg extension, which could write only artifacts
   * that are set in package.json.files[], to have a similar structure of a package.
   */
  async getArtifacts(component, legacyScope) {
    if (!legacyScope) {
      // when capsules are written via the workspace, do not write artifacts, they get created by
      // build-pipeline. when capsules are written via the scope, we do need the dists.
      return [];
    }
    if (component.buildStatus !== 'succeed') {
      // this is important for "bit sign" when on lane to not go to the original scope
      return [];
    }
    const extensionsNamesForArtifacts = ['teambit.compilation/compiler'];
    const artifactsFiles = (0, _lodash().flatten)(extensionsNamesForArtifacts.map(extName => (0, _artifactFiles().getArtifactFilesByExtension)(component.extensions, extName)));
    const artifactsVinylFlattened = [];
    await Promise.all(artifactsFiles.map(async artifactFiles => {
      if (!artifactFiles) return;
      if (!(artifactFiles instanceof _artifactFiles().ArtifactFiles)) {
        artifactFiles = (0, _artifactFiles().deserializeArtifactFiles)(artifactFiles);
      }
      // fyi, if this is coming from the isolator aspect, it is optimized to import all at once.
      // see artifact-files.importMultipleDistsArtifacts().
      const vinylFiles = await artifactFiles.getVinylsAndImportIfMissing(component.id, legacyScope);
      artifactsVinylFlattened.push(...vinylFiles);
    }));
    const artifactsDir = component.writtenPath;
    if (artifactsDir) {
      artifactsVinylFlattened.forEach(a => a.updatePaths({
        newBase: artifactsDir
      }));
    }
    return artifactsVinylFlattened;
  }
}
exports.IsolatorMain = IsolatorMain;
(0, _defineProperty2().default)(IsolatorMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(IsolatorMain, "dependencies", [_dependencyResolver().DependencyResolverAspect, _logger().LoggerAspect, _component().ComponentAspect, _graph().GraphAspect, _globalConfig().default, _aspectLoader().AspectLoaderAspect]);
(0, _defineProperty2().default)(IsolatorMain, "defaultConfig", {});
_isolator().IsolatorAspect.addRuntime(IsolatorMain);

//# sourceMappingURL=isolator.main.runtime.js.map