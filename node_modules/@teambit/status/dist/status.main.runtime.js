"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatusMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _componentId() {
  const data = require("@teambit/component-id");
  _componentId = function () {
    return data;
  };
  return data;
}
function _analytics() {
  const data = require("@teambit/legacy/dist/analytics/analytics");
  _analytics = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
function _loaderMessages() {
  const data = require("@teambit/legacy/dist/cli/loader/loader-messages");
  _loaderMessages = function () {
    return data;
  };
  return data;
}
function _remove() {
  const data = require("@teambit/remove");
  _remove = function () {
    return data;
  };
  return data;
}
function _componentsPendingImport() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/exceptions/components-pending-import"));
  _componentsPendingImport = function () {
    return data;
  };
  return data;
}
function _componentsList() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/components-list"));
  _componentsList = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _insights() {
  const data = require("@teambit/insights");
  _insights = function () {
    return data;
  };
  return data;
}
function _issues() {
  const data = _interopRequireDefault(require("@teambit/issues"));
  _issues = function () {
    return data;
  };
  return data;
}
function _statusCmd() {
  const data = require("./status-cmd");
  _statusCmd = function () {
    return data;
  };
  return data;
}
function _status() {
  const data = require("./status.aspect");
  _status = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class StatusMain {
  constructor(workspace, issues, insights, remove) {
    this.workspace = workspace;
    this.issues = issues;
    this.insights = insights;
    this.remove = remove;
  }
  async status() {
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    _loader().default.start(_loaderMessages().BEFORE_STATUS);
    const consumer = this.workspace.consumer;
    const laneObj = await consumer.getCurrentLaneObject();
    const componentsList = new (_componentsList().default)(consumer);
    const loadOpts = {
      loadDocs: false,
      loadCompositions: false
    };
    const newComponents = await componentsList.listNewComponents(true, loadOpts);
    const modifiedComponents = await componentsList.listModifiedComponents(true, loadOpts);
    const stagedComponents = await componentsList.listExportPendingComponents(laneObj);
    await this.addRemovedStagedIfNeeded(stagedComponents);
    const stagedComponentsWithVersions = await (0, _pMapSeries().default)(stagedComponents, async stagedComp => {
      const versions = await stagedComp.getLocalTagsOrHashes(consumer.scope.objects);
      return {
        id: stagedComp.toBitId(),
        versions
      };
    });
    const autoTagPendingComponents = await componentsList.listAutoTagPendingComponents();
    const autoTagPendingComponentsIds = autoTagPendingComponents.map(component => component.id);
    const allInvalidComponents = await componentsList.listInvalidComponents();
    const locallySoftRemoved = await componentsList.listLocallySoftRemoved();
    const remotelySoftRemoved = await componentsList.listRemotelySoftRemoved();
    const importPendingComponents = allInvalidComponents
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    .filter(c => c.error instanceof _componentsPendingImport().default)
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    .map(i => i.id);
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const invalidComponents = allInvalidComponents.filter(c => !(c.error instanceof _componentsPendingImport().default));
    const outdatedComponents = await componentsList.listOutdatedComponents();
    const mergePendingComponents = await componentsList.listMergePendingComponents();
    const newAndModifiedLegacy = newComponents.concat(modifiedComponents);
    const issuesToIgnore = this.issues.getIssuesToIgnoreGlobally();
    if (newAndModifiedLegacy.length) {
      const newAndModified = await this.workspace.getManyByLegacy(newAndModifiedLegacy, loadOpts);
      await this.issues.triggerAddComponentIssues(newAndModified, issuesToIgnore);
      this.issues.removeIgnoredIssuesFromComponents(newAndModified);
    }
    const componentsWithIssues = newAndModifiedLegacy.filter(component => {
      return component.issues && !component.issues.isEmpty();
    });
    const componentsDuringMergeState = componentsList.listDuringMergeStateComponents();
    const softTaggedComponents = componentsList.listSoftTaggedComponents();
    const snappedComponents = (await componentsList.listSnappedComponentsOnMain()).map(c => c.toBitId());
    const pendingUpdatesFromMain = await componentsList.listUpdatesFromMainPending();
    const updatesFromForked = await componentsList.listUpdatesFromForked();
    const currentLaneId = consumer.getCurrentLaneId();
    const currentLane = await consumer.getCurrentLaneObject();
    const forkedLaneId = currentLane === null || currentLane === void 0 ? void 0 : currentLane.forkedFrom;
    _analytics().Analytics.setExtraData('new_components', newComponents.length);
    _analytics().Analytics.setExtraData('staged_components', stagedComponents.length);
    _analytics().Analytics.setExtraData('num_components_with_missing_dependencies', componentsWithIssues.length);
    _analytics().Analytics.setExtraData('autoTagPendingComponents', autoTagPendingComponents.length);
    _analytics().Analytics.setExtraData('deleted', invalidComponents.length);
    const convertBitIdToComponentIdsAndSort = async ids => _componentId().ComponentID.sortIds(await this.workspace.resolveMultipleComponentIds(ids));
    const convertObjToComponentIdsAndSort = async objectsWithId => {
      const results = await Promise.all(objectsWithId.map(async obj => {
        return _objectSpread(_objectSpread({}, obj), {}, {
          id: await this.workspace.resolveComponentId(obj.id)
        });
      }));
      return results.sort((a, b) => a.id.toString().localeCompare(b.id.toString()));
    };
    await consumer.onDestroy();
    return {
      newComponents: await convertBitIdToComponentIdsAndSort(newComponents.map(c => c.id)),
      modifiedComponents: await convertBitIdToComponentIdsAndSort(modifiedComponents.map(c => c.id)),
      stagedComponents: await convertObjToComponentIdsAndSort(stagedComponentsWithVersions),
      // @ts-ignore - not clear why, it fails the "bit build" without it
      componentsWithIssues: await convertObjToComponentIdsAndSort(componentsWithIssues.map(c => ({
        id: c.id,
        issues: c.issues
      }))),
      // no need to sort, we don't print it as is
      importPendingComponents: await convertBitIdToComponentIdsAndSort(importPendingComponents),
      // no need to sort, we use only its length
      autoTagPendingComponents: await convertBitIdToComponentIdsAndSort(autoTagPendingComponentsIds),
      invalidComponents: await convertObjToComponentIdsAndSort(invalidComponents.map(c => ({
        id: c.id,
        error: c.error
      }))),
      locallySoftRemoved: await convertBitIdToComponentIdsAndSort(locallySoftRemoved),
      remotelySoftRemoved: await convertBitIdToComponentIdsAndSort(remotelySoftRemoved.map(c => c.id)),
      outdatedComponents: await convertObjToComponentIdsAndSort(outdatedComponents.map(c => ({
        id: c.id,
        // @ts-ignore
        latestVersion: c.latestVersion
      }))),
      mergePendingComponents: await convertObjToComponentIdsAndSort(mergePendingComponents.map(c => ({
        id: c.id,
        divergeData: c.diverge
      }))),
      componentsDuringMergeState: await convertBitIdToComponentIdsAndSort(componentsDuringMergeState),
      softTaggedComponents: await convertBitIdToComponentIdsAndSort(softTaggedComponents),
      snappedComponents: await convertBitIdToComponentIdsAndSort(snappedComponents),
      pendingUpdatesFromMain: await convertObjToComponentIdsAndSort(pendingUpdatesFromMain),
      updatesFromForked: await convertObjToComponentIdsAndSort(updatesFromForked),
      currentLaneId,
      forkedLaneId
    };
  }
  async addRemovedStagedIfNeeded(stagedComponents) {
    const removedStagedIds = await this.remove.getRemovedStaged();
    if (!removedStagedIds.length) return;
    const removedStagedBitIds = removedStagedIds.map(id => id._legacy);
    const nonExistsInStaged = removedStagedBitIds.filter(id => !stagedComponents.find(c => c.toBitId().isEqualWithoutVersion(id)));
    if (!nonExistsInStaged.length) return;
    const modelComps = await Promise.all(nonExistsInStaged.map(id => this.workspace.scope.legacyScope.getModelComponent(id)));
    stagedComponents.push(...modelComps);
  }
  static async provider([cli, workspace, insights, issues, remove]) {
    const statusMain = new StatusMain(workspace, issues, insights, remove);
    cli.register(new (_statusCmd().StatusCmd)(statusMain));
    return statusMain;
  }
}
exports.StatusMain = StatusMain;
(0, _defineProperty2().default)(StatusMain, "slots", []);
(0, _defineProperty2().default)(StatusMain, "dependencies", [_cli().CLIAspect, _workspace().default, _insights().InsightsAspect, _issues().default, _remove().RemoveAspect]);
(0, _defineProperty2().default)(StatusMain, "runtime", _cli().MainRuntime);
_status().StatusAspect.addRuntime(StatusMain);

//# sourceMappingURL=status.main.runtime.js.map