"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatusCmd = void 0;
exports.formatIssues = formatIssues;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _ramda() {
  const data = _interopRequireDefault(require("ramda"));
  _ramda = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@teambit/legacy/dist/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _chalkBox() {
  const data = require("@teambit/legacy/dist/cli/chalk-box");
  _chalkBox = function () {
    return data;
  };
  return data;
}
function _componentIssuesTemplate() {
  const data = require("@teambit/legacy/dist/cli/templates/component-issues-template");
  _componentIssuesTemplate = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _componentVersion() {
  const data = require("@teambit/component-version");
  _componentVersion = function () {
    return data;
  };
  return data;
}
const TROUBLESHOOTING_MESSAGE = `${_chalk().default.yellow(`learn more at https://${_constants().BASE_DOCS_DOMAIN}/components/adding-components`)}`;
class StatusCmd {
  constructor(status) {
    this.status = status;
    (0, _defineProperty2().default)(this, "name", 'status');
    (0, _defineProperty2().default)(this, "description", 'present the current status of components in the workspace, and notifies when issues are detected');
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "extendedDescription", void 0);
    (0, _defineProperty2().default)(this, "alias", 's');
    (0, _defineProperty2().default)(this, "options", [['j', 'json', 'return a json version of the component'], ['', 'verbose', 'show extra data: full snap hashes for staged, divergence point for lanes and updates-from-main for forked lanes'], ['', 'strict', 'in case issues found, exit with code 1']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "migration", true);
  }
  async json() {
    const {
      newComponents,
      modifiedComponents,
      stagedComponents,
      componentsWithIssues,
      importPendingComponents,
      autoTagPendingComponents,
      invalidComponents,
      locallySoftRemoved,
      remotelySoftRemoved,
      outdatedComponents,
      mergePendingComponents,
      componentsDuringMergeState,
      softTaggedComponents,
      snappedComponents,
      pendingUpdatesFromMain,
      updatesFromForked,
      currentLaneId,
      forkedLaneId
    } = await this.status.status();
    return {
      newComponents: newComponents.map(c => c.toStringWithoutVersion()),
      modifiedComponents: modifiedComponents.map(c => c.toString()),
      stagedComponents: stagedComponents.map(c => ({
        id: c.id.toStringWithoutVersion(),
        versions: c.versions
      })),
      componentsWithIssues: componentsWithIssues.map(c => {
        var _c$issues;
        return {
          id: c.id.toString(),
          issues: (_c$issues = c.issues) === null || _c$issues === void 0 ? void 0 : _c$issues.toObject()
        };
      }),
      importPendingComponents: importPendingComponents.map(id => id.toString()),
      autoTagPendingComponents: autoTagPendingComponents.map(s => s.toString()),
      invalidComponents,
      locallySoftRemoved: locallySoftRemoved.map(id => id.toString()),
      remotelySoftRemoved: remotelySoftRemoved.map(id => id.toString()),
      outdatedComponents: outdatedComponents.map(c => c.id.toString()),
      mergePendingComponents: mergePendingComponents.map(c => c.id.toString()),
      componentsDuringMergeState: componentsDuringMergeState.map(id => id.toString()),
      softTaggedComponents: softTaggedComponents.map(s => s.toString()),
      snappedComponents: snappedComponents.map(s => s.toString()),
      pendingUpdatesFromMain: pendingUpdatesFromMain.map(p => ({
        id: p.id.toString(),
        divergeData: p.divergeData
      })),
      updatesFromForked: updatesFromForked.map(p => ({
        id: p.id.toString(),
        divergeData: p.divergeData
      })),
      currentLaneId,
      forkedLaneId
    };
  }
  async report(_args, {
    strict,
    verbose
  }) {
    const {
      newComponents,
      modifiedComponents,
      stagedComponents,
      componentsWithIssues,
      importPendingComponents,
      autoTagPendingComponents,
      invalidComponents,
      locallySoftRemoved,
      remotelySoftRemoved,
      outdatedComponents,
      mergePendingComponents,
      componentsDuringMergeState,
      softTaggedComponents,
      snappedComponents,
      pendingUpdatesFromMain,
      updatesFromForked,
      currentLaneId,
      forkedLaneId
    } = await this.status.status();
    // If there is problem with at least one component we want to show a link to the
    // troubleshooting doc
    let showTroubleshootingLink = false;
    function format(id, showIssues = false, message, localVersions) {
      const idWithIssues = componentsWithIssues.find(c => c.id.isEqual(id));
      const softTagged = softTaggedComponents.find(softTaggedId => softTaggedId.isEqual(id));
      const messageStatusText = message || 'ok';
      const messageStatusTextWithSoftTag = softTagged ? `${messageStatusText} (soft-tagged)` : messageStatusText;
      const color = message ? 'yellow' : 'green';
      const messageStatus = _chalk().default[color](messageStatusTextWithSoftTag);
      if (!showIssues) {
        return `${(0, _chalkBox().formatBitString)(id.toStringWithoutVersion())} ... ${messageStatus}`;
      }
      let bitFormatted = `${(0, _chalkBox().formatBitString)(id.toStringWithoutVersion())}`;
      if (localVersions) {
        if (verbose) {
          bitFormatted += `. versions: ${localVersions.join(', ')}`;
        } else {
          const [snaps, tags] = (0, _lodash().partition)(localVersions, version => (0, _componentVersion().isHash)(version));
          const tagsStr = tags.length ? `versions: ${tags.join(', ')}` : '';
          const snapsStr = snaps.length ? `${snaps.length} snap(s)` : '';
          bitFormatted += `. `;
          bitFormatted += tagsStr && snapsStr ? `${tagsStr}. and ${snapsStr}` : tagsStr || snapsStr;
        }
      }
      bitFormatted += ' ... ';
      if (!idWithIssues) return `${bitFormatted}${messageStatus}`;
      showTroubleshootingLink = true;
      return `${bitFormatted} ${_chalk().default.red(_constants().statusFailureMsg)}${formatIssues(idWithIssues.issues)}`;
    }
    const importPendingWarning = importPendingComponents.length ? _chalk().default.yellow(`${_constants().IMPORT_PENDING_MSG}.\n`) : '';
    const splitByMissing = _ramda().default.groupBy(component => {
      return component.includes(_constants().statusFailureMsg) ? 'missing' : 'nonMissing';
    });
    const {
      missing,
      nonMissing
    } = splitByMissing(newComponents.map(c => format(c, true)));
    const outdatedTitle = _chalk().default.underline.white('pending updates');
    const outdatedDesc = '(use "bit checkout head" to merge changes)\n(use "bit diff [component_id] [new_version]" to compare changes)\n(use "bit log [component_id]" to list all available versions)\n';
    const outdatedComps = outdatedComponents.map(component => {
      return `    > ${_chalk().default.cyan(component.id.toStringWithoutVersion())} current: ${component.id.version} latest: ${
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      component.latestVersion}\n`;
    }).join('');
    const outdatedStr = outdatedComponents.length ? [outdatedTitle, outdatedDesc, outdatedComps].join('\n') : '';
    const pendingMergeTitle = _chalk().default.underline.white('pending merge');
    const pendingMergeDesc = `(use "bit reset" to add local changes on top of the remote and discard local tags.
alternatively, to keep local tags/snaps history, use "bit merge <remote-name>/<lane-name> [component-id]")\n`;
    const pendingMergeComps = mergePendingComponents.map(component => {
      return `    > ${_chalk().default.cyan(component.id.toString())} local and remote have diverged and have ${component.divergeData.snapsOnLocalOnly.length} and ${component.divergeData.snapsOnRemoteOnly.length} different snaps each, respectively\n`;
    }).join('');
    const pendingMergeStr = pendingMergeComps.length ? [pendingMergeTitle, pendingMergeDesc, pendingMergeComps].join('\n') : '';
    const compDuringMergeTitle = _chalk().default.underline.white('components during merge state');
    const compDuringMergeDesc = `(use "bit snap/tag [--unmerged]" to complete the merge process
or use "bit merge [component-id] --abort" to cancel the merge operation)\n`;
    const compDuringMergeComps = componentsDuringMergeState.map(id => {
      return `    > ${_chalk().default.cyan(id.toString())}`;
    }).join('\n');
    const compDuringMergeStr = compDuringMergeComps.length ? [compDuringMergeTitle, compDuringMergeDesc, compDuringMergeComps].join('\n') : '';
    const newComponentDescription = '\n(use "bit tag [version]" to lock a version with all your changes)\n';
    const newComponentsTitle = newComponents.length ? _chalk().default.underline.white('new components') + newComponentDescription : '';
    const newComponentsOutput = [newComponentsTitle, ...(nonMissing || []), ...(missing || [])].join('\n');
    const modifiedDesc = '(use "bit diff" to compare changes)\n';
    const modifiedComponentOutput = (0, _utils().immutableUnshift)(modifiedComponents.map(c => format(c, true)), modifiedComponents.length ? _chalk().default.underline.white('modified components') + newComponentDescription + modifiedDesc : '').join('\n');
    const autoTagPendingOutput = (0, _utils().immutableUnshift)(autoTagPendingComponents.map(c => format(c)), autoTagPendingComponents.length ? _chalk().default.underline.white('components pending to be tagged automatically (when their dependencies are tagged)') : '').join('\n');
    const invalidDesc = '\nthese components were failed to load.\n';
    const invalidComponentOutput = (0, _utils().immutableUnshift)(invalidComponents.map(c => format(c.id, false, (0, _componentIssuesTemplate().getInvalidComponentLabel)(c.error))).sort(), invalidComponents.length ? _chalk().default.underline.white(_constants().statusInvalidComponentsMsg) + invalidDesc : '').join('\n');
    const locallySoftRemovedDesc = '\n(tag/snap and export them to update the remote)\n';
    const locallySoftRemovedOutput = (0, _utils().immutableUnshift)(locallySoftRemoved.map(c => format(c)).sort(), locallySoftRemoved.length ? _chalk().default.underline.white('soft-removed components locally') + locallySoftRemovedDesc : '').join('\n');
    const remotelySoftRemovedDesc = '\n(use "bit remove" to remove them from the workspace)\n';
    const remotelySoftRemovedOutput = (0, _utils().immutableUnshift)(remotelySoftRemoved.map(c => format(c)).sort(), remotelySoftRemoved.length ? _chalk().default.underline.white('soft-removed components on the remote') + remotelySoftRemovedDesc : '').join('\n');
    const stagedDesc = '\n(use "bit export" to push these components to a remote scope)\n';
    const stagedComponentsOutput = (0, _utils().immutableUnshift)(stagedComponents.map(c => format(c.id, true, undefined, c.versions)), stagedComponents.length ? _chalk().default.underline.white('staged components') + stagedDesc : '').join('\n');
    const snappedDesc = '\n(use "bit tag [version]" or "bit tag --snapped [version]" to lock a version)\n';
    const snappedComponentsOutput = (0, _utils().immutableUnshift)(snappedComponents.map(c => format(c)), snappedComponents.length ? _chalk().default.underline.white('snapped components') + snappedDesc : '').join('\n');
    const getUpdateFromMsg = (divergeData, from = 'main') => {
      if (divergeData.err) return divergeData.err.message;
      let msg = `${from} is ahead by ${divergeData.snapsOnRemoteOnly.length || 0} snaps`;
      if (divergeData.snapsOnLocalOnly && verbose) {
        var _divergeData$commonSn;
        msg += ` (diverged since ${(_divergeData$commonSn = divergeData.commonSnapBeforeDiverge) === null || _divergeData$commonSn === void 0 ? void 0 : _divergeData$commonSn.toShortString()})`;
      }
      return msg;
    };
    let updatesFromMainOutput = '';
    if (!forkedLaneId || verbose) {
      const updatesFromMainDesc = '\n(use "bit lane merge main" to merge the changes)\n';
      const pendingUpdatesFromMainIds = pendingUpdatesFromMain.map(c => format(c.id, false, getUpdateFromMsg(c.divergeData)));
      updatesFromMainOutput = [pendingUpdatesFromMain.length ? _chalk().default.underline.white('pending updates from main') + updatesFromMainDesc : '', ...pendingUpdatesFromMainIds].join('\n');
    }
    let updatesFromForkedOutput = '';
    if (forkedLaneId) {
      const updatesFromForkedDesc = `\n(use "bit lane merge ${forkedLaneId.toString()}" to merge the changes
use "bit fetch ${forkedLaneId.toString()} --lanes" to update ${forkedLaneId.name} locally)\n`;
      const pendingUpdatesFromForkedIds = updatesFromForked.map(c => format(c.id, false, getUpdateFromMsg(c.divergeData, forkedLaneId.name)));
      updatesFromForkedOutput = [updatesFromForked.length ? _chalk().default.underline.white(`updates from ${forkedLaneId.name}`) + updatesFromForkedDesc : '', ...pendingUpdatesFromForkedIds].join('\n');
    }
    const laneStr = currentLaneId.isDefault() ? '' : `\non ${_chalk().default.bold(currentLaneId.toString())} lane`;
    const troubleshootingStr = showTroubleshootingLink ? `\n${TROUBLESHOOTING_MESSAGE}` : '';
    const statusMsg = importPendingWarning + (0, _lodash().compact)([outdatedStr, pendingMergeStr, updatesFromMainOutput, updatesFromForkedOutput, compDuringMergeStr, newComponentsOutput, modifiedComponentOutput, snappedComponentsOutput, stagedComponentsOutput, autoTagPendingOutput, invalidComponentOutput, locallySoftRemovedOutput, remotelySoftRemovedOutput]).join(_chalk().default.underline('\n                         \n') + _chalk().default.white('\n')) + troubleshootingStr;
    const results = (statusMsg || _chalk().default.yellow(_constants().statusWorkspaceIsCleanMsg)) + laneStr;
    const exitCode = componentsWithIssues.length && strict ? 1 : 0;
    return {
      data: results,
      code: exitCode
    };
  }
}
exports.StatusCmd = StatusCmd;
function formatIssues(issues) {
  return `       ${issues === null || issues === void 0 ? void 0 : issues.outputForCLI()}\n`;
}

//# sourceMappingURL=status-cmd.js.map