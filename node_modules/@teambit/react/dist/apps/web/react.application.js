"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactApp = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fs() {
  const data = require("fs");
  _fs = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _toolboxNetwork() {
  const data = require("@teambit/toolbox.network.get-port");
  _toolboxNetwork = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = _interopRequireDefault(require("lodash.compact"));
  _lodash = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _plugins() {
  const data = require("./plugins");
  _plugins = function () {
    return data;
  };
  return data;
}
function _webpack() {
  const data = require("../../webpack");
  _webpack = function () {
    return data;
  };
  return data;
}
function _computeResults() {
  const data = require("./compute-results");
  _computeResults = function () {
    return data;
  };
  return data;
}
function _webpackAppSsr() {
  const data = require("./webpack/webpack.app.ssr.config");
  _webpackAppSsr = function () {
    return data;
  };
  return data;
}
function _mutators() {
  const data = require("./webpack/mutators");
  _mutators = function () {
    return data;
  };
  return data;
}
function _ssrExpress() {
  const data = require("./ssr/ssr-express");
  _ssrExpress = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class ReactApp {
  constructor(name, entry, ssr, portRange, reactEnv, logger, dependencyResolver, prerender, bundler, ssrBundler, devServer, transformers = [], deploy, favicon) {
    this.name = name;
    this.entry = entry;
    this.ssr = ssr;
    this.portRange = portRange;
    this.reactEnv = reactEnv;
    this.logger = logger;
    this.dependencyResolver = dependencyResolver;
    this.prerender = prerender;
    this.bundler = bundler;
    this.ssrBundler = ssrBundler;
    this.devServer = devServer;
    this.transformers = transformers;
    this.deploy = deploy;
    this.favicon = favicon;
    (0, _defineProperty2().default)(this, "applicationType", 'react-common-js');
    (0, _defineProperty2().default)(this, "dir", 'public');
    (0, _defineProperty2().default)(this, "ssrDir", 'ssr');
  }
  async run(context) {
    const [from, to] = this.portRange;
    const port = await _toolboxNetwork().Port.getPort(from, to);
    if (this.devServer) {
      await this.devServer.listen(port);
      return port;
    }
    const devServerContext = await this.getDevServerContext(context);
    const devServer = this.reactEnv.getDevServer(devServerContext, [_mutators().addDevServer, _mutators().setOutput, ...this.transformers]);
    await devServer.listen(port);
    return port;
  }
  async runSsr(context) {
    var _this$logger, _this$logger2, _this$logger3;
    const [from, to] = this.portRange;
    const port = await _toolboxNetwork().Port.getPort(from, to);

    // bundle client
    const clientBundle = await this.buildClient(context);
    if (clientBundle.errors.length > 0) return {
      errors: clientBundle.errors
    };
    (_this$logger = this.logger) === null || _this$logger === void 0 ? void 0 : _this$logger.info('[react.application] [ssr] client bundle - complete');

    // bundle server
    const serverBundle = await this.buildSsr(context);
    if (serverBundle.errors.length > 0) return {
      errors: serverBundle.errors
    };
    (_this$logger2 = this.logger) === null || _this$logger2 === void 0 ? void 0 : _this$logger2.info('[react.application] [ssr] server bundle - complete');

    // load server-side runtime
    const app = await (0, _ssrExpress().loadSsrApp)(context.workdir, context.appName);
    (_this$logger3 = this.logger) === null || _this$logger3 === void 0 ? void 0 : _this$logger3.info('[react.application] [ssr] bundle code - loaded');
    const expressApp = (0, _ssrExpress().createExpressSsr)({
      name: context.appName,
      workdir: context.workdir,
      port,
      app,
      assets: (0, _ssrExpress().parseAssets)(clientBundle.assets),
      logger: this.logger
    });
    expressApp.listen(port);
    return {
      port
    };
  }
  async buildClient(context) {
    const htmlConfig = [{
      title: context.appName,
      templateContent: (0, _webpack().html)(context.appName),
      minify: false,
      favicon: this.favicon
    }];

    // extend, including prototype methods
    const ctx = Object.assign(Object.create(context), {
      html: htmlConfig,
      targets: [{
        entries: await this.getEntries(),
        components: [context.appComponent],
        outputPath: (0, _path().resolve)(context.workdir, (0, _webpackAppSsr().calcOutputPath)(context.appName, 'browser')),
        hostDependencies: await this.getPeers(),
        aliasHostDependencies: true
      }],
      // @ts-ignore
      capsuleNetwork: undefined,
      previousTasksResults: []
    });
    const bundler = await this.reactEnv.getBundler(ctx, [config => config.merge([(0, _webpackAppSsr().clientConfig)()]), ...this.transformers]);
    const bundleResult = await bundler.run();
    return bundleResult[0];
  }
  async buildSsr(context) {
    // extend, including prototype methods
    const ctx = Object.assign(Object.create(context), _objectSpread(_objectSpread({}, context), {}, {
      targets: [{
        entries: await this.getSsrEntries(),
        components: [context.appComponent],
        outputPath: (0, _path().resolve)(context.workdir, (0, _webpackAppSsr().calcOutputPath)(context.appName, 'ssr')),
        hostDependencies: await this.getPeers(),
        aliasHostDependencies: true
      }],
      // @ts-ignore
      capsuleNetwork: undefined,
      previousTasksResults: []
    }));
    const bundler = await this.reactEnv.getBundler(ctx, [config => config.merge([(0, _webpackAppSsr().ssrConfig)()]), ...this.transformers]);
    const bundleResult = await bundler.run();
    return bundleResult[0];
  }
  async build(context) {
    const htmlConfig = [{
      title: context.name,
      templateContent: (0, _webpack().html)(context.name),
      minify: false,
      favicon: this.favicon
      // filename: ''.html`,
    }];

    Object.assign(context, {
      html: htmlConfig
    });
    const bundler = await this.getBundler(context);
    const bundleResult = await bundler.run();
    const ssrAppDir = (0, _path().join)(this.getPublicDir(context.artifactsDir));
    if (this.ssr) await this.buildSsrApp(context, ssrAppDir);
    return (0, _computeResults().computeResults)(bundleResult, {
      publicDir: `${this.getPublicDir(context.artifactsDir)}/${this.dir}`,
      ssrPublicDir: ssrAppDir
    });
  }
  async buildSsrApp(context, ssrAppDir) {
    const ssrBundler = await this.getSsrBundler(context);
    await ssrBundler.run();
    const runner = (0, _fs().readFileSync)((0, _path().join)(__dirname, './ssr/app/runner')).toString();
    context.capsule.fs.writeFileSync((0, _path().join)(ssrAppDir, 'runner.js'), runner);
    const capsuleSsrDir = context.capsule.fs.getPath(ssrAppDir);
    const installer = this.dependencyResolver.getInstaller({
      packageManager: 'teambit.dependencies/yarn',
      rootDir: capsuleSsrDir,
      cacheRootDirectory: capsuleSsrDir
    });
    await installer.install(capsuleSsrDir, this.getSsrPolicy(), new (_component().ComponentMap)(new Map()));
    return ssrAppDir;
  }
  getSsrPolicy() {
    const workspacePolicy = new (_dependencyResolver().WorkspacePolicy)([]);
    workspacePolicy.add({
      lifecycleType: 'runtime',
      dependencyId: 'express',
      value: {
        version: '4.18.1'
      }
    });
    workspacePolicy.add({
      lifecycleType: 'runtime',
      dependencyId: '@teambit/react.rendering.ssr',
      value: {
        version: '0.0.3'
      }
    });
    workspacePolicy.add({
      lifecycleType: 'runtime',
      dependencyId: '@teambit/ui-foundation.ui.pages.static-error',
      value: {
        version: '0.0.75'
      }
    });
    workspacePolicy.add({
      lifecycleType: 'peer',
      dependencyId: 'react',
      value: {
        version: '17.0.2'
      }
    });
    workspacePolicy.add({
      lifecycleType: 'peer',
      dependencyId: 'react-dom',
      value: {
        version: '17.0.2'
      }
    });
    return workspacePolicy;
  }
  getBundler(context) {
    if (this.bundler) return this.bundler;
    return this.getDefaultBundler(context);
  }
  getSsrBundler(context) {
    if (this.ssrBundler) return this.ssrBundler;
    return this.getDefaultSsrBundler(context);
  }
  async getDefaultBundler(context) {
    const {
      capsule
    } = context;
    const publicDir = this.getPublicDir(context.artifactsDir);
    const outputPath = (0, _path().join)(capsule.path, publicDir);
    const bundlerContext = await this.getBuildContext(context, {
      outputPath
    });
    const transformers = (0, _lodash().default)([configMutator => configMutator.merge((0, _webpackAppSsr().buildConfig)({
      outputPath: (0, _path().join)(outputPath, this.dir)
    })), config => {
      if (this.prerender) config.addPlugin((0, _plugins().prerenderPlugin)(this.prerender));
      return config;
    }, (0, _mutators().replaceTerserPlugin)({
      prerender: !!this.prerender
    }), ...this.transformers]);
    const reactEnv = context.env;
    const bundler = await reactEnv.getBundler(bundlerContext, transformers);
    return bundler;
  }
  async getDefaultSsrBundler(context) {
    const {
      capsule
    } = context;
    const publicDir = this.getPublicDir(context.artifactsDir);
    const outputPath = (0, _path().join)(capsule.path, publicDir);
    const bundlerContext = await this.getBuildContext(context, {
      outputPath
    });
    const transformers = (0, _lodash().default)([configMutator => configMutator.merge((0, _webpackAppSsr().ssrBuildConfig)({
      outputPath: (0, _path().join)(outputPath, this.ssrDir)
    })), (0, _mutators().replaceTerserPlugin)({
      prerender: !!this.prerender
    }), ...this.transformers]);
    const reactEnv = context.env;
    const bundler = await reactEnv.getBundler(bundlerContext, transformers);
    return bundler;
  }
  async getBuildContext(context, {
    outputPath
  }) {
    const {
      capsule
    } = context;
    const reactEnv = context.env;
    const {
      distDir
    } = reactEnv.getCompiler();
    const targetEntries = await this.getEntries(`${capsule.path}/${distDir}`);
    const entries = targetEntries.map(entry => require.resolve(`${capsule.path}/${distDir}/${(0, _path().basename)(entry)}`));
    const bundlerContext = Object.assign(context, {
      targets: [{
        components: [capsule === null || capsule === void 0 ? void 0 : capsule.component],
        entries,
        outputPath,
        hostRootDir: capsule === null || capsule === void 0 ? void 0 : capsule.path,
        hostDependencies: await this.getPeers(),
        aliasHostDependencies: true
      }],
      entry: [],
      rootPath: '/',
      metaData: {
        initiator: `building app: ${context.name}`,
        envId: context.id
      }
    });
    return bundlerContext;
  }
  getPublicDir(artifactsDir) {
    return (0, _path().join)(artifactsDir, this.applicationType, this.name);
  }
  async getEntries(path) {
    if (Array.isArray(this.entry)) return this.entry;
    return this.entry(path);
  }
  async getSsrEntries() {
    if (!this.ssr) throw new (_bitError().BitError)('tried to build ssr without ssr entries');
    if (typeof this.ssr === 'string') return [this.ssr];
    return [await this.ssr()];
  }
  async getDevServerContext(context) {
    const entries = await this.getEntries();
    return Object.assign(context, {
      entry: entries,
      rootPath: '',
      publicPath: `public/${this.name}`,
      title: this.name,
      favicon: this.favicon,
      hostDependencies: await this.getPeers(),
      aliasHostDependencies: true
    });
  }
  getPeers() {
    return this.reactEnv.getPeerDependenciesList();
  }
}
exports.ReactApp = ReactApp;

//# sourceMappingURL=react.application.js.map