"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.trim.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SnappingMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _featureToggle() {
  const data = require("@teambit/legacy/dist/api/consumer/lib/feature-toggle");
  _featureToggle = function () {
    return data;
  };
  return data;
}
function _getFlattenedDependencies() {
  const data = require("@teambit/legacy/dist/scope/component-ops/get-flattened-dependencies");
  _getFlattenedDependencies = function () {
    return data;
  };
  return data;
}
function _community() {
  const data = _interopRequireDefault(require("@teambit/community"));
  _community = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _ramda() {
  const data = _interopRequireDefault(require("ramda"));
  _ramda = function () {
    return data;
  };
  return data;
}
function _semver() {
  const data = _interopRequireDefault(require("semver"));
  _semver = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _analytics() {
  const data = require("@teambit/legacy/dist/analytics/analytics");
  _analytics = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _componentsList() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/components-list"));
  _componentsList = function () {
    return data;
  };
  return data;
}
function _hooks() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/hooks"));
  _hooks = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _hasWildcard() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/string/has-wildcard"));
  _hasWildcard = function () {
    return data;
  };
  return data;
}
function _semverHelper() {
  const data = require("@teambit/legacy/dist/utils/semver-helper");
  _semverHelper = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
function _componentsPendingImport() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/exceptions/components-pending-import"));
  _componentsPendingImport = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _pMap() {
  const data = _interopRequireDefault(require("p-map"));
  _pMap = function () {
    return data;
  };
  return data;
}
function _insights() {
  const data = require("@teambit/insights");
  _insights = function () {
    return data;
  };
  return data;
}
function _concurrency() {
  const data = require("@teambit/legacy/dist/utils/concurrency");
  _concurrency = function () {
    return data;
  };
  return data;
}
function _untagComponent() {
  const data = require("@teambit/legacy/dist/scope/component-ops/untag-component");
  _untagComponent = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = require("@teambit/scope");
  _scope = function () {
    return data;
  };
  return data;
}
function _issues() {
  const data = _interopRequireDefault(require("@teambit/issues"));
  _issues = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("@teambit/builder");
  _builder = function () {
    return data;
  };
  return data;
}
function _export() {
  const data = require("@teambit/export");
  _export = function () {
    return data;
  };
  return data;
}
function _unmergedComponents() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/scope/lanes/unmerged-components"));
  _unmergedComponents = function () {
    return data;
  };
  return data;
}
function _artifactFiles() {
  const data = require("@teambit/legacy/dist/consumer/component/sources/artifact-files");
  _artifactFiles = function () {
    return data;
  };
  return data;
}
function _snapCmd() {
  const data = require("./snap-cmd");
  _snapCmd = function () {
    return data;
  };
  return data;
}
function _snapping() {
  const data = require("./snapping.aspect");
  _snapping = function () {
    return data;
  };
  return data;
}
function _tagCmd() {
  const data = require("./tag-cmd");
  _tagCmd = function () {
    return data;
  };
  return data;
}
function _componentsHaveIssues() {
  const data = require("./components-have-issues");
  _componentsHaveIssues = function () {
    return data;
  };
  return data;
}
function _resetCmd() {
  const data = _interopRequireDefault(require("./reset-cmd"));
  _resetCmd = function () {
    return data;
  };
  return data;
}
function _tagModelComponent() {
  const data = require("./tag-model-component");
  _tagModelComponent = function () {
    return data;
  };
  return data;
}
function _tagFromScope() {
  const data = require("./tag-from-scope.cmd");
  _tagFromScope = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const HooksManagerInstance = _hooks().default.getInstance();
class SnappingMain {
  constructor(workspace, logger, issues, insights, dependencyResolver, scope, exporter, builder) {
    var _this$scope, _this$scope$legacySco;
    this.workspace = workspace;
    this.logger = logger;
    this.issues = issues;
    this.insights = insights;
    this.dependencyResolver = dependencyResolver;
    this.scope = scope;
    this.exporter = exporter;
    this.builder = builder;
    (0, _defineProperty2().default)(this, "objectsRepo", void 0);
    this.objectsRepo = (_this$scope = this.scope) === null || _this$scope === void 0 ? void 0 : (_this$scope$legacySco = _this$scope.legacyScope) === null || _this$scope$legacySco === void 0 ? void 0 : _this$scope$legacySco.objects;
  }

  /**
   * tag the given component ids or all modified/new components if "all" param is set.
   * tag is a similar operation as a snap, which saves the changes into the local scope, but it also creates an alias
   * with a valid semver to that version.
   * tag can be done only on main, not on a lane.
   */
  // eslint-disable-next-line complexity
  async tag({
    ids = [],
    message = '',
    version,
    editor = '',
    snapped = false,
    unmerged = false,
    releaseType,
    preReleaseId,
    ignoreIssues,
    ignoreNewestVersion = false,
    skipTests = false,
    skipAutoTag = false,
    build,
    unmodified = false,
    soft = false,
    persist = false,
    forceDeploy = false,
    incrementBy = 1,
    disableTagAndSnapPipelines = false
  }) {
    build = (0, _featureToggle().isFeatureEnabled)(_featureToggle().BUILD_ON_CI) ? Boolean(build) : true;
    if (soft) build = false;
    if (disableTagAndSnapPipelines && forceDeploy) {
      throw new (_bitError().BitError)('you can use either force-deploy or disable-tag-pipeline, but not both');
    }
    if (editor && persist) {
      throw new (_bitError().BitError)('you can use either --editor or --persist, but not both');
    }
    if (editor && message) {
      throw new (_bitError().BitError)('you can use either --editor or --message, but not both');
    }
    const exactVersion = version;
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    const idsHasWildcard = (0, _hasWildcard().default)(ids);
    const isAll = Boolean(!ids.length || idsHasWildcard);
    const validExactVersion = (0, _semverHelper().validateVersion)(exactVersion);
    const consumer = this.workspace.consumer;
    const componentsList = new (_componentsList().default)(consumer);
    _loader().default.start('determine components to tag...');
    const newComponents = await componentsList.listNewComponents();
    const {
      bitIds,
      warnings
    } = await this.getComponentsToTag(unmodified, exactVersion, persist, ids, snapped, unmerged);
    if (_ramda().default.isEmpty(bitIds)) return null;
    const legacyBitIds = _bitId().BitIds.fromArray(bitIds);
    this.logger.debug(`tagging the following components: ${legacyBitIds.toString()}`);
    _analytics().Analytics.addBreadCrumb('tag', `tagging the following components: ${_analytics().Analytics.hashData(legacyBitIds)}`);
    if (!soft) {
      await this.workspace.consumer.componentFsCache.deleteAllDependenciesDataCache();
    }
    const components = await this.loadComponentsForTag(legacyBitIds);
    await this.throwForLegacyDependenciesInsideHarmony(components);
    await this.throwForComponentIssues(components, ignoreIssues);
    this.throwForPendingImport(components);
    const {
      taggedComponents,
      autoTaggedResults,
      publishedPackages
    } = await (0, _tagModelComponent().tagModelComponent)({
      workspace: this.workspace,
      scope: this.scope,
      snapping: this,
      builder: this.builder,
      consumerComponents: components,
      ids: legacyBitIds,
      message,
      editor,
      exactVersion: validExactVersion,
      releaseType,
      preReleaseId,
      ignoreNewestVersion,
      skipTests,
      skipAutoTag,
      soft,
      build,
      persist,
      disableTagAndSnapPipelines,
      forceDeploy,
      incrementBy,
      packageManagerConfigRootDir: this.workspace.path,
      dependencyResolver: this.dependencyResolver
    });
    const tagResults = {
      taggedComponents,
      autoTaggedResults,
      isSoftTag: soft,
      publishedPackages
    };
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    tagResults.warnings = warnings;

    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    tagResults.newComponents = newComponents;
    const postHook = isAll ? _constants().POST_TAG_ALL_HOOK : _constants().POST_TAG_HOOK;
    HooksManagerInstance === null || HooksManagerInstance === void 0 ? void 0 : HooksManagerInstance.triggerHook(postHook, tagResults);
    _analytics().Analytics.setExtraData('num_components',
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    _ramda().default.concat(tagResults.taggedComponents, tagResults.autoTaggedResults, tagResults.newComponents).length);
    await consumer.onDestroy();
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return tagResults;
  }
  async tagFromScope(params) {
    if (this.workspace) {
      throw new (_bitError().BitError)(`unable to run this command from a workspace, please create a new bare-scope and run it from there`);
    }
    const componentIds = await this.scope.resolveMultipleComponentIds(params.ids);
    const componentIdsLatest = componentIds.map(id => id.changeVersion(_constants().LATEST));
    const components = await this.scope.import(componentIdsLatest);
    const consumerComponents = components.map(c => c.state._consumer);
    const legacyIds = _bitId().BitIds.fromArray(componentIds.map(id => id._legacy));
    const results = await (0, _tagModelComponent().tagModelComponent)(_objectSpread(_objectSpread({}, params), {}, {
      scope: this.scope,
      consumerComponents,
      snapping: this,
      builder: this.builder,
      dependencyResolver: this.dependencyResolver,
      skipAutoTag: false,
      persist: true,
      ids: legacyIds,
      message: params.message
    }));
    const {
      taggedComponents,
      autoTaggedResults,
      publishedPackages
    } = results;
    if (params.push) {
      await this.exporter.exportMany({
        scope: this.scope.legacyScope,
        ids: legacyIds,
        idsWithFutureScope: legacyIds,
        allVersions: false
      });
    }
    return {
      taggedComponents,
      autoTaggedResults,
      isSoftTag: false,
      publishedPackages,
      warnings: [],
      newComponents: new (_bitId().BitIds)()
    };
  }

  /**
   * save the local changes of a component(s) into the scope. snap can be done on main or on a lane.
   * once a component is snapped on a lane, it becomes part of it.
   */
  async snap({
    pattern,
    legacyBitIds,
    // @todo: change to ComponentID[]. pass only if have the ids already parsed.
    unmerged,
    message = '',
    ignoreIssues,
    skipTests = false,
    skipAutoSnap = false,
    build,
    disableTagAndSnapPipelines = false,
    forceDeploy = false,
    unmodified = false
  }) {
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    if (pattern && legacyBitIds) throw new Error(`please pass either pattern or legacyBitIds, not both`);
    const consumer = this.workspace.consumer;
    const componentsList = new (_componentsList().default)(consumer);
    const newComponents = await componentsList.listNewComponents();
    const ids = legacyBitIds || (await getIdsToSnap(this.workspace));
    if (!ids) return null;
    this.logger.debug(`snapping the following components: ${ids.toString()}`);
    await this.workspace.consumer.componentFsCache.deleteAllDependenciesDataCache();
    const components = await this.loadComponentsForTag(ids);
    await this.throwForLegacyDependenciesInsideHarmony(components);
    await this.throwForComponentIssues(components, ignoreIssues);
    this.throwForPendingImport(components);
    const {
      taggedComponents,
      autoTaggedResults
    } = await (0, _tagModelComponent().tagModelComponent)({
      workspace: this.workspace,
      scope: this.scope,
      snapping: this,
      builder: this.builder,
      consumerComponents: components,
      ids,
      ignoreNewestVersion: false,
      message,
      skipTests,
      skipAutoTag: skipAutoSnap,
      persist: true,
      soft: false,
      build,
      isSnap: true,
      disableTagAndSnapPipelines,
      forceDeploy,
      packageManagerConfigRootDir: this.workspace.path,
      dependencyResolver: this.dependencyResolver
    });
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const snapResults = {
      snappedComponents: taggedComponents,
      autoSnappedResults: autoTaggedResults
    };
    snapResults.newComponents = newComponents;
    const currentLane = consumer.getCurrentLaneId();
    snapResults.laneName = currentLane.isDefault() ? null : currentLane.name;
    await consumer.onDestroy();
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return snapResults;
    async function getIdsToSnap(workspace) {
      if (unmerged) {
        return componentsList.listDuringMergeStateComponents();
      }
      const tagPendingComponents = unmodified ? await componentsList.listPotentialTagAllWorkspace() : await componentsList.listTagPendingComponents();
      if (_ramda().default.isEmpty(tagPendingComponents)) return null;
      const tagPendingComponentsIds = await workspace.resolveMultipleComponentIds(tagPendingComponents);
      // when unmodified, we ask for all components, throw if no matching. if not unmodified and no matching, see error
      // below, suggesting to use --unmodified flag.
      const shouldThrowForNoMatching = unmodified;
      const getCompIds = async () => {
        if (!pattern) return tagPendingComponentsIds;
        if (!pattern.includes('*') && !pattern.includes(',')) {
          const compId = await workspace.resolveComponentId(pattern);
          return [compId];
        }
        return workspace.scope.filterIdsFromPoolIdsByPattern(pattern, tagPendingComponentsIds, shouldThrowForNoMatching);
      };
      const componentIds = await getCompIds();
      if (!componentIds.length && pattern) {
        const allTagPending = await componentsList.listPotentialTagAllWorkspace();
        if (allTagPending.length) {
          throw new (_bitError().BitError)(`unable to find matching for "${pattern}" pattern among modified/new components.
there are matching among unmodified components thought. consider using --unmodified flag if needed`);
        }
      }
      if (!componentIds.length) {
        return null;
      }
      return _bitId().BitIds.fromArray(componentIds.map(c => c._legacy));
    }
  }

  /**
   * remove tags/snaps that exist locally, which were not exported yet.
   * once a tag/snap is exported, it's impossible to delete it as other components may depend on it
   */
  async reset(componentPattern, head, force = false, soft = false) {
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    const consumer = this.workspace.consumer;
    const currentLane = await consumer.getCurrentLaneObject();
    const untag = async () => {
      if (!componentPattern) {
        return (0, _untagComponent().removeLocalVersionsForAllComponents)(consumer, currentLane, head);
      }
      const candidateComponents = await (0, _untagComponent().getComponentsWithOptionToUntag)(consumer);
      const idsMatchingPattern = await this.workspace.idsByPattern(componentPattern);
      const idsMatchingPatternBitIds = _bitId().BitIds.fromArray(idsMatchingPattern.map(id => id._legacy));
      const componentsToUntag = candidateComponents.filter(modelComponent => idsMatchingPatternBitIds.hasWithoutVersion(modelComponent.toBitId()));
      return (0, _untagComponent().removeLocalVersionsForMultipleComponents)(componentsToUntag, currentLane, head, force, consumer.scope);
    };
    const softUntag = async () => {
      const componentsList = new (_componentsList().default)(consumer);
      const softTaggedComponents = componentsList.listSoftTaggedComponents();
      const softTaggedComponentsIds = await this.workspace.resolveMultipleComponentIds(softTaggedComponents);
      const idsToRemoveSoftTags = componentPattern ? this.workspace.scope.filterIdsFromPoolIdsByPattern(componentPattern, softTaggedComponentsIds) : softTaggedComponentsIds;
      return (0, _lodash().compact)(idsToRemoveSoftTags.map(componentId => {
        var _componentMap$nextVer;
        const componentMap = consumer.bitMap.getComponent(componentId._legacy, {
          ignoreScopeAndVersion: true
        });
        const removedVersion = (_componentMap$nextVer = componentMap.nextVersion) === null || _componentMap$nextVer === void 0 ? void 0 : _componentMap$nextVer.version;
        if (!removedVersion) return null;
        componentMap.clearNextVersion();
        return {
          id: componentId._legacy,
          versions: [removedVersion]
        };
      }));
    };
    let results;
    const isRealUntag = !soft;
    if (isRealUntag) {
      results = await untag();
      await consumer.scope.objects.persist();
      const components = results.map(result => result.component);
      await (0, _tagModelComponent().updateComponentsVersions)(this.workspace, components, false);
    } else {
      results = await softUntag();
      consumer.bitMap.markAsChanged();
    }
    await consumer.onDestroy();
    return {
      results,
      isSoftUntag: !isRealUntag
    };
  }
  async _addFlattenedDependenciesToComponents(scope, components) {
    _loader().default.start('importing missing dependencies...');
    const flattenedDependenciesGetter = new (_getFlattenedDependencies().FlattenedDependenciesGetter)(scope, components);
    await flattenedDependenciesGetter.populateFlattenedDependencies();
    _loader().default.stop();
  }
  _updateComponentsByTagResult(components, tagResult) {
    tagResult.forEach(result => {
      const matchingComponent = components.find(c => c.id.isEqual(result.id));
      if (matchingComponent) {
        const existingBuilder = matchingComponent.extensions.findCoreExtension(_constants().Extensions.builder);
        if (existingBuilder) existingBuilder.data = result.builderData.data;else matchingComponent.extensions.push(result.builderData);
      }
    });
  }
  _getPublishedPackages(components) {
    const publishedPackages = components.map(comp => {
      var _builderExt$data, _builderExt$data$aspe, _pkgData$data;
      const builderExt = comp.extensions.findCoreExtension(_constants().Extensions.builder);
      const pkgData = builderExt === null || builderExt === void 0 ? void 0 : (_builderExt$data = builderExt.data) === null || _builderExt$data === void 0 ? void 0 : (_builderExt$data$aspe = _builderExt$data.aspectsData) === null || _builderExt$data$aspe === void 0 ? void 0 : _builderExt$data$aspe.find(a => a.aspectId === _constants().Extensions.pkg);
      return pkgData === null || pkgData === void 0 ? void 0 : (_pkgData$data = pkgData.data) === null || _pkgData$data === void 0 ? void 0 : _pkgData$data.publishedPackage;
    });
    return (0, _lodash().compact)(publishedPackages);
  }
  async _addCompToObjects({
    source,
    consumer,
    lane,
    shouldValidateVersion = false
  }) {
    // if a component exists in the model, add a new version. Otherwise, create a new component on the model
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const component = await this.scope.legacyScope.sources.findOrAddComponent(source);
    const artifactFiles = (0, _artifactFiles().getArtifactsFiles)(source.extensions);
    const artifacts = this.transformArtifactsFromVinylToSource(artifactFiles);
    const {
      version,
      files
    } = await this.scope.legacyScope.sources.consumerComponentToVersion(source);
    this.objectsRepo.add(version);
    if (!source.version) throw new Error(`addSource expects source.version to be set`);
    component.addVersion(version, source.version, lane, this.objectsRepo);
    const unmergedComponent = consumer.scope.objects.unmergedComponents.getEntry(component.name);
    if (unmergedComponent) {
      if (unmergedComponent.unrelated) {
        this.logger.debug(`sources.addSource, unmerged component "${component.name}". adding an unrelated entry ${unmergedComponent.head.hash}`);
        version.unrelated = {
          head: unmergedComponent.head,
          laneId: unmergedComponent.laneId
        };
      } else {
        version.addParent(unmergedComponent.head);
        this.logger.debug(`sources.addSource, unmerged component "${component.name}". adding a parent ${unmergedComponent.head.hash}`);
        version.log.message = version.log.message || _unmergedComponents().default.buildSnapMessage(unmergedComponent);
      }
      consumer.scope.objects.unmergedComponents.removeComponent(component.name);
    }
    this.objectsRepo.add(component);
    files.forEach(file => this.objectsRepo.add(file.file));
    if (artifacts) artifacts.forEach(file => this.objectsRepo.add(file.source));
    if (shouldValidateVersion) version.validate();
    return component;
  }
  async _addCompFromScopeToObjects(source, lane) {
    const objectRepo = this.objectsRepo;
    // if a component exists in the model, add a new version. Otherwise, create a new component on the model
    const component = await this.scope.legacyScope.sources.findOrAddComponent(source);
    const artifactFiles = (0, _artifactFiles().getArtifactsFiles)(source.extensions);
    const artifacts = this.transformArtifactsFromVinylToSource(artifactFiles);
    const {
      version,
      files
    } = await this.scope.legacyScope.sources.consumerComponentToVersion(source);
    objectRepo.add(version);
    if (!source.version) throw new Error(`addSource expects source.version to be set`);
    component.addVersion(version, source.version, lane, objectRepo);
    objectRepo.add(component);
    files.forEach(file => objectRepo.add(file.file));
    if (artifacts) artifacts.forEach(file => objectRepo.add(file.source));
    return component;
  }
  async _enrichComp(consumerComponent) {
    const objects = await this._getObjectsToEnrichComp(consumerComponent);
    objects.forEach(obj => this.objectsRepo.add(obj));
    return consumerComponent;
  }
  async _getObjectsToEnrichComp(consumerComponent) {
    const component = consumerComponent.modelComponent || (await this.scope.legacyScope.sources.findOrAddComponent(consumerComponent));
    const version = await component.loadVersion(consumerComponent.id.version, this.objectsRepo, true, true);
    const artifactFiles = (0, _artifactFiles().getArtifactsFiles)(consumerComponent.extensions);
    const artifacts = this.transformArtifactsFromVinylToSource(artifactFiles);
    version.extensions = consumerComponent.extensions;
    version.buildStatus = consumerComponent.buildStatus;
    const artifactObjects = artifacts.map(file => file.source);
    return [version, ...artifactObjects];
  }
  transformArtifactsFromVinylToSource(artifactsFiles) {
    const artifacts = [];
    artifactsFiles.forEach(artifactFiles => {
      const artifactsSource = _artifactFiles().ArtifactFiles.fromVinylsToSources(artifactFiles.vinyls);
      if (artifactsSource.length) artifactFiles.populateRefsFromSources(artifactsSource);
      artifacts.push(...artifactsSource);
    });
    return artifacts;
  }
  async loadComponentsForTag(ids) {
    const {
      components,
      removedComponents
    } = await this.workspace.consumer.loadComponents(ids.toVersionLatest());
    components.forEach(component => {
      const componentMap = component.componentMap;
      if (!componentMap.rootDir) {
        throw new Error(`unable to tag ${component.id.toString()}, the "rootDir" is missing in the .bitmap file`);
      }
    });
    return [...components, ...removedComponents];
  }
  async throwForComponentIssues(legacyComponents, ignoreIssues) {
    if (ignoreIssues === '*') {
      // ignore all issues
      return;
    }
    const issuesToIgnoreFromFlag = (ignoreIssues === null || ignoreIssues === void 0 ? void 0 : ignoreIssues.split(',').map(issue => issue.trim())) || [];
    const issuesToIgnoreFromConfig = this.issues.getIssuesToIgnoreGlobally();
    const issuesToIgnore = [...issuesToIgnoreFromFlag, ...issuesToIgnoreFromConfig];
    const components = await this.workspace.getManyByLegacy(legacyComponents);
    await this.issues.triggerAddComponentIssues(components, issuesToIgnore);
    this.issues.removeIgnoredIssuesFromComponents(components);
    const componentsWithBlockingIssues = legacyComponents.filter(component => {
      var _component$issues;
      return (_component$issues = component.issues) === null || _component$issues === void 0 ? void 0 : _component$issues.shouldBlockTagging();
    });
    if (!_ramda().default.isEmpty(componentsWithBlockingIssues)) {
      throw new (_componentsHaveIssues().ComponentsHaveIssues)(componentsWithBlockingIssues);
    }
  }
  throwForPendingImport(components) {
    const areComponentsMissingFromScope = components.filter(c => !c.removed).some(c => !c.componentFromModel && c.id.hasScope());
    if (areComponentsMissingFromScope) {
      throw new (_componentsPendingImport().default)();
    }
  }
  async throwForLegacyDependenciesInsideHarmony(components) {
    const throwForComponent = async component => {
      const dependenciesIds = component.getAllDependenciesIds();
      const legacyScope = this.workspace.scope.legacyScope;
      await Promise.all(dependenciesIds.map(async depId => {
        if (!depId.hasVersion()) return;
        const modelComp = await legacyScope.getModelComponentIfExist(depId);
        if (!modelComp) return;
        const version = await modelComp.loadVersion(depId.version, legacyScope.objects);
        if (version.isLegacy) {
          throw new Error(`unable tagging "${component.id.toString()}", its dependency "${depId.toString()}" is legacy`);
        }
      }));
    };
    await (0, _pMap().default)(components, component => throwForComponent(component), {
      concurrency: (0, _concurrency().concurrentComponentsLimit)()
    });
  }
  async getComponentsToTag(includeUnmodified, exactVersion, persist, ids, snapped, unmerged) {
    const warnings = [];
    const componentsList = new (_componentsList().default)(this.workspace.consumer);
    if (persist) {
      const softTaggedComponents = componentsList.listSoftTaggedComponents();
      return {
        bitIds: softTaggedComponents,
        warnings: []
      };
    }
    const tagPendingBitIds = includeUnmodified ? await componentsList.listPotentialTagAllWorkspace() : await componentsList.listTagPendingComponents();
    const tagPendingComponentsIds = await this.workspace.resolveMultipleComponentIds(tagPendingBitIds);
    const snappedComponents = await componentsList.listSnappedComponentsOnMain();
    const snappedComponentsIds = snappedComponents.map(c => c.toBitId());
    if (ids.length) {
      const componentIds = await (0, _pMapSeries().default)(ids, async id => {
        const [idWithoutVer, version] = id.split('@');
        const idHasWildcard = (0, _hasWildcard().default)(id);
        if (idHasWildcard) {
          const allIds = this.workspace.scope.filterIdsFromPoolIdsByPattern(idWithoutVer, tagPendingComponentsIds);
          return allIds.map(componentId => componentId.changeVersion(version));
        }
        const componentId = await this.workspace.resolveComponentId(idWithoutVer);
        if (!includeUnmodified) {
          const componentStatus = await this.workspace.consumer.getComponentStatusById(componentId._legacy);
          if (componentStatus.modified === false) return null;
        }
        return componentId.changeVersion(version);
      });
      return {
        bitIds: (0, _lodash().compact)(componentIds.flat()).map(bitId => bitId._legacy),
        warnings
      };
    }
    if (snapped) {
      return {
        bitIds: snappedComponentsIds,
        warnings
      };
    }
    if (unmerged) {
      return {
        bitIds: componentsList.listDuringMergeStateComponents(),
        warnings
      };
    }
    const tagPendingBitIdsIncludeSnapped = [...tagPendingBitIds, ...snappedComponentsIds];
    if (includeUnmodified && exactVersion) {
      const tagPendingComponentsLatest = await this.workspace.scope.legacyScope.latestVersions(tagPendingBitIds, false);
      tagPendingComponentsLatest.forEach(componentId => {
        if (componentId.version && _semver().default.valid(componentId.version) && _semver().default.gt(componentId.version, exactVersion)) {
          warnings.push(`warning: ${componentId.toString()} has a version greater than ${exactVersion}`);
        }
      });
    }
    return {
      bitIds: tagPendingBitIdsIncludeSnapped.map(id => id.changeVersion(undefined)),
      warnings
    };
  }
  static async provider([workspace, cli, community, loggerMain, issues, insights, dependencyResolver, scope, exporter, builder]) {
    const logger = loggerMain.createLogger(_snapping().SnappingAspect.id);
    const snapping = new SnappingMain(workspace, logger, issues, insights, dependencyResolver, scope, exporter, builder);
    const snapCmd = new (_snapCmd().SnapCmd)(community.getBaseDomain(), snapping, logger);
    const tagCmd = new (_tagCmd().TagCmd)(snapping, logger);
    const tagFromScopeCmd = new (_tagFromScope().TagFromScopeCmd)(snapping, logger);
    const resetCmd = new (_resetCmd().default)(snapping);
    cli.register(tagCmd, snapCmd, resetCmd, tagFromScopeCmd);
    return snapping;
  }
}
exports.SnappingMain = SnappingMain;
(0, _defineProperty2().default)(SnappingMain, "slots", []);
(0, _defineProperty2().default)(SnappingMain, "dependencies", [_workspace().default, _cli().CLIAspect, _community().default, _logger().LoggerAspect, _issues().default, _insights().InsightsAspect, _dependencyResolver().DependencyResolverAspect, _scope().ScopeAspect, _export().ExportAspect, _builder().BuilderAspect]);
(0, _defineProperty2().default)(SnappingMain, "runtime", _cli().MainRuntime);
_snapping().SnappingAspect.addRuntime(SnappingMain);
var _default = SnappingMain;
exports.default = _default;

//# sourceMappingURL=snapping.main.runtime.js.map