"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SnapCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _componentIssues() {
  const data = require("@teambit/component-issues");
  _componentIssues = function () {
    return data;
  };
  return data;
}
function _featureToggle() {
  const data = require("@teambit/legacy/dist/api/consumer/lib/feature-toggle");
  _featureToggle = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
class SnapCmd {
  constructor(docsDomain, snapping, logger) {
    this.snapping = snapping;
    this.logger = logger;
    (0, _defineProperty2().default)(this, "name", 'snap [component-pattern]');
    (0, _defineProperty2().default)(this, "description", 'EXPERIMENTAL. create an immutable and exportable component snapshot (no release version)');
    (0, _defineProperty2().default)(this, "extendedDescription", void 0);
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'component-pattern',
      description: `${_constants().COMPONENT_PATTERN_HELP}. By default, all new and modified components are snapped.`
    }]);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['m', 'message <message>', 'log message describing the latest changes'], ['', 'unmodified', 'include unmodified components (by default, only new and modified components are snapped)'], ['', 'unmerged', 'EXPERIMENTAL. complete a merge process by snapping the unmerged components'], ['', 'build', 'Harmony only. run the pipeline build and complete the tag'], ['', 'skip-tests', 'skip running component tests during snap process'], ['', 'skip-auto-snap', 'skip auto snapping dependents'], ['', 'disable-snap-pipeline', 'skip the snap pipeline'], ['', 'force-deploy', 'Harmony only. run the deploy pipeline although the build failed'], ['i', 'ignore-issues [issues]', `ignore component issues (shown in "bit status" as "issues found"), issues to ignore:
[${Object.keys(_componentIssues().IssuesClasses).join(', ')}]
to ignore multiple issues, separate them by a comma and wrap with quotes. to ignore all issues, specify "*".`], ['a', 'all', 'DEPRECATED (not needed anymore, it is the default now). snap all new and modified components'], ['f', 'force', 'DEPRECATED (use "--skip-tests" or "--unmodified" instead). force-snap even if tests are failing and even when component has not changed']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
    this.extendedDescription = `https://${docsDomain}/components/snaps
${(0, _constants().WILDCARD_HELP)('snap')}`;
  }
  async report([pattern], {
    message = '',
    all = false,
    force = false,
    unmerged = false,
    ignoreIssues,
    build,
    skipTests = false,
    skipAutoSnap = false,
    disableSnapPipeline = false,
    forceDeploy = false,
    unmodified = false
  }) {
    build = (0, _featureToggle().isFeatureEnabled)(_featureToggle().BUILD_ON_CI) ? Boolean(build) : true;
    const disableTagAndSnapPipelines = disableSnapPipeline;
    if (disableTagAndSnapPipelines && forceDeploy) {
      throw new (_bitError().BitError)('you can use either force-deploy or disable-snap-pipeline, but not both');
    }
    if (all) {
      this.logger.consoleWarning(`--all is deprecated, please omit it. "bit snap" by default will snap all new and modified components`);
    }
    if (force) {
      this.logger.consoleWarning(`--force is deprecated, use either --skip-tests or --unmodified depending on the use case`);
      if (pattern) unmodified = true;
    }
    if (!message) {
      this.logger.consoleWarning(`--message will be mandatory in the next few releases. make sure to add a message with your snap`);
    }
    const results = await this.snapping.snap({
      pattern,
      message,
      unmerged,
      ignoreIssues,
      build,
      skipTests,
      skipAutoSnap,
      disableTagAndSnapPipelines,
      forceDeploy,
      unmodified
    });
    if (!results) return _chalk().default.yellow(_constants().NOTHING_TO_SNAP_MSG);
    const {
      snappedComponents,
      autoSnappedResults,
      warnings,
      newComponents,
      laneName
    } = results;
    const changedComponents = snappedComponents.filter(component => !newComponents.searchWithoutVersion(component.id));
    const addedComponents = snappedComponents.filter(component => newComponents.searchWithoutVersion(component.id));
    const autoTaggedCount = autoSnappedResults ? autoSnappedResults.length : 0;
    const warningsOutput = warnings && warnings.length ? `${_chalk().default.yellow(warnings.join('\n'))}\n\n` : '';
    const tagExplanation = `\n(use "bit export" to push these components to a remote")
(use "bit reset" to unstage versions)\n`;
    const outputComponents = comps => {
      return comps.map(component => {
        let componentOutput = `     > ${component.id.toString()}`;
        const autoTag = autoSnappedResults.filter(result => result.triggeredBy.searchWithoutScopeAndVersion(component.id));
        if (autoTag.length) {
          const autoTagComp = autoTag.map(a => a.component.id.toString());
          componentOutput += `\n       ${_constants().AUTO_SNAPPED_MSG} (${autoTagComp.length} total):
            ${autoTagComp.join('\n            ')}`;
        }
        return componentOutput;
      }).join('\n');
    };
    const outputIfExists = (label, explanation, components) => {
      if (!components.length) return '';
      return `\n${_chalk().default.underline(label)}\n(${explanation})\n${outputComponents(components)}\n`;
    };
    const laneStr = laneName ? ` on "${laneName}" lane` : '';
    return warningsOutput + _chalk().default.green(`${snappedComponents.length + autoTaggedCount} component(s) snapped${laneStr}`) + tagExplanation + outputIfExists('new components', 'first version for components', addedComponents) + outputIfExists('changed components', 'components that got a version bump', changedComponents);
  }
}
exports.SnapCmd = SnapCmd;

//# sourceMappingURL=snap-cmd.js.map