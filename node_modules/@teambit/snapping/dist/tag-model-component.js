"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tagModelComponent = tagModelComponent;
exports.updateComponentsVersions = updateComponentsVersions;
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _nodeFetch() {
  const data = _interopRequireDefault(require("node-fetch"));
  _nodeFetch = function () {
    return data;
  };
  return data;
}
function _ramda() {
  const data = _interopRequireDefault(require("ramda"));
  _ramda = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _uuid() {
  const data = require("uuid");
  _uuid = function () {
    return data;
  };
  return data;
}
function globalConfig() {
  const data = _interopRequireWildcard(require("@teambit/legacy/dist/api/consumer/lib/global-config"));
  globalConfig = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _componentSchema() {
  const data = require("@teambit/legacy/dist/consumer/component/component-schema");
  _componentSchema = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _showDoctorError() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/error/show-doctor-error"));
  _showDoctorError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@teambit/legacy/dist/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _autoTag() {
  const data = require("@teambit/legacy/dist/scope/component-ops/auto-tag");
  _autoTag = function () {
    return data;
  };
  return data;
}
function _semverHelper() {
  const data = require("@teambit/legacy/dist/utils/semver-helper");
  _semverHelper = function () {
    return data;
  };
  return data;
}
function _messagePerComponent() {
  const data = require("@teambit/legacy/dist/scope/component-ops/message-per-component");
  _messagePerComponent = function () {
    return data;
  };
  return data;
}
function _models() {
  const data = require("@teambit/legacy/dist/scope/models");
  _models = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function updateDependenciesVersions(componentsToTag, dependencyResolver) {
  const getNewDependencyVersion = id => {
    const foundDependency = componentsToTag.find(component => component.id.isEqualWithoutVersion(id));
    return foundDependency ? id.changeVersion(foundDependency.version) : null;
  };
  const changeExtensionsVersion = component => {
    component.extensions.forEach(ext => {
      if (ext.extensionId) {
        const newDepId = getNewDependencyVersion(ext.extensionId);
        if (newDepId) ext.extensionId = newDepId;
      }
    });
  };
  componentsToTag.forEach(oneComponentToTag => {
    oneComponentToTag.getAllDependencies().forEach(dependency => {
      const newDepId = getNewDependencyVersion(dependency.id);
      if (newDepId) dependency.id = newDepId;
    });
    changeExtensionsVersion(oneComponentToTag);
    // @ts-ignore
    oneComponentToTag = dependencyResolver.updateDepsOnLegacyTag(oneComponentToTag, getNewDependencyVersion.bind(this));
  });
}
function setHashes(componentsToTag) {
  componentsToTag.forEach(componentToTag => {
    componentToTag.version = (0, _utils().sha1)((0, _uuid().v4)());
  });
}
async function setFutureVersions(componentsToTag, scope, releaseType, exactVersion, persist, autoTagIds, ids, incrementBy, preRelease, soft) {
  await Promise.all(componentsToTag.map(async componentToTag => {
    var _componentToTag$compo, _componentToTag$compo2;
    const isAutoTag = autoTagIds.hasWithoutVersion(componentToTag.id);
    const modelComponent = await scope.sources.findOrAddComponent(componentToTag);
    const nextVersion = (_componentToTag$compo = componentToTag.componentMap) === null || _componentToTag$compo === void 0 ? void 0 : (_componentToTag$compo2 = _componentToTag$compo.nextVersion) === null || _componentToTag$compo2 === void 0 ? void 0 : _componentToTag$compo2.version;
    componentToTag.previouslyUsedVersion = componentToTag.version;
    if (nextVersion && persist) {
      var _componentToTag$compo3, _componentToTag$compo4;
      const exactVersionOrReleaseType = (0, _semverHelper().getValidVersionOrReleaseType)(nextVersion);
      componentToTag.version = modelComponent.getVersionToAdd(exactVersionOrReleaseType.releaseType, exactVersionOrReleaseType.exactVersion, undefined, (_componentToTag$compo3 = componentToTag.componentMap) === null || _componentToTag$compo3 === void 0 ? void 0 : (_componentToTag$compo4 = _componentToTag$compo3.nextVersion) === null || _componentToTag$compo4 === void 0 ? void 0 : _componentToTag$compo4.preRelease);
    } else if (isAutoTag) {
      // auto-tag always bumped as patch
      componentToTag.version = soft ? 'patch' : modelComponent.getVersionToAdd('patch', undefined, incrementBy, preRelease);
    } else {
      const versionByEnteredId = getVersionByEnteredId(ids, componentToTag, modelComponent);
      componentToTag.version = soft ? versionByEnteredId || exactVersion || releaseType : versionByEnteredId || modelComponent.getVersionToAdd(releaseType, exactVersion, incrementBy, preRelease);
    }
  }));
}
function getVersionByEnteredId(enteredIds, component, modelComponent) {
  const enteredId = enteredIds.searchWithoutVersion(component.id);
  if (enteredId && enteredId.hasVersion()) {
    const exactVersionOrReleaseType = (0, _semverHelper().getValidVersionOrReleaseType)(enteredId.version);
    return modelComponent.getVersionToAdd(exactVersionOrReleaseType.releaseType, exactVersionOrReleaseType.exactVersion);
  }
  return undefined;
}
async function tagModelComponent({
  workspace,
  scope,
  snapping,
  builder,
  consumerComponents,
  ids,
  message,
  editor,
  exactVersion,
  releaseType,
  preReleaseId,
  ignoreNewestVersion = false,
  skipTests = false,
  skipAutoTag,
  soft,
  build,
  persist,
  isSnap = false,
  disableTagAndSnapPipelines,
  forceDeploy,
  incrementBy,
  packageManagerConfigRootDir,
  dependencyResolver
}) {
  const consumer = workspace === null || workspace === void 0 ? void 0 : workspace.consumer;
  const legacyScope = scope.legacyScope;
  const consumerComponentsIdsMap = {};
  // Concat and unique all the dependencies from all the components so we will not import
  // the same dependency more then once, it's mainly for performance purpose
  consumerComponents.forEach(consumerComponent => {
    const componentIdString = consumerComponent.id.toString();
    // Store it in a map so we can take it easily from the sorted array which contain only the id
    consumerComponentsIdsMap[componentIdString] = consumerComponent;
  });
  const componentsToTag = _ramda().default.values(consumerComponentsIdsMap); // consumerComponents unique
  const idsToTag = _bitId().BitIds.fromArray(componentsToTag.map(c => c.id));
  // ids without versions are new. it's impossible that tagged (and not-modified) components has
  // them as dependencies.
  const idsToTriggerAutoTag = idsToTag.filter(id => id.hasVersion());
  const autoTagData = skipAutoTag || !consumer ? [] : await (0, _autoTag().getAutoTagInfo)(consumer, _bitId().BitIds.fromArray(idsToTriggerAutoTag));
  const autoTagComponents = autoTagData.map(autoTagItem => autoTagItem.component);
  const autoTagComponentsFiltered = autoTagComponents.filter(c => !idsToTag.has(c.id));
  const autoTagIds = _bitId().BitIds.fromArray(autoTagComponentsFiltered.map(autoTag => autoTag.id));
  const allComponentsToTag = [...componentsToTag, ...autoTagComponentsFiltered];
  const messagesFromEditorFetcher = new (_messagePerComponent().MessagePerComponentFetcher)(idsToTag, autoTagIds);
  const messagePerId = editor ? await messagesFromEditorFetcher.getMessagesFromEditor(legacyScope.tmp, editor) : [];

  // check for each one of the components whether it is using an old version
  if (!ignoreNewestVersion && !isSnap) {
    const newestVersionsP = allComponentsToTag.map(async component => {
      if (component.componentFromModel) {
        // otherwise it's a new component, so this check is irrelevant
        const modelComponent = await legacyScope.getModelComponentIfExist(component.id);
        if (!modelComponent) throw new (_showDoctorError().default)(`component ${component.id} was not found in the model`);
        if (!modelComponent.listVersions().length) return null; // no versions yet, no issues.
        const latest = modelComponent.latest();
        if (latest !== component.version) {
          return {
            componentId: component.id.toStringWithoutVersion(),
            currentVersion: component.version,
            latestVersion: latest
          };
        }
      }
      return null;
    });
    const newestVersions = await Promise.all(newestVersionsP);
    const newestVersionsWithoutEmpty = newestVersions.filter(newest => newest);
    if (!(0, _lodash().isEmpty)(newestVersionsWithoutEmpty)) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      throw new (_exceptions().NewerVersionFound)(newestVersionsWithoutEmpty);
    }
  }
  _logger().default.debugAndAddBreadCrumb('tag-model-components', 'sequentially persist all components');
  // go through all components and find the future versions for them
  isSnap ? setHashes(allComponentsToTag) : await setFutureVersions(allComponentsToTag, legacyScope, releaseType, exactVersion, persist, autoTagIds, ids, incrementBy, preReleaseId, soft);
  setCurrentSchema(allComponentsToTag);
  // go through all dependencies and update their versions
  updateDependenciesVersions(allComponentsToTag, dependencyResolver);
  await addLogToComponents(componentsToTag, autoTagComponents, persist, message, messagePerId);
  if (soft) {
    if (!consumer) throw new Error(`unable to soft-tag without consumer`);
    consumer.updateNextVersionOnBitmap(allComponentsToTag, preReleaseId);
  } else {
    await snapping._addFlattenedDependenciesToComponents(legacyScope, allComponentsToTag);
    emptyBuilderData(allComponentsToTag);
    addBuildStatus(allComponentsToTag, _constants().BuildStatus.Pending);
    await addComponentsToScope(legacyScope, snapping, allComponentsToTag, Boolean(build), consumer);
    if (workspace) await updateComponentsVersions(workspace, allComponentsToTag);
  }
  const publishedPackages = [];
  if (build) {
    const onTagOpts = {
      disableTagAndSnapPipelines,
      throwOnError: true,
      forceDeploy,
      skipTests,
      isSnap
    };
    const seedersOnly = !workspace; // if tag from scope, build only the given components
    const isolateOptions = {
      packageManagerConfigRootDir,
      seedersOnly
    };
    await scope.reloadAspectsWithNewVersion(allComponentsToTag);
    const harmonyComps = await (workspace || scope).getManyByLegacy(allComponentsToTag);
    const {
      builderDataMap
    } = await builder.tagListener(harmonyComps, onTagOpts, isolateOptions);
    const buildResult = scope.builderDataMapToLegacyOnTagResults(builderDataMap);
    snapping._updateComponentsByTagResult(allComponentsToTag, buildResult);
    publishedPackages.push(...snapping._getPublishedPackages(allComponentsToTag));
    addBuildStatus(allComponentsToTag, _constants().BuildStatus.Succeed);
    await (0, _pMapSeries().default)(allComponentsToTag, consumerComponent => snapping._enrichComp(consumerComponent));
  }
  if (!soft) {
    await removeDeletedComponentsFromBitmap(allComponentsToTag, workspace);
    await legacyScope.objects.persist();
  }
  return {
    taggedComponents: componentsToTag,
    autoTaggedResults: autoTagData,
    publishedPackages
  };
}
async function removeDeletedComponentsFromBitmap(comps, workspace) {
  if (!workspace) {
    return;
  }
  await Promise.all(comps.map(async comp => {
    if (comp.removed) {
      const compId = await workspace.resolveComponentId(comp.id);
      workspace.bitMap.removeComponent(compId);
    }
  }));
}
async function addComponentsToScope(scope, snapping, components, shouldValidateVersion, consumer) {
  const lane = await scope.getCurrentLaneObject();
  if (consumer) {
    await (0, _pMapSeries().default)(components, async component => {
      await snapping._addCompToObjects({
        source: component,
        consumer,
        lane,
        shouldValidateVersion
      });
    });
  } else {
    await (0, _pMapSeries().default)(components, async component => {
      await snapping._addCompFromScopeToObjects(component, lane);
    });
  }
}
function emptyBuilderData(components) {
  components.forEach(component => {
    const existingBuilder = component.extensions.findCoreExtension(_constants().Extensions.builder);
    if (existingBuilder) existingBuilder.data = {};
  });
}
async function addLogToComponents(components, autoTagComps, persist, message, messagePerComponent) {
  const username = await globalConfig().get(_constants().CFG_USER_NAME_KEY);
  const bitCloudUsername = await getBitCloudUsername();
  const email = await globalConfig().get(_constants().CFG_USER_EMAIL_KEY);
  const getLog = component => {
    var _component$componentM, _messagePerComponent$;
    const nextVersion = persist ? (_component$componentM = component.componentMap) === null || _component$componentM === void 0 ? void 0 : _component$componentM.nextVersion : null;
    const msgFromEditor = (_messagePerComponent$ = messagePerComponent.find(item => item.id.isEqualWithoutVersion(component.id))) === null || _messagePerComponent$ === void 0 ? void 0 : _messagePerComponent$.msg;
    return {
      username: (nextVersion === null || nextVersion === void 0 ? void 0 : nextVersion.username) || bitCloudUsername || username,
      email: (nextVersion === null || nextVersion === void 0 ? void 0 : nextVersion.email) || email,
      message: (nextVersion === null || nextVersion === void 0 ? void 0 : nextVersion.message) || msgFromEditor || message,
      date: Date.now().toString()
    };
  };
  components.forEach(component => {
    component.log = getLog(component);
  });
  autoTagComps.forEach(autoTagComp => {
    autoTagComp.log = getLog(autoTagComp);
    const defaultMsg = 'bump dependencies versions';
    if (message) {
      autoTagComp.log.message += ` (${defaultMsg})`;
    } else if (!autoTagComp.log.message) {
      autoTagComp.log.message = defaultMsg;
    }
  });
}
async function getBitCloudUsername() {
  const token = await globalConfig().get(_constants().CFG_USER_TOKEN_KEY);
  if (!token) return '';
  try {
    const res = await (0, _nodeFetch().default)(`https://api.${_constants().BASE_CLOUD_DOMAIN}/user`, {
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });
    const object = await res.json();
    const user = object.payload;
    const username = user.username;
    return username;
  } catch (error) {
    return undefined;
  }
}
function setCurrentSchema(components) {
  components.forEach(component => {
    component.schema = _componentSchema().CURRENT_SCHEMA;
  });
}
function addBuildStatus(components, buildStatus) {
  components.forEach(component => {
    component.buildStatus = buildStatus;
  });
}
async function updateComponentsVersions(workspace, components, isTag = true) {
  const consumer = workspace.consumer;
  const currentLane = consumer.getCurrentLaneId();
  const stagedConfig = await workspace.scope.getStagedConfig();
  const isAvailableOnMain = async (component, id) => {
    if (currentLane.isDefault()) {
      return true;
    }
    if (!id.hasVersion()) {
      // component was unsnapped on the current lane and is back to a new component
      return true;
    }
    const modelComponent = component instanceof _models().ModelComponent ? component : await consumer.scope.getModelComponent(component.id);
    return modelComponent.hasHead();
  };
  const updateVersions = async unknownComponent => {
    const id = unknownComponent instanceof _models().ModelComponent ? unknownComponent.toBitIdWithLatestVersionAllowNull() : unknownComponent.id;
    consumer.bitMap.updateComponentId(id);
    const availableOnMain = await isAvailableOnMain(unknownComponent, id);
    if (!availableOnMain) {
      consumer.bitMap.setComponentProp(id, 'onLanesOnly', true);
    }
    const componentMap = consumer.bitMap.getComponent(id);
    const compId = await workspace.resolveComponentId(id);
    // it can be either a tag/snap or reset.
    if (isTag) {
      const config = componentMap.config;
      stagedConfig.addComponentConfig(compId, config);
      consumer.bitMap.removeConfig(id);
    } else if (!componentMap.config) {
      componentMap.config = stagedConfig.getConfigPerId(compId);
    }
    componentMap.clearNextVersion();
  };
  // important! DO NOT use Promise.all here! otherwise, you're gonna enter into a whole world of pain.
  // imagine tagging comp1 with auto-tagged comp2, comp1 package.json is written while comp2 is
  // trying to get the dependencies of comp1 using its package.json.
  await (0, _pMapSeries().default)(components, updateVersions);
  await stagedConfig.write();
}

//# sourceMappingURL=tag-model-component.js.map