import { CLIMain } from '@teambit/cli';
import { LegacyOnTagResult } from '@teambit/legacy/dist/scope/scope';
import { Scope as LegacyScope } from '@teambit/legacy/dist/scope';
import { CommunityMain } from '@teambit/community';
import { Workspace } from '@teambit/workspace';
import { ReleaseType } from 'semver';
import { BitIds } from '@teambit/legacy/dist/bit-id';
import { Consumer } from '@teambit/legacy/dist/consumer';
import { TagResults } from '@teambit/legacy/dist/api/consumer/lib/tag';
import { SnapResults } from '@teambit/legacy/dist/api/consumer/lib/snap';
import { Logger, LoggerMain } from '@teambit/logger';
import ConsumerComponent from '@teambit/legacy/dist/consumer/component/consumer-component';
import { InsightsMain } from '@teambit/insights';
import { untagResult } from '@teambit/legacy/dist/scope/component-ops/untag-component';
import { ScopeMain } from '@teambit/scope';
import { Lane, ModelComponent } from '@teambit/legacy/dist/scope/models';
import { IssuesMain } from '@teambit/issues';
import { DependencyResolverMain } from '@teambit/dependency-resolver';
import { BuilderMain } from '@teambit/builder';
import { ExportMain } from '@teambit/export';
import { BitObject } from '@teambit/legacy/dist/scope/objects';
import { BasicTagParams } from './tag-model-component';
export declare class SnappingMain {
    private workspace;
    private logger;
    private issues;
    private insights;
    private dependencyResolver;
    private scope;
    private exporter;
    private builder;
    private objectsRepo;
    constructor(workspace: Workspace, logger: Logger, issues: IssuesMain, insights: InsightsMain, dependencyResolver: DependencyResolverMain, scope: ScopeMain, exporter: ExportMain, builder: BuilderMain);
    /**
     * tag the given component ids or all modified/new components if "all" param is set.
     * tag is a similar operation as a snap, which saves the changes into the local scope, but it also creates an alias
     * with a valid semver to that version.
     * tag can be done only on main, not on a lane.
     */
    tag({ ids, message, version, editor, snapped, unmerged, releaseType, preReleaseId, ignoreIssues, ignoreNewestVersion, skipTests, skipAutoTag, build, unmodified, soft, persist, forceDeploy, incrementBy, disableTagAndSnapPipelines, }: {
        ids?: string[];
        all?: boolean | string;
        snapped?: boolean;
        unmerged?: boolean;
        version?: string;
        releaseType?: ReleaseType;
        ignoreIssues?: string;
        scope?: string | boolean;
        incrementBy?: number;
    } & Partial<BasicTagParams>): Promise<TagResults | null>;
    tagFromScope(params: {
        ids: string[];
        push?: boolean;
        version?: string;
        releaseType?: ReleaseType;
        ignoreIssues?: string;
        incrementBy?: number;
    } & Partial<BasicTagParams>): Promise<TagResults | null>;
    /**
     * save the local changes of a component(s) into the scope. snap can be done on main or on a lane.
     * once a component is snapped on a lane, it becomes part of it.
     */
    snap({ pattern, legacyBitIds, // @todo: change to ComponentID[]. pass only if have the ids already parsed.
    unmerged, message, ignoreIssues, skipTests, skipAutoSnap, build, disableTagAndSnapPipelines, forceDeploy, unmodified, }: {
        pattern?: string;
        legacyBitIds?: BitIds;
        unmerged?: boolean;
        message?: string;
        ignoreIssues?: string;
        build: boolean;
        skipTests?: boolean;
        skipAutoSnap?: boolean;
        disableTagAndSnapPipelines?: boolean;
        forceDeploy?: boolean;
        unmodified?: boolean;
    }): Promise<SnapResults | null>;
    /**
     * remove tags/snaps that exist locally, which were not exported yet.
     * once a tag/snap is exported, it's impossible to delete it as other components may depend on it
     */
    reset(componentPattern?: string, head?: boolean, force?: boolean, soft?: boolean): Promise<{
        results: untagResult[];
        isSoftUntag: boolean;
    }>;
    _addFlattenedDependenciesToComponents(scope: LegacyScope, components: ConsumerComponent[]): Promise<void>;
    _updateComponentsByTagResult(components: ConsumerComponent[], tagResult: LegacyOnTagResult[]): void;
    _getPublishedPackages(components: ConsumerComponent[]): string[];
    _addCompToObjects({ source, consumer, lane, shouldValidateVersion, }: {
        source: ConsumerComponent;
        consumer: Consumer;
        lane: Lane | null;
        shouldValidateVersion?: boolean;
    }): Promise<ModelComponent>;
    _addCompFromScopeToObjects(source: ConsumerComponent, lane: Lane | null): Promise<ModelComponent>;
    _enrichComp(consumerComponent: ConsumerComponent): Promise<ConsumerComponent>;
    _getObjectsToEnrichComp(consumerComponent: ConsumerComponent): Promise<BitObject[]>;
    private transformArtifactsFromVinylToSource;
    private loadComponentsForTag;
    private throwForComponentIssues;
    private throwForPendingImport;
    private throwForLegacyDependenciesInsideHarmony;
    private getComponentsToTag;
    static slots: never[];
    static dependencies: import("@teambit/harmony").Aspect[];
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static provider([workspace, cli, community, loggerMain, issues, insights, dependencyResolver, scope, exporter, builder,]: [
        Workspace,
        CLIMain,
        CommunityMain,
        LoggerMain,
        IssuesMain,
        InsightsMain,
        DependencyResolverMain,
        ScopeMain,
        ExportMain,
        BuilderMain
    ]): Promise<SnappingMain>;
}
export default SnappingMain;
