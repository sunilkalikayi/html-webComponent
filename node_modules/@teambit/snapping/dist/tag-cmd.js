"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TagCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _tag() {
  const data = require("@teambit/legacy/dist/api/consumer/lib/tag");
  _tag = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _componentIssues() {
  const data = require("@teambit/component-issues");
  _componentIssues = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
const RELEASE_TYPES = ['major', 'premajor', 'minor', 'preminor', 'patch', 'prepatch', 'prerelease'];
class TagCmd {
  // In case a compiler / tester is not installed

  constructor(snapping, logger) {
    this.snapping = snapping;
    this.logger = logger;
    (0, _defineProperty2().default)(this, "name", 'tag [component-patterns...]');
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "description", 'create an immutable and exportable component snapshot, tagged with a release version.');
    (0, _defineProperty2().default)(this, "extendedDescription", `if no patterns are provided, it will tag all new and modified components.
if patterns are entered, you can specify a version per pattern using "@" sign, e.g. bit tag foo@1.0.0 bar@minor baz@major`);
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'component-patterns...',
      description: 'a list of component names, IDs or patterns (separated by space). run "bit pattern --help" to get more data about patterns. By default, all modified are tagged.'
    }]);
    (0, _defineProperty2().default)(this, "helpUrl", 'components/tags');
    (0, _defineProperty2().default)(this, "alias", 't');
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "options", [['m', 'message <message>', 'a log message describing latest changes'], ['u', 'unmodified', 'include unmodified components (by default, only new and modified components are tagged)'], ['', 'editor [editor]', 'EXPERIMENTAL. open an editor to write a tag message for each component. optionally, specify the editor-name (defaults to vim).'], ['v', 'ver <version>', 'tag with the given version'], ['l', 'increment <level>', `options are: [${RELEASE_TYPES.join(', ')}], default to patch`], ['', 'prerelease-id <id>', 'prerelease identifier (e.g. "dev" to get "1.0.0-dev.1")'], ['p', 'patch', 'syntactic sugar for "--increment patch"'], ['', 'minor', 'syntactic sugar for "--increment minor"'], ['', 'major', 'syntactic sugar for "--increment major"'], ['', 'pre-release [identifier]', 'syntactic sugar for "--increment prerelease" and `--prerelease-id <identifier>`'], ['', 'snapped', 'EXPERIMENTAL. tag components that their head is a snap (not a tag)'], ['', 'unmerged', 'EXPERIMENTAL. complete a merge process by tagging the unmerged components'], ['', 'skip-tests', 'skip running component tests during tag process'], ['', 'skip-auto-tag', 'skip auto tagging dependents'], ['', 'soft', 'do not persist. only keep note of the changes to be made'], ['', 'persist', 'persist the changes generated by --soft tag'], ['', 'disable-tag-pipeline', 'skip the tag pipeline to avoid publishing the components'], ['', 'force-deploy', 'run the tag pipeline although the build failed'], ['', 'increment-by <number>', '(default to 1) increment semver flag (patch/minor/major) by. e.g. incrementing patch by 2: 0.0.1 -> 0.0.3.'], ['i', 'ignore-issues [issues]', `ignore component issues (shown in "bit status" as "issues found"), issues to ignore:
[${Object.keys(_componentIssues().IssuesClasses).join(', ')}]
to ignore multiple issues, separate them by a comma and wrap with quotes. to ignore all issues, specify "*".`], ['I', 'ignore-newest-version', 'ignore existing of newer versions (default = false)'], ['b', 'build', 'EXPERIMENTAL. not needed for now. run the pipeline build and complete the tag'], ['a', 'all [version]', 'DEPRECATED (not needed anymore, it is the default now). tag all new and modified components'], ['s', 'scope [version]', 'DEPRECATED (use "--unmodified" instead). tag all components of the current scope'], ['f', 'force', 'DEPRECATED (use "--skip-tests" or "--unmodified" instead). force-tag even if tests are failing and even when component has not changed'], ['', 'disable-deploy-pipeline', 'DEPRECATED. use --disable-tag-pipeline instead']]);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "remoteOp", true);
    (0, _defineProperty2().default)(this, "examples", [{
      cmd: 'tag --ver 1.0.0',
      description: 'tag all components to version 1.0.0'
    }]);
  }

  // eslint-disable-next-line complexity
  async report([patterns = []], {
    message = '',
    ver,
    all = false,
    editor = '',
    snapped = false,
    unmerged = false,
    patch,
    minor,
    major,
    preRelease,
    increment,
    prereleaseId,
    force = false,
    ignoreUnresolvedDependencies,
    ignoreIssues,
    ignoreNewestVersion = false,
    skipTests = false,
    skipAutoTag = false,
    scope,
    unmodified = false,
    build,
    soft = false,
    persist = false,
    disableDeployPipeline = false,
    disableTagPipeline = false,
    forceDeploy = false,
    incrementBy = 1
  }) {
    if (typeof ignoreUnresolvedDependencies === 'boolean') {
      throw new (_bitError().BitError)(`--ignore-unresolved-dependencies has been removed, please use --ignore-issues instead`);
    }
    if (ignoreIssues && typeof ignoreIssues === 'boolean') {
      throw new (_bitError().BitError)(`--ignore-issues expects issues to be ignored, please run "bit tag -h" for the issues list`);
    }
    if (disableDeployPipeline) {
      this.logger.consoleWarning(`--disable-deploy-pipeline is deprecated, please use --disable-tag-pipeline instead`);
    }
    if (!message && !persist) {
      this.logger.consoleWarning(`--message will be mandatory in the next few releases. make sure to add a message with your tag`);
    }
    if (all) {
      this.logger.consoleWarning(`--all is deprecated, please omit it. "bit tag" by default will tag all new and modified components. to specify a version, use --ver flag`);
      if (typeof all === 'string') {
        ver = all;
      }
    }
    if (scope) {
      this.logger.consoleWarning(`--scope is deprecated, use --unmodified instead`);
      unmodified = true;
      if (typeof scope === 'string') {
        ver = scope;
      }
    }
    if (force) {
      this.logger.consoleWarning(`--force is deprecated, use either --skip-tests or --unmodified depending on the use case`);
      if (patterns.length) unmodified = true;
    }
    if (prereleaseId && (!increment || increment === 'major' || increment === 'minor' || increment === 'patch')) {
      throw new (_bitError().BitError)(`--prerelease-id should be entered along with --increment flag, while --increment must be one of the following: [prepatch, prerelease, preminor, premajor]`);
    }
    const releaseFlags = [patch, minor, major, preRelease].filter(x => x);
    if (releaseFlags.length > 1) {
      throw new (_bitError().BitError)('you can use only one of the following - patch, minor, major, pre-release');
    }
    const getReleaseType = () => {
      if (increment) {
        if (!RELEASE_TYPES.includes(increment)) {
          throw new (_bitError().BitError)(`invalid increment-level "${increment}".
  semver allows the following options only: ${RELEASE_TYPES.join(', ')}`);
        }
        return increment;
      }
      if (major) return 'major';
      if (minor) return 'minor';
      if (patch) return 'patch';
      if (preRelease) return 'prerelease';
      return _constants().DEFAULT_BIT_RELEASE_TYPE;
    };
    const getPreReleaseId = () => {
      if (prereleaseId) {
        return prereleaseId;
      }
      if (preRelease && typeof preRelease === 'string') {
        return preRelease;
      }
      return undefined;
    };
    const disableTagAndSnapPipelines = disableTagPipeline || disableDeployPipeline;
    const params = {
      ids: patterns,
      snapped,
      unmerged,
      editor,
      message,
      releaseType: getReleaseType(),
      preReleaseId: getPreReleaseId(),
      ignoreIssues,
      ignoreNewestVersion,
      skipTests,
      skipAutoTag,
      build,
      soft,
      persist,
      unmodified,
      disableTagAndSnapPipelines,
      forceDeploy,
      incrementBy,
      version: ver
    };
    const results = await this.snapping.tag(params);
    if (!results) return _chalk().default.yellow(_tag().NOTHING_TO_TAG_MSG);
    const {
      taggedComponents,
      autoTaggedResults,
      warnings,
      newComponents
    } = results;
    const changedComponents = taggedComponents.filter(component => !newComponents.searchWithoutVersion(component.id));
    const addedComponents = taggedComponents.filter(component => newComponents.searchWithoutVersion(component.id));
    const autoTaggedCount = autoTaggedResults ? autoTaggedResults.length : 0;
    const warningsOutput = warnings && warnings.length ? `${_chalk().default.yellow(warnings.join('\n'))}\n\n` : '';
    const tagExplanationPersist = `\n(use "bit export [collection]" to push these components to a remote")
(use "bit reset" to unstage versions)\n`;
    const tagExplanationSoft = `\n(use "bit tag --persist" to persist the changes")
(use "bit reset --soft" to remove the soft-tags)\n`;
    const tagExplanation = results.isSoftTag ? tagExplanationSoft : tagExplanationPersist;
    const outputComponents = comps => {
      return comps.map(component => {
        let componentOutput = `     > ${component.id.toString()}`;
        const autoTag = autoTaggedResults.filter(result => result.triggeredBy.searchWithoutScopeAndVersion(component.id));
        if (autoTag.length) {
          const autoTagComp = autoTag.map(a => a.component.id.toString());
          componentOutput += `\n       ${_tag().AUTO_TAGGED_MSG}:
            ${autoTagComp.join('\n            ')}`;
        }
        return componentOutput;
      }).join('\n');
    };
    const publishOutput = () => {
      const {
        publishedPackages
      } = results;
      if (!publishedPackages || !publishedPackages.length) return '';
      const successTitle = `\n\n${_chalk().default.green(`published the following ${publishedPackages.length} component(s) successfully\n`)}`;
      const successCompsStr = publishedPackages.join('\n');
      const successOutput = successCompsStr ? successTitle + successCompsStr : '';
      return successOutput;
    };
    const softTagPrefix = results.isSoftTag ? 'soft-tagged ' : '';
    const outputIfExists = (label, explanation, components) => {
      if (!components.length) return '';
      return `\n${_chalk().default.underline(softTagPrefix + label)}\n(${explanation})\n${outputComponents(components)}\n`;
    };
    const newDesc = results.isSoftTag ? 'set to be tagged first version for components' : 'first version for components';
    const changedDesc = results.isSoftTag ? 'components that set to get a version bump' : 'components that got a version bump';
    const softTagClarification = results.isSoftTag ? _chalk().default.bold('keep in mind that this is a soft-tag (changes recorded to be tagged), to persist the changes use --persist flag') : '';
    return warningsOutput + _chalk().default.green(`${taggedComponents.length + autoTaggedCount} component(s) ${results.isSoftTag ? 'soft-' : ''}tagged`) + tagExplanation + outputIfExists('new components', newDesc, addedComponents) + outputIfExists('changed components', changedDesc, changedComponents) + publishOutput() + softTagClarification;
  }
}
exports.TagCmd = TagCmd;

//# sourceMappingURL=tag-cmd.js.map