{"version":3,"names":["updateDependenciesVersions","componentsToTag","dependencyResolver","getNewDependencyVersion","id","foundDependency","find","component","isEqualWithoutVersion","changeVersion","version","changeExtensionsVersion","extensions","forEach","ext","extensionId","newDepId","oneComponentToTag","getAllDependencies","dependency","updateDepsOnLegacyTag","bind","setHashes","componentToTag","sha1","v4","setFutureVersions","scope","releaseType","exactVersion","persist","autoTagIds","ids","incrementBy","preRelease","soft","Promise","all","map","isAutoTag","hasWithoutVersion","modelComponent","sources","findOrAddComponent","nextVersion","componentMap","previouslyUsedVersion","exactVersionOrReleaseType","getValidVersionOrReleaseType","getVersionToAdd","undefined","versionByEnteredId","getVersionByEnteredId","enteredIds","enteredId","searchWithoutVersion","hasVersion","tagModelComponent","workspace","snapping","builder","consumerComponents","message","editor","preReleaseId","ignoreNewestVersion","skipTests","skipAutoTag","build","isSnap","disableTagAndSnapPipelines","forceDeploy","packageManagerConfigRootDir","consumer","legacyScope","consumerComponentsIdsMap","consumerComponent","componentIdString","toString","R","values","idsToTag","BitIds","fromArray","c","idsToTriggerAutoTag","filter","autoTagData","getAutoTagInfo","autoTagComponents","autoTagItem","autoTagComponentsFiltered","has","autoTag","allComponentsToTag","messagesFromEditorFetcher","MessagePerComponentFetcher","messagePerId","getMessagesFromEditor","tmp","newestVersionsP","componentFromModel","getModelComponentIfExist","ShowDoctorError","listVersions","length","latest","componentId","toStringWithoutVersion","currentVersion","latestVersion","newestVersions","newestVersionsWithoutEmpty","newest","isEmpty","NewerVersionFound","logger","debugAndAddBreadCrumb","setCurrentSchema","addLogToComponents","Error","updateNextVersionOnBitmap","_addFlattenedDependenciesToComponents","emptyBuilderData","addBuildStatus","BuildStatus","Pending","addComponentsToScope","Boolean","updateComponentsVersions","publishedPackages","onTagOpts","throwOnError","seedersOnly","isolateOptions","reloadAspectsWithNewVersion","harmonyComps","getManyByLegacy","builderDataMap","tagListener","buildResult","builderDataMapToLegacyOnTagResults","_updateComponentsByTagResult","push","_getPublishedPackages","Succeed","mapSeries","_enrichComp","removeDeletedComponentsFromBitmap","objects","taggedComponents","autoTaggedResults","comps","comp","removed","compId","resolveComponentId","bitMap","removeComponent","components","shouldValidateVersion","lane","getCurrentLaneObject","_addCompToObjects","source","_addCompFromScopeToObjects","existingBuilder","findCoreExtension","Extensions","data","autoTagComps","messagePerComponent","username","globalConfig","get","CFG_USER_NAME_KEY","bitCloudUsername","getBitCloudUsername","email","CFG_USER_EMAIL_KEY","getLog","msgFromEditor","item","msg","date","Date","now","log","autoTagComp","defaultMsg","token","CFG_USER_TOKEN_KEY","res","fetch","BASE_CLOUD_DOMAIN","headers","Authorization","object","json","user","payload","error","schema","CURRENT_SCHEMA","buildStatus","isTag","currentLane","getCurrentLaneId","stagedConfig","getStagedConfig","isAvailableOnMain","isDefault","ModelComponent","getModelComponent","hasHead","updateVersions","unknownComponent","toBitIdWithLatestVersionAllowNull","updateComponentId","availableOnMain","setComponentProp","getComponent","config","addComponentConfig","removeConfig","getConfigPerId","clearNextVersion","write"],"sources":["tag-model-component.ts"],"sourcesContent":["import mapSeries from 'p-map-series';\nimport fetch from 'node-fetch';\nimport R from 'ramda';\nimport { isEmpty } from 'lodash';\nimport { ReleaseType } from 'semver';\nimport { v4 } from 'uuid';\nimport * as globalConfig from '@teambit/legacy/dist/api/consumer/lib/global-config';\nimport { Scope } from '@teambit/legacy/dist/scope';\nimport { BitId, BitIds } from '@teambit/legacy/dist/bit-id';\nimport {\n  BuildStatus,\n  CFG_USER_EMAIL_KEY,\n  CFG_USER_NAME_KEY,\n  CFG_USER_TOKEN_KEY,\n  BASE_CLOUD_DOMAIN,\n  Extensions,\n} from '@teambit/legacy/dist/constants';\nimport { CURRENT_SCHEMA } from '@teambit/legacy/dist/consumer/component/component-schema';\nimport Component from '@teambit/legacy/dist/consumer/component/consumer-component';\nimport Consumer from '@teambit/legacy/dist/consumer/consumer';\nimport { NewerVersionFound } from '@teambit/legacy/dist/consumer/exceptions';\nimport ShowDoctorError from '@teambit/legacy/dist/error/show-doctor-error';\nimport logger from '@teambit/legacy/dist/logger/logger';\nimport { sha1 } from '@teambit/legacy/dist/utils';\nimport { AutoTagResult, getAutoTagInfo } from '@teambit/legacy/dist/scope/component-ops/auto-tag';\nimport { getValidVersionOrReleaseType } from '@teambit/legacy/dist/utils/semver-helper';\nimport { BuilderMain } from '@teambit/builder';\nimport { Log } from '@teambit/legacy/dist/scope/models/version';\nimport {\n  MessagePerComponent,\n  MessagePerComponentFetcher,\n} from '@teambit/legacy/dist/scope/component-ops/message-per-component';\nimport { ModelComponent } from '@teambit/legacy/dist/scope/models';\nimport { DependencyResolverMain } from '@teambit/dependency-resolver';\nimport { ScopeMain } from '@teambit/scope';\nimport { Workspace } from '@teambit/workspace';\nimport { SnappingMain } from './snapping.main.runtime';\n\nexport type onTagIdTransformer = (id: BitId) => BitId | null;\n\nexport type BasicTagParams = {\n  message: string;\n  ignoreNewestVersion?: boolean;\n  skipTests?: boolean;\n  skipAutoTag?: boolean;\n  build?: boolean;\n  soft?: boolean;\n  persist: boolean;\n  disableTagAndSnapPipelines?: boolean;\n  forceDeploy?: boolean;\n  preReleaseId?: string;\n  editor?: string;\n  unmodified?: boolean;\n};\n\nfunction updateDependenciesVersions(componentsToTag: Component[], dependencyResolver: DependencyResolverMain): void {\n  const getNewDependencyVersion = (id: BitId): BitId | null => {\n    const foundDependency = componentsToTag.find((component) => component.id.isEqualWithoutVersion(id));\n    return foundDependency ? id.changeVersion(foundDependency.version) : null;\n  };\n  const changeExtensionsVersion = (component: Component): void => {\n    component.extensions.forEach((ext) => {\n      if (ext.extensionId) {\n        const newDepId = getNewDependencyVersion(ext.extensionId);\n        if (newDepId) ext.extensionId = newDepId;\n      }\n    });\n  };\n\n  componentsToTag.forEach((oneComponentToTag) => {\n    oneComponentToTag.getAllDependencies().forEach((dependency) => {\n      const newDepId = getNewDependencyVersion(dependency.id);\n      if (newDepId) dependency.id = newDepId;\n    });\n    changeExtensionsVersion(oneComponentToTag);\n    // @ts-ignore\n    oneComponentToTag = dependencyResolver.updateDepsOnLegacyTag(oneComponentToTag, getNewDependencyVersion.bind(this));\n  });\n}\n\nfunction setHashes(componentsToTag: Component[]): void {\n  componentsToTag.forEach((componentToTag) => {\n    componentToTag.version = sha1(v4());\n  });\n}\n\nasync function setFutureVersions(\n  componentsToTag: Component[],\n  scope: Scope,\n  releaseType: ReleaseType | undefined,\n  exactVersion: string | null | undefined,\n  persist: boolean,\n  autoTagIds: BitIds,\n  ids: BitIds,\n  incrementBy?: number,\n  preRelease?: string,\n  soft?: boolean\n): Promise<void> {\n  await Promise.all(\n    componentsToTag.map(async (componentToTag) => {\n      const isAutoTag = autoTagIds.hasWithoutVersion(componentToTag.id);\n      const modelComponent = await scope.sources.findOrAddComponent(componentToTag);\n      const nextVersion = componentToTag.componentMap?.nextVersion?.version;\n      componentToTag.previouslyUsedVersion = componentToTag.version;\n      if (nextVersion && persist) {\n        const exactVersionOrReleaseType = getValidVersionOrReleaseType(nextVersion);\n        componentToTag.version = modelComponent.getVersionToAdd(\n          exactVersionOrReleaseType.releaseType,\n          exactVersionOrReleaseType.exactVersion,\n          undefined,\n          componentToTag.componentMap?.nextVersion?.preRelease\n        );\n      } else if (isAutoTag) {\n        // auto-tag always bumped as patch\n        componentToTag.version = soft\n          ? 'patch'\n          : modelComponent.getVersionToAdd('patch', undefined, incrementBy, preRelease);\n      } else {\n        const versionByEnteredId = getVersionByEnteredId(ids, componentToTag, modelComponent);\n        componentToTag.version = soft\n          ? versionByEnteredId || exactVersion || releaseType\n          : versionByEnteredId || modelComponent.getVersionToAdd(releaseType, exactVersion, incrementBy, preRelease);\n      }\n    })\n  );\n}\n\nfunction getVersionByEnteredId(\n  enteredIds: BitIds,\n  component: Component,\n  modelComponent: ModelComponent\n): string | undefined {\n  const enteredId = enteredIds.searchWithoutVersion(component.id);\n  if (enteredId && enteredId.hasVersion()) {\n    const exactVersionOrReleaseType = getValidVersionOrReleaseType(enteredId.version as string);\n    return modelComponent.getVersionToAdd(\n      exactVersionOrReleaseType.releaseType,\n      exactVersionOrReleaseType.exactVersion\n    );\n  }\n  return undefined;\n}\n\nexport async function tagModelComponent({\n  workspace,\n  scope,\n  snapping,\n  builder,\n  consumerComponents,\n  ids,\n  message,\n  editor,\n  exactVersion,\n  releaseType,\n  preReleaseId,\n  ignoreNewestVersion = false,\n  skipTests = false,\n  skipAutoTag,\n  soft,\n  build,\n  persist,\n  isSnap = false,\n  disableTagAndSnapPipelines,\n  forceDeploy,\n  incrementBy,\n  packageManagerConfigRootDir,\n  dependencyResolver,\n}: {\n  workspace?: Workspace;\n  scope: ScopeMain;\n  snapping: SnappingMain;\n  builder: BuilderMain;\n  consumerComponents: Component[];\n  ids: BitIds;\n  exactVersion?: string | null | undefined;\n  releaseType?: ReleaseType;\n  incrementBy?: number;\n  isSnap?: boolean;\n  packageManagerConfigRootDir?: string;\n  dependencyResolver: DependencyResolverMain;\n} & BasicTagParams): Promise<{\n  taggedComponents: Component[];\n  autoTaggedResults: AutoTagResult[];\n  publishedPackages: string[];\n}> {\n  const consumer = workspace?.consumer;\n  const legacyScope = scope.legacyScope;\n  const consumerComponentsIdsMap = {};\n  // Concat and unique all the dependencies from all the components so we will not import\n  // the same dependency more then once, it's mainly for performance purpose\n  consumerComponents.forEach((consumerComponent) => {\n    const componentIdString = consumerComponent.id.toString();\n    // Store it in a map so we can take it easily from the sorted array which contain only the id\n    consumerComponentsIdsMap[componentIdString] = consumerComponent;\n  });\n  const componentsToTag: Component[] = R.values(consumerComponentsIdsMap); // consumerComponents unique\n  const idsToTag = BitIds.fromArray(componentsToTag.map((c) => c.id));\n  // ids without versions are new. it's impossible that tagged (and not-modified) components has\n  // them as dependencies.\n  const idsToTriggerAutoTag = idsToTag.filter((id) => id.hasVersion());\n  const autoTagData =\n    skipAutoTag || !consumer ? [] : await getAutoTagInfo(consumer, BitIds.fromArray(idsToTriggerAutoTag));\n  const autoTagComponents = autoTagData.map((autoTagItem) => autoTagItem.component);\n  const autoTagComponentsFiltered = autoTagComponents.filter((c) => !idsToTag.has(c.id));\n  const autoTagIds = BitIds.fromArray(autoTagComponentsFiltered.map((autoTag) => autoTag.id));\n  const allComponentsToTag = [...componentsToTag, ...autoTagComponentsFiltered];\n\n  const messagesFromEditorFetcher = new MessagePerComponentFetcher(idsToTag, autoTagIds);\n  const messagePerId = editor ? await messagesFromEditorFetcher.getMessagesFromEditor(legacyScope.tmp, editor) : [];\n\n  // check for each one of the components whether it is using an old version\n  if (!ignoreNewestVersion && !isSnap) {\n    const newestVersionsP = allComponentsToTag.map(async (component) => {\n      if (component.componentFromModel) {\n        // otherwise it's a new component, so this check is irrelevant\n        const modelComponent = await legacyScope.getModelComponentIfExist(component.id);\n        if (!modelComponent) throw new ShowDoctorError(`component ${component.id} was not found in the model`);\n        if (!modelComponent.listVersions().length) return null; // no versions yet, no issues.\n        const latest = modelComponent.latest();\n        if (latest !== component.version) {\n          return {\n            componentId: component.id.toStringWithoutVersion(),\n            currentVersion: component.version,\n            latestVersion: latest,\n          };\n        }\n      }\n      return null;\n    });\n    const newestVersions = await Promise.all(newestVersionsP);\n    const newestVersionsWithoutEmpty = newestVersions.filter((newest) => newest);\n    if (!isEmpty(newestVersionsWithoutEmpty)) {\n      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!\n      throw new NewerVersionFound(newestVersionsWithoutEmpty);\n    }\n  }\n\n  logger.debugAndAddBreadCrumb('tag-model-components', 'sequentially persist all components');\n  // go through all components and find the future versions for them\n  isSnap\n    ? setHashes(allComponentsToTag)\n    : await setFutureVersions(\n        allComponentsToTag,\n        legacyScope,\n        releaseType,\n        exactVersion,\n        persist,\n        autoTagIds,\n        ids,\n        incrementBy,\n        preReleaseId,\n        soft\n      );\n  setCurrentSchema(allComponentsToTag);\n  // go through all dependencies and update their versions\n  updateDependenciesVersions(allComponentsToTag, dependencyResolver);\n\n  await addLogToComponents(componentsToTag, autoTagComponents, persist, message, messagePerId);\n\n  if (soft) {\n    if (!consumer) throw new Error(`unable to soft-tag without consumer`);\n    consumer.updateNextVersionOnBitmap(allComponentsToTag, preReleaseId);\n  } else {\n    await snapping._addFlattenedDependenciesToComponents(legacyScope, allComponentsToTag);\n    emptyBuilderData(allComponentsToTag);\n    addBuildStatus(allComponentsToTag, BuildStatus.Pending);\n    await addComponentsToScope(legacyScope, snapping, allComponentsToTag, Boolean(build), consumer);\n    if (workspace) await updateComponentsVersions(workspace, allComponentsToTag);\n  }\n\n  const publishedPackages: string[] = [];\n  if (build) {\n    const onTagOpts = { disableTagAndSnapPipelines, throwOnError: true, forceDeploy, skipTests, isSnap };\n    const seedersOnly = !workspace; // if tag from scope, build only the given components\n    const isolateOptions = { packageManagerConfigRootDir, seedersOnly };\n\n    await scope.reloadAspectsWithNewVersion(allComponentsToTag);\n    const harmonyComps = await (workspace || scope).getManyByLegacy(allComponentsToTag);\n    const { builderDataMap } = await builder.tagListener(harmonyComps, onTagOpts, isolateOptions);\n    const buildResult = scope.builderDataMapToLegacyOnTagResults(builderDataMap);\n\n    snapping._updateComponentsByTagResult(allComponentsToTag, buildResult);\n    publishedPackages.push(...snapping._getPublishedPackages(allComponentsToTag));\n    addBuildStatus(allComponentsToTag, BuildStatus.Succeed);\n    await mapSeries(allComponentsToTag, (consumerComponent) => snapping._enrichComp(consumerComponent));\n  }\n\n  if (!soft) {\n    await removeDeletedComponentsFromBitmap(allComponentsToTag, workspace);\n    await legacyScope.objects.persist();\n  }\n\n  return { taggedComponents: componentsToTag, autoTaggedResults: autoTagData, publishedPackages };\n}\n\nasync function removeDeletedComponentsFromBitmap(comps: Component[], workspace?: Workspace) {\n  if (!workspace) {\n    return;\n  }\n  await Promise.all(\n    comps.map(async (comp) => {\n      if (comp.removed) {\n        const compId = await workspace.resolveComponentId(comp.id);\n        workspace.bitMap.removeComponent(compId);\n      }\n    })\n  );\n}\n\nasync function addComponentsToScope(\n  scope: Scope,\n  snapping: SnappingMain,\n  components: Component[],\n  shouldValidateVersion: boolean,\n  consumer?: Consumer\n) {\n  const lane = await scope.getCurrentLaneObject();\n  if (consumer) {\n    await mapSeries(components, async (component) => {\n      await snapping._addCompToObjects({\n        source: component,\n        consumer,\n        lane,\n        shouldValidateVersion,\n      });\n    });\n  } else {\n    await mapSeries(components, async (component) => {\n      await snapping._addCompFromScopeToObjects(component, lane);\n    });\n  }\n}\n\nfunction emptyBuilderData(components: Component[]) {\n  components.forEach((component) => {\n    const existingBuilder = component.extensions.findCoreExtension(Extensions.builder);\n    if (existingBuilder) existingBuilder.data = {};\n  });\n}\n\nasync function addLogToComponents(\n  components: Component[],\n  autoTagComps: Component[],\n  persist: boolean,\n  message: string,\n  messagePerComponent: MessagePerComponent[]\n) {\n  const username = await globalConfig.get(CFG_USER_NAME_KEY);\n  const bitCloudUsername = await getBitCloudUsername();\n  const email = await globalConfig.get(CFG_USER_EMAIL_KEY);\n  const getLog = (component: Component): Log => {\n    const nextVersion = persist ? component.componentMap?.nextVersion : null;\n    const msgFromEditor = messagePerComponent.find((item) => item.id.isEqualWithoutVersion(component.id))?.msg;\n    return {\n      username: nextVersion?.username || bitCloudUsername || username,\n      email: nextVersion?.email || email,\n      message: nextVersion?.message || msgFromEditor || message,\n      date: Date.now().toString(),\n    };\n  };\n\n  components.forEach((component) => {\n    component.log = getLog(component);\n  });\n  autoTagComps.forEach((autoTagComp) => {\n    autoTagComp.log = getLog(autoTagComp);\n    const defaultMsg = 'bump dependencies versions';\n    if (message) {\n      autoTagComp.log.message += ` (${defaultMsg})`;\n    } else if (!autoTagComp.log.message) {\n      autoTagComp.log.message = defaultMsg;\n    }\n  });\n}\n\nasync function getBitCloudUsername(): Promise<string | undefined> {\n  const token = await globalConfig.get(CFG_USER_TOKEN_KEY);\n  if (!token) return '';\n  try {\n    const res = await fetch(`https://api.${BASE_CLOUD_DOMAIN}/user`, {\n      headers: {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/json',\n      },\n    });\n    const object = await res.json();\n    const user = object.payload;\n    const username = user.username;\n    return username;\n  } catch (error) {\n    return undefined;\n  }\n}\n\nfunction setCurrentSchema(components: Component[]) {\n  components.forEach((component) => {\n    component.schema = CURRENT_SCHEMA;\n  });\n}\n\nfunction addBuildStatus(components: Component[], buildStatus: BuildStatus) {\n  components.forEach((component) => {\n    component.buildStatus = buildStatus;\n  });\n}\n\nexport async function updateComponentsVersions(\n  workspace: Workspace,\n  components: Array<ModelComponent | Component>,\n  isTag = true\n): Promise<any> {\n  const consumer = workspace.consumer;\n  const currentLane = consumer.getCurrentLaneId();\n  const stagedConfig = await workspace.scope.getStagedConfig();\n  const isAvailableOnMain = async (component: ModelComponent | Component, id: BitId): Promise<boolean> => {\n    if (currentLane.isDefault()) {\n      return true;\n    }\n    if (!id.hasVersion()) {\n      // component was unsnapped on the current lane and is back to a new component\n      return true;\n    }\n    const modelComponent =\n      component instanceof ModelComponent ? component : await consumer.scope.getModelComponent(component.id);\n    return modelComponent.hasHead();\n  };\n\n  const updateVersions = async (unknownComponent: ModelComponent | Component) => {\n    const id: BitId =\n      unknownComponent instanceof ModelComponent\n        ? unknownComponent.toBitIdWithLatestVersionAllowNull()\n        : unknownComponent.id;\n    consumer.bitMap.updateComponentId(id);\n    const availableOnMain = await isAvailableOnMain(unknownComponent, id);\n    if (!availableOnMain) {\n      consumer.bitMap.setComponentProp(id, 'onLanesOnly', true);\n    }\n    const componentMap = consumer.bitMap.getComponent(id);\n    const compId = await workspace.resolveComponentId(id);\n    // it can be either a tag/snap or reset.\n    if (isTag) {\n      const config = componentMap.config;\n      stagedConfig.addComponentConfig(compId, config);\n      consumer.bitMap.removeConfig(id);\n    } else if (!componentMap.config) {\n      componentMap.config = stagedConfig.getConfigPerId(compId);\n    }\n    componentMap.clearNextVersion();\n  };\n  // important! DO NOT use Promise.all here! otherwise, you're gonna enter into a whole world of pain.\n  // imagine tagging comp1 with auto-tagged comp2, comp1 package.json is written while comp2 is\n  // trying to get the dependencies of comp1 using its package.json.\n  await mapSeries(components, updateVersions);\n  await stagedConfig.write();\n}\n"],"mappings":"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"}