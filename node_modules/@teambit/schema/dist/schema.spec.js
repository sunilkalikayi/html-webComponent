"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _semanticsEntities() {
  const data = require("@teambit/semantics.entities.semantic-schema");
  _semanticsEntities = function () {
    return data;
  };
  return data;
}
function _harmonyTesting() {
  const data = require("@teambit/harmony.testing.load-aspect");
  _harmonyTesting = function () {
    return data;
  };
  return data;
}
function _workspaceTesting() {
  const data = require("@teambit/workspace.testing.mock-workspace");
  _workspaceTesting = function () {
    return data;
  };
  return data;
}
function _componentId() {
  const data = require("@teambit/component-id");
  _componentId = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _() {
  const data = require(".");
  _ = function () {
    return data;
  };
  return data;
}
describe('SchemaAspect', function () {
  let schema;
  let workspace;
  let workspaceData;
  beforeAll(async () => {
    workspaceData = (0, _workspaceTesting().mockWorkspace)();
    const {
      workspacePath
    } = workspaceData;
    // eslint-disable-next-line no-console
    console.log('workspace created at ', workspacePath);
    schema = await (0, _harmonyTesting().loadAspect)(_().SchemaAspect, workspacePath);
  });
  afterAll(async () => {
    await (0, _workspaceTesting().destroyWorkspace)(workspaceData);
  });
  describe('getSchema()', () => {
    let apiSchema;
    beforeAll(async () => {
      const {
        workspacePath
      } = workspaceData;
      const compDir = _path().default.join(workspacePath, 'button');
      const src = _path().default.join(getMockDir(), 'button');
      await _fsExtra().default.copy(src, compDir);
      workspace = await (0, _harmonyTesting().loadAspect)(_workspace().default, workspacePath);
      await workspace.track({
        rootDir: compDir,
        defaultScope: 'org.scope'
      });
      await workspace.bitMap.write();
      schema = await (0, _harmonyTesting().loadAspect)(_().SchemaAspect, workspacePath);
      const compId = await workspace.resolveComponentId('button');
      const comp = await workspace.get(compId);
      apiSchema = await schema.getSchema(comp);
    });
    it('should be able to generate JSON object with all schemas', async () => {
      const results = apiSchema.toObject();
      const expectedJsonPath = _path().default.join(getMockDir(), 'button-schemas.json');
      // uncomment the next line temporarily to sync the expected json with new schema changes
      // fs.outputFileSync(expectedJsonPath, JSON.stringify(results, undefined, 2));
      const expectedJson = _fsExtra().default.readJsonSync(expectedJsonPath);
      // @ts-ignore it exists on Jest. for some reason ts assumes this is Jasmine.
      expect(results).toMatchObject(expectedJson);
    });
  });
  describe('getSchemaFromObject', () => {
    it('should be able to deserialize an JSON object to SchemaNode instances', () => {
      const jsonPath = _path().default.join(getMockDir(), 'button-schemas.json');
      const json = _fsExtra().default.readJsonSync(jsonPath);
      const apiSchema = schema.getSchemaFromObject(json);
      expect(apiSchema instanceof _semanticsEntities().APISchema).toBeTruthy();
      expect(apiSchema.componentId instanceof _componentId().ComponentID).toBeTruthy();
      // @ts-ignore it exists on Jest. for some reason ts assumes this is Jasmine.
      expect(apiSchema.toObject()).toMatchObject(json);
    });
    it('should not throw when it does not recognize the schema', () => {
      const jsonPath = _path().default.join(getMockDir(), 'button-old-schema.json');
      const json = _fsExtra().default.readJsonSync(jsonPath);
      const apiSchema = schema.getSchemaFromObject(json);
      expect(apiSchema instanceof _semanticsEntities().APISchema).toBeTruthy();
      expect(apiSchema.module.exports[0] instanceof _semanticsEntities().UnknownSchema).toBeTruthy();
      // @ts-ignore
      expect(apiSchema.module.exports[0].location).toMatchObject({
        file: 'index.ts',
        line: 21,
        character: 14
      });
    });
  });
});
function getCurrentDir() {
  const currentDir = __dirname;
  if (currentDir.endsWith(`${_path().default.sep}dist`)) return currentDir.slice(0, -5);
  return currentDir;
}
function getMockDir() {
  return _path().default.join(getCurrentDir(), 'mock');
}

//# sourceMappingURL=schema.spec.js.map