/**
 * General comment of the myFunc
 * @deprecate example of deprecation tag
 * @param a { number } this is A
 * @param b this is B
 * @returns { number } results of adding a to b
 */
export declare function myFunc(a?: number, b?: number): number;
export * from './button';
export declare function Hi(): void;
export declare const a = 4, b: 5;
export * as Compositions from './button.composition';
export declare const HiThere = "HiThere";
export declare const Function: () => void;
export declare const Array: string[];
declare class Foo {
}
declare class ClassSomething {
    readonly da: 'dsa';
    app: string;
    constructor(da: 'dsa');
    a(): Foo;
    get getter(): string;
    set setter(a: boolean);
}
export { ClassSomething };
export declare type IndexSig = {
    [key: string]: boolean;
};
export interface Hello {
    propertySig: () => void;
    methodSig(): string;
}
declare const obj: {
    a: number;
    b: number;
};
export declare const a1: typeof obj;
export declare type TypeOperator = keyof typeof obj;
declare class Bar {
    foo(): void;
}
export declare const getBar: (bar: Bar) => Bar;
export declare const tuple: ([a, b, c]: [string, Function, Record<string, any>]) => void;
export declare enum Food {
    Falafel = 0,
    Hummus = 1,
    Tahini = 2
}
export declare function getPromise(): Promise<string>;
declare class T1 {
}
declare class T2 {
}
declare class T3<T, K> {
}
export declare type TypeRefWithArgs = T3<T1, T2>;
export declare type ParenthesizedType = (T1 | T2)[];
export declare function typePredicateFn(str: any): str is string;
export declare function typePredicateNoTypeFn(condition: any, msg?: string): asserts condition;
export declare function objectBindingElements({ prop }: {
    prop?: number | undefined;
}): Promise<number>;
export declare function arrayBindingElements([prop]: [string]): Promise<string>;
interface config {
    someField: {
        a: string;
        b: boolean;
    };
}
export declare type IndexedAccessType = config['someField'];
declare const computedName = "str";
export interface ComputedNameWithType {
    [computedName]: boolean;
}
export interface ComputedNameNoType {
    [computedName]: any;
}
declare type World1 = 'world1-a' | 'world1-b';
declare type World2 = 'world2';
export declare type templateLiteralType = `hello ${World1} hi ${World2}`;
export interface CallSignatureWithTypeParams {
    <T>(a: string): T;
}
/**
 * Conditional Generic Type
 */
export declare type If<T, U, Y, N> = T extends U ? Y : N;
