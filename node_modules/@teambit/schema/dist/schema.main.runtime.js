"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SchemaMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = _interopRequireDefault(require("@teambit/component"));
  _component = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = _interopRequireDefault(require("@teambit/graphql"));
  _graphql = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = require("@teambit/envs");
  _envs = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _semanticsEntities() {
  const data = require("@teambit/semantics.entities.semantic-schema");
  _semanticsEntities = function () {
    return data;
  };
  return data;
}
function _schema() {
  const data = require("./schema.aspect");
  _schema = function () {
    return data;
  };
  return data;
}
function _schema2() {
  const data = require("./schema.cmd");
  _schema2 = function () {
    return data;
  };
  return data;
}
function _schema3() {
  const data = require("./schema.graphql");
  _schema3 = function () {
    return data;
  };
  return data;
}
/**
 * extension for extracting component schemas.
 */
class SchemaMain {
  constructor(
  /**
   * parsers slot.
   */
  parserSlot, envs, config, logger) {
    this.parserSlot = parserSlot;
    this.envs = envs;
    this.config = config;
    this.logger = logger;
  }

  /**
   * get the default parser.
   */
  getDefaultParser() {
    return this.parserSlot.get(this.config.defaultParser);
  }

  /**
   * parse a module into a component schema.
   */
  parseModule(path) {
    const parsers = this.parserSlot.toArray();
    let maybeParser = parsers.find(([, parser]) => {
      const match = path.match(parser.extension);
      return match;
    });
    if (!maybeParser) {
      maybeParser = [this.config.defaultParser, this.getDefaultParser()];
    }
    const [, parser] = maybeParser;
    return parser.parseModule(path);
  }
  getSchemaExtractor(component) {
    const env = this.envs.getEnv(component).env;
    if (typeof env.getSchemaExtractor === 'undefined') {
      throw new Error(`No SchemaExtractor defined for ${env.name}`);
    }
    return env.getSchemaExtractor();
  }

  /**
   * get a schema of a component.
   * @param component target component.
   */
  async getSchema(component) {
    this.logger.debug(`getSchema of ${component.id.toString()}`);
    const env = this.envs.getEnv(component).env;
    if (typeof env.getSchemaExtractor === 'undefined') {
      throw new Error(`No SchemaExtractor defined for ${env.name}`);
    }
    const schemaExtractor = env.getSchemaExtractor();
    return schemaExtractor.extract(component);
  }
  getSchemaFromObject(obj) {
    return _semanticsEntities().APISchema.fromObject(obj);
  }

  /**
   * register a new parser.
   */
  registerParser(parser) {
    this.parserSlot.register(parser);
    return this;
  }
  static async provider([envs, cli, component, graphql, loggerMain], config, [parserSlot]) {
    const logger = loggerMain.createLogger(_schema().SchemaAspect.id);
    const schema = new SchemaMain(parserSlot, envs, config, logger);
    cli.register(new (_schema2().SchemaCommand)(schema, component, logger));
    graphql.register((0, _schema3().schemaSchema)(schema));

    // workspace.onComponentLoad(async (component) => {
    //   const apiSchema = await schema.getSchema(component);
    //   return {};
    // });

    return schema;
  }
}
exports.SchemaMain = SchemaMain;
(0, _defineProperty2().default)(SchemaMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(SchemaMain, "dependencies", [_envs().EnvsAspect, _cli().CLIAspect, _component().default, _graphql().default, _logger().LoggerAspect]);
(0, _defineProperty2().default)(SchemaMain, "slots", [_harmony().Slot.withType()]);
(0, _defineProperty2().default)(SchemaMain, "defaultConfig", {
  defaultParser: 'teambit.typescript/typescript'
});
_schema().SchemaAspect.addRuntime(SchemaMain);
var _default = SchemaMain;
exports.default = _default;

//# sourceMappingURL=schema.main.runtime.js.map