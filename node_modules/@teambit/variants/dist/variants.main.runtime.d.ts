import type { ConfigMain } from '@teambit/config';
import ConsumerOverrides from '@teambit/legacy/dist/consumer/config/consumer-overrides';
import { ExtensionDataList } from '@teambit/legacy/dist/consumer/config/extension-data';
import { PathLinuxRelative } from '@teambit/legacy/dist/utils/path';
import { MatchedPatternWithConfig } from '@teambit/workspace.modules.match-pattern';
export declare type Patterns = {
    [pattern: string]: Record<string, any>;
};
export declare type VariantsComponentConfig = {
    propagate: boolean;
    exclude?: string[];
    defaultScope?: string;
    extensions: ExtensionDataList;
    maxSpecificity: number;
    sortedMatches: MatchedPatternWithConfig[];
};
export declare class VariantsMain {
    private patterns;
    private configAspect;
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: import("@teambit/harmony").Aspect[];
    _loadedLegacy: ConsumerOverrides;
    constructor(patterns: Patterns, configAspect: ConfigMain);
    private validateConfig;
    raw(): Patterns;
    /**
     * Get all the patterns defined in the variants section of the workspace as the legacy ConsumerOverrides format
     */
    legacy(): ConsumerOverrides;
    /**
     * Gets the config for specific component after merge all matching patterns of the component dir and id in the variants section
     * @param rootDir
     */
    byRootDirAndName(rootDir: PathLinuxRelative, componentName: string): VariantsComponentConfig | undefined;
    /**
     * Updates the specified extension object of the specified variant.
     * @param {string} variant - The variant pattern.
     * @param {string} extensionId - The extension ID.
     * @param {Object} extensionConfig - The extension configuration.
     * @param {boolean} opts.overrideExisting - When true, any existing entries are overriden.
     */
    setExtension(variant: string, extensionId: string, extensionConfig: any, opts?: {
        overrideExisting?: boolean;
    }): void;
    static provider([configAspect]: [ConfigMain], config: any): Promise<VariantsMain>;
}
