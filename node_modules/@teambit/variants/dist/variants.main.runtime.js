"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VariantsMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _config() {
  const data = require("@teambit/config");
  _config = function () {
    return data;
  };
  return data;
}
function _consumerOverrides() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/config/consumer-overrides"));
  _consumerOverrides = function () {
    return data;
  };
  return data;
}
function _extensionData() {
  const data = require("@teambit/legacy/dist/consumer/config/extension-data");
  _extensionData = function () {
    return data;
  };
  return data;
}
function _commentJson() {
  const data = require("comment-json");
  _commentJson = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _workspaceModules() {
  const data = require("@teambit/workspace.modules.match-pattern");
  _workspaceModules = function () {
    return data;
  };
  return data;
}
function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");
  _legacyBitId = function () {
    return data;
  };
  return data;
}
function _variants() {
  const data = require("./variants.aspect");
  _variants = function () {
    return data;
  };
  return data;
}
const INTERNAL_FIELDS = ['propagate', 'exclude', 'defaultScope'];
class VariantsMain {
  constructor(patterns, configAspect) {
    this.patterns = patterns;
    this.configAspect = configAspect;
    (0, _defineProperty2().default)(this, "_loadedLegacy", void 0);
    this._loadedLegacy = _consumerOverrides().default.load(this.patterns);
    this.validateConfig();
  }
  validateConfig() {
    (0, _lodash().forEach)(this.patterns, (patternConfig, pattern) => {
      if (patternConfig.defaultScope && !(0, _legacyBitId().isValidScopeName)(patternConfig.defaultScope)) {
        throw new (_legacyBitId().InvalidScopeName)(patternConfig.defaultScope, undefined, pattern);
      }
    });
  }
  raw() {
    return this.patterns;
  }

  /**
   * Get all the patterns defined in the variants section of the workspace as the legacy ConsumerOverrides format
   */
  legacy() {
    // return ConsumerOverrides.load(this.patterns);
    return this._loadedLegacy;
  }

  /**
   * Gets the config for specific component after merge all matching patterns of the component dir and id in the variants section
   * @param rootDir
   */
  byRootDirAndName(rootDir, componentName) {
    const matches = [];
    (0, _lodash().forEach)(this.patterns, (patternConfig, pattern) => {
      const match = (0, _workspaceModules().isMatchPattern)(rootDir, componentName, pattern);

      // Ignore matches with exclude matches
      if (match.match && !match.excluded) {
        matches.push({
          config: patternConfig,
          specificity: match.maxSpecificity,
          pattern: match.pattern
        });
      }
    });
    const sortedMatches = (0, _workspaceModules().sortMatchesBySpecificity)(matches);
    let defaultScope;
    let propagate = true;
    const extensionsToMerge = [];
    sortedMatches.forEach(match => {
      defaultScope = defaultScope || match.config.defaultScope;
      if (propagate) {
        extensionsToMerge.push(getExtensionFromPatternRawConfig(match.config));
      }
      if (match.config.propagate === false) {
        propagate = false;
      }
    });
    const mergedExtensions = _extensionData().ExtensionDataList.mergeConfigs(extensionsToMerge);
    const result = {
      defaultScope,
      extensions: mergedExtensions,
      propagate,
      maxSpecificity: sortedMatches.length ? sortedMatches[0].specificity : -1,
      sortedMatches
    };
    return result;
  }

  /**
   * Updates the specified extension object of the specified variant.
   * @param {string} variant - The variant pattern.
   * @param {string} extensionId - The extension ID.
   * @param {Object} extensionConfig - The extension configuration.
   * @param {boolean} opts.overrideExisting - When true, any existing entries are overriden.
   */
  setExtension(variant, extensionId, extensionConfig, opts) {
    var _this$patterns$varian;
    const newVariant = (_this$patterns$varian = this.patterns[variant]) !== null && _this$patterns$varian !== void 0 ? _this$patterns$varian : {};
    (0, _commentJson().assign)(newVariant, {
      [extensionId]: extensionConfig
    });
    (0, _commentJson().assign)(this.patterns, {
      [variant]: newVariant
    });
    this.configAspect.setExtension(_variants().VariantsAspect.id, this.patterns, {
      overrideExisting: (opts === null || opts === void 0 ? void 0 : opts.overrideExisting) === true,
      ignoreVersion: true
    });
  }
  static async provider([configAspect], config) {
    return new VariantsMain(config, configAspect);
  }
}
exports.VariantsMain = VariantsMain;
(0, _defineProperty2().default)(VariantsMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(VariantsMain, "dependencies", [_config().ConfigAspect]);
function getExtensionFromPatternRawConfig(config) {
  const rawExtensions = (0, _lodash().omit)(config, INTERNAL_FIELDS);
  const extensions = _extensionData().ExtensionDataList.fromConfigObject(rawExtensions);
  return extensions;
}
_variants().VariantsAspect.addRuntime(VariantsMain);

//# sourceMappingURL=variants.main.runtime.js.map