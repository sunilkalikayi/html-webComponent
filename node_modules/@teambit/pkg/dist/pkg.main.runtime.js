"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.async-iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PkgMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = _interopRequireDefault(require("@teambit/component"));
  _component = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = require("@teambit/envs");
  _envs = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _isolator() {
  const data = require("@teambit/isolator");
  _isolator = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = require("@teambit/scope");
  _scope = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = require("@teambit/workspace");
  _workspace = function () {
    return data;
  };
  return data;
}
function _packageJsonTransformer() {
  const data = require("@teambit/legacy/dist/consumer/component/package-json-transformer");
  _packageJsonTransformer = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("@teambit/builder");
  _builder = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _componentPackageVersion() {
  const data = require("@teambit/component-package-version");
  _componentPackageVersion = function () {
    return data;
  };
  return data;
}
function _componentIssues() {
  const data = require("@teambit/component-issues");
  _componentIssues = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = require("@teambit/graphql");
  _graphql = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _inMemoryCache() {
  const data = require("@teambit/legacy/dist/cache/in-memory-cache");
  _inMemoryCache = function () {
    return data;
  };
  return data;
}
function _cacheFactory() {
  const data = require("@teambit/legacy/dist/cache/cache-factory");
  _cacheFactory = function () {
    return data;
  };
  return data;
}
function _packer() {
  const data = require("./packer");
  _packer = function () {
    return data;
  };
  return data;
}
function _pack() {
  const data = require("./pack.cmd");
  _pack = function () {
    return data;
  };
  return data;
}
function _pkg() {
  const data = require("./pkg.aspect");
  _pkg = function () {
    return data;
  };
  return data;
}
function _preparePackages() {
  const data = require("./prepare-packages.task");
  _preparePackages = function () {
    return data;
  };
  return data;
}
function _publish() {
  const data = require("./publish.cmd");
  _publish = function () {
    return data;
  };
  return data;
}
function _publisher() {
  const data = require("./publisher");
  _publisher = function () {
    return data;
  };
  return data;
}
function _publish2() {
  const data = require("./publish.task");
  _publish2 = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _pkgArtifact() {
  const data = require("./pkg-artifact");
  _pkgArtifact = function () {
    return data;
  };
  return data;
}
function _package() {
  const data = require("./package.route");
  _package = function () {
    return data;
  };
  return data;
}
function _packageDependency() {
  const data = require("./package-dependency");
  _packageDependency = function () {
    return data;
  };
  return data;
}
function _pkg2() {
  const data = require("./pkg.graphql");
  _pkg2 = function () {
    return data;
  };
  return data;
}
function _package2() {
  const data = require("./package.fragment");
  _package2 = function () {
    return data;
  };
  return data;
}
function _pack2() {
  const data = require("./pack.task");
  _pack2 = function () {
    return data;
  };
  return data;
}
function _pkg3() {
  const data = require("./pkg.service");
  _pkg3 = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _asyncIterator(iterable) { var method, async, sync, retry = 2; for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = "@@asyncIterator", sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function (s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function (value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }
class PkgMain {
  static async provider([cli, scope, envs, isolator, logger, workspace, builder, dependencyResolver, componentAspect, graphql], config, [packageJsonPropsRegistry]) {
    const logPublisher = logger.createLogger(_pkg().PkgAspect.id);
    const host = componentAspect.getHost();
    const packer = new (_packer().Packer)(isolator, logPublisher, host, scope);
    const publisher = new (_publisher().Publisher)(isolator, logPublisher, scope === null || scope === void 0 ? void 0 : scope.legacyScope, workspace);
    const publishTask = new (_publish2().PublishTask)(_pkg().PkgAspect.id, publisher, logPublisher);
    const packTask = new (_pack2().PackTask)(_pkg().PkgAspect.id, packer, logPublisher);
    const pkg = new PkgMain(logPublisher, config, packageJsonPropsRegistry, workspace, scope, builder, packer, envs, componentAspect, publishTask, dependencyResolver);
    componentAspect.registerShowFragments([new (_package2().PackageFragment)(pkg)]);
    dependencyResolver.registerDependencyFactories([new (_packageDependency().PackageDependencyFactory)()]);
    graphql.register((0, _pkg2().pkgSchema)(pkg));
    envs.registerService(new (_pkg3().PkgService)());
    componentAspect.registerRoute([new (_package().PackageRoute)(pkg)]);

    // we ended up not using the publish-dry-run task. It used to run "npm publish --dry-run"
    // and also "npm pack --dry-run", but it's not that useful and it takes long to complete.
    // we might revise our decision later.
    // const dryRunTask = new PublishDryRunTask(PkgAspect.id, publisher, packer, logPublisher);
    const preparePackagesTask = new (_preparePackages().PreparePackagesTask)(_pkg().PkgAspect.id, logPublisher, envs);
    // dryRunTask.dependencies = [BuildTaskHelper.serializeId(preparePackagesTask)];
    builder.registerBuildTasks([preparePackagesTask]);
    builder.registerTagTasks([packTask, publishTask]);
    builder.registerSnapTasks([packTask]);
    if (workspace) {
      // workspace.onComponentLoad(pkg.mergePackageJsonProps.bind(pkg));
      workspace.onComponentLoad(async component => {
        await pkg.addMissingLinksFromNodeModulesIssue(component);
        const data = await pkg.mergePackageJsonProps(component);
        return {
          packageJsonModification: data
        };
      });
    }
    _packageJsonTransformer().PackageJsonTransformer.registerPackageJsonTransformer(pkg.transformPackageJson.bind(pkg));
    // TODO: consider passing the pkg instead of packer
    cli.register(new (_pack().PackCmd)(packer), new (_publish().PublishCmd)(publisher));
    return pkg;
  }
  /**
   * get the package name of a component.
   */
  getPackageName(component) {
    return this.dependencyResolver.getPackageName(component);
  }

  /*
   * Returns the location where the component is installed with its peer dependencies
   * This is used in cases you want to actually run the components and make sure all the dependencies (especially peers) are resolved correctly
   */
  getRuntimeModulePath(component, options = {}) {
    const relativePath = this.dependencyResolver.getRuntimeModulePath(component);
    if (options !== null && options !== void 0 && options.absPath) {
      if (this.workspace) {
        return (0, _path().join)(this.workspace.path, relativePath);
      }
      throw new Error('getModulePath with abs path option is not implemented for scope');
    }
    return relativePath;
  }

  /**
   * returns the package path in the /node_modules/ folder
   * In case you call this in order to run the code from the path, please refer to the `getRuntimeModulePath` API
   */
  getModulePath(component, options = {}) {
    const relativePath = this.dependencyResolver.getModulePath(component);
    if (options !== null && options !== void 0 && options.absPath) {
      if (this.workspace) {
        return (0, _path().join)(this.workspace.path, relativePath);
      }
      throw new Error('getModulePath with abs path option is not implemented for scope');
    }
    return relativePath;
  }
  isModulePathExists(component) {
    const packageDir = this.getModulePath(component, {
      absPath: true
    });
    return _fsExtra().default.existsSync(packageDir);
  }
  async addMissingLinksFromNodeModulesIssue(component) {
    const exist = this.isModulePathExists(component);
    if (!exist) {
      component.state.issues.getOrCreate(_componentIssues().IssuesClasses.MissingLinksFromNodeModulesToSrc).data = true;
    }
    // we don't want to add any data to the compiler aspect, only to add issues on the component
    return undefined;
  }
  // cache components manifests
  constructor(
  /**
   * logger extension
   */
  logger,
  /**
   * pkg extension configuration.
   */
  config,
  /**
   * Registry for changes by other extensions.
   */
  packageJsonPropsRegistry, workspace, scope, builder,
  /**
   * A utils class to packing components into tarball
   */
  packer,
  /**
   * envs extension.
   */
  envs, componentAspect,
  /**
   * keep it as public. external env might want to register it to the snap pipeline
   */
  publishTask, dependencyResolver) {
    this.logger = logger;
    this.config = config;
    this.packageJsonPropsRegistry = packageJsonPropsRegistry;
    this.workspace = workspace;
    this.scope = scope;
    this.builder = builder;
    this.packer = packer;
    this.envs = envs;
    this.componentAspect = componentAspect;
    this.publishTask = publishTask;
    this.dependencyResolver = dependencyResolver;
    (0, _defineProperty2().default)(this, "shouldPreserveConfigForClonedComponent", false);
    (0, _defineProperty2().default)(this, "manifestCache", void 0);
    this.manifestCache = (0, _cacheFactory().createInMemoryCache)({
      maxSize: (0, _inMemoryCache().getMaxSizeForComponents)()
    });
  }

  /**
   * register changes in the package.json
   */
  registerPackageJsonNewProps(props) {
    return this.packageJsonPropsRegistry.register(props);
  }

  /**
   * Pack a component and generate a tarball suitable for npm registry
   *
   * @param {string} componentId
   * @param {(string | undefined)} scopePath
   * @param {string} outDir
   * @param {boolean} [prefix=false]
   * @param {boolean} [override=false]
   * @param {boolean} [keep=false]
   * @returns {Promise<PackResult>}
   * @memberof PkgExtension
   */
  async packComponent(componentId, scopePath, options) {
    return this.packer.packComponent(componentId, scopePath, options);
  }

  /**
   * Merge the configs provided by:
   * 1. envs configured in the component - via getPackageJsonProps method
   * 2. extensions that registered to the registerPackageJsonNewProps slot (and configured for the component)
   * 3. props defined by the user (they are the strongest one)
   */
  async mergePackageJsonProps(component) {
    var _this$envs$calculateE;
    let newProps = {};
    const mergeToNewProps = otherProps => {
      const files = [...(newProps.files || []), ...(otherProps.files || [])];
      const merged = _objectSpread(_objectSpread({}, newProps), otherProps);
      if (files.length) merged.files = files;
      return merged;
    };
    const env = (_this$envs$calculateE = this.envs.calculateEnv(component)) === null || _this$envs$calculateE === void 0 ? void 0 : _this$envs$calculateE.env;
    if (env !== null && env !== void 0 && env.getPackageJsonProps && typeof env.getPackageJsonProps === 'function') {
      const propsFromEnv = env.getPackageJsonProps();
      newProps = mergeToNewProps(propsFromEnv);
    }
    const configuredIds = component.state.aspects.ids;
    configuredIds.forEach(extId => {
      // Only get props from configured extensions on this specific component
      const props = this.packageJsonPropsRegistry.get(extId);
      if (props) {
        newProps = mergeToNewProps(props);
      }
    });
    const currentExtension = component.state.aspects.get(_pkg().PkgAspect.id);
    const currentConfig = currentExtension === null || currentExtension === void 0 ? void 0 : currentExtension.config;
    if (currentConfig && currentConfig.packageJson) {
      newProps = mergeToNewProps(currentConfig.packageJson);
    }
    // Keys not allowed to override
    const specialKeys = ['extensions', 'dependencies', 'devDependencies', 'peerDependencies'];
    return (0, _lodash().omit)(newProps, specialKeys);
  }
  getPackageJsonModifications(component) {
    var _currentData$packageJ;
    const currentExtension = component.state.aspects.get(_pkg().PkgAspect.id);
    const currentData = currentExtension === null || currentExtension === void 0 ? void 0 : currentExtension.data;
    return (_currentData$packageJ = currentData === null || currentData === void 0 ? void 0 : currentData.packageJsonModification) !== null && _currentData$packageJ !== void 0 ? _currentData$packageJ : {};
  }
  async getPkgArtifact(component) {
    const artifacts = await this.builder.getArtifactsVinylByAspect(component, _pkg().PkgAspect.id);
    if (!artifacts.length) throw new (_exceptions().PkgArtifactNotFound)(component.id);
    return new (_pkgArtifact().PkgArtifact)(artifacts);
  }
  async getManifest(component) {
    const name = this.getPackageName(component);
    const latestVersion = component.latest;
    if (!latestVersion) {
      throw new (_bitError().BitError)('can not get manifest for component without versions');
    }
    const preReleaseLatestTags = component.tags.getPreReleaseLatestTags();
    const latest = (0, _componentPackageVersion().snapToSemver)(latestVersion);
    const distTags = _objectSpread({
      latest
    }, preReleaseLatestTags);
    const versionsFromCache = this.manifestCache.get(name);
    const getVersions = async () => {
      var _component$head;
      const headHash = (_component$head = component.head) === null || _component$head === void 0 ? void 0 : _component$head.hash;
      if (!headHash) throw new (_bitError().BitError)(`unable to get manifest for "${name}", the head is empty`);
      if (versionsFromCache) {
        if (versionsFromCache.head !== headHash) this.manifestCache.delete(name);else {
          return versionsFromCache.manifest;
        }
      }
      const versions = await this.getAllSnapsManifests(component);
      const versionsWithoutEmpty = (0, _lodash().compact)(versions);
      this.manifestCache.set(name, {
        head: headHash,
        manifest: versionsWithoutEmpty
      });
      return versionsWithoutEmpty;
    };
    const versions = await getVersions();
    const externalRegistry = this.isPublishedToExternalRegistry(component);
    return {
      name,
      distTags,
      externalRegistry,
      versions
    };
  }
  async getAllSnapsManifests(component) {
    const iterable = component.snapsIterable();
    const result = [];
    var _iteratorAbruptCompletion = false;
    var _didIteratorError = false;
    var _iteratorError;
    try {
      for (var _iterator = _asyncIterator(iterable), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {
        const snap = _step.value;
        const manifest = await this.getSnapManifest(component, snap);
        if (manifest) {
          result.push(manifest);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (_iteratorAbruptCompletion && _iterator.return != null) {
          await _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return result;
  }

  /**
   * Check if the component should be fetched from bit registry or from another registry
   * This will usually determined by the latest version of the component
   * @param component
   */
  isPublishedToExternalRegistry(component) {
    var _pkgExt$config, _pkgExt$config$packag, _pkgExt$config2, _pkgExt$config2$packa;
    const pkgExt = component.get(_pkg().PkgAspect.id);
    // By default publish to bit registry
    if (!pkgExt) return false;
    return !!((_pkgExt$config = pkgExt.config) !== null && _pkgExt$config !== void 0 && (_pkgExt$config$packag = _pkgExt$config.packageJson) !== null && _pkgExt$config$packag !== void 0 && _pkgExt$config$packag.name || (_pkgExt$config2 = pkgExt.config) !== null && _pkgExt$config2 !== void 0 && (_pkgExt$config2$packa = _pkgExt$config2.packageJson) !== null && _pkgExt$config2$packa !== void 0 && _pkgExt$config2$packa.publishConfig);
  }
  getComponentBuildData(component) {
    const data = this.builder.getDataByAspect(component, _pkg().PkgAspect.id);
    if (data) return data;
    // backward compatibility. the data used to be saved on the pkg aspect rather than on the
    // builder aspect
    const currentExtension = component.state.aspects.get(_pkg().PkgAspect.id);
    return currentExtension === null || currentExtension === void 0 ? void 0 : currentExtension.data;
  }
  async getSnapManifest(component, snap) {
    var _version$extensions$f, _version$extensions$f2, _builderData$find, _currentData$pkgJson;
    const idWithCorrectVersion = component.id.changeVersion(snap.hash);

    // @todo: this is a hack. see below the right way to do it.
    const version = await this.scope.legacyScope.getVersionInstance(idWithCorrectVersion._legacy);
    const builderData = (_version$extensions$f = version.extensions.findCoreExtension(_builder().BuilderAspect.id)) === null || _version$extensions$f === void 0 ? void 0 : (_version$extensions$f2 = _version$extensions$f.data) === null || _version$extensions$f2 === void 0 ? void 0 : _version$extensions$f2.aspectsData;
    const currentData = builderData === null || builderData === void 0 ? void 0 : (_builderData$find = builderData.find(a => a.aspectId === _pkg().PkgAspect.id)) === null || _builderData$find === void 0 ? void 0 : _builderData$find.data;

    // @todo: this is the proper way to communicate with the builder aspect. however, getting
    // the entire Component for each one of the snaps is terrible in terms of the performance.

    // const updatedComponent = await this.componentAspect.getHost().get(idWithCorrectVersion, true);
    // if (!updatedComponent) {
    //   throw new BitError(`snap ${snap.hash} for component ${component.id.toString()} is missing`);
    // }
    // const currentData = this.getComponentBuildData(updatedComponent);

    // If for some reason the version has no package.json manifest, return undefined
    if (!(currentData !== null && currentData !== void 0 && currentData.pkgJson)) {
      return undefined;
    }
    const pkgJson = (_currentData$pkgJson = currentData === null || currentData === void 0 ? void 0 : currentData.pkgJson) !== null && _currentData$pkgJson !== void 0 ? _currentData$pkgJson : {};
    const checksum = currentData === null || currentData === void 0 ? void 0 : currentData.checksum;
    if (!checksum) {
      this.logger.error(`checksum for ${component.id.toString()} is missing`);
      return undefined;
    }
    const dist = {
      shasum: checksum,
      tarball: this.componentAspect.getRoute(idWithCorrectVersion, _package().routePath)
    };
    const manifest = _objectSpread(_objectSpread({}, pkgJson), {}, {
      dist
    });
    return manifest;
  }
  async getPackageTarFile(component) {
    const artifacts = await this.builder.getArtifactsVinylByAspectAndName(component, _pkg().PkgAspect.id, _packer().TAR_FILE_ARTIFACT_NAME);
    if (!artifacts.length) throw new (_exceptions().PackageTarFiletNotFound)(component.id);
    return artifacts[0];
  }
  async transformPackageJson(legacyComponent, packageJsonObject) {
    // const newId = await this.workspace.resolveComponentId(component.id);
    // const newComponent = await this.workspace.get(newId);
    const host = this.componentAspect.getHost();
    const id = await host.resolveComponentId(legacyComponent.id);
    const newComponent = await host.get(id);
    if (!newComponent) throw new Error(`cannot transform package.json of component: ${legacyComponent.id.toString()}`);
    const newProps = this.getPackageJsonModifications(newComponent);
    return Object.assign(packageJsonObject, newProps);
  }
}
exports.PkgMain = PkgMain;
(0, _defineProperty2().default)(PkgMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(PkgMain, "dependencies", [_cli().CLIAspect, _scope().ScopeAspect, _envs().EnvsAspect, _isolator().IsolatorAspect, _logger().LoggerAspect, _workspace().WorkspaceAspect, _builder().BuilderAspect, _dependencyResolver().DependencyResolverAspect, _component().default, _graphql().GraphqlAspect]);
(0, _defineProperty2().default)(PkgMain, "slots", [_harmony().Slot.withType()]);
(0, _defineProperty2().default)(PkgMain, "defaultConfig", {});
_pkg().PkgAspect.addRuntime(PkgMain);

//# sourceMappingURL=pkg.main.runtime.js.map