"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Publisher = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _execa() {
  const data = _interopRequireDefault(require("execa"));
  _execa = function () {
    return data;
  };
  return data;
}
function _pkg() {
  const data = require("./pkg.aspect");
  _pkg = function () {
    return data;
  };
  return data;
}
class Publisher {
  // @todo: decide if this is mandatory or using the workspace settings
  constructor(isolator, logger, scope, workspace, options = {}) {
    this.isolator = isolator;
    this.logger = logger;
    this.scope = scope;
    this.workspace = workspace;
    this.options = options;
    (0, _defineProperty2().default)(this, "packageManager", 'npm');
  }
  async publish(componentPattern, options) {
    const componentIds = await this.workspace.idsByPattern(componentPattern);
    this.options = options;
    const capsules = await this.getComponentCapsules(componentIds);
    // const capsules = await this.getComponentCapsulesFromScope(componentIds);
    return this.publishMultipleCapsules(capsules);
  }
  async publishMultipleCapsules(capsules) {
    const description = `publish components${this.options.dryRun ? ' (dry-run)' : ''}`;
    const longProcessLogger = this.logger.createLongProcessLogger(description, capsules.length);
    const results = (0, _pMapSeries().default)(capsules, capsule => {
      longProcessLogger.logProgress(capsule.component.id.toString());
      return this.publishOneCapsule(capsule);
    });
    longProcessLogger.end();
    return results;
  }
  async publishOneCapsule(capsule) {
    const startTime = Date.now();
    const publishParams = ['publish'];
    if (this.options.dryRun) publishParams.push('--dry-run');
    publishParams.push(...this.getTagFlagForPreRelease(capsule.component.id));
    const extraArgs = this.getExtraArgsFromConfig(capsule.component);
    if (extraArgs && Array.isArray(extraArgs) && extraArgs !== null && extraArgs !== void 0 && extraArgs.length) {
      const extraArgsSplit = extraArgs.map(arg => arg.split(' ')).flat();
      publishParams.push(...extraArgsSplit);
    }
    const publishParamsStr = publishParams.join(' ');
    const cwd = capsule.path;
    const componentIdStr = capsule.id.toString();
    const errors = [];
    let metadata = {};
    try {
      // @todo: once capsule.exec works properly, replace this
      const {
        stdout,
        stderr
      } = await (0, _execa().default)(this.packageManager, publishParams, {
        cwd
      });
      this.logger.debug(`${componentIdStr}, successfully ran ${this.packageManager} ${publishParamsStr} at ${cwd}`);
      this.logger.debug(`${componentIdStr}, stdout: ${stdout}`);
      this.logger.debug(`${componentIdStr}, stderr: ${stderr}`);
      const publishedPackage = stdout.replace('+ ', ''); // npm adds "+ " prefix before the published package
      metadata = this.options.dryRun ? {} : {
        publishedPackage
      };
    } catch (err) {
      const errorMsg = `failed running ${this.packageManager} ${publishParamsStr} at ${cwd}`;
      this.logger.error(`${componentIdStr}, ${errorMsg}`);
      if (err.stderr) this.logger.error(`${componentIdStr}, ${err.stderr}`);
      errors.push(`${errorMsg}\n${err.stderr}`);
    }
    const component = capsule.component;
    return {
      component,
      metadata,
      errors,
      startTime,
      endTime: Date.now()
    };
  }
  getTagFlagForPreRelease(id) {
    const preReleaseData = id.getVersionPreReleaseData();
    if (!preReleaseData) return [];
    const maybeIdentifier = preReleaseData[0]; // it can be numeric as in 1.0.0-0.
    if (typeof maybeIdentifier !== 'string') return [];
    return ['--tag', maybeIdentifier];
  }
  async getComponentCapsules(componentIds) {
    const idsToPublish = await this.getIdsToPublish(componentIds);
    this.logger.debug(`total ${idsToPublish.length} to publish out of ${componentIds.length}`);
    const componentIdsToPublish = await this.workspace.resolveMultipleComponentIds(idsToPublish);
    const network = await this.isolator.isolateComponents(componentIdsToPublish, {
      packageManagerConfigRootDir: this.workspace.path
    });
    return network.seedersCapsules;
  }

  /**
   * only components that use pkg extension and configure "publishConfig" with their own registry
   * or custom "name", should be published. ignore the rest.
   */
  async getIdsToPublish(componentIds) {
    await this.throwForNonStagedOrTaggedComponents(componentIds);
    const ids = _bitId().BitIds.fromArray(componentIds.map(compId => compId._legacy));
    const components = await this.scope.getComponentsAndVersions(ids, true);
    return components.filter(c => this.shouldPublish(c.version.extensions)).map(c => c.component.toBitId().changeVersion(c.versionStr).toString());
  }

  // TODO: consider using isPublishedToExternalRegistry from pkg.main.runtime (need to send it a component not extensions)
  shouldPublish(extensions) {
    var _pkgExt$config, _pkgExt$config$packag, _pkgExt$config2, _pkgExt$config2$packa;
    const pkgExt = extensions.findExtension(_pkg().PkgAspect.id);
    if (!pkgExt) return false;
    return ((_pkgExt$config = pkgExt.config) === null || _pkgExt$config === void 0 ? void 0 : (_pkgExt$config$packag = _pkgExt$config.packageJson) === null || _pkgExt$config$packag === void 0 ? void 0 : _pkgExt$config$packag.name) || ((_pkgExt$config2 = pkgExt.config) === null || _pkgExt$config2 === void 0 ? void 0 : (_pkgExt$config2$packa = _pkgExt$config2.packageJson) === null || _pkgExt$config2$packa === void 0 ? void 0 : _pkgExt$config2$packa.publishConfig);
  }
  getExtraArgsFromConfig(component) {
    var _pkgExt$config3;
    const pkgExt = component.config.extensions.findExtension(_pkg().PkgAspect.id);
    return pkgExt === null || pkgExt === void 0 ? void 0 : (_pkgExt$config3 = pkgExt.config) === null || _pkgExt$config3 === void 0 ? void 0 : _pkgExt$config3.packageManagerPublishArgs;
  }
  async throwForNonStagedOrTaggedComponents(componentIds) {
    const idsWithoutScope = componentIds.filter(id => !id._legacy.hasScope());
    if (!idsWithoutScope.length) return;
    if (!this.options.allowStaged && !this.options.dryRun) {
      throw new (_bitError().BitError)(`unable to publish the following component(s), please make sure they are exported: ${idsWithoutScope.join(', ')}`);
    }
    const missingFromScope = [];
    await Promise.all(idsWithoutScope.map(async id => {
      const inScope = await this.scope.isComponentInScope(id._legacy);
      if (!inScope) {
        missingFromScope.push(id);
      }
    }));
    if (missingFromScope.length) {
      throw new (_bitError().BitError)(`unable to publish the following component(s), please make sure they are tagged: ${missingFromScope.join(', ')}`);
    }
  }
}
exports.Publisher = Publisher;

//# sourceMappingURL=publisher.js.map