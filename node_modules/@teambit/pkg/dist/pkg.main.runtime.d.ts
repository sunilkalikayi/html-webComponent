import { CLIMain } from '@teambit/cli';
import { Component, ComponentMain, IComponent, Snap } from '@teambit/component';
import { EnvsMain } from '@teambit/envs';
import { SlotRegistry } from '@teambit/harmony';
import { IsolatorMain } from '@teambit/isolator';
import { LoggerMain, Logger } from '@teambit/logger';
import { ScopeMain } from '@teambit/scope';
import { Workspace } from '@teambit/workspace';
import LegacyComponent from '@teambit/legacy/dist/consumer/component';
import { BuilderMain } from '@teambit/builder';
import { CloneConfig } from '@teambit/new-component-helper';
import { AbstractVinyl } from '@teambit/legacy/dist/consumer/component/sources';
import { GraphqlMain } from '@teambit/graphql';
import { DependencyResolverMain } from '@teambit/dependency-resolver';
import { Packer, PackOptions, PackResult } from './packer';
import { PublishTask } from './publish.task';
import { PkgArtifact } from './pkg-artifact';
export interface PackageJsonProps {
    [key: string]: any;
}
export declare type PackageJsonPropsRegistry = SlotRegistry<PackageJsonProps>;
export declare type PkgExtensionConfig = {};
declare type GetModulePathOptions = {
    absPath?: boolean;
};
/**
 * Config for variants
 */
export declare type ComponentPkgExtensionConfig = {
    /**
     * properties to add to the package.json of the component.
     */
    packageJson: Record<string, any>;
};
/**
 * Data stored in the component
 */
export declare type ComponentPkgExtensionData = {
    /**
     * properties to add to the package.json of the component.
     */
    packageJsonModification: Record<string, any>;
    /**
     * Final package.json after creating tar file
     */
    pkgJson?: Record<string, any>;
    /**
     * Checksum of the tar file
     */
    checksum?: string;
};
export declare type ComponentPackageManifest = {
    name: string;
    distTags: Record<string, string>;
    externalRegistry: boolean;
    versions: VersionPackageManifest[];
};
export declare type VersionPackageManifest = {
    [key: string]: any;
    dist: {
        tarball: string;
        shasum: string;
    };
};
export declare class PkgMain implements CloneConfig {
    /**
     * logger extension
     */
    readonly logger: Logger;
    /**
     * pkg extension configuration.
     */
    readonly config: PkgExtensionConfig;
    /**
     * Registry for changes by other extensions.
     */
    private packageJsonPropsRegistry;
    private workspace;
    private scope;
    private builder;
    /**
     * A utils class to packing components into tarball
     */
    private packer;
    /**
     * envs extension.
     */
    private envs;
    private componentAspect;
    /**
     * keep it as public. external env might want to register it to the snap pipeline
     */
    publishTask: PublishTask;
    private dependencyResolver;
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: import("@teambit/harmony").Aspect[];
    static slots: ((registerFn: () => string) => SlotRegistry<PackageJsonProps>)[];
    static defaultConfig: {};
    static provider([cli, scope, envs, isolator, logger, workspace, builder, dependencyResolver, componentAspect, graphql]: [
        CLIMain,
        ScopeMain,
        EnvsMain,
        IsolatorMain,
        LoggerMain,
        Workspace,
        BuilderMain,
        DependencyResolverMain,
        ComponentMain,
        GraphqlMain
    ], config: PkgExtensionConfig, [packageJsonPropsRegistry]: [PackageJsonPropsRegistry]): Promise<PkgMain>;
    readonly shouldPreserveConfigForClonedComponent = false;
    /**
     * get the package name of a component.
     */
    getPackageName(component: Component): string;
    getRuntimeModulePath(component: Component, options?: GetModulePathOptions): string;
    /**
     * returns the package path in the /node_modules/ folder
     * In case you call this in order to run the code from the path, please refer to the `getRuntimeModulePath` API
     */
    getModulePath(component: Component, options?: GetModulePathOptions): string;
    isModulePathExists(component: Component): boolean;
    addMissingLinksFromNodeModulesIssue(component: Component): Promise<undefined>;
    private manifestCache;
    constructor(
    /**
     * logger extension
     */
    logger: Logger, 
    /**
     * pkg extension configuration.
     */
    config: PkgExtensionConfig, 
    /**
     * Registry for changes by other extensions.
     */
    packageJsonPropsRegistry: PackageJsonPropsRegistry, workspace: Workspace, scope: ScopeMain, builder: BuilderMain, 
    /**
     * A utils class to packing components into tarball
     */
    packer: Packer, 
    /**
     * envs extension.
     */
    envs: EnvsMain, componentAspect: ComponentMain, 
    /**
     * keep it as public. external env might want to register it to the snap pipeline
     */
    publishTask: PublishTask, dependencyResolver: DependencyResolverMain);
    /**
     * register changes in the package.json
     */
    registerPackageJsonNewProps(props: PackageJsonProps): void;
    /**
     * Pack a component and generate a tarball suitable for npm registry
     *
     * @param {string} componentId
     * @param {(string | undefined)} scopePath
     * @param {string} outDir
     * @param {boolean} [prefix=false]
     * @param {boolean} [override=false]
     * @param {boolean} [keep=false]
     * @returns {Promise<PackResult>}
     * @memberof PkgExtension
     */
    packComponent(componentId: string, scopePath: string | undefined, options: PackOptions): Promise<PackResult>;
    /**
     * Merge the configs provided by:
     * 1. envs configured in the component - via getPackageJsonProps method
     * 2. extensions that registered to the registerPackageJsonNewProps slot (and configured for the component)
     * 3. props defined by the user (they are the strongest one)
     */
    mergePackageJsonProps(component: Component): Promise<PackageJsonProps>;
    getPackageJsonModifications(component: Component): Record<string, any>;
    getPkgArtifact(component: Component): Promise<PkgArtifact>;
    getManifest(component: Component): Promise<ComponentPackageManifest>;
    private getAllSnapsManifests;
    /**
     * Check if the component should be fetched from bit registry or from another registry
     * This will usually determined by the latest version of the component
     * @param component
     */
    isPublishedToExternalRegistry(component: IComponent): boolean;
    private getComponentBuildData;
    getSnapManifest(component: Component, snap: Snap): Promise<VersionPackageManifest | undefined>;
    getPackageTarFile(component: Component): Promise<AbstractVinyl>;
    transformPackageJson(legacyComponent: LegacyComponent, packageJsonObject: Record<string, any>): Promise<Record<string, any>>;
}
export {};
