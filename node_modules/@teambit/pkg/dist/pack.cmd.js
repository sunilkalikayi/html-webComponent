"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PackCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars

class PackCmd {
  constructor(packer) {
    this.packer = packer;
    (0, _defineProperty2().default)(this, "name", 'pack <componentId> [scopePath]');
    (0, _defineProperty2().default)(this, "description", 'create tar for npm publish');
    (0, _defineProperty2().default)(this, "options", [['d', 'out-dir <out-dir>', 'directory to put the result tar file'], ['o', 'override', 'override existing pack file'], ['k', 'keep', 'should keep isolated environment [default = false]'], ['p', 'prefix', 'keep custom (binding) prefix'],
    // ['c', 'use-capsule', 'isolate using the capsule and pack on the capsule'],
    ['j', 'json', 'return the output as JSON']]);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "group", 'collaborate');
  }
  async report(args, options) {
    var _packResult$data, _packResult$data2, _packResult$data$meta, _packResult$data$meta2;
    const packResult = await this.json(args, options);
    const warnings = ((_packResult$data = packResult.data) === null || _packResult$data === void 0 ? void 0 : _packResult$data.warnings) || [];
    const warningsOutput = warnings.map(warning => _chalk().default.yellow(warning)).join('\n');
    const errors = ((_packResult$data2 = packResult.data) === null || _packResult$data2 === void 0 ? void 0 : _packResult$data2.errors) || [];
    const errorsOutput = errors.map(error => _chalk().default.yellow(error)).join('\n');
    const tarPathOutput = (_packResult$data$meta = packResult.data.metadata) !== null && _packResult$data$meta !== void 0 && _packResult$data$meta.tarPath ? _chalk().default.green(`tar path for component ${packResult.data.id}: ${(_packResult$data$meta2 = packResult.data.metadata) === null || _packResult$data$meta2 === void 0 ? void 0 : _packResult$data$meta2.tarPath}`) : '';
    return `${warningsOutput}\n${errorsOutput}\n${tarPathOutput}`;
  }
  async json([componentId, scopePath], options) {
    const compId = typeof componentId === 'string' ? componentId : componentId[0];
    let scopePathStr;
    if (scopePath) {
      scopePathStr = typeof scopePath !== 'string' ? scopePath[0] : scopePath;
    }
    const concreteOpts = {
      writeOptions: {
        outDir: options.outDir,
        override: options.override
      },
      prefix: options.prefix,
      keep: options.keep
      // useCapsule: options.useCapsule,
    };

    const packResult = await this.packer.packComponent(compId, scopePathStr, concreteOpts);
    return {
      data: packResult,
      code: 0
    };
  }
}
exports.PackCmd = PackCmd;

//# sourceMappingURL=pack.cmd.js.map