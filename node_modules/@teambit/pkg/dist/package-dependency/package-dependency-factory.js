"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PackageDependencyFactory = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _packageDependency() {
  const data = require("./package-dependency");
  _packageDependency = function () {
    return data;
  };
  return data;
}
const TYPE = 'package';
// TODO: think about where is the right place to put this
class PackageDependencyFactory {
  // parse<PackageDependency, SerializedDependency>(serialized: SerializedDependency): PackageDependency {
  //   return new PackageDependency(serialized.id, serialized.version, serialized.type, serialized.lifecycle as DependencyLifecycleType);
  // }

  constructor() {
    (0, _defineProperty2().default)(this, "type", void 0);
    this.type = TYPE;
  }
  async parse(serialized) {
    // return new PackageDependency(serialized.id, serialized.version, serialized.type, serialized.lifecycle as DependencyLifecycleType) as unknown as PackageDependency;
    return new (_packageDependency().PackageDependency)(serialized.id, serialized.version, serialized.lifecycle, serialized.source);
  }
  async fromLegacyComponent(legacyComponent) {
    const runtimePackageDeps = transformLegacyComponentPackageDepsToSerializedDependency(legacyComponent.packageDependencies, 'runtime');
    const devPackageDeps = transformLegacyComponentPackageDepsToSerializedDependency(legacyComponent.devPackageDependencies, 'dev');
    const peerPackageDeps = transformLegacyComponentPackageDepsToSerializedDependency(legacyComponent.peerPackageDependencies, 'peer');
    const serializedPackageDeps = runtimePackageDeps.concat(devPackageDeps).concat(peerPackageDeps);
    const packageDepsP = serializedPackageDeps.map(dep => this.parse(dep));
    const packageDeps = await Promise.all(packageDepsP);
    const dependencyList = new (_dependencyResolver().DependencyList)(packageDeps);
    return dependencyList;
  }

  // parse: <PackageDependency, SerializedDependency>(serialized: SerializedDependency) =>  {
  //   return new PackageDependency(serialized.id, serialized.version, serialized.type, serialized.lifecycle as DependencyLifecycleType);
  // }
}
exports.PackageDependencyFactory = PackageDependencyFactory;
function transformLegacyComponentPackageDepsToSerializedDependency(packageDepObj, lifecycle) {
  const res = Object.entries(packageDepObj).map(([packageName, version]) => {
    return {
      id: packageName,
      version,
      __type: TYPE,
      lifecycle
    };
  });
  return res;
}

//# sourceMappingURL=package-dependency-factory.js.map