"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PublishCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
class PublishCmd {
  constructor(publisher) {
    this.publisher = publisher;
    (0, _defineProperty2().default)(this, "name", 'publish <component-pattern>');
    (0, _defineProperty2().default)(this, "description", 'publish components to npm (npm publish)');
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'component-pattern',
      description: _constants().COMPONENT_PATTERN_HELP
    }]);
    (0, _defineProperty2().default)(this, "options", [['d', 'dry-run', 'npm publish --dry-run'], ['', 'allow-staged', 'allow publish components that were not exported yet (not recommended)'], ['j', 'json', 'return the output as JSON']]);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "group", 'collaborate');
  }
  async report(args, options) {
    const result = await this.json(args, options);
    const publishResults = result.data;
    if (!publishResults.length) return 'no components were found candidate for publish';
    const publishOrDryRun = options.dryRun ? 'dry-run' : 'published';
    const title = _chalk().default.white.bold(`successfully ${publishOrDryRun} the following components\n`);
    const output = publishResults.map(publishResult => {
      const compName = publishResult.component.id.toString();
      const getData = () => {
        var _publishResult$errors, _publishResult$metada;
        if ((_publishResult$errors = publishResult.errors) !== null && _publishResult$errors !== void 0 && _publishResult$errors.length) {
          return _chalk().default.red(publishResult.errors.join('\n'));
        }
        return _chalk().default.green(((_publishResult$metada = publishResult.metadata) === null || _publishResult$metada === void 0 ? void 0 : _publishResult$metada.publishedPackage) || '');
      };
      return `${_chalk().default.bold(compName)}\n${getData()}\n`;
    }).join('\n');
    return title + output;
  }
  async json([pattern], options) {
    const packResult = await this.publisher.publish(pattern, options);
    return {
      data: packResult,
      code: 0
    };
  }
}
exports.PublishCmd = PublishCmd;

//# sourceMappingURL=publish.cmd.js.map