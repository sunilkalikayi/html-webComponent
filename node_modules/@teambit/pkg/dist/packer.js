"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "PackOptions", {
  enumerable: true,
  get: function () {
    return _pack().PackOptions;
  }
});
exports.TAR_FILE_ARTIFACT_NAME = exports.Packer = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = _interopRequireDefault(require("lodash"));
  _lodash = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/scope/scope"));
  _scope = function () {
    return data;
  };
  return data;
}
function _pack() {
  const data = require("@teambit/legacy/dist/pack");
  _pack = function () {
    return data;
  };
  return data;
}
function _pMap() {
  const data = _interopRequireDefault(require("p-map"));
  _pMap = function () {
    return data;
  };
  return data;
}
function _scopeNotFound() {
  const data = require("./exceptions/scope-not-found");
  _scopeNotFound = function () {
    return data;
  };
  return data;
}
// @ts-ignore (for some reason the tsc -w not found this)

const DEFAULT_TAR_DIR_IN_CAPSULE = 'package-tar';
const PACK_CONCURRENCY = 10;
const TAR_FILE_ARTIFACT_NAME = 'package tar file';
exports.TAR_FILE_ARTIFACT_NAME = TAR_FILE_ARTIFACT_NAME;
class Packer {
  constructor(isolator, logger, host, scope) {
    this.isolator = isolator;
    this.logger = logger;
    this.host = host;
    this.scope = scope;
    (0, _defineProperty2().default)(this, "legacyPacker", void 0);
    this.legacyPacker = new (_pack().Packer)(this.logger);
  }
  async packComponent(componentId, scopePath, options) {
    var _this$scope;
    // By default do not load scope from cache when packing
    const loadScopeFromCache = options && options.loadScopeFromCache !== undefined ? !!options.loadScopeFromCache : false;
    const legacyScope = scopePath ? await _scope().default.load(scopePath, loadScopeFromCache) : (_this$scope = this.scope) === null || _this$scope === void 0 ? void 0 : _this$scope.legacyScope;
    if (!legacyScope) {
      throw new (_scopeNotFound().ScopeNotFound)(scopePath);
    }
    const capsule = await this.getCapsule(componentId, legacyScope);
    const res = await this.packCapsule(capsule, options.writeOptions, options.dryRun);
    return Object.assign({}, _lodash().default.omit(res, ['component']), {
      id: componentId
    });
  }
  async packMultipleCapsules(capsules, writeOptions = {
    override: true
  }, dryRun = false, omitFullTarPath = false) {
    // const description = `packing components${dryRun ? ' (dry-run)' : ''}`;
    const results = (0, _pMap().default)(capsules, capsule => {
      return this.packCapsule(capsule, writeOptions, dryRun, omitFullTarPath);
    }, {
      concurrency: PACK_CONCURRENCY
    });
    return results;
  }
  async packCapsule(capsule, writeOptions = {
    override: true
  }, dryRun = false, omitFullTarPath = false) {
    var _concreteWriteOpts$ou;
    const concreteWriteOpts = writeOptions;
    // Set the package-tar as out dir to easily read the tar later
    concreteWriteOpts.outDir = (_concreteWriteOpts$ou = concreteWriteOpts.outDir) !== null && _concreteWriteOpts$ou !== void 0 ? _concreteWriteOpts$ou : DEFAULT_TAR_DIR_IN_CAPSULE;
    const packResult = await this.legacyPacker.npmPack(capsule.path, concreteWriteOpts.outDir || capsule.path, concreteWriteOpts.override, dryRun);
    const component = capsule.component;
    const fieldsToRemove = [];
    if (omitFullTarPath) {
      fieldsToRemove.push('tarPath');
    }
    // TODO: @gilad please make sure to fix this type error now that I added lodash types
    const metadata = (0, _lodash().default)(packResult.metadata).omitBy(_lodash().default.isUndefined).omit(fieldsToRemove).value();
    return {
      component,
      metadata,
      errors: packResult.errors,
      warnings: packResult.warnings,
      startTime: packResult.startTime,
      endTime: packResult.endTime
    };
  }
  getArtifactDefInCapsule(outDir) {
    const rootDir = outDir || DEFAULT_TAR_DIR_IN_CAPSULE;
    const def = {
      name: TAR_FILE_ARTIFACT_NAME,
      globPatterns: [`${rootDir}/*.tgz`]
    };
    return def;
  }
  async getCapsule(componentIdStr, legacyScope) {
    const componentId = await this.host.resolveComponentId(componentIdStr);
    const network = await this.isolator.isolateComponents([componentId], {
      baseDir: this.host.path
    }, legacyScope);
    const capsule = network.seedersCapsules.getCapsule(componentId);
    if (!capsule) throw new Error(`capsule not found for ${componentId}`);
    return capsule;
  }
}
exports.Packer = Packer;

//# sourceMappingURL=packer.js.map