"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormatCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _timer() {
  const data = require("@teambit/legacy/dist/toolbox/timer");
  _timer = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
class FormatCmd {
  constructor(formatter, componentHost, workspace) {
    this.formatter = formatter;
    this.componentHost = componentHost;
    this.workspace = workspace;
    (0, _defineProperty2().default)(this, "name", 'format [component...]');
    (0, _defineProperty2().default)(this, "description", 'format components in the development workspace');
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "options", [['c', 'changed', 'format only new and modified components'], ['', 'check', 'will output a human-friendly message and a list of unformatted files, if any'], ['j', 'json', 'return the format results in json format']]);
  }
  async report([components = []], formatterOptions) {
    const {
      duration,
      data,
      componentsIdsToFormat
    } = await this.json([components], formatterOptions);
    const title = _chalk().default.bold(`formatting total of ${_chalk().default.cyan(componentsIdsToFormat.length.toString())} component(s) in workspace '${_chalk().default.cyan(this.componentHost.name)}`);
    const componentsOutputs = this.getAllComponentsResultOutput(data.results, {
      check: formatterOptions.check
    });
    const {
      seconds
    } = duration;
    const summery = `formatted ${_chalk().default.cyan(componentsIdsToFormat.length.toString())} components in ${_chalk().default.cyan(seconds.toString())}.`;
    return `${title}\n\n${componentsOutputs}\n\n${summery}`;
  }
  async json([components = []], formatterCmdOptions) {
    const timer = _timer().Timer.create();
    timer.start();
    const componentsIds = await this.getIdsToFormat(components, formatterCmdOptions.changed);
    const componentsToFormat = await this.workspace.getMany(componentsIds);
    const opts = {};
    const formatterResults = formatterCmdOptions.check ? await this.formatter.check(componentsToFormat, opts) : await this.formatter.format(componentsToFormat, opts);
    const jsonFormatterResults = toJsonFormatResults(formatterResults);
    const timerResponse = timer.stop();
    return {
      duration: timerResponse,
      data: jsonFormatterResults,
      componentsIdsToFormat: componentsToFormat.map(comp => comp.id.toString())
    };
  }
  async getIdsToFormat(components, changed = false) {
    if (components.length) {
      return this.workspace.resolveMultipleComponentIds(components);
    }
    if (changed) {
      return this.workspace.getNewAndModifiedIds();
    }
    return this.componentHost.listIds();
  }
  getAllComponentsResultOutput(componentsResult, context) {
    const allResults = componentsResult.map(comp => this.getOneComponentResultOutput(comp, context));
    return allResults.join('\n\n');
  }
  getOneComponentResultOutput(componentResult, context) {
    const title = _chalk().default.bold.cyan(componentResult.componentId.toString({
      ignoreVersion: true
    }));
    const filesWithIssues = componentResult.results.filter(fileResult => fileResult.hasIssues);
    if (!filesWithIssues || !filesWithIssues.length) {
      return `${title}\n${_chalk().default.green('no issues found')}`;
    }
    let subTitle = _chalk().default.green('the following files have been re-formatted:');
    if (context.check) {
      subTitle = _chalk().default.red('issues found in the following files:');
    }
    const files = filesWithIssues.map(this.getOneComponentFileResultOutput);
    return `${title}\n${subTitle}\n${files.join('\n')}`;
  }
  getOneComponentFileResultOutput(fileResult) {
    return fileResult.filePath;
  }
}
exports.FormatCmd = FormatCmd;
function toJsonFormatResults(results) {
  const newResults = results.results.map(res => {
    var _res$data;
    const resultsWithoutComponent = (_res$data = res.data) === null || _res$data === void 0 ? void 0 : _res$data.results.map(result => {
      return {
        componentId: result.component.id,
        results: result.results
      };
    });
    return (0, _lodash().compact)(resultsWithoutComponent);
  });
  return {
    results: (0, _lodash().compact)((0, _lodash().flatten)(newResults)),
    errors: results === null || results === void 0 ? void 0 : results.errors
  };
}

//# sourceMappingURL=format.cmd.js.map