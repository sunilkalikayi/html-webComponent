import { LaneId } from '@teambit/lane-id';
import { BitId, BitIds } from '@teambit/legacy/dist/bit-id';
import { Consumer } from '@teambit/legacy/dist/consumer';
import { ComponentWithDependencies, Scope } from '@teambit/legacy/dist/scope';
import DependencyGraph from '@teambit/legacy/dist/scope/graph/scope-graph';
import { Lane } from '@teambit/legacy/dist/scope/models';
import Component from '@teambit/legacy/dist/consumer/component';
import { FilesStatus, MergeStrategy } from '@teambit/legacy/dist/consumer/versions-ops/merge-version/merge-version';
import { MergeResultsThreeWay } from '@teambit/legacy/dist/consumer/versions-ops/merge-version/three-way-merge';
import VersionDependencies from '@teambit/legacy/dist/scope/version-dependencies';
import { GraphMain } from '@teambit/graph';
import { Workspace } from '@teambit/workspace';
export declare type ImportOptions = {
    ids: string[];
    verbose?: boolean;
    merge?: boolean;
    mergeStrategy?: MergeStrategy;
    writeToPath?: string;
    writeConfig?: boolean;
    override?: boolean;
    installNpmPackages: boolean;
    objectsOnly?: boolean;
    saveDependenciesAsComponents?: boolean;
    importDependenciesDirectly?: boolean;
    importDependents?: boolean;
    fromOriginalScope?: boolean;
    saveInLane?: boolean;
    lanes?: {
        laneIds: LaneId[];
        lanes: Lane[];
    };
    allHistory?: boolean;
};
declare type ComponentMergeStatus = {
    componentWithDependencies: ComponentWithDependencies;
    mergeResults: MergeResultsThreeWay | null | undefined;
};
declare type ImportedVersions = {
    [id: string]: string[];
};
export declare type ImportStatus = 'added' | 'updated' | 'up to date';
export declare type ImportDetails = {
    id: string;
    versions: string[];
    latestVersion: string | null;
    status: ImportStatus;
    filesStatus: FilesStatus | null | undefined;
    missingDeps: BitId[];
    deprecated: boolean;
    removed?: boolean;
};
export declare type ImportResult = {
    importedIds: BitId[];
    importedDeps: BitId[];
    writtenComponents?: Component[];
    importDetails: ImportDetails[];
    cancellationMessage?: string;
};
export default class ImportComponents {
    private workspace;
    private graph;
    options: ImportOptions;
    consumer: Consumer;
    scope: Scope;
    mergeStatus: {
        [id: string]: FilesStatus;
    };
    private laneObjects;
    private divergeData;
    constructor(workspace: Workspace, graph: GraphMain, options: ImportOptions);
    importComponents(): Promise<ImportResult>;
    importObjectsOnLane(): Promise<ImportResult>;
    importSpecificComponents(): Promise<ImportResult>;
    _fetchDivergeData(componentsWithDependencies: ComponentWithDependencies[]): Promise<void>;
    _throwForDivergedHistory(): void;
    private _importComponentsObjects;
    /**
     * consider the following use cases:
     * 1) no ids were provided. it should import all the lanes components objects AND main components objects
     * (otherwise, if main components are not imported and are missing, then bit-status complains about it)
     * 2) ids are provided with wildcards. we assume the user wants only the ids that are available on the lane.
     * because a user may entered "bit import scope/*" and this scope has many component on the lane and many not on the lane.
     * we want to bring only the components on the lane.
     * 3) ids are provided without wildcards. here, the user knows exactly what's needed and it's ok to get the ids from
     * main if not found on the lane.
     */
    private getBitIdsForLanes;
    private getBitIdsForNonLanes;
    private getBitIds;
    _getDependenciesFromGraph(bitIds: BitId[], graphs: DependencyGraph[]): BitId[];
    _getDependentsFromGraph(bitIds: BitId[], graphs: DependencyGraph[]): BitId[];
    _getComponentsGraphs(bitIds: BitId[]): Promise<DependencyGraph[]>;
    importAccordingToBitMap(): Promise<ImportResult>;
    private getIdsToImportFromBitmap;
    _getCurrentVersions(ids: BitIds): Promise<ImportedVersions>;
    /**
     * get import details, includes the diff between the versions array before import and after import
     */
    _getImportDetails(currentVersions: ImportedVersions, components: VersionDependencies[]): Promise<ImportDetails[]>;
    _throwForPotentialIssues(ids: BitIds): Promise<void>;
    _throwForModifiedOrNewComponents(ids: BitIds): Promise<void>;
    /**
     * Model Component id() calculation uses id.toString() for the hash.
     * If an imported component has scopereadonly name equals to a local name, both will have the exact same
     * hash and they'll override each other.
     */
    _throwForDifferentComponentWithSameName(ids: BitIds): void;
    _getMergeStatus(componentWithDependencies: ComponentWithDependencies): Promise<ComponentMergeStatus>;
    /**
     * 1) when there are conflicts and the strategy is "ours", don't write the imported component to
     * the filesystem, only update bitmap.
     *
     * 2) when there are conflicts and the strategy is "theirs", override the local changes by the
     * imported component. (similar to --override)
     *
     * 3) when there is no conflict or there are conflicts and the strategy is manual, write the files
     * according to the merge result. (done by applyModifiedVersion())
     */
    _updateComponentFilesPerMergeStrategy(componentMergeStatus: ComponentMergeStatus): FilesStatus | null | undefined;
    /**
     * update the component files if they are modified and there is a merge strategy.
     * returns only the components that need to be written to the filesystem
     */
    updateAllComponentsAccordingToMergeStrategy(componentsWithDependencies: ComponentWithDependencies[]): Promise<ComponentWithDependencies[]>;
    _shouldSaveLaneData(): boolean;
    _saveLaneDataIfNeeded(componentsWithDependencies: ComponentWithDependencies[]): Promise<void>;
    _writeToFileSystem(componentsWithDependencies: ComponentWithDependencies[]): Promise<void>;
}
export {};
