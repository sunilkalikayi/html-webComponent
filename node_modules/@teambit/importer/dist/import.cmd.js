"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImportCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _ramda() {
  const data = _interopRequireDefault(require("ramda"));
  _ramda = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _mergeVersion() {
  const data = require("@teambit/legacy/dist/consumer/versions-ops/merge-version/merge-version");
  _mergeVersion = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@teambit/legacy/dist/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _chalkBox() {
  const data = require("@teambit/legacy/dist/cli/chalk-box");
  _chalkBox = function () {
    return data;
  };
  return data;
}
class ImportCmd {
  // gets populated by yargs-adapter.handler().

  constructor(importer, docsDomain) {
    this.importer = importer;
    this.docsDomain = docsDomain;
    (0, _defineProperty2().default)(this, "name", 'import [component-patterns...]');
    (0, _defineProperty2().default)(this, "description", 'import components from their remote scopes to the local workspace');
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'component-patterns...',
      description: 'component IDs or component patterns (separated by space). Use patterns to import groups of components using a common scope or namespace. E.g., "utils/*" (wrap with double quotes)'
    }]);
    (0, _defineProperty2().default)(this, "extendedDescription", void 0);
    (0, _defineProperty2().default)(this, "group", 'collaborate');
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['p', 'path <path>', 'import components into a specific directory (a relative path in the workspace)'], ['o', 'objects', 'import components objects to the local scope without checkout (without writing them to the file system). This is a default behavior for import with no id argument'], ['d', 'display-dependencies', 'display the imported dependencies'], ['O', 'override', 'override local changes'], ['v', 'verbose', 'show verbose output for inspection'], ['j', 'json', 'return the output as JSON'],
    // ['', 'conf', 'write the configuration file (component.json) of the component'], // not working. need to fix once ComponentWriter is moved to Harmony
    ['', 'skip-npm-install', 'DEPRECATED. use "--skip-dependency-installation" instead'], ['', 'skip-dependency-installation', 'do not install packages of the imported components'], ['m', 'merge [strategy]', 'merge local changes with the imported version. strategy should be "theirs", "ours" or "manual"'], ['', 'dependencies', 'EXPERIMENTAL. import all dependencies and write them to the workspace'], ['', 'dependents', 'EXPERIMENTAL. import components found while traversing from the given ids upwards to the workspace components'], ['', 'save-in-lane', 'EXPERIMENTAL. when checked out to a lane and the component is not on the remote-lane, save it in the lane (default to save on main)'], ['', 'all-history', 'relevant for fetching all components objects. avoid optimizations, fetch all history versions, always']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "remoteOp", true);
    (0, _defineProperty2().default)(this, "_packageManagerArgs", void 0);
    this.extendedDescription = `https://${docsDomain}/components/importing-components
${(0, _constants().WILDCARD_HELP)('import')}`;
  }
  async report([ids = []], {
    path,
    objects = false,
    displayDependencies = false,
    override = false,
    verbose = false,
    json = false,
    conf,
    skipNpmInstall = false,
    skipDependencyInstallation = false,
    merge,
    saveInLane = false,
    dependencies = false,
    dependents = false,
    allHistory = false
  }) {
    if (objects && merge) {
      throw new (_generalError().default)('you cant use --objects and --merge flags combined');
    }
    if (override && merge) {
      throw new (_generalError().default)('you cant use --override and --merge flags combined');
    }
    if (!ids.length && dependencies) {
      throw new (_generalError().default)('you have to specify ids to use "--dependencies" flag');
    }
    if (!ids.length && dependents) {
      throw new (_generalError().default)('you have to specify ids to use "--dependents" flag');
    }
    if (skipNpmInstall) {
      // eslint-disable-next-line no-console
      console.log(_chalk().default.yellow(`"--skip-npm-install" has been deprecated, please use "--skip-dependency-installation" instead`));
      skipDependencyInstallation = true;
    }
    let mergeStrategy;
    if (merge && _ramda().default.is(String, merge)) {
      const options = Object.keys(_mergeVersion().MergeOptions);
      if (!options.includes(merge)) {
        throw new (_generalError().default)(`merge must be one of the following: ${options.join(', ')}`);
      }
      mergeStrategy = merge;
    }
    const importOptions = {
      ids,
      verbose,
      merge: Boolean(merge),
      mergeStrategy,
      writeToPath: path,
      objectsOnly: objects,
      override,
      writeConfig: Boolean(conf),
      installNpmPackages: !skipDependencyInstallation,
      saveInLane,
      importDependenciesDirectly: dependencies,
      importDependents: dependents,
      allHistory
    };
    const importResults = await this.importer.import(importOptions, this._packageManagerArgs);
    const {
      importDetails,
      importedIds,
      importedDeps
    } = importResults;
    if (json) {
      return JSON.stringify({
        importDetails
      }, null, 4);
    }
    if (!importedIds.length) {
      return _chalk().default.yellow(importResults.cancellationMessage || 'nothing to import');
    }
    const titlePrefix = importedIds.length === 1 ? 'successfully imported one component' : `successfully imported ${importedIds.length} components`;
    let upToDateCount = 0;
    const importedComponents = importedIds.map(bitId => {
      const details = importDetails.find(c => c.id === bitId.toStringWithoutVersion());
      if (!details) throw new Error(`missing details of component ${bitId.toString()}`);
      if (details.status === 'up to date') {
        upToDateCount += 1;
      }
      return formatPlainComponentItemWithVersions(bitId, details);
    });
    const upToDateStr = upToDateCount === 0 ? '' : `, ${upToDateCount} components are up to date`;
    const title = `${titlePrefix}${upToDateStr}`;
    const componentDependenciesOutput = [_chalk().default.green(title), ...(0, _lodash().compact)(importedComponents)].join('\n');
    const importedDepsOutput = displayDependencies && importedDeps.length ? (0, _utils().immutableUnshift)(_ramda().default.uniq(importedDeps.map(_chalkBox().formatPlainComponentItem)), _chalk().default.green(`\n\nsuccessfully imported ${importedDeps.length} component dependencies`)).join('\n') : '';
    const dependenciesOutput = componentDependenciesOutput + importedDepsOutput;
    return dependenciesOutput;
  }
}
exports.ImportCmd = ImportCmd;
function formatPlainComponentItemWithVersions(bitId, importDetails) {
  const status = importDetails.status;
  const id = bitId.toStringWithoutVersion();
  const getVersionsOutput = () => {
    if (!importDetails.versions.length) return '';
    if (importDetails.latestVersion) {
      return `${importDetails.versions.length} new version(s) available, latest ${importDetails.latestVersion}`;
    }
    return `new versions: ${importDetails.versions.join(', ')}`;
  };
  const versions = getVersionsOutput();
  const usedVersion = status === 'added' ? `, currently used version ${bitId.version}` : '';
  const getConflictMessage = () => {
    if (!importDetails.filesStatus) return '';
    const conflictedFiles = Object.keys(importDetails.filesStatus)
    // @ts-ignore file is set
    .filter(file => importDetails.filesStatus[file] === _mergeVersion().FileStatus.manual);
    if (!conflictedFiles.length) return '';
    return `(the following files were saved with conflicts ${conflictedFiles.map(file => _chalk().default.bold(file)).join(', ')}) `;
  };
  const conflictMessage = getConflictMessage();
  const deprecated = importDetails.deprecated ? _chalk().default.yellow('deprecated') : '';
  const removed = importDetails.removed ? _chalk().default.red('removed') : '';
  const missingDeps = importDetails.missingDeps.length ? _chalk().default.red(`missing dependencies: ${importDetails.missingDeps.map(d => d.toString()).join(', ')}`) : '';
  if (status === 'up to date' && !missingDeps && !deprecated && !conflictMessage) {
    return undefined;
  }
  return `- ${_chalk().default.green(status)} ${_chalk().default.cyan(id)} ${versions}${usedVersion} ${conflictMessage}${deprecated}${removed} ${missingDeps}`;
}

//# sourceMappingURL=import.cmd.js.map