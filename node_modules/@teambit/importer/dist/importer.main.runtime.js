"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImporterMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _community() {
  const data = require("@teambit/community");
  _community = function () {
    return data;
  };
  return data;
}
function _analytics() {
  const data = require("@teambit/legacy/dist/analytics/analytics");
  _analytics = function () {
    return data;
  };
  return data;
}
function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/bit/component-id-to-package-name"));
  _componentIdToPackageName = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");
  _legacyBitId = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/scope/component-ops/scope-components-importer"));
  _scopeComponentsImporter = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
function _scopeNotFoundOrDenied() {
  const data = require("@teambit/legacy/dist/remotes/exceptions/scope-not-found-or-denied");
  _scopeNotFoundOrDenied = function () {
    return data;
  };
  return data;
}
function _graph() {
  const data = _interopRequireDefault(require("@teambit/graph"));
  _graph = function () {
    return data;
  };
  return data;
}
function _laneNotFound() {
  const data = require("@teambit/legacy/dist/api/scope/lib/exceptions/lane-not-found");
  _laneNotFound = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _import() {
  const data = require("./import.cmd");
  _import = function () {
    return data;
  };
  return data;
}
function _importer() {
  const data = require("./importer.aspect");
  _importer = function () {
    return data;
  };
  return data;
}
function _fetchCmd() {
  const data = require("./fetch-cmd");
  _fetchCmd = function () {
    return data;
  };
  return data;
}
function _importComponents() {
  const data = _interopRequireDefault(require("./import-components"));
  _importComponents = function () {
    return data;
  };
  return data;
}
class ImporterMain {
  constructor(workspace, depResolver, graph) {
    this.workspace = workspace;
    this.depResolver = depResolver;
    this.graph = graph;
  }
  async import(importOptions, packageManagerArgs) {
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    const consumer = this.workspace.consumer;
    consumer.packageManagerArgs = packageManagerArgs;
    if (!importOptions.ids.length) {
      importOptions.objectsOnly = true;
    }
    if (this.workspace.consumer.isOnLane()) {
      const currentRemoteLane = await this.workspace.getCurrentRemoteLane();
      if (currentRemoteLane) {
        importOptions.lanes = {
          laneIds: [currentRemoteLane.toLaneId()],
          lanes: [currentRemoteLane]
        };
      } else if (!importOptions.ids.length) {
        // this is probably a local lane that was never exported.
        // although no need to fetch from the lane, still, the import is needed for main (which are available on this
        // local lane)
        const currentLaneId = this.workspace.getCurrentLaneId();
        importOptions.lanes = {
          laneIds: [currentLaneId],
          lanes: []
        };
      }
    }
    const importComponents = new (_importComponents().default)(this.workspace, this.graph, importOptions);
    const results = await importComponents.importComponents();
    _analytics().Analytics.setExtraData('num_components', results.importedIds.length);
    if (results.writtenComponents && results.writtenComponents.length) {
      await this.removeFromWorkspaceConfig(results.writtenComponents);
    }
    await consumer.onDestroy();
    return results;
  }

  /**
   * @todo: combine with this.import()
   */
  async importWithOptions(importOptions) {
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    const importComponents = new (_importComponents().default)(this.workspace, this.graph, importOptions);
    return importComponents.importComponents();
  }
  async fetch(ids, lanes, components, fromOriginalScope) {
    if (!lanes && !components) {
      throw new (_bitError().BitError)(`please provide the type of objects you would like to pull, the options are --components and --lanes`);
    }
    _loader().default.start('fetching objects...');
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    const consumer = this.workspace.consumer;
    const importOptions = {
      ids,
      objectsOnly: true,
      verbose: false,
      writeConfig: false,
      override: false,
      installNpmPackages: false,
      fromOriginalScope
    };
    if (lanes) {
      importOptions.lanes = await getLanes();
      importOptions.ids = [];
    }
    const importComponents = new (_importComponents().default)(this.workspace, this.graph, importOptions);
    const {
      importedIds,
      importDetails
    } = await importComponents.importComponents();
    _analytics().Analytics.setExtraData('num_components', importedIds.length);
    await consumer.onDestroy();
    return {
      importedIds,
      importDetails
    };
    async function getLanes() {
      const result = {
        laneIds: [],
        lanes: []
      };
      let remoteLaneIds = [];
      if (ids.length) {
        remoteLaneIds = ids.map(id => {
          const trackLane = consumer.scope.lanes.getRemoteTrackedDataByLocalLane(id);
          if (trackLane) return _laneId().LaneId.from(trackLane.remoteLane, trackLane.remoteScope);
          return _laneId().LaneId.parse(id);
        });
      } else {
        remoteLaneIds = await consumer.scope.objects.remoteLanes.getAllRemoteLaneIds();
      }
      const scopeComponentImporter = _scopeComponentsImporter().default.getInstance(consumer.scope);
      try {
        const remoteLanes = await scopeComponentImporter.importLanes(remoteLaneIds);
        result.laneIds.push(...remoteLaneIds);
        result.lanes.push(...remoteLanes);
      } catch (err) {
        if (err instanceof _legacyBitId().InvalidScopeName || err instanceof _scopeNotFoundOrDenied().ScopeNotFoundOrDenied || err instanceof _laneNotFound().LaneNotFound || err instanceof _legacyBitId().InvalidScopeNameFromRemote) {
          // the lane could be a local lane so no need to throw an error in such case
          _loader().default.stop();
          _logger().default.console(`unable to get lane's data from a remote due to an error:\n${err.message}`, 'warn', 'yellow');
        } else {
          throw err;
        }
      }
      return result;
    }
  }
  async removeFromWorkspaceConfig(component) {
    const importedPackageNames = this.getImportedPackagesNames(component);
    this.depResolver.removeFromRootPolicy(importedPackageNames);
    await this.depResolver.persistConfig(this.workspace.path);
  }
  getImportedPackagesNames(components) {
    return components.map(component => (0, _componentIdToPackageName().default)(component));
  }
  static async provider([cli, workspace, depResolver, community, graph]) {
    const importerMain = new ImporterMain(workspace, depResolver, graph);
    cli.register(new (_import().ImportCmd)(importerMain, community.getDocsDomain()), new (_fetchCmd().FetchCmd)(importerMain));
    return importerMain;
  }
}
exports.ImporterMain = ImporterMain;
(0, _defineProperty2().default)(ImporterMain, "slots", []);
(0, _defineProperty2().default)(ImporterMain, "dependencies", [_cli().CLIAspect, _workspace().default, _dependencyResolver().DependencyResolverAspect, _community().CommunityAspect, _graph().default]);
(0, _defineProperty2().default)(ImporterMain, "runtime", _cli().MainRuntime);
_importer().ImporterAspect.addRuntime(ImporterMain);

//# sourceMappingURL=importer.main.runtime.js.map