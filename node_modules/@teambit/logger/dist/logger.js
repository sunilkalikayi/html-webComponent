"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Logger = void 0;
function _loader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _longProcessLogger() {
  const data = require("./long-process-logger");
  _longProcessLogger = function () {
    return data;
  };
  return data;
}
class Logger {
  constructor(extensionName) {
    this.extensionName = extensionName;
  }
  trace(message, ...meta) {
    _logger().default.trace(this.colorMessage(message), ...meta);
  }
  debug(message, ...meta) {
    _logger().default.debug(this.colorMessage(message), ...meta);
  }
  info(message, ...meta) {
    _logger().default.info(this.colorMessage(message), ...meta);
  }
  warn(message, ...meta) {
    _logger().default.warn(this.colorMessage(message), ...meta);
  }
  error(message, ...meta) {
    _logger().default.error(this.colorMessage(message), ...meta);
  }
  fatal(message, ...meta) {
    _logger().default.fatal(this.colorMessage(message), ...meta);
  }
  get isLoaderStarted() {
    return _loader().default.isStarted;
  }
  /**
   * use it for a long running process. upon creation it logs the `processDescription`.
   * if the process involves iteration over a list of items, such as running tag on a list of
   * components, then pass the `totalItems` as the total of the total components in the list.
   * later, during the iteration, call `LongProcessLogger.logProgress(componentName)`.
   * once done, call `LongProcessLogger.end()`
   * the status-line will show all messages in the terminal.
   */
  createLongProcessLogger(processDescription, totalItems) {
    return new (_longProcessLogger().LongProcessLogger)(this, this.extensionName, processDescription, totalItems);
  }
  /**
   * single status-line on the bottom of the screen.
   * the text is replaced every time this method is called.
   */
  setStatusLine(text) {
    _loader().default.setTextAndRestart(text);
  }
  /**
   * remove the text from the last line on the screen.
   */
  clearStatusLine() {
    _loader().default.stop();
  }
  /**
   * print to the screen. if message is empty, print the last logged message.
   */
  console(message, ...meta) {
    if (message) this.info(message, meta);
    if (!_loader().default.isStarted && _logger().default.shouldWriteToConsole) {
      // eslint-disable-next-line no-console
      console.log(message, ...meta);
    } else {
      _loader().default.stopAndPersist({
        text: message
      });
    }
  }
  consoleWarn(message, ...meta) {
    if (message) this.warn(message, ...meta);
    if (!_loader().default.isStarted && _logger().default.shouldWriteToConsole) {
      // eslint-disable-next-line no-console
      console.warn(message, ...meta);
    } else {
      _loader().default.stopAndPersist({
        text: message
      });
    }
  }
  consoleError(message, ...meta) {
    if (message) this.error(message, ...meta);
    if (!_loader().default.isStarted && _logger().default.shouldWriteToConsole) {
      // eslint-disable-next-line no-console
      console.error(message, ...meta);
    } else {
      _loader().default.stopAndPersist({
        text: message
      });
    }
  }

  /**
   * print to the screen as a title, with bold text.
   */
  consoleTitle(message) {
    this.info(message);
    _loader().default.stopAndPersist({
      text: _chalk().default.bold(message)
    });
  }
  /**
   * print to the screen with a green `✔` prefix. if message is empty, print the last logged message.
   */
  consoleSuccess(message) {
    if (message) this.info(message);
    _loader().default.succeed(message);
  }

  /**
   * turn off the logger.
   */
  off() {
    return _loader().default.off();
  }
  on() {
    return _loader().default.on();
  }
  profile(id, console) {
    _logger().default.profile(id, console);
  }

  /**
   * print to the screen with a red `✖` prefix. if message is empty, print the last logged message.
   */
  consoleFailure(message) {
    if (message) this.error(message);
    _loader().default.fail(message);
  }
  /**
   * print to the screen with a red `⚠` prefix. if message is empty, print the last logged message.
   */
  consoleWarning(message) {
    if (message) {
      this.warn(message);
      message = _chalk().default.yellow(message);
    }
    _loader().default.warn(message);
  }
  colorMessage(message) {
    if (_logger().default.isJsonFormat) return `${this.extensionName}, ${message}`;
    return `${_chalk().default.bold(this.extensionName)}, ${message}`;
  }
}
exports.Logger = Logger;

//# sourceMappingURL=logger.js.map