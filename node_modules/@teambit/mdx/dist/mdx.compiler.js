"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MDXCompiler = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = require("fs-extra");
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _mdxModules() {
  const data = require("@teambit/mdx.modules.mdx-compiler");
  _mdxModules = function () {
    return data;
  };
  return data;
}
function _minimatch() {
  const data = _interopRequireDefault(require("minimatch"));
  _minimatch = function () {
    return data;
  };
  return data;
}
function _compilationModules() {
  const data = require("@teambit/compilation.modules.babel-compiler");
  _compilationModules = function () {
    return data;
  };
  return data;
}
class MDXCompiler {
  constructor(id, config) {
    this.id = id;
    this.config = config;
    (0, _defineProperty2().default)(this, "displayName", 'MDX');
    (0, _defineProperty2().default)(this, "shouldCopyNonSupportedFiles", true);
    (0, _defineProperty2().default)(this, "distDir", 'dist');
  }
  displayConfig() {
    return JSON.stringify(this.config, null, 2);
  }
  getDistDir() {
    return this.distDir;
  }
  transpileFile(fileContent, options) {
    const afterMdxCompile = (0, _mdxModules().compileSync)(fileContent, {
      filepath: options.filePath,
      // this compiler is not indented to compile according to the bit flavour.
      bitFlavour: false
    });
    const filePathAfterMdxCompile = this.replaceFileExtToJs(options.filePath);
    const afterBabelCompile = (0, _compilationModules().transpileFileContent)(afterMdxCompile.contents, {
      rootDir: options.componentDir,
      filePath: filePathAfterMdxCompile
    }, this.config.babelTransformOptions || {});
    return afterBabelCompile;
  }

  /**
   * compile components inside isolated capsules. this being used during tag for the release.
   * meaning, the final package of the component has the dists generated by this method.
   */
  async build(context) {
    const capsules = context.capsuleNetwork.seedersCapsules;
    const componentsResults = capsules.map(capsule => {
      const srcFiles = capsule.component.filesystem.files.filter(file => {
        return this.isFileSupported(file.relative);
      });
      const errors = srcFiles.map(srcFile => {
        try {
          const transpiled = this.transpileFile(srcFile.contents.toString('utf-8'), {
            filePath: this.replaceFileExtToJs(srcFile.relative),
            componentDir: capsule.path
          });
          if (!transpiled) {
            return undefined;
          }
          (0, _fsExtra().outputFileSync)((0, _path().join)(capsule.path, this.getDistPathBySrcPath(transpiled[0].outputPath)), transpiled[0].outputText);
          if (transpiled.length > 1) {
            (0, _fsExtra().outputFileSync)((0, _path().join)(capsule.path, this.distDir, transpiled[1].outputPath), transpiled[1].outputText);
          }
          return undefined;
        } catch (err) {
          return err;
        }
      });
      return {
        errors: errors.filter(err => !!err),
        component: capsule.component
      };
    });
    return {
      componentsResults,
      artifacts: [{
        name: 'dist',
        globPatterns: [`${this.distDir}/**`]
      }]
    };
  }

  /**
   * given a source file, return its parallel in the dists. e.g. "index.ts" => "dist/index.js"
   * both, the return path and the given path are relative paths.
   */
  getDistPathBySrcPath(srcPath) {
    const fileWithNewExt = this.replaceFileExtToJs(srcPath);
    return (0, _path().join)(this.distDir, fileWithNewExt);
  }
  replaceFileExtToJs(srcPath) {
    let fileWithNewExt = srcPath;
    if (this.isFileSupported(srcPath)) {
      fileWithNewExt = srcPath.replace('.mdx', '.mdx.js');
    }
    return fileWithNewExt;
  }

  /**
   * only supported files matching get compiled. others, are copied to the dist dir.
   */
  isFileSupported(filePath) {
    var _this$config$ignoredE, _this$config$ignoredP;
    const ignoredExtensions = (_this$config$ignoredE = this.config.ignoredExtensions) !== null && _this$config$ignoredE !== void 0 ? _this$config$ignoredE : [];
    const ignoredExt = ignoredExtensions.find(ext => filePath.endsWith(ext));
    const ignoredPatterns = (_this$config$ignoredP = this.config.ignoredPatterns) !== null && _this$config$ignoredP !== void 0 ? _this$config$ignoredP : [];
    const ignoredPattern = ignoredPatterns.find(pattern => (0, _minimatch().default)(filePath, pattern));
    return !ignoredExt && !ignoredPattern && (filePath.endsWith('.mdx') || filePath.endsWith('.md'));
  }

  /**
   * returns the version of the current compiler instance (e.g. '4.0.1').
   */
  version() {
    return '';
  }
}
exports.MDXCompiler = MDXCompiler;

//# sourceMappingURL=mdx.compiler.js.map