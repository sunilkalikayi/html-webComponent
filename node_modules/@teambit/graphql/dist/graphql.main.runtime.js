"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Verb = exports.GraphqlMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _graphqlTools() {
  const data = require("graphql-tools");
  _graphqlTools = function () {
    return data;
  };
  return data;
}
function _core() {
  const data = require("@graphql-modules/core");
  _core = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _express() {
  const data = _interopRequireDefault(require("express"));
  _express = function () {
    return data;
  };
  return data;
}
function _expressGraphql() {
  const data = require("express-graphql");
  _expressGraphql = function () {
    return data;
  };
  return data;
}
function _toolboxNetwork() {
  const data = require("@teambit/toolbox.network.get-port");
  _toolboxNetwork = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = require("graphql");
  _graphql = function () {
    return data;
  };
  return data;
}
function _graphqlSubscriptions() {
  const data = require("graphql-subscriptions");
  _graphqlSubscriptions = function () {
    return data;
  };
  return data;
}
function _http() {
  const data = require("http");
  _http = function () {
    return data;
  };
  return data;
}
function _httpProxy() {
  const data = _interopRequireDefault(require("http-proxy"));
  _httpProxy = function () {
    return data;
  };
  return data;
}
function _subscriptionsTransportWs() {
  const data = require("subscriptions-transport-ws");
  _subscriptionsTransportWs = function () {
    return data;
  };
  return data;
}
function _cors() {
  const data = _interopRequireDefault(require("cors"));
  _cors = function () {
    return data;
  };
  return data;
}
function _createRemoteSchemas() {
  const data = require("./create-remote-schemas");
  _createRemoteSchemas = function () {
    return data;
  };
  return data;
}
function _graphql2() {
  const data = require("./graphql.aspect");
  _graphql2 = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
let Verb;
exports.Verb = Verb;
(function (Verb) {
  Verb["WRITE"] = "write";
  Verb["READ"] = "read";
})(Verb || (exports.Verb = Verb = {}));
class GraphqlMain {
  constructor(
  /**
   * extension config
   */
  config,
  /**
   * slot for registering graphql modules
   */
  moduleSlot,
  /**
   * harmony context.
   */
  context,
  /**
   * logger extension.
   */
  logger, graphQLServerSlot,
  /**
   * graphql pubsub. allows to emit events to clients.
   */
  pubSubSlot) {
    this.config = config;
    this.moduleSlot = moduleSlot;
    this.context = context;
    this.logger = logger;
    this.graphQLServerSlot = graphQLServerSlot;
    this.pubSubSlot = pubSubSlot;
    (0, _defineProperty2().default)(this, "modules", new Map());
  }
  get pubsub() {
    const pubSubSlots = this.pubSubSlot.values();
    if (pubSubSlots.length) return pubSubSlots[0];
    return new (_graphqlSubscriptions().PubSub)();
  }
  /**
   * returns the schema for a specific aspect by its id.
   */
  getSchema(aspectId) {
    return this.moduleSlot.get(aspectId);
  }

  /**
   * get multiple schema by aspect ids.
   */
  getSchemas(aspectIds) {
    return this.moduleSlot.toArray().filter(([aspectId]) => {
      return aspectIds.includes(aspectId);
    }).map(([, schema]) => {
      return schema;
    });
  }
  async createServer(options) {
    const {
      graphiql = true
    } = options;
    const localSchema = this.createRootModule(options.schemaSlot);
    const remoteSchemas = await (0, _createRemoteSchemas().createRemoteSchemas)(options.remoteSchemas || this.graphQLServerSlot.values());
    const schemas = [localSchema.schema].concat(remoteSchemas).filter(x => x);
    const schema = (0, _graphqlTools().mergeSchemas)({
      schemas
    });

    // TODO: @guy please consider to refactor to express extension.
    const app = options.app || (0, _express().default)();
    app.use(
    // @ts-ignore todo: it's not clear what's the issue.
    (0, _cors().default)({
      origin(origin, callback) {
        callback(null, true);
      },
      credentials: true
    }));
    app.use('/graphql',
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    (0, _expressGraphql().graphqlHTTP)((request, res, params) => ({
      customFormatErrorFn: err => {
        var _err$originalError, _err$originalError$er, _err$originalError2, _err$originalError2$c, _err$originalError3, _err$originalError3$e, _err$originalError4;
        this.logger.error('graphql got an error during running the following query:', params);
        this.logger.error('graphql error ', err);
        return Object.assign(err, {
          // @ts-ignore
          ERR_CODE: (err === null || err === void 0 ? void 0 : (_err$originalError = err.originalError) === null || _err$originalError === void 0 ? void 0 : (_err$originalError$er = _err$originalError.errors) === null || _err$originalError$er === void 0 ? void 0 : _err$originalError$er[0].ERR_CODE) || ((_err$originalError2 = err.originalError) === null || _err$originalError2 === void 0 ? void 0 : (_err$originalError2$c = _err$originalError2.constructor) === null || _err$originalError2$c === void 0 ? void 0 : _err$originalError2$c.name),
          // @ts-ignore
          HTTP_CODE: (err === null || err === void 0 ? void 0 : (_err$originalError3 = err.originalError) === null || _err$originalError3 === void 0 ? void 0 : (_err$originalError3$e = _err$originalError3.errors) === null || _err$originalError3$e === void 0 ? void 0 : _err$originalError3$e[0].HTTP_CODE) || ((_err$originalError4 = err.originalError) === null || _err$originalError4 === void 0 ? void 0 : _err$originalError4.code)
        });
      },
      schema,
      rootValue: request,
      graphiql
    })));
    const server = (0, _http().createServer)(app);
    const subscriptionsPort = options.subscriptionsPortRange || this.config.subscriptionsPortRange;
    const subscriptionServerPort = await this.getPort(subscriptionsPort);
    const {
      port
    } = await this.createSubscription(options, subscriptionServerPort);
    this.proxySubscription(server, port);
    return server;
  }

  /**
   * register a new graphql server.
   */
  registerServer(server) {
    this.graphQLServerSlot.register(server);
    return this;
  }

  /**
   * register a pubsub client
   */
  registerPubSub(pubsub) {
    const pubSubSlots = this.pubSubSlot.toArray();
    if (pubSubSlots.length) throw new Error('can not register more then one pubsub provider');
    this.pubSubSlot.register(pubsub);
    return this;
  }

  /**
   * start a graphql server.
   */
  async listen(port, server, app) {
    const serverPort = port || this.config.port;
    const subServer = server || (await this.createServer({
      app
    }));
    subServer.listen(serverPort, () => {
      this.logger.info(`API Server over HTTP is now running on http://localhost:${serverPort}`);
      this.logger.info(`API Server over web socket with subscriptions is now running on ws://localhost:${serverPort}/${this.config.subscriptionsPath}`);
    });
  }

  /**
   * register a new graphql module.
   */
  register(schema) {
    // const module = new GraphQLModule(schema);
    this.moduleSlot.register(schema);
    return this;
  }
  async getPort(range) {
    const [from, to] = range;
    return _toolboxNetwork().Port.getPort(from, to);
  }

  /** create Subscription server with different port */

  async createSubscription(options, port) {
    // Create WebSocket listener server
    const websocketServer = (0, _http().createServer)((request, response) => {
      response.writeHead(404);
      response.end();
    });

    // Bind it to port and start listening
    websocketServer.listen(port, () => this.logger.debug(`Websocket Server is now running on http://localhost:${port}`));
    const localSchema = this.createRootModule(options.schemaSlot);
    const remoteSchemas = await (0, _createRemoteSchemas().createRemoteSchemas)(options.remoteSchemas || this.graphQLServerSlot.values());
    const schemas = [localSchema.schema].concat(remoteSchemas).filter(x => x);
    const schema = (0, _graphqlTools().mergeSchemas)({
      schemas
    });

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const subServer = new (_subscriptionsTransportWs().SubscriptionServer)({
      execute: _graphql().execute,
      subscribe: _graphql().subscribe,
      schema,
      onConnect: options.onWsConnect
    }, {
      server: websocketServer,
      path: this.config.subscriptionsPath
    });
    return {
      subServer,
      port
    };
  }
  /** proxy ws Subscription server to avoid conflict with different websocket connections */

  proxySubscription(server, port) {
    const proxServer = _httpProxy().default.createProxyServer();
    const subscriptionsPath = this.config.subscriptionsPath;
    server.on('upgrade', function (req, socket, head) {
      if (req.url === subscriptionsPath) {
        proxServer.ws(req, socket, head, {
          target: {
            host: 'localhost',
            port
          }
        });
      }
    });
  }
  createRootModule(schemaSlot) {
    const modules = this.buildModules(schemaSlot);
    return new (_core().GraphQLModule)({
      imports: modules
    });
  }
  buildModules(schemaSlot) {
    const schemaSlots = schemaSlot ? schemaSlot.toArray() : this.moduleSlot.toArray();
    return schemaSlots.map(([extensionId, schema]) => {
      const moduleDeps = this.getModuleDependencies(extensionId);
      const module = new (_core().GraphQLModule)({
        typeDefs: schema.typeDefs,
        resolvers: schema.resolvers,
        schemaDirectives: schema.schemaDirectives,
        imports: moduleDeps,
        context: session => {
          var _session$headers;
          return _objectSpread(_objectSpread({}, session), {}, {
            verb: (session === null || session === void 0 ? void 0 : (_session$headers = session.headers) === null || _session$headers === void 0 ? void 0 : _session$headers['x-verb']) || Verb.READ
          });
        }
      });
      this.modules.set(extensionId, module);
      return module;
    });
  }
  getModuleDependencies(extensionId) {
    const extension = this.context.extensions.get(extensionId);
    if (!extension) throw new Error(`aspect ${extensionId} was not found`);
    const deps = this.context.getDependencies(extension);
    const ids = deps.map(dep => dep.id);

    // @ts-ignore check :TODO why types are breaking here.
    return Array.from(this.modules.entries()).map(([depId, module]) => {
      const dep = ids.includes(depId);
      if (!dep) return undefined;
      return module;
    }).filter(module => !!module);
  }
  static async provider([loggerFactory], config, [moduleSlot, graphQLServerSlot, pubSubSlot], context) {
    const logger = loggerFactory.createLogger(_graphql2().GraphqlAspect.id);
    const graphqlMain = new GraphqlMain(config, moduleSlot, context, logger, graphQLServerSlot, pubSubSlot);
    return graphqlMain;
  }
}
exports.GraphqlMain = GraphqlMain;
(0, _defineProperty2().default)(GraphqlMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(GraphqlMain, "defaultConfig", {
  port: 4000,
  subscriptionsPortRange: [2000, 2100],
  subscriptionsPath: '/subscriptions'
});
(0, _defineProperty2().default)(GraphqlMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(GraphqlMain, "dependencies", [_logger().LoggerAspect]);
_graphql2().GraphqlAspect.addRuntime(GraphqlMain);

//# sourceMappingURL=graphql.main.runtime.js.map