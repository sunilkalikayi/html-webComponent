"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.YarnPackageManager = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _parsePackageName() {
  const data = _interopRequireDefault(require("parse-package-name"));
  _parsePackageName = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _core() {
  const data = require("@yarnpkg/core");
  _core = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@yarnpkg/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _fslib() {
  const data = require("@yarnpkg/fslib");
  _fslib = function () {
    return data;
  };
  return data;
}
function _pluginNpm() {
  const data = _interopRequireDefault(require("@yarnpkg/plugin-npm"));
  _pluginNpm = function () {
    return data;
  };
  return data;
}
function _parseOverrides() {
  const data = require("@pnpm/parse-overrides");
  _parseOverrides = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _userHome() {
  const data = _interopRequireDefault(require("user-home"));
  _userHome = function () {
    return data;
  };
  return data;
}
function _versionSelectorType2() {
  const data = _interopRequireDefault(require("version-selector-type"));
  _versionSelectorType2 = function () {
    return data;
  };
  return data;
}
function _yaml() {
  const data = _interopRequireDefault(require("yaml"));
  _yaml = function () {
    return data;
  };
  return data;
}
function _createRootComponentsDir() {
  const data = require("./create-root-components-dir");
  _createRootComponentsDir = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class YarnPackageManager {
  constructor(depResolver, logger) {
    this.depResolver = depResolver;
    this.logger = logger;
  }
  async install({
    rootDir,
    manifests,
    componentDirectoryMap
  }, installOptions = {}) {
    this.logger.setStatusLine('installing dependencies');
    const rootDirPath = _fslib().npath.toPortablePath(rootDir);
    const cacheDir = this.getCacheFolder(installOptions.cacheRootDir);
    const config = await this.computeConfiguration(rootDirPath, cacheDir, {
      nodeLinker: installOptions.nodeLinker,
      packageManagerConfigRootDir: installOptions.packageManagerConfigRootDir
    });
    const project = new (_core().Project)(rootDirPath, {
      configuration: config
    });

    // @ts-ignore
    project.setupResolutions();
    if (installOptions.rootComponentsForCapsules && !installOptions.useNesting) {
      installOptions.overrides = _objectSpread(_objectSpread({}, installOptions.overrides), this._createLocalDirectoryOverrides(rootDir, componentDirectoryMap));
    }
    const workspaceManifest = manifests[rootDir];
    manifests = (0, _lodash().omit)(manifests, rootDir);
    const rootWs = await this.createWorkspace(rootDir, project, workspaceManifest, installOptions.overrides);
    if (installOptions.rootComponents) {
      rootWs.manifest.installConfig = {
        hoistingLimits: 'dependencies'
      };
    }
    if (installOptions.rootComponents) {
      // Manifests are extended with "wrapper components"
      // that group all workspace components with their dependencies and peer dependencies.
      manifests = _objectSpread(_objectSpread({}, await (0, _createRootComponentsDir().createRootComponentsDir)({
        depResolver: this.depResolver,
        rootDir,
        componentDirectoryMap
      })), Object.entries(manifests).reduce((acc, [dir, manifest]) => {
        acc[dir] = _objectSpread(_objectSpread({}, manifest), {}, {
          dependencies: _objectSpread(_objectSpread(_objectSpread({}, manifest.peerDependencies), manifest['defaultPeerDependencies']), manifest.dependencies)
        });
        return acc;
      }, {}));
    } else if (installOptions.useNesting) {
      manifests[rootDir] = workspaceManifest;
      // Nesting is used for scope aspect capsules.
      // In a capsule, all peer dependencies should be installed,
      // so we make runtime dependencies from peer dependencies.
      manifests[rootDir].dependencies = _objectSpread(_objectSpread(_objectSpread({}, manifests[rootDir].peerDependencies), manifests[rootDir]['defaultPeerDependencies']), manifests[rootDir].dependencies);
    } else if (installOptions.rootComponentsForCapsules) {
      await updateManifestsForInstallationInWorkspaceCapsules(manifests);
    } else {
      manifests = await (0, _dependencyResolver().extendWithComponentsFromDir)(rootDir, manifests);
    }
    this.logger.debug(`running installation in root dir ${rootDir}`);
    this.logger.debug('root manifest for installation', workspaceManifest);
    this.logger.debug('components manifests for installation', manifests);
    const workspacesP = Object.keys(manifests).map(async path => {
      const manifest = manifests[path];
      const workspace = await this.createWorkspace(path, project, manifest);
      return workspace;
    });
    const workspaces = await Promise.all(workspacesP);
    if (!installOptions.rootComponents && !installOptions.rootComponentsForCapsules && !installOptions.useNesting) {
      const workspacesIdents = {};
      for (const workspace of workspaces) {
        const workspaceIdentHash = workspace.locator.identHash;
        if (workspacesIdents[workspaceIdentHash]) {
          this.logger.debug(`overriding internal workspace fields to prevent duplications for workspace ${workspace.cwd}`);
          this.overrideInternalWorkspaceParams(workspace);
        }
        workspacesIdents[workspace.locator.identHash] = true;
      }
    }
    if (!manifests[rootDir]) {
      workspaces.push(rootWs);
    }
    this.setupWorkspaces(project, workspaces);
    const cache = await _core().Cache.find(config);
    // const existingPackageJsons = await this.backupPackageJsons(rootDir, componentDirectoryMap);

    const installReport = await _core().StreamReport.start({
      stdout: process.stdout,
      configuration: config
    }, async report => {
      await project.install({
        persistProject: false,
        cache,
        report
      });
      await project.persistLockfile();
    });

    // TODO: check if package.json and link files generation can be prevented through the yarn API or
    // mock the files by hooking to `xfs`.
    // see the persistProject: false above
    // await this.restorePackageJsons(existingPackageJsons);

    if (installReport.hasErrors()) process.exit(installReport.exitCode());
    this.logger.consoleSuccess('installing dependencies');
  }

  /**
   * Every component is overriden with a local directory of that component.
   * So the component will be installed from the local directory, not from the registry.
   */
  _createLocalDirectoryOverrides(rootDir, componentDirectoryMap) {
    const overrides = {};
    Array.from(componentDirectoryMap.hashMap.entries()).forEach(([, [component, path]]) => {
      const name = this.depResolver.getPackageName(component);
      overrides[name] = `file:${(0, _path().relative)(rootDir, path)}`;
    });
    return overrides;
  }
  getPackageJsonPath(dir) {
    const packageJsonPath = (0, _path().join)(dir, 'package.json');
    return packageJsonPath;
  }
  async backupPackageJsons(rootDir, componentDirectoryMap) {
    const result = {};
    const rootPackageJsonPath = this.getPackageJsonPath(rootDir);
    result[rootPackageJsonPath] = await this.getFileToBackup(rootPackageJsonPath);
    const componentsBackupsP = componentDirectoryMap.toArray().map(async ([component, dir]) => {
      const {
        packageJsonPath,
        file
      } = await this.getComponentPackageJsonToBackup(component, dir);
      result[packageJsonPath] = file;
    });
    await Promise.all(componentsBackupsP);
    return result;
  }
  async restorePackageJsons(backupJsons) {
    const promises = Object.entries(backupJsons).map(async ([packageJsonPath, file]) => {
      const exists = await _fsExtra().default.pathExists(packageJsonPath);
      // if there is no backup it means it wasn't there before and should be deleted
      if (!file) {
        if (exists) {
          return _fsExtra().default.remove(packageJsonPath);
        }
        return undefined;
      }
      return _fsExtra().default.writeFile(packageJsonPath, file);
    });
    await Promise.all(promises);
  }
  async getFileToBackup(packageJsonPath) {
    const exists = await _fsExtra().default.pathExists(packageJsonPath);
    if (!exists) {
      return undefined;
    }
    const existingFile = await _fsExtra().default.readFile(packageJsonPath);
    return existingFile;
  }
  async getComponentPackageJsonToBackup(component, dir) {
    const packageJsonPath = (0, _path().resolve)((0, _path().join)(dir, 'package.json'));
    const result = {
      packageJsonPath,
      file: await this.getFileToBackup(packageJsonPath)
    };
    return result;
  }
  async createWorkspace(rootDir, project, manifest, overrides) {
    const wsPath = _fslib().npath.toPortablePath(rootDir);
    const name = manifest.name || 'workspace';
    const ws = new (_core().Workspace)(wsPath, {
      project
    });
    await ws.setup();
    const identity = _core().structUtils.parseIdent(name);
    // const needOverrideInternal = !!ws.manifest.name && !!manifest.name;
    ws.manifest.name = identity;
    ws.manifest.version = manifest.version;
    ws.manifest.dependencies = this.computeDeps(manifest.dependencies);
    ws.manifest.devDependencies = this.computeDeps(manifest.devDependencies);
    ws.manifest.peerDependencies = this.computeDeps(manifest.peerDependencies);
    ws.manifest.installConfig = manifest.installConfig;
    if (overrides) {
      ws.manifest.resolutions = convertOverridesToResolutions(overrides);
    }

    // if (needOverrideInternal) this.overrideInternalWorkspaceParams(ws);

    return ws;
  }

  /**
   * This is used to handle cases where in the capsules dirs we have the same component with different versions
   * The yarn ident is calculated by the manifest (package.json) name if exist
   * in our case for the same component with different versions we will get the same ident which will result errors later.
   * This is make sense in the original case of yarn workspace (it make sense you don't have 2 workspace with same name)
   * However in our case it doesn't make sense.
   * This function will make sure the ident will use the version as well
   * @param ws
   */
  overrideInternalWorkspaceParams(ws) {
    var _ws$manifest$name, _ws$manifest$name2;
    const ident = _core().structUtils.makeIdent(((_ws$manifest$name = ws.manifest.name) === null || _ws$manifest$name === void 0 ? void 0 : _ws$manifest$name.scope) || null, `${(_ws$manifest$name2 = ws.manifest.name) === null || _ws$manifest$name2 === void 0 ? void 0 : _ws$manifest$name2.name}-${ws.manifest.version}`);
    ws.manifest.name = ident;

    // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)
    ws.locator = _core().structUtils.makeLocator(ident, ws.reference);

    // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)
    ws.anchoredDescriptor = _core().structUtils.makeDescriptor(ws.locator, `${_core().WorkspaceResolver.protocol}${ws.relativeCwd}`);

    // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)
    ws.anchoredLocator = _core().structUtils.makeLocator(ws.locator, `${_core().WorkspaceResolver.protocol}${ws.relativeCwd}`);
  }
  setupWorkspaces(project, workspaces) {
    project.workspaces = [];
    project.workspacesByCwd = new Map();
    project.workspacesByIdent = new Map();
    workspaces.forEach(workspace => {
      const dup = project.workspacesByIdent.get(workspace.locator.identHash);
      if (typeof dup !== `undefined`) {
        throw new Error(`Duplicate workspace name: ${workspace.cwd} conflicts with ${dup.cwd}`);
      }
      project.workspaces.push(workspace);
      project.workspacesByCwd.set(workspace.cwd, workspace);
      project.workspacesByIdent.set(workspace.locator.identHash, workspace);
    });
  }
  async getScopedRegistries(registries) {
    const scopedRegistries = Object.keys(registries.scopes).reduce((acc, scopeName) => {
      const regDef = registries.scopes[scopeName];
      const authProp = this.getAuthProp(regDef);
      acc[scopeName] = {
        npmRegistryServer: regDef.uri,
        npmAlwaysAuth: regDef.alwaysAuth
      };
      if (authProp) {
        acc[scopeName][authProp.keyName] = authProp.value;
      }
      return acc;
    }, {});
    return scopedRegistries;
  }
  getAuthProp(registry) {
    if (registry.token) {
      return {
        keyName: 'npmAuthToken',
        value: registry.token
      };
    }
    if (registry.baseToken) {
      return {
        keyName: 'npmAuthIdent',
        value: registry.baseToken
      };
    }
    return undefined;
  }
  getCacheFolder(baseDir = _userHome().default) {
    return `${baseDir}/.yarn/cache`;
  }

  // TODO: implement this to automate configuration.
  async computeConfiguration(rootDirPath, cacheFolder, options) {
    const registries = await this.depResolver.getRegistries();
    const proxyConfig = await this.depResolver.getProxyConfig();
    const networkConfig = await this.depResolver.getNetworkConfig();
    const pluginConfig = (0, _cli().getPluginConfiguration)();
    let startingCwd;
    if (options.packageManagerConfigRootDir) {
      startingCwd = _fslib().npath.toPortablePath(options.packageManagerConfigRootDir);
    } else {
      startingCwd = rootDirPath;
    }
    const config = await _core().Configuration.find(startingCwd, pluginConfig);
    const scopedRegistries = await this.getScopedRegistries(registries);
    const defaultRegistry = registries.defaultRegistry;
    const defaultAuthProp = this.getAuthProp(defaultRegistry);
    const data = {
      nodeLinker: options.nodeLinker === 'isolated' ? 'pnpm' : 'node-modules',
      installStatePath: `${rootDirPath}/.yarn/install-state.gz`,
      cacheFolder,
      pnpDataPath: `${rootDirPath}/.pnp.meta.json`,
      npmScopes: scopedRegistries,
      virtualFolder: `${rootDirPath}/.yarn/__virtual__`,
      npmRegistryServer: defaultRegistry.uri || 'https://registry.yarnpkg.com',
      npmAlwaysAuth: defaultRegistry.alwaysAuth,
      httpProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.httpProxy,
      httpsProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.httpsProxy,
      enableStrictSsl: networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.strictSSL,
      // enableInlineBuilds: true,
      globalFolder: `${_userHome().default}/.yarn/global`,
      // We need to disable self-references as say create circular symlinks.
      nmSelfReferences: false

      // TODO: check about support for the following: (see more here - https://github.com/yarnpkg/berry/issues/1434#issuecomment-801449010)
      // ca?: string;
      // cert?: string;
      // key?: string;
      // noProxy?: boolean | string;
    };

    if (defaultAuthProp) {
      data[defaultAuthProp.keyName] = defaultAuthProp.value;
    }
    // TODO: node-modules is hardcoded now until adding support for pnp.
    config.use('<bit>', data, rootDirPath, {});
    return config;
  }
  computeDeps(rawDeps) {
    const map = new Map();
    if (!rawDeps) return map;
    Object.keys(rawDeps).forEach(packageName => {
      const ident = _core().structUtils.parseIdent(packageName);
      map.set(ident.identHash, _core().structUtils.makeDescriptor(ident, rawDeps[packageName]));
    });
    return map;
  }
  async resolveRemoteVersion(packageName, options) {
    var _versionSelectorType;
    const parsedPackage = (0, _parsePackageName().default)(packageName);
    const parsedVersion = parsedPackage.version;
    const versionType = parsedVersion && ((_versionSelectorType = (0, _versionSelectorType2().default)(parsedVersion)) === null || _versionSelectorType === void 0 ? void 0 : _versionSelectorType.type);
    if (versionType === 'version') {
      return {
        packageName: parsedPackage.name,
        version: parsedVersion,
        isSemver: true
      };
    }
    if (!_pluginNpm().default.resolvers) {
      throw new Error('npm resolvers for yarn API not found');
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const [_NpmRemapResolver, NpmSemverResolver, NpmTagResolver] = _pluginNpm().default.resolvers;
    let resolver = new NpmSemverResolver();
    const ident = _core().structUtils.parseIdent(parsedPackage.name);
    let range = 'npm:*';
    const rootDirPath = _fslib().npath.toPortablePath(options.rootDir);
    const cacheDir = this.getCacheFolder(options.cacheRootDir);
    const config = await this.computeConfiguration(rootDirPath, cacheDir, {
      packageManagerConfigRootDir: options.packageManagerConfigRootDir
    });
    const project = new (_core().Project)(rootDirPath, {
      configuration: config
    });
    const report = new (_core().LightReport)({
      configuration: config,
      stdout: process.stdout
    });

    // Handle cases when the version is a dist tag like dev / latest for example bit install lodash@latest
    if (versionType === 'tag') {
      resolver = new NpmTagResolver();
      range = `npm:${parsedPackage.version}`;
    }
    const descriptor = _core().structUtils.makeDescriptor(ident, range);

    // @ts-ignore
    project.setupResolutions();
    const resolveOptions = {
      project,
      resolver,
      report
    };
    // const candidates = await resolver.getCandidates(descriptor, new Map(), resolveOptions);
    const candidates = await resolver.getCandidates(descriptor, new Map(), resolveOptions);
    const parsedRange = _core().structUtils.parseRange(candidates[0].reference);
    const version = parsedRange.selector;
    return {
      packageName: parsedPackage.name,
      version,
      isSemver: true
    };
  }
  async getInjectedDirs(rootDir, componentDir, packageName) {
    const modulesDir = (0, _path().join)(rootDir, 'node_modules');
    (0, _path().relative)(modulesDir, componentDir);
    let yarnStateContent;
    try {
      yarnStateContent = await _fsExtra().default.readFile((0, _path().join)(modulesDir, '.yarn-state.yml'), 'utf-8');
    } catch (err) {
      if (err.code === 'ENOENT') return [];
    }
    const yarnState = _yaml().default.parse(yarnStateContent);
    const injectedDirs = [];
    for (const [key, {
      locations
    }] of Object.entries(yarnState)) {
      if (key.startsWith(`${packageName}@`) || key.startsWith(`${packageName}__root@`)) {
        for (const location of locations) {
          injectedDirs.push(location);
        }
      }
    }
    return injectedDirs;
  }
  supportsDedupingOnExistingRoot() {
    return true;
  }
}
exports.YarnPackageManager = YarnPackageManager;
function convertOverridesToResolutions(overrides) {
  const parsedOverrides = (0, _parseOverrides().parseOverrides)(overrides);
  return parsedOverrides.map(override => ({
    pattern: {
      from: override.parentPkg ? toYarnResolutionSelector(override.parentPkg) : undefined,
      descriptor: toYarnResolutionSelector(override.targetPkg)
    },
    reference: override.newPref
  }));
}
function toYarnResolutionSelector({
  name,
  pref
}) {
  return {
    fullName: name,
    description: pref
  };
}

/**
 * This function prepares the component manifests for installation inside a capsule.
 * Inside a capsule, all peer dependencies of the component should be installed.
 * So peer dependencies are added to the manifest as runtime dependencies.
 * Also, the package.json files are update to contain other component dependencies
 * in dependencies as local "file:" dependencies.
 */
async function updateManifestsForInstallationInWorkspaceCapsules(manifests) {
  await Promise.all(Object.entries(manifests).map(async ([dir, manifest]) => {
    const pkgJsonPath = (0, _path().join)(dir, 'package.json');
    const pkgJson = await _fsExtra().default.readJson(pkgJsonPath);
    // We need to write the package.json files because they need to contain the workspace dependencies.
    // When packages are installed via the "file:" protocol, Yarn reads their package.json files
    // from the file system even if they are from the workspace.
    await _fsExtra().default.writeJson(pkgJsonPath, _objectSpread(_objectSpread({}, pkgJson), {}, {
      dependencies: manifest.dependencies
    }), {
      spaces: 2
    });
    manifest.dependencies = _objectSpread(_objectSpread(_objectSpread({}, manifest.peerDependencies), manifest.defaultPeerDependencies), manifest.dependencies);
    manifest.installConfig = {
      hoistingLimits: 'workspaces'
    };
  }));
}

//# sourceMappingURL=yarn.package-manager.js.map