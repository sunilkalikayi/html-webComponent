import { InstallationContext, DependencyResolverMain, PackageManager, PackageManagerInstallOptions, PackageManagerResolveRemoteVersionOptions, ResolvedPackageVersion } from '@teambit/dependency-resolver';
import { Logger } from '@teambit/logger';
export declare class YarnPackageManager implements PackageManager {
    private depResolver;
    private logger;
    constructor(depResolver: DependencyResolverMain, logger: Logger);
    install({ rootDir, manifests, componentDirectoryMap }: InstallationContext, installOptions?: PackageManagerInstallOptions): Promise<void>;
    /**
     * Every component is overriden with a local directory of that component.
     * So the component will be installed from the local directory, not from the registry.
     */
    private _createLocalDirectoryOverrides;
    private getPackageJsonPath;
    private backupPackageJsons;
    private restorePackageJsons;
    private getFileToBackup;
    private getComponentPackageJsonToBackup;
    private createWorkspace;
    /**
     * This is used to handle cases where in the capsules dirs we have the same component with different versions
     * The yarn ident is calculated by the manifest (package.json) name if exist
     * in our case for the same component with different versions we will get the same ident which will result errors later.
     * This is make sense in the original case of yarn workspace (it make sense you don't have 2 workspace with same name)
     * However in our case it doesn't make sense.
     * This function will make sure the ident will use the version as well
     * @param ws
     */
    private overrideInternalWorkspaceParams;
    private setupWorkspaces;
    private getScopedRegistries;
    private getAuthProp;
    private getCacheFolder;
    private computeConfiguration;
    private computeDeps;
    resolveRemoteVersion(packageName: string, options: PackageManagerResolveRemoteVersionOptions): Promise<ResolvedPackageVersion>;
    getInjectedDirs(rootDir: string, componentDir: string, packageName: string): Promise<string[]>;
    supportsDedupingOnExistingRoot(): boolean;
}
