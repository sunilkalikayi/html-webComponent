"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRootComponentsDir = createRootComponentsDir;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * All components are copied to a temporary folder (`<workspace-root>/.bit_components`).
 * Each of the copies gets a `package.json` generated, where the component dependencies
 * from the workspace are declared using the `file:` protocol.
 * Every workspace component is then referenced from the `node_modules/<pkgname>` directory (using the `file:` protocol).
 * The peer dependencies of the components are added as runtime dependencies of `node_modules/<pkgname>`.
 *
 * This way Yarn will install each workspace component in isolation with its component dependencies and peer dependencies
 * inside `node_modules/<pkgName>/node_modules`.
 */
async function createRootComponentsDir({
  depResolver,
  rootDir,
  componentDirectoryMap
}) {
  const pickedComponents = new Map();
  const deps = await pickComponentsAndAllDeps(depResolver, Array.from(componentDirectoryMap.hashMap.keys()), componentDirectoryMap, pickedComponents, rootDir);
  const copiesDir = _path().default.join(rootDir, 'node_modules/.bit_components');
  await Promise.all(Array.from(pickedComponents.entries()).map(async ([rootComponentDir, packageJson]) => {
    const rel = _path().default.relative(rootDir, rootComponentDir);
    const targetDir = _path().default.join(copiesDir, rel);
    const modulesDir = _path().default.join(rootComponentDir, 'node_modules');
    await _fsExtra().default.copy(rootComponentDir, targetDir, {
      filter: src => src !== modulesDir,
      overwrite: true
    });
    await _fsExtra().default.writeJson(_path().default.join(targetDir, 'package.json'), packageJson, {
      spaces: 2
    });
  }));
  const newManifestsByPaths = {};
  for (const rootComponentDir of deps) {
    const rel = _path().default.relative(rootDir, rootComponentDir);
    const targetDir = _path().default.join(copiesDir, rel);
    const pkgJson = pickedComponents.get(rootComponentDir);
    if (pkgJson) {
      const compDir = _path().default.join(rootDir, 'node_modules', pkgJson.name);
      newManifestsByPaths[compDir] = {
        name: pkgJson.name,
        dependencies: _objectSpread(_objectSpread({
          [pkgJson.name]: `file:${_path().default.relative(compDir, targetDir)}`
        }, pkgJson.peerDependencies), pkgJson['defaultPeerDependencies']),
        // is it needed?
        installConfig: {
          hoistingLimits: 'dependencies'
        }
      };
    }
  }
  return newManifestsByPaths;
}

/**
 * This function generates a `package.json` for each component in the workspace.
 * Any component dependencies that are present in the workspace are added to the dependencies
 * as local `file:` dependencies.
 */
async function pickComponentsAndAllDeps(depResolver, rootComponentIds, componentDirectoryMap, pickedComponents, rootDir) {
  const dependencies = [];
  await Promise.all(rootComponentIds.map(async rootComponentId => {
    const component = componentDirectoryMap.hashMap.get(rootComponentId);
    if (component) {
      dependencies.push(component[1]);
      let packageJsonObject = pickedComponents.get(component[1]);
      if (!packageJsonObject) {
        const pkgName = depResolver.getPackageName(component[0]);
        packageJsonObject = JSON.parse(await _fsExtra().default.readFile(_path().default.join(rootDir, 'node_modules', pkgName, 'package.json'), 'utf-8'));
        pickedComponents.set(component[1], packageJsonObject);
      }
      const depsList = await depResolver.getDependencies(component[0]);
      const deps = await pickComponentsAndAllDeps(depResolver, depsList.dependencies.filter(dep => dep instanceof _dependencyResolver().ComponentDependency).map(dep => dep.componentId.toString()), componentDirectoryMap, pickedComponents, rootDir);
      for (const dep of deps) {
        const pkgJson = pickedComponents.get(dep);
        if (pkgJson) {
          packageJsonObject.dependencies[pkgJson.name] = `file:${_path().default.relative(component[1], dep)}`;
        }
      }
    }
  }));
  return dependencies;
}

//# sourceMappingURL=create-root-components-dir.js.map