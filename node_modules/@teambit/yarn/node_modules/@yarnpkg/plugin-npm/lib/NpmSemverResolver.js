"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmSemverResolver = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const core_3 = require("@yarnpkg/core");
const core_4 = require("@yarnpkg/core");
const semver_1 = tslib_1.__importDefault(require("semver"));
const NpmSemverFetcher_1 = require("./NpmSemverFetcher");
const constants_1 = require("./constants");
const npmHttpUtils = tslib_1.__importStar(require("./npmHttpUtils"));
const NODE_GYP_IDENT = core_4.structUtils.makeIdent(null, `node-gyp`);
const NODE_GYP_MATCH = /\b(node-gyp|prebuild-install)\b/;
class NpmSemverResolver {
    supportsDescriptor(descriptor, opts) {
        if (!descriptor.range.startsWith(constants_1.PROTOCOL))
            return false;
        return !!core_2.semverUtils.validRange(descriptor.range.slice(constants_1.PROTOCOL.length));
    }
    supportsLocator(locator, opts) {
        if (!locator.reference.startsWith(constants_1.PROTOCOL))
            return false;
        const { selector } = core_4.structUtils.parseRange(locator.reference);
        if (!semver_1.default.valid(selector))
            return false;
        return true;
    }
    shouldPersistResolution(locator, opts) {
        return true;
    }
    bindDescriptor(descriptor, fromLocator, opts) {
        return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
        return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
        const range = core_2.semverUtils.validRange(descriptor.range.slice(constants_1.PROTOCOL.length));
        if (range === null)
            throw new Error(`Expected a valid range, got ${descriptor.range.slice(constants_1.PROTOCOL.length)}`);
        const registryData = await npmHttpUtils.get(npmHttpUtils.getIdentUrl(descriptor), {
            configuration: opts.project.configuration,
            ident: descriptor,
            jsonResponse: true,
        });
        const candidates = core_1.miscUtils.mapAndFilter(Object.keys(registryData.versions), version => {
            try {
                const candidate = new core_2.semverUtils.SemVer(version);
                if (range.test(candidate)) {
                    return candidate;
                }
            }
            catch { }
            return core_1.miscUtils.mapAndFilter.skip;
        });
        const noDeprecatedCandidates = candidates.filter(version => {
            return !registryData.versions[version.raw].deprecated;
        });
        // If there are versions that aren't deprecated, use them
        const finalCandidates = noDeprecatedCandidates.length > 0
            ? noDeprecatedCandidates
            : candidates;
        finalCandidates.sort((a, b) => {
            return -a.compare(b);
        });
        return finalCandidates.map(version => {
            const versionLocator = core_4.structUtils.makeLocator(descriptor, `${constants_1.PROTOCOL}${version.raw}`);
            const archiveUrl = registryData.versions[version.raw].dist.tarball;
            if (NpmSemverFetcher_1.NpmSemverFetcher.isConventionalTarballUrl(versionLocator, archiveUrl, { configuration: opts.project.configuration })) {
                return versionLocator;
            }
            else {
                return core_4.structUtils.bindLocator(versionLocator, { __archiveUrl: archiveUrl });
            }
        });
    }
    async getSatisfying(descriptor, references, opts) {
        const range = core_2.semverUtils.validRange(descriptor.range.slice(constants_1.PROTOCOL.length));
        if (range === null)
            throw new Error(`Expected a valid range, got ${descriptor.range.slice(constants_1.PROTOCOL.length)}`);
        return core_1.miscUtils.mapAndFilter(references, reference => {
            try {
                const { selector } = core_4.structUtils.parseRange(reference, { requireProtocol: constants_1.PROTOCOL });
                const version = new core_2.semverUtils.SemVer(selector);
                if (range.test(version)) {
                    return { reference, version };
                }
            }
            catch { }
            return core_1.miscUtils.mapAndFilter.skip;
        })
            .sort((a, b) => -a.version.compare(b.version))
            .map(({ reference }) => core_4.structUtils.makeLocator(descriptor, reference));
    }
    async resolve(locator, opts) {
        const { selector } = core_4.structUtils.parseRange(locator.reference);
        const version = core_2.semverUtils.clean(selector);
        if (version === null)
            throw new core_1.ReportError(core_1.MessageName.RESOLVER_NOT_FOUND, `The npm semver resolver got selected, but the version isn't semver`);
        const registryData = await npmHttpUtils.get(npmHttpUtils.getIdentUrl(locator), {
            configuration: opts.project.configuration,
            ident: locator,
            jsonResponse: true,
        });
        if (!Object.prototype.hasOwnProperty.call(registryData, `versions`))
            throw new core_1.ReportError(core_1.MessageName.REMOTE_INVALID, `Registry returned invalid data for - missing "versions" field`);
        if (!Object.prototype.hasOwnProperty.call(registryData.versions, version))
            throw new core_1.ReportError(core_1.MessageName.REMOTE_NOT_FOUND, `Registry failed to return reference "${version}"`);
        const manifest = new core_1.Manifest();
        manifest.load(registryData.versions[version]);
        // Manually add node-gyp dependency if there is a script using it and not already set
        // This is because the npm registry will automatically add a `node-gyp rebuild` install script
        // in the metadata if there is not already an install script and a binding.gyp file exists.
        // Also, node-gyp is not always set as a dependency in packages, so it will also be added if used in scripts.
        if (!manifest.dependencies.has(NODE_GYP_IDENT.identHash) && !manifest.peerDependencies.has(NODE_GYP_IDENT.identHash)) {
            for (const value of manifest.scripts.values()) {
                if (value.match(NODE_GYP_MATCH)) {
                    manifest.dependencies.set(NODE_GYP_IDENT.identHash, core_4.structUtils.makeDescriptor(NODE_GYP_IDENT, `latest`));
                    opts.report.reportWarningOnce(core_1.MessageName.NODE_GYP_INJECTED, `${core_4.structUtils.prettyLocator(opts.project.configuration, locator)}: Implicit dependencies on node-gyp are discouraged`);
                    break;
                }
            }
        }
        // Apparently some packages have a `deprecated` field set to an empty string
        // (even though that shouldn't be possible since `npm deprecate ... ""` undeprecates
        // the package, completely removing the `deprecated` field). Both the npm website
        // and all other package managers skip showing deprecation warnings in this case.
        if (typeof manifest.raw.deprecated === `string` && manifest.raw.deprecated !== ``) {
            const prefix = core_4.structUtils.prettyLocator(opts.project.configuration, locator);
            // If the `deprecated` field contains anything, even only whitespace, the package
            // is considered deprecated by both the npm website and CLI.
            const deprecationMessage = manifest.raw.deprecated.match(/\S/)
                ? `${prefix} is deprecated: ${manifest.raw.deprecated}`
                : `${prefix} is deprecated`;
            opts.report.reportWarningOnce(core_1.MessageName.DEPRECATED_PACKAGE, deprecationMessage);
        }
        return {
            ...locator,
            version,
            languageName: `node`,
            linkType: core_3.LinkType.HARD,
            conditions: manifest.getConditions(),
            dependencies: manifest.dependencies,
            peerDependencies: manifest.peerDependencies,
            dependenciesMeta: manifest.dependenciesMeta,
            peerDependenciesMeta: manifest.peerDependenciesMeta,
            bin: manifest.bin,
        };
    }
}
exports.NpmSemverResolver = NpmSemverResolver;
