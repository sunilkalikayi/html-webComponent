"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.del = exports.put = exports.post = exports.get = exports.getIdentUrl = exports.customPackageError = exports.handleInvalidAuthenticationError = exports.AuthType = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const enquirer_1 = require("enquirer");
const url_1 = require("url");
const npmConfigUtils = tslib_1.__importStar(require("./npmConfigUtils"));
var AuthType;
(function (AuthType) {
    AuthType[AuthType["NO_AUTH"] = 0] = "NO_AUTH";
    AuthType[AuthType["BEST_EFFORT"] = 1] = "BEST_EFFORT";
    AuthType[AuthType["CONFIGURATION"] = 2] = "CONFIGURATION";
    AuthType[AuthType["ALWAYS_AUTH"] = 3] = "ALWAYS_AUTH";
})(AuthType = exports.AuthType || (exports.AuthType = {}));
/**
 * Consumes all 401 Unauthorized errors and reports them as `AUTHENTICATION_INVALID`.
 *
 * It doesn't handle 403 Forbidden, as the npm registry uses it when the user attempts
 * a prohibited action, such as publishing a package with a similar name to an existing package.
 */
async function handleInvalidAuthenticationError(error, { attemptedAs, registry, headers, configuration }) {
    var _a, _b;
    if (isOtpError(error))
        throw new core_2.ReportError(core_2.MessageName.AUTHENTICATION_INVALID, `Invalid OTP token`);
    if (((_a = error.originalError) === null || _a === void 0 ? void 0 : _a.name) === `HTTPError` && ((_b = error.originalError) === null || _b === void 0 ? void 0 : _b.response.statusCode) === 401) {
        throw new core_2.ReportError(core_2.MessageName.AUTHENTICATION_INVALID, `Invalid authentication (${typeof attemptedAs !== `string` ? `as ${await whoami(registry, headers, { configuration })}` : `attempted as ${attemptedAs}`})`);
    }
}
exports.handleInvalidAuthenticationError = handleInvalidAuthenticationError;
function customPackageError(error) {
    var _a;
    return ((_a = error.response) === null || _a === void 0 ? void 0 : _a.statusCode) === 404 ? `Package not found` : null;
}
exports.customPackageError = customPackageError;
function getIdentUrl(ident) {
    if (ident.scope) {
        return `/@${ident.scope}%2f${ident.name}`;
    }
    else {
        return `/${ident.name}`;
    }
}
exports.getIdentUrl = getIdentUrl;
async function get(path, { configuration, headers, ident, authType, registry, ...rest }) {
    if (ident && typeof registry === `undefined`)
        registry = npmConfigUtils.getScopeRegistry(ident.scope, { configuration });
    if (ident && ident.scope && typeof authType === `undefined`)
        authType = AuthType.BEST_EFFORT;
    if (typeof registry !== `string`)
        throw new Error(`Assertion failed: The registry should be a string`);
    const auth = await getAuthenticationHeader(registry, { authType, configuration, ident });
    if (auth)
        headers = { ...headers, authorization: auth };
    try {
        return await core_1.httpUtils.get(path.charAt(0) === `/` ? `${registry}${path}` : path, { configuration, headers, ...rest });
    }
    catch (error) {
        await handleInvalidAuthenticationError(error, { registry, configuration, headers });
        throw error;
    }
}
exports.get = get;
async function post(path, body, { attemptedAs, configuration, headers, ident, authType = AuthType.ALWAYS_AUTH, registry, otp, ...rest }) {
    if (ident && typeof registry === `undefined`)
        registry = npmConfigUtils.getScopeRegistry(ident.scope, { configuration });
    if (typeof registry !== `string`)
        throw new Error(`Assertion failed: The registry should be a string`);
    const auth = await getAuthenticationHeader(registry, { authType, configuration, ident });
    if (auth)
        headers = { ...headers, authorization: auth };
    if (otp)
        headers = { ...headers, ...getOtpHeaders(otp) };
    try {
        return await core_1.httpUtils.post(registry + path, body, { configuration, headers, ...rest });
    }
    catch (error) {
        if (!isOtpError(error) || otp) {
            await handleInvalidAuthenticationError(error, { attemptedAs, registry, configuration, headers });
            throw error;
        }
        otp = await askForOtp();
        const headersWithOtp = { ...headers, ...getOtpHeaders(otp) };
        // Retrying request with OTP
        try {
            return await core_1.httpUtils.post(`${registry}${path}`, body, { configuration, headers: headersWithOtp, ...rest });
        }
        catch (error) {
            await handleInvalidAuthenticationError(error, { attemptedAs, registry, configuration, headers });
            throw error;
        }
    }
}
exports.post = post;
async function put(path, body, { attemptedAs, configuration, headers, ident, authType = AuthType.ALWAYS_AUTH, registry, otp, ...rest }) {
    if (ident && typeof registry === `undefined`)
        registry = npmConfigUtils.getScopeRegistry(ident.scope, { configuration });
    if (typeof registry !== `string`)
        throw new Error(`Assertion failed: The registry should be a string`);
    const auth = await getAuthenticationHeader(registry, { authType, configuration, ident });
    if (auth)
        headers = { ...headers, authorization: auth };
    if (otp)
        headers = { ...headers, ...getOtpHeaders(otp) };
    try {
        return await core_1.httpUtils.put(registry + path, body, { configuration, headers, ...rest });
    }
    catch (error) {
        if (!isOtpError(error)) {
            await handleInvalidAuthenticationError(error, { attemptedAs, registry, configuration, headers });
            throw error;
        }
        otp = await askForOtp();
        const headersWithOtp = { ...headers, ...getOtpHeaders(otp) };
        // Retrying request with OTP
        try {
            return await core_1.httpUtils.put(`${registry}${path}`, body, { configuration, headers: headersWithOtp, ...rest });
        }
        catch (error) {
            await handleInvalidAuthenticationError(error, { attemptedAs, registry, configuration, headers });
            throw error;
        }
    }
}
exports.put = put;
async function del(path, { attemptedAs, configuration, headers, ident, authType = AuthType.ALWAYS_AUTH, registry, otp, ...rest }) {
    if (ident && typeof registry === `undefined`)
        registry = npmConfigUtils.getScopeRegistry(ident.scope, { configuration });
    if (typeof registry !== `string`)
        throw new Error(`Assertion failed: The registry should be a string`);
    const auth = await getAuthenticationHeader(registry, { authType, configuration, ident });
    if (auth)
        headers = { ...headers, authorization: auth };
    if (otp)
        headers = { ...headers, ...getOtpHeaders(otp) };
    try {
        return await core_1.httpUtils.del(registry + path, { configuration, headers, ...rest });
    }
    catch (error) {
        if (!isOtpError(error) || otp) {
            await handleInvalidAuthenticationError(error, { attemptedAs, registry, configuration, headers });
            throw error;
        }
        otp = await askForOtp();
        const headersWithOtp = { ...headers, ...getOtpHeaders(otp) };
        // Retrying request with OTP
        try {
            return await core_1.httpUtils.del(`${registry}${path}`, { configuration, headers: headersWithOtp, ...rest });
        }
        catch (error) {
            await handleInvalidAuthenticationError(error, { attemptedAs, registry, configuration, headers });
            throw error;
        }
    }
}
exports.del = del;
async function getAuthenticationHeader(registry, { authType = AuthType.CONFIGURATION, configuration, ident }) {
    const effectiveConfiguration = npmConfigUtils.getAuthConfiguration(registry, { configuration, ident });
    const mustAuthenticate = shouldAuthenticate(effectiveConfiguration, authType);
    if (!mustAuthenticate)
        return null;
    const header = await configuration.reduceHook((hooks) => {
        return hooks.getNpmAuthenticationHeader;
    }, undefined, registry, { configuration, ident });
    if (header)
        return header;
    if (effectiveConfiguration.get(`npmAuthToken`))
        return `Bearer ${effectiveConfiguration.get(`npmAuthToken`)}`;
    if (effectiveConfiguration.get(`npmAuthIdent`)) {
        const npmAuthIdent = effectiveConfiguration.get(`npmAuthIdent`);
        if (npmAuthIdent.includes(`:`))
            return `Basic ${Buffer.from(npmAuthIdent).toString(`base64`)}`;
        return `Basic ${npmAuthIdent}`;
    }
    if (mustAuthenticate && authType !== AuthType.BEST_EFFORT) {
        throw new core_2.ReportError(core_2.MessageName.AUTHENTICATION_NOT_FOUND, `No authentication configured for request`);
    }
    else {
        return null;
    }
}
function shouldAuthenticate(authConfiguration, authType) {
    switch (authType) {
        case AuthType.CONFIGURATION:
            return authConfiguration.get(`npmAlwaysAuth`);
        case AuthType.BEST_EFFORT:
        case AuthType.ALWAYS_AUTH:
            return true;
        case AuthType.NO_AUTH:
            return false;
        default:
            throw new Error(`Unreachable`);
    }
}
async function whoami(registry, headers, { configuration }) {
    var _a;
    if (typeof headers === `undefined` || typeof headers.authorization === `undefined`)
        return `an anonymous user`;
    try {
        const response = await core_1.httpUtils.get(new url_1.URL(`${registry}/-/whoami`).href, {
            configuration,
            headers,
            jsonResponse: true,
        });
        return (_a = response.username) !== null && _a !== void 0 ? _a : `an unknown user`;
    }
    catch {
        return `an unknown user`;
    }
}
async function askForOtp() {
    if (process.env.TEST_ENV)
        return process.env.TEST_NPM_2FA_TOKEN || ``;
    const { otp } = await (0, enquirer_1.prompt)({
        type: `password`,
        name: `otp`,
        message: `One-time password:`,
        required: true,
        onCancel: () => process.exit(130),
    });
    return otp;
}
function isOtpError(error) {
    var _a, _b;
    if (((_a = error.originalError) === null || _a === void 0 ? void 0 : _a.name) !== `HTTPError`)
        return false;
    try {
        const authMethods = (_b = error.originalError) === null || _b === void 0 ? void 0 : _b.response.headers[`www-authenticate`].split(/,\s*/).map((s) => s.toLowerCase());
        return authMethods.includes(`otp`);
    }
    catch (e) {
        return false;
    }
}
function getOtpHeaders(otp) {
    return {
        [`npm-otp`]: otp,
    };
}
