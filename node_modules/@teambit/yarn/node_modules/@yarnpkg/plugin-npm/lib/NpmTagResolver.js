"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmTagResolver = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const NpmSemverFetcher_1 = require("./NpmSemverFetcher");
const constants_1 = require("./constants");
const npmHttpUtils = tslib_1.__importStar(require("./npmHttpUtils"));
class NpmTagResolver {
    supportsDescriptor(descriptor, opts) {
        if (!descriptor.range.startsWith(constants_1.PROTOCOL))
            return false;
        if (!core_1.TAG_REGEXP.test(descriptor.range.slice(constants_1.PROTOCOL.length)))
            return false;
        return true;
    }
    supportsLocator(locator, opts) {
        // Once transformed into locators, the tags are resolved by the NpmSemverResolver
        return false;
    }
    shouldPersistResolution(locator, opts) {
        // Once transformed into locators, the tags are resolved by the NpmSemverResolver
        throw new Error(`Unreachable`);
    }
    bindDescriptor(descriptor, fromLocator, opts) {
        return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
        return [];
    }
    async getCandidates(descriptor, dependencies, opts) {
        const tag = descriptor.range.slice(constants_1.PROTOCOL.length);
        const registryData = await npmHttpUtils.get(npmHttpUtils.getIdentUrl(descriptor), {
            configuration: opts.project.configuration,
            ident: descriptor,
            jsonResponse: true,
        });
        if (!Object.prototype.hasOwnProperty.call(registryData, `dist-tags`))
            throw new core_1.ReportError(core_1.MessageName.REMOTE_INVALID, `Registry returned invalid data - missing "dist-tags" field`);
        const distTags = registryData[`dist-tags`];
        if (!Object.prototype.hasOwnProperty.call(distTags, tag))
            throw new core_1.ReportError(core_1.MessageName.REMOTE_NOT_FOUND, `Registry failed to return tag "${tag}"`);
        const version = distTags[tag];
        const versionLocator = core_2.structUtils.makeLocator(descriptor, `${constants_1.PROTOCOL}${version}`);
        const archiveUrl = registryData.versions[version].dist.tarball;
        if (NpmSemverFetcher_1.NpmSemverFetcher.isConventionalTarballUrl(versionLocator, archiveUrl, { configuration: opts.project.configuration })) {
            return [versionLocator];
        }
        else {
            return [core_2.structUtils.bindLocator(versionLocator, { __archiveUrl: archiveUrl })];
        }
    }
    async getSatisfying(descriptor, references, opts) {
        // We can't statically know if a tag resolves to a specific version without using the network
        return null;
    }
    async resolve(locator, opts) {
        // Once transformed into locators (through getCandidates), the tags are resolved by the NpmSemverResolver
        throw new Error(`Unreachable`);
    }
}
exports.NpmTagResolver = NpmTagResolver;
