"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmRemapResolver = void 0;
const core_1 = require("@yarnpkg/core");
const constants_1 = require("./constants");
class NpmRemapResolver {
    supportsDescriptor(descriptor, opts) {
        if (!descriptor.range.startsWith(constants_1.PROTOCOL))
            return false;
        if (!core_1.structUtils.tryParseDescriptor(descriptor.range.slice(constants_1.PROTOCOL.length), true))
            return false;
        return true;
    }
    supportsLocator(locator, opts) {
        // Once transformed into locators, the descriptors are resolved by the NpmSemverResolver
        return false;
    }
    shouldPersistResolution(locator, opts) {
        // Once transformed into locators, the descriptors are resolved by the NpmSemverResolver
        throw new Error(`Unreachable`);
    }
    bindDescriptor(descriptor, fromLocator, opts) {
        return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
        const nextDescriptor = core_1.structUtils.parseDescriptor(descriptor.range.slice(constants_1.PROTOCOL.length), true);
        return opts.resolver.getResolutionDependencies(nextDescriptor, opts);
    }
    async getCandidates(descriptor, dependencies, opts) {
        const nextDescriptor = core_1.structUtils.parseDescriptor(descriptor.range.slice(constants_1.PROTOCOL.length), true);
        return await opts.resolver.getCandidates(nextDescriptor, dependencies, opts);
    }
    async getSatisfying(descriptor, references, opts) {
        const nextDescriptor = core_1.structUtils.parseDescriptor(descriptor.range.slice(constants_1.PROTOCOL.length), true);
        return opts.resolver.getSatisfying(nextDescriptor, references, opts);
    }
    resolve(locator, opts) {
        // Once transformed into locators, the descriptors are resolved by the NpmSemverResolver
        throw new Error(`Unreachable`);
    }
}
exports.NpmRemapResolver = NpmRemapResolver;
