"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmSemverFetcher = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const semver_1 = tslib_1.__importDefault(require("semver"));
const url_1 = require("url");
const constants_1 = require("./constants");
const npmConfigUtils = tslib_1.__importStar(require("./npmConfigUtils"));
const npmHttpUtils = tslib_1.__importStar(require("./npmHttpUtils"));
class NpmSemverFetcher {
    supports(locator, opts) {
        if (!locator.reference.startsWith(constants_1.PROTOCOL))
            return false;
        const url = new url_1.URL(locator.reference);
        if (!semver_1.default.valid(url.pathname))
            return false;
        if (url.searchParams.has(`__archiveUrl`))
            return false;
        return true;
    }
    getLocalPath(locator, opts) {
        return null;
    }
    async fetch(locator, opts) {
        const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
        const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
            onHit: () => opts.report.reportCacheHit(locator),
            onMiss: () => opts.report.reportCacheMiss(locator, `${core_1.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote registry`),
            loader: () => this.fetchFromNetwork(locator, opts),
            skipIntegrityCheck: opts.skipIntegrityCheck,
            ...opts.cacheOptions,
        });
        return {
            packageFs,
            releaseFs,
            prefixPath: core_1.structUtils.getIdentVendorPath(locator),
            checksum,
        };
    }
    async fetchFromNetwork(locator, opts) {
        let sourceBuffer;
        try {
            sourceBuffer = await npmHttpUtils.get(NpmSemverFetcher.getLocatorUrl(locator), {
                configuration: opts.project.configuration,
                ident: locator,
            });
        }
        catch (error) {
            // The npm registry doesn't always support %2f when fetching the package tarballs ðŸ¤¡
            // OK: https://registry.yarnpkg.com/@emotion%2fbabel-preset-css-prop/-/babel-preset-css-prop-10.0.7.tgz
            // KO: https://registry.yarnpkg.com/@xtuc%2fieee754/-/ieee754-1.2.0.tgz
            sourceBuffer = await npmHttpUtils.get(NpmSemverFetcher.getLocatorUrl(locator).replace(/%2f/g, `/`), {
                configuration: opts.project.configuration,
                ident: locator,
            });
        }
        return await core_1.tgzUtils.convertToZip(sourceBuffer, {
            compressionLevel: opts.project.configuration.get(`compressionLevel`),
            prefixPath: core_1.structUtils.getIdentVendorPath(locator),
            stripComponents: 1,
        });
    }
    static isConventionalTarballUrl(locator, url, { configuration }) {
        let registry = npmConfigUtils.getScopeRegistry(locator.scope, { configuration });
        const path = NpmSemverFetcher.getLocatorUrl(locator);
        // From time to time the npm registry returns http urls instead of https ðŸ¤¡
        url = url.replace(/^https?:(\/\/(?:[^/]+\.)?npmjs.org(?:$|\/))/, `https:$1`);
        // The yarnpkg and npmjs registries are interchangeable for that matter, so we uniformize them
        registry = registry.replace(/^https:\/\/registry\.npmjs\.org($|\/)/, `https://registry.yarnpkg.com$1`);
        url = url.replace(/^https:\/\/registry\.npmjs\.org($|\/)/, `https://registry.yarnpkg.com$1`);
        if (url === registry + path)
            return true;
        if (url === registry + path.replace(/%2f/g, `/`))
            return true;
        return false;
    }
    static getLocatorUrl(locator) {
        const version = core_1.semverUtils.clean(locator.reference.slice(constants_1.PROTOCOL.length));
        if (version === null)
            throw new core_2.ReportError(core_2.MessageName.RESOLVER_NOT_FOUND, `The npm semver resolver got selected, but the version isn't semver`);
        return `${npmHttpUtils.getIdentUrl(locator)}/-/${locator.name}-${version}.tgz`;
    }
}
exports.NpmSemverFetcher = NpmSemverFetcher;
