"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DevFilesMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = require("@teambit/envs");
  _envs = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/legacy/dist/consumer/component/dependencies/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = require("@teambit/graphql");
  _graphql = function () {
    return data;
  };
  return data;
}
function _devFiles() {
  const data = require("./dev-files.aspect");
  _devFiles = function () {
    return data;
  };
  return data;
}
function _devFiles2() {
  const data = require("./dev-files");
  _devFiles2 = function () {
    return data;
  };
  return data;
}
function _devFiles3() {
  const data = require("./dev-files.fragment");
  _devFiles3 = function () {
    return data;
  };
  return data;
}
function _devFiles4() {
  const data = require("./dev-files.graphql");
  _devFiles4 = function () {
    return data;
  };
  return data;
}
class DevFilesMain {
  constructor(envs, devPatternSlot,
  /**
   * configuration loaded into the dev files aspect.
   */
  config) {
    this.envs = envs;
    this.devPatternSlot = devPatternSlot;
    this.config = config;
  }

  /**
   * compute all dev patterns on a component.
   * computing of dev patterns is a merge of the configuration, the env (env.getDevPatterns(component)) and
   * the registering aspects (through registerDevPattern()).
   */
  computeDevPatterns(component) {
    var _envDef$env;
    const entry = component.state.aspects.get(_devFiles().DevFilesAspect.id);
    const configuredPatterns = (entry === null || entry === void 0 ? void 0 : entry.config.devFilePatterns) || [];
    const envDef = this.envs.calculateEnv(component);
    const envPatterns = (_envDef$env = envDef.env) !== null && _envDef$env !== void 0 && _envDef$env.getDevPatterns ? envDef.env.getDevPatterns(component) : [];
    const getPatterns = devPatterns => {
      if ((0, _lodash().isFunction)(devPatterns)) {
        return devPatterns(component);
      }
      return devPatterns;
    };
    const patternSlot = this.devPatternSlot.toArray();
    const fromSlot = patternSlot.reduce((acc, current) => {
      const [aspectId, patterns] = current;
      if (!acc[aspectId]) acc[aspectId] = [];
      // if (component.state.aspects.get(aspectId)) acc[aspectId] = acc[aspectId].concat(patterns);
      acc[aspectId] = acc[aspectId].concat(getPatterns(patterns));
      return acc;
    }, {});
    return Object.assign({
      [envDef.id]: envPatterns,
      config: configuredPatterns
    }, fromSlot);
  }

  /**
   * get all dev files configured on a component.
   */
  getDevPatterns(component, aspectId) {
    const entry = component.state.aspects.get(_devFiles().DevFilesAspect.id);
    const devPatterns = (entry === null || entry === void 0 ? void 0 : entry.data.devPatterns) || {};
    return aspectId ? devPatterns[aspectId] : (0, _lodash().flatten)(Object.values(devPatterns));
  }

  /**
   * determine whether a file of a component is a dev file.
   */
  isDevFile(component, filePath) {
    const devFiles = this.computeDevFiles(component);
    return devFiles.includes(filePath);
  }

  /**
   * register a new dev pattern.
   * @param regex dev pattern
   */
  registerDevPattern(pattern) {
    return this.devPatternSlot.register(pattern);
  }

  /**
   * get all dev patterns registered.
   * If you want to use this during onLoad event you might need to use computeDevFiles instead, since the component might not include this data yet
   */
  getDevFiles(component) {
    const entry = component.state.aspects.get(_devFiles().DevFilesAspect.id);
    const rawDevFiles = (entry === null || entry === void 0 ? void 0 : entry.data.devFiles) || {};
    return new (_devFiles2().DevFiles)(rawDevFiles);
  }

  /**
   * compute all dev files of a component.
   */
  computeDevFiles(component) {
    const devPatterns = this.computeDevPatterns(component);
    const rawDevFiles = Object.keys(devPatterns).reduce((acc, aspectId) => {
      if (!acc[aspectId]) acc[aspectId] = [];
      const patterns = devPatterns[aspectId];
      acc[aspectId] = component.state.filesystem.byGlob(patterns).map(file => file.relative);
      return acc;
    }, {});
    return new (_devFiles2().DevFiles)(rawDevFiles);
  }
  static async provider([envs, workspace, componentAspect, graphql], config, [devPatternSlot]) {
    const devFiles = new DevFilesMain(envs, devPatternSlot, config);
    componentAspect.registerShowFragments([new (_devFiles3().DevFilesFragment)(devFiles)]);
    if (workspace) {
      workspace.onComponentLoad(async component => {
        return {
          devPatterns: devFiles.computeDevPatterns(component),
          devFiles: devFiles.computeDevFiles(component).toObject()
        };
      });
      _dependencyResolver().DependencyResolver.getDevFiles = async consumerComponent => {
        const componentId = await workspace.resolveComponentId(consumerComponent.id);
        // Do not change the storeInCache=false arg. if you think you need to change it, please talk to Gilad first
        const component = await workspace.get(componentId, consumerComponent, true, false);
        if (!component) throw Error(`failed to transform component ${consumerComponent.id.toString()} in harmony`);
        const computedDevFiles = devFiles.computeDevFiles(component);
        return computedDevFiles.list();
      };
    }
    graphql.register((0, _devFiles4().devFilesSchema)(devFiles));
    return devFiles;
  }
}
exports.DevFilesMain = DevFilesMain;
(0, _defineProperty2().default)(DevFilesMain, "slots", [_harmony().Slot.withType()]);
(0, _defineProperty2().default)(DevFilesMain, "defaultConfig", {
  patterns: []
});
(0, _defineProperty2().default)(DevFilesMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(DevFilesMain, "dependencies", [_envs().EnvsAspect, _workspace().default, _component().ComponentAspect, _graphql().GraphqlAspect]);
_devFiles().DevFilesAspect.addRuntime(DevFilesMain);

//# sourceMappingURL=dev-files.main.runtime.js.map