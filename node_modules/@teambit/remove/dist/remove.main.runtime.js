"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.RemoveMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");
  _legacyBitId = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _removeComponents() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/remove-components"));
  _removeComponents = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _hasWildcard() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/string/has-wildcard"));
  _hasWildcard = function () {
    return data;
  };
  return data;
}
function _listScope() {
  const data = require("@teambit/legacy/dist/api/consumer/lib/list-scope");
  _listScope = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _deleteComponentFiles() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/delete-component-files"));
  _deleteComponentFiles = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = _interopRequireDefault(require("@teambit/component"));
  _component = function () {
    return data;
  };
  return data;
}
function _packageJsonUtils() {
  const data = require("@teambit/legacy/dist/consumer/component/package-json-utils");
  _packageJsonUtils = function () {
    return data;
  };
  return data;
}
function _removeCmd() {
  const data = require("./remove-cmd");
  _removeCmd = function () {
    return data;
  };
  return data;
}
function _remove() {
  const data = require("./remove.aspect");
  _remove = function () {
    return data;
  };
  return data;
}
function _remove2() {
  const data = require("./remove.fragment");
  _remove2 = function () {
    return data;
  };
  return data;
}
const BEFORE_REMOVE = 'removing components';
class RemoveMain {
  constructor(workspace, logger) {
    this.workspace = workspace;
    this.logger = logger;
  }
  async remove({
    componentsPattern,
    force,
    remote,
    track,
    deleteFiles,
    fromLane
  }) {
    var _this$workspace;
    this.logger.setStatusLine(BEFORE_REMOVE);
    const bitIds = remote ? await this.getRemoteBitIdsToRemove(componentsPattern) : await this.getLocalBitIdsToRemove(componentsPattern);
    this.logger.setStatusLine(BEFORE_REMOVE); // again because the loader might changed when talking to the remote
    const consumer = (_this$workspace = this.workspace) === null || _this$workspace === void 0 ? void 0 : _this$workspace.consumer;
    const removeResults = await (0, _removeComponents().default)({
      consumer,
      ids: _bitId().BitIds.fromArray(bitIds),
      force,
      remote,
      track,
      deleteFiles,
      fromLane
    });
    if (consumer) await consumer.onDestroy();
    return removeResults;
  }
  async softRemove(componentsPattern) {
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    const componentIds = await this.workspace.idsByPattern(componentsPattern);
    const components = await this.workspace.getMany(componentIds);
    const newComps = components.filter(c => !c.id.hasVersion());
    if (newComps.length) {
      throw new (_bitError().BitError)(`unable to soft-remove the following new component(s), please remove them without --soft\n${newComps.map(c => c.id.toString()).join('\n')}`);
    }
    await (0, _packageJsonUtils().removeComponentsFromNodeModules)(this.workspace.consumer, components.map(c => c.state._consumer));
    // don't use `this.workspace.addSpecificComponentConfig`, if the component has component.json it will be deleted
    // during this removal along with the entire component dir.
    componentIds.map(compId => this.workspace.bitMap.addComponentConfig(compId, _remove().RemoveAspect.id, {
      removed: true
    }));
    await this.workspace.bitMap.write();
    const bitIds = _bitId().BitIds.fromArray(componentIds.map(id => id._legacy));
    await (0, _deleteComponentFiles().default)(this.workspace.consumer, bitIds);
    return componentIds;
  }
  getRemoveInfo(component) {
    var _component$config$ext;
    const data = (_component$config$ext = component.config.extensions.findExtension(_remove().RemoveAspect.id)) === null || _component$config$ext === void 0 ? void 0 : _component$config$ext.config;
    return {
      removed: (data === null || data === void 0 ? void 0 : data.removed) || false
    };
  }
  isRemoved(component) {
    return this.getRemoveInfo(component).removed;
  }

  /**
   * get components that were soft-removed and tagged/snapped but not exported yet.
   */
  async getRemovedStaged() {
    const stagedConfig = await this.workspace.scope.getStagedConfig();
    return stagedConfig.getAll().filter(compConfig => {
      var _compConfig$config, _compConfig$config$Re;
      return (_compConfig$config = compConfig.config) === null || _compConfig$config === void 0 ? void 0 : (_compConfig$config$Re = _compConfig$config[_remove().RemoveAspect.id]) === null || _compConfig$config$Re === void 0 ? void 0 : _compConfig$config$Re.removed;
    }).map(compConfig => compConfig.id);
  }
  async getLocalBitIdsToRemove(componentsPattern) {
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    const componentIds = await this.workspace.idsByPattern(componentsPattern);
    return componentIds.map(id => id._legacy);
  }
  async getRemoteBitIdsToRemove(componentsPattern) {
    if ((0, _hasWildcard().default)(componentsPattern)) {
      return (0, _listScope().getRemoteBitIdsByWildcards)(componentsPattern);
    }
    return [_legacyBitId().BitId.parse(componentsPattern, true)];
  }
  static async provider([workspace, cli, loggerMain, componentAspect]) {
    const logger = loggerMain.createLogger(_remove().RemoveAspect.id);
    const removeMain = new RemoveMain(workspace, logger);
    componentAspect.registerShowFragments([new (_remove2().RemoveFragment)(removeMain)]);
    cli.register(new (_removeCmd().RemoveCmd)(removeMain));
    return new RemoveMain(workspace, logger);
  }
}
exports.RemoveMain = RemoveMain;
(0, _defineProperty2().default)(RemoveMain, "slots", []);
(0, _defineProperty2().default)(RemoveMain, "dependencies", [_workspace().default, _cli().CLIAspect, _logger().LoggerAspect, _component().default]);
(0, _defineProperty2().default)(RemoveMain, "runtime", _cli().MainRuntime);
_remove().RemoveAspect.addRuntime(RemoveMain);
var _default = RemoveMain;
exports.default = _default;

//# sourceMappingURL=remove.main.runtime.js.map