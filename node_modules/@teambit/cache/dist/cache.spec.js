"use strict";

require("core-js/modules/es.promise.js");
function _uuid() {
  const data = require("uuid");
  _uuid = function () {
    return data;
  };
  return data;
}
function _fs() {
  const data = require("fs");
  _fs = function () {
    return data;
  };
  return data;
}
function _chai() {
  const data = require("chai");
  _chai = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _cacheMain() {
  const data = require("./cache.main.runtime");
  _cacheMain = function () {
    return data;
  };
  return data;
}
describe('Cache Aspect', () => {
  const cacheDirectory = `/tmp/bit/${(0, _uuid().v4)()}`;
  const cache = new (_cacheMain().CacheMain)({
    cacheDirectory
  }, new (_logger().Logger)('cache.main.runtime'));
  it('it should set cache with ttl', async () => {
    await cache.set('_foo', 'bar', 1000);
    const data = await cache.get('_foo');
    (0, _chai().expect)(data).to.equal('bar');
  });

  // this test is flaky, it fails often on CircleCI.
  // it('it should expire cache', async () => {
  //   await cache.set('_foo', 'bar', 1);
  //   const data = await cache.get('_foo');
  //   expect(data).to.equal(null);
  // });

  it('it should set cache without expire ttl', async () => {
    await cache.set('_foo', 'bar');
    const data = await cache.get('_foo');
    (0, _chai().expect)(data).to.equal('bar');
  });
  afterAll(() => {
    (0, _fs().rmdirSync)(cacheDirectory, {
      recursive: true
    });
  });
});

//# sourceMappingURL=cache.spec.js.map