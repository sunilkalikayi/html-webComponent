"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.InstallMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _community() {
  const data = require("@teambit/community");
  _community = function () {
    return data;
  };
  return data;
}
function _compiler() {
  const data = require("@teambit/compiler");
  _compiler = function () {
    return data;
  };
  return data;
}
function _manyComponentsWriter() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/many-components-writer"));
  _manyComponentsWriter = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = require("@teambit/workspace");
  _workspace = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/bit/component-id-to-package-name"));
  _componentIdToPackageName = function () {
    return data;
  };
  return data;
}
function _variants() {
  const data = require("@teambit/variants");
  _variants = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _componentIssues() {
  const data = require("@teambit/component-issues");
  _componentIssues = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _importer() {
  const data = require("@teambit/importer");
  _importer = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _issues() {
  const data = require("@teambit/issues");
  _issues = function () {
    return data;
  };
  return data;
}
function _exceptions2() {
  const data = require("./exceptions");
  _exceptions2 = function () {
    return data;
  };
  return data;
}
function _install() {
  const data = require("./install.aspect");
  _install = function () {
    return data;
  };
  return data;
}
function _pickOutdatedPkgs() {
  const data = require("./pick-outdated-pkgs");
  _pickOutdatedPkgs = function () {
    return data;
  };
  return data;
}
function _link() {
  const data = require("./link");
  _link = function () {
    return data;
  };
  return data;
}
function _install2() {
  const data = _interopRequireDefault(require("./install.cmd"));
  _install2 = function () {
    return data;
  };
  return data;
}
function _uninstall() {
  const data = _interopRequireDefault(require("./uninstall.cmd"));
  _uninstall = function () {
    return data;
  };
  return data;
}
function _update() {
  const data = _interopRequireDefault(require("./update.cmd"));
  _update = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class InstallMain {
  constructor(dependencyResolver, logger, workspace, variants, importer, compiler) {
    this.dependencyResolver = dependencyResolver;
    this.logger = logger;
    this.workspace = workspace;
    this.variants = variants;
    this.importer = importer;
    this.compiler = compiler;
  }
  /**
   * Install dependencies for all components in the workspace
   *
   * @returns
   * @memberof Workspace
   */
  async install(packages, options) {
    if (packages && packages.length) {
      await this._addPackages(packages, options);
    }
    if (options !== null && options !== void 0 && options.addMissingPeers) {
      var _options$copyPeerToRu, _options$copyPeerToRu2;
      const compDirMap = await this.getComponentsDirectory([]);
      const mergedRootPolicy = this.dependencyResolver.getWorkspacePolicy();
      const depsFilterFn = await this.generateFilterFnForDepsFromLocalRemote();
      const pmInstallOptions = {
        dedupe: options === null || options === void 0 ? void 0 : options.dedupe,
        copyPeerToRuntimeOnRoot: (_options$copyPeerToRu = options === null || options === void 0 ? void 0 : options.copyPeerToRuntimeOnRoot) !== null && _options$copyPeerToRu !== void 0 ? _options$copyPeerToRu : true,
        copyPeerToRuntimeOnComponents: (_options$copyPeerToRu2 = options === null || options === void 0 ? void 0 : options.copyPeerToRuntimeOnComponents) !== null && _options$copyPeerToRu2 !== void 0 ? _options$copyPeerToRu2 : false,
        dependencyFilterFn: depsFilterFn,
        overrides: this.dependencyResolver.config.overrides,
        packageImportMethod: this.dependencyResolver.config.packageImportMethod
      };
      const missingPeers = await this.dependencyResolver.getMissingPeerDependencies(this.workspace.path, mergedRootPolicy, compDirMap, pmInstallOptions);
      if (missingPeers) {
        const missingPeerPackages = Object.entries(missingPeers).map(([peerName, range]) => `${peerName}@${range}`);
        await this._addPackages(missingPeerPackages, options);
      } else {
        this.logger.console('No missing peer dependencies found.');
      }
    }
    if (options !== null && options !== void 0 && options.import) {
      this.logger.setStatusLine('importing missing objects');
      await this.importObjects();
      this.logger.consoleSuccess();
    }
    return this._installModules(options);
  }
  async _addPackages(packages, options) {
    if (!(options !== null && options !== void 0 && options.variants) && (options === null || options === void 0 ? void 0 : options.lifecycleType) === 'dev') {
      throw new (_exceptions2().DependencyTypeNotSupportedInPolicy)(options === null || options === void 0 ? void 0 : options.lifecycleType);
    }
    this.logger.debug(`installing the following packages: ${packages.join()}`);
    const resolver = await this.dependencyResolver.getVersionResolver();
    const resolvedPackagesP = packages.map(packageName => resolver.resolveRemoteVersion(packageName, {
      rootDir: this.workspace.path
    }));
    const resolvedPackages = await Promise.all(resolvedPackagesP);
    const newWorkspacePolicyEntries = [];
    resolvedPackages.forEach(resolvedPackage => {
      if (resolvedPackage.version) {
        const versionWithPrefix = this.dependencyResolver.getVersionWithSavePrefix(resolvedPackage.version, options === null || options === void 0 ? void 0 : options.savePrefix);
        newWorkspacePolicyEntries.push({
          dependencyId: resolvedPackage.packageName,
          value: {
            version: versionWithPrefix
          },
          lifecycleType: (options === null || options === void 0 ? void 0 : options.lifecycleType) || 'runtime'
        });
      }
    });
    if (!(options !== null && options !== void 0 && options.variants)) {
      var _options$updateExisti;
      this.dependencyResolver.addToRootPolicy(newWorkspacePolicyEntries, {
        updateExisting: (_options$updateExisti = options === null || options === void 0 ? void 0 : options.updateExisting) !== null && _options$updateExisti !== void 0 ? _options$updateExisti : false
      });
    } else {
      // TODO: implement
    }
    await this.dependencyResolver.persistConfig(this.workspace.path);
  }
  async _installModules(options) {
    var _options$copyPeerToRu3, _options$copyPeerToRu4;
    this.logger.console(`installing dependencies in workspace using ${_chalk().default.cyan(this.dependencyResolver.getPackageManagerName())}`);
    this.logger.debug(`installing dependencies in workspace with options`, options);
    const mergedRootPolicy = this.dependencyResolver.getWorkspacePolicy();
    const depsFilterFn = await this.generateFilterFnForDepsFromLocalRemote();
    const hasRootComponents = this.dependencyResolver.hasRootComponents();
    const pmInstallOptions = {
      dedupe: !hasRootComponents && (options === null || options === void 0 ? void 0 : options.dedupe),
      copyPeerToRuntimeOnRoot: (_options$copyPeerToRu3 = options === null || options === void 0 ? void 0 : options.copyPeerToRuntimeOnRoot) !== null && _options$copyPeerToRu3 !== void 0 ? _options$copyPeerToRu3 : true,
      copyPeerToRuntimeOnComponents: (_options$copyPeerToRu4 = options === null || options === void 0 ? void 0 : options.copyPeerToRuntimeOnComponents) !== null && _options$copyPeerToRu4 !== void 0 ? _options$copyPeerToRu4 : false,
      dependencyFilterFn: depsFilterFn,
      overrides: this.dependencyResolver.config.overrides,
      packageImportMethod: this.dependencyResolver.config.packageImportMethod,
      rootComponents: hasRootComponents
    };
    // TODO: pass get install options
    const installer = this.dependencyResolver.getInstaller({});
    let current = await this._getComponentsManifests(installer, mergedRootPolicy, pmInstallOptions);
    let prev;
    // TODO: this make duplicate
    // this.logger.consoleSuccess();
    // TODO: add the links results to the output
    await this.link({
      linkTeambitBit: true,
      legacyLink: true,
      linkCoreAspects: this.dependencyResolver.linkCoreAspects(),
      linkDepsResolvedFromEnv: !hasRootComponents,
      linkNestedDepsInNM: false
    });
    const linkOpts = {
      linkTeambitBit: false,
      legacyLink: true,
      linkCoreAspects: false,
      linkDepsResolvedFromEnv: !hasRootComponents,
      linkNestedDepsInNM: !this.workspace.isLegacy && !hasRootComponents
    };
    /* eslint-disable no-await-in-loop */
    do {
      this.workspace.consumer.componentLoader.clearComponentsCache();
      this.workspace.clearCache();
      await installer.installComponents(this.workspace.path, current.manifests, mergedRootPolicy, current.componentDirectoryMap, {
        installTeambitBit: false
      }, pmInstallOptions);
      // Core aspects should be relinked after installation because Yarn removes all symlinks created not by Yarn.
      // If we don't link the core aspects immediately, the components will fail during load.
      await this.linkCoreAspectsAndLegacy({
        linkTeambitBit: false,
        linkCoreAspects: this.dependencyResolver.linkCoreAspects()
      });
      await this.compiler.compileOnWorkspace([], {
        initiator: _compiler().CompilationInitiator.Install
      });
      await this.link(linkOpts);
      prev = current;
      current = await this._getComponentsManifests(installer, mergedRootPolicy, pmInstallOptions);
    } while (!(0, _lodash().isEqual)(prev.manifests, current.manifests));
    /* eslint-enable no-await-in-loop */
    return current.componentDirectoryMap;
  }
  async _getComponentsManifests(dependencyInstaller, rootPolicy, installOptions) {
    const componentDirectoryMap = await this.getComponentsDirectory([]);
    const manifests = await dependencyInstaller.getComponentManifests(_objectSpread(_objectSpread({}, installOptions), {}, {
      componentDirectoryMap,
      rootPolicy,
      rootDir: this.workspace.path
    }));
    return {
      componentDirectoryMap,
      manifests
    };
  }

  /**
   * Updates out-of-date dependencies in the workspace.
   *
   * @param options.all {Boolean} updates all outdated dependencies without showing a prompt.
   */
  async updateDependencies(options) {
    const {
      componentConfigFiles,
      componentPoliciesById
    } = await this._getComponentsWithDependencyPolicies();
    const variantPatterns = this.variants.raw();
    const variantPoliciesByPatterns = this._variantPatternsToDepPolicesDict(variantPatterns);
    const components = await this.workspace.list();
    const outdatedPkgs = await this.dependencyResolver.getOutdatedPkgsFromPolicies({
      rootDir: this.workspace.path,
      variantPoliciesByPatterns,
      componentPoliciesById,
      components
    });
    let outdatedPkgsToUpdate;
    if (options.all) {
      outdatedPkgsToUpdate = outdatedPkgs;
    } else {
      this.logger.off();
      outdatedPkgsToUpdate = await (0, _pickOutdatedPkgs().pickOutdatedPkgs)(outdatedPkgs);
      this.logger.on();
    }
    const {
      updatedVariants,
      updatedComponents
    } = this.dependencyResolver.applyUpdates(outdatedPkgsToUpdate, {
      variantPoliciesByPatterns,
      componentPoliciesById
    });
    await this._updateVariantsPolicies(variantPatterns, updatedVariants);
    const updatedComponentConfigFiles = Object.values((0, _lodash().pick)(componentConfigFiles, updatedComponents));
    await this._saveManyComponentConfigFiles(updatedComponentConfigFiles);
    await this.workspace._reloadConsumer();
    return this._installModules({
      dedupe: true
    });
  }
  async addDuplicateComponentAndPackageIssue(components) {
    const workspacePolicy = this.dependencyResolver.getWorkspacePolicy();
    components.forEach(component => {
      const pkgName = (0, _componentIdToPackageName().default)(component.state._consumer);
      const found = workspacePolicy.find(pkgName);
      if (found) {
        component.state.issues.getOrCreate(_componentIssues().IssuesClasses.DuplicateComponentAndPackage).data = found.dependencyId;
      }
    });
  }
  async _getComponentsWithDependencyPolicies() {
    const allComponentIds = await this.workspace.listIds();
    const componentConfigFiles = {};
    const componentPoliciesById = {};
    (await Promise.all(allComponentIds.map(componentId => this.workspace.componentConfigFile(componentId)))).forEach((componentConfigFile, index) => {
      if (!componentConfigFile) return;
      const depResolverConfig = componentConfigFile.aspects.get(_dependencyResolver().DependencyResolverAspect.id);
      if (!depResolverConfig) return;
      const componentId = allComponentIds[index].toString();
      componentConfigFiles[componentId] = componentConfigFile;
      componentPoliciesById[componentId] = depResolverConfig.config.policy;
    });
    return {
      componentConfigFiles,
      componentPoliciesById
    };
  }
  _variantPatternsToDepPolicesDict(variantPatterns) {
    const variantPoliciesByPatterns = {};
    for (const [variantPattern, extensions] of Object.entries(variantPatterns)) {
      var _extensions$Dependenc;
      if ((_extensions$Dependenc = extensions[_dependencyResolver().DependencyResolverAspect.id]) !== null && _extensions$Dependenc !== void 0 && _extensions$Dependenc.policy) {
        var _extensions$Dependenc2;
        variantPoliciesByPatterns[variantPattern] = (_extensions$Dependenc2 = extensions[_dependencyResolver().DependencyResolverAspect.id]) === null || _extensions$Dependenc2 === void 0 ? void 0 : _extensions$Dependenc2.policy;
      }
    }
    return variantPoliciesByPatterns;
  }
  _updateVariantsPolicies(variantPatterns, updateVariantPolicies) {
    for (const variantPattern of updateVariantPolicies) {
      this.variants.setExtension(variantPattern, _dependencyResolver().DependencyResolverAspect.id, variantPatterns[variantPattern][_dependencyResolver().DependencyResolverAspect.id], {
        overrideExisting: true
      });
    }
    return this.dependencyResolver.persistConfig(this.workspace.path);
  }
  async _saveManyComponentConfigFiles(componentConfigFiles) {
    await Promise.all(Array.from(componentConfigFiles).map(async componentConfigFile => {
      await componentConfigFile.write({
        override: true
      });
    }));
  }

  /**
   * Uninstall the specified packages from dependencies.
   *
   * @param {string[]} the list of packages that should be removed from dependencies.
   */
  async uninstallDependencies(packages) {
    this.dependencyResolver.removeFromRootPolicy(packages);
    await this.dependencyResolver.persistConfig(this.workspace.path);
    return this._installModules({
      dedupe: true
    });
  }
  async linkCoreAspectsAndLegacy(options = {}) {
    const linker = this.dependencyResolver.getLinker({
      rootDir: this.workspace.path,
      linkingOptions: options
    });
    const compIds = await this.workspace.listIds();
    const res = await linker.linkCoreAspectsAndLegacy(this.workspace.path, compIds, options);
    return res;
  }
  async link(options = {}) {
    if (options.fetchObject) {
      await this.importObjects();
    }
    options.consumer = this.workspace.consumer;
    const compDirMap = await this.getComponentsDirectory([]);
    const mergedRootPolicy = this.dependencyResolver.getWorkspacePolicy();
    const linker = this.dependencyResolver.getLinker({
      rootDir: this.workspace.path,
      linkingOptions: options
    });
    const res = await linker.link(this.workspace.path, mergedRootPolicy, compDirMap, options);
    return res;
  }
  async importObjects() {
    const importOptions = {
      ids: [],
      objectsOnly: true,
      installNpmPackages: false
    };
    try {
      await this.importer.import(importOptions, []);
    } catch (err) {
      // TODO: this is a hack since the legacy throw an error, we should provide a way to not throw this error from the legacy
      if (err instanceof _exceptions().NothingToImport) {
        // Do not write nothing to import warning
        return;
      }
      throw err;
    }
  }

  /**
   * Generate a filter to pass to the installer
   * This will filter deps which are come from remotes which defined in scope.json
   * those components comes from local remotes, usually doesn't have a package in a registry
   * so no reason to try to install them (it will fail)
   */
  async generateFilterFnForDepsFromLocalRemote() {
    // TODO: once scope create a new API for this, replace it with the new one
    const remotes = await this.workspace.scope._legacyRemotes();
    const reg = await this.dependencyResolver.getRegistries();
    const packageScopes = Object.keys(reg.scopes);
    return dependencyList => {
      const filtered = dependencyList.filter(dep => {
        if (!(dep instanceof _dependencyResolver().ComponentDependency)) {
          return true;
        }
        if (remotes.isHub(dep.componentId.scope)) {
          return true;
        }
        if (packageScopes.some(scope => dep.packageName.startsWith(`@${scope}/`))) {
          return true;
        }
        return false;
      });
      return filtered;
    };
  }
  async getComponentsDirectory(ids) {
    const components = ids.length ? await this.workspace.getMany(ids) : await this.workspace.list();
    return _component().ComponentMap.as(components, component => this.workspace.componentDir(component.id));
  }
  static async provider([dependencyResolver, workspace, loggerExt, variants, cli, community, importer, compiler, issues]) {
    const logger = loggerExt.createLogger('teambit.bit/install');
    const installExt = new InstallMain(dependencyResolver, logger, workspace, variants, importer, compiler);
    _manyComponentsWriter().default.registerExternalInstaller({
      install: async () => {
        // TODO: think how we should pass this options
        const installOpts = {
          dedupe: true,
          updateExisting: false,
          import: false
        };
        return installExt.install(undefined, installOpts);
      }
    });
    if (issues) {
      issues.registerAddComponentsIssues(installExt.addDuplicateComponentAndPackageIssue.bind(installExt));
    }
    const commands = [new (_install2().default)(installExt, workspace, logger), new (_uninstall().default)(installExt), new (_update().default)(installExt), new (_link().LinkCommand)(installExt, workspace, logger, community.getDocsDomain())];
    cli.register(...commands);
    return installExt;
  }
}
exports.InstallMain = InstallMain;
(0, _defineProperty2().default)(InstallMain, "slots", []);
(0, _defineProperty2().default)(InstallMain, "dependencies", [_dependencyResolver().DependencyResolverAspect, _workspace().WorkspaceAspect, _logger().LoggerAspect, _variants().VariantsAspect, _cli().CLIAspect, _community().CommunityAspect, _importer().ImporterAspect, _compiler().CompilerAspect, _issues().IssuesAspect]);
(0, _defineProperty2().default)(InstallMain, "runtime", _cli().MainRuntime);
_install().InstallAspect.addRuntime(InstallMain);
var _default = InstallMain;
exports.default = _default;

//# sourceMappingURL=install.main.runtime.js.map