"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeOutdatedPkgChoices = makeOutdatedPkgChoices;
exports.pickOutdatedPkgs = pickOutdatedPkgs;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _colorizeSemverDiff() {
  const data = _interopRequireDefault(require("@pnpm/colorize-semver-diff"));
  _colorizeSemverDiff = function () {
    return data;
  };
  return data;
}
function _semverDiff() {
  const data = _interopRequireDefault(require("@pnpm/semver-diff"));
  _semverDiff = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _table() {
  const data = require("table");
  _table = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _enquirer() {
  const data = require("enquirer");
  _enquirer = function () {
    return data;
  };
  return data;
}
function _semver() {
  const data = _interopRequireDefault(require("semver"));
  _semver = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * Lets the user pick the packages that should be updated.
 */
async function pickOutdatedPkgs(outdatedPkgs) {
  const {
    updateDependencies
  } = await (0, _enquirer().prompt)({
    choices: makeOutdatedPkgChoices(outdatedPkgs),
    footer: '\nEnter to start updating. Ctrl-c to cancel.',
    indicator: (state, choice) => ` ${choice.enabled ? '●' : '○'}`,
    message: 'Choose which packages to update ' + `(Press ${_chalk().default.cyan('<space>')} to select, ` + `${_chalk().default.cyan('<a>')} to toggle all, ` + `${_chalk().default.cyan('<i>')} to invert selection)
${_chalk().default.green('Green')} - indicates a semantically safe update
${_chalk().default.red('Red')} - indicates a semantically breaking change`,
    name: 'updateDependencies',
    pointer: '❯',
    styles: {
      dark: _chalk().default.white,
      em: _chalk().default.bgBlack.whiteBright,
      success: _chalk().default.white
    },
    type: 'multiselect',
    validate(value) {
      if (value.length === 0) {
        return 'You must choose at least one package.';
      }
      return true;
    },
    j() {
      return this.down();
    },
    k() {
      return this.up();
    },
    result(names) {
      // This is needed in order to have the values of the choices in the answer object.
      // Otherwise, only the names of the selected choices would've been included.
      return this.map(names);
    },
    cancel() {
      // By default, canceling the prompt via Ctrl+c throws an empty string.
      // The custom cancel function prevents that behavior.
      // Otherwise, Bit CLI would print an error and confuse users.
      // See related issue: https://github.com/enquirer/enquirer/issues/225
    }
  });
  return Object.values(updateDependencies !== null && updateDependencies !== void 0 ? updateDependencies : {}).filter(updateDependency => typeof updateDependency !== 'string');
}
const DEP_TYPE_PRIORITY = {
  dependencies: 0,
  devDependencies: 1,
  peerDependencies: 2
};

/**
 * Groups the outdated packages and makes choices for enquirer's prompt.
 */
function makeOutdatedPkgChoices(outdatedPkgs) {
  const mergedOutdatedPkgs = mergeOutdatedPkgs(outdatedPkgs);
  mergedOutdatedPkgs.sort((pkg1, pkg2) => {
    if (pkg1.targetField === pkg2.targetField) return pkg1.name.localeCompare(pkg2.name);
    return DEP_TYPE_PRIORITY[pkg1.targetField] - DEP_TYPE_PRIORITY[pkg2.targetField];
  });
  const renderedTable = alignColumns(outdatedPkgsRows(mergedOutdatedPkgs));
  const groupedChoices = {};
  mergedOutdatedPkgs.forEach((outdatedPkg, index) => {
    const context = renderContext(outdatedPkg);
    if (!groupedChoices[context]) {
      groupedChoices[context] = [];
    }
    groupedChoices[context].push({
      message: renderedTable[index],
      name: outdatedPkg.name,
      value: outdatedPkg
    });
  });
  const choices = Object.entries(groupedChoices).map(([context, subChoices]) => ({
    message: _chalk().default.cyan(context),
    choices: subChoices
  }));
  return choices;
}
function mergeOutdatedPkgs(outdatedPkgs) {
  const mergedOutdatedPkgs = {};
  const outdatedPkgsNotFromComponentModel = [];
  for (const outdatedPkg of outdatedPkgs) {
    if (outdatedPkg.source === 'component-model' && outdatedPkg.componentId) {
      if (!mergedOutdatedPkgs[outdatedPkg.name]) {
        mergedOutdatedPkgs[outdatedPkg.name] = _objectSpread(_objectSpread({}, (0, _lodash().omit)(outdatedPkg, ['componentId'])), {}, {
          source: 'rootPolicy',
          dependentComponents: [outdatedPkg.componentId]
        });
      } else {
        if (mergedOutdatedPkgs[outdatedPkg.name].currentRange !== outdatedPkg.currentRange) {
          mergedOutdatedPkgs[outdatedPkg.name].hasDifferentRanges = true;
        }
        mergedOutdatedPkgs[outdatedPkg.name].currentRange = tryPickLowestRange(mergedOutdatedPkgs[outdatedPkg.name].currentRange, outdatedPkg.currentRange);
        mergedOutdatedPkgs[outdatedPkg.name].dependentComponents.push(outdatedPkg.componentId);
        if (outdatedPkg.targetField === 'dependencies') {
          mergedOutdatedPkgs[outdatedPkg.name].targetField = outdatedPkg.targetField;
        }
      }
    } else {
      outdatedPkgsNotFromComponentModel.push(outdatedPkg);
    }
  }
  return [...Object.values(mergedOutdatedPkgs), ...outdatedPkgsNotFromComponentModel];
}
function tryPickLowestRange(range1, range2) {
  if (range1 === '*' || range2 === '*') return '*';
  try {
    return _semver().default.lt(rangeToVersion(range1), rangeToVersion(range2)) ? range1 : range2;
  } catch (_unused) {
    return '*';
  }
}
function rangeToVersion(range) {
  if (range.startsWith('~') || range.startsWith('^')) {
    return range.substring(1);
  }
  return range;
}
function renderContext(outdatedPkg) {
  if (outdatedPkg.variantPattern) {
    return `${outdatedPkg.variantPattern} (variant)`;
  }
  if (outdatedPkg.componentId) {
    return `${outdatedPkg.componentId} (component)`;
  }
  return 'Root policies';
}
const TARGET_FIELD_TO_DEP_TYPE = {
  devDependencies: 'dev',
  dependencies: 'runtime',
  peerDependencies: 'peer'
};
function outdatedPkgsRows(outdatedPkgs) {
  return outdatedPkgs.map(outdatedPkg => {
    const {
      change,
      diff
    } = (0, _semverDiff().default)(outdatedPkg.currentRange, outdatedPkg.latestRange);
    let colorizeChange = change !== null && change !== void 0 ? change : 'breaking';
    if (change === 'feature') {
      colorizeChange = 'fix';
    }
    const latest = (0, _colorizeSemverDiff().default)({
      change: colorizeChange,
      diff
    });
    return [outdatedPkg.name, _chalk().default.grey(`(${TARGET_FIELD_TO_DEP_TYPE[outdatedPkg.targetField]})`), outdatedPkg.hasDifferentRanges ? '*' : outdatedPkg.currentRange, '❯', latest, outdatedPkg.dependentComponents ? renderDependents(outdatedPkg.dependentComponents) : ' '];
  });
}
function renderDependents(dependentComponents) {
  let result = `because of ${dependentComponents[0]}`;
  if (dependentComponents.length > 1) {
    result += ` and ${dependentComponents.length - 1} other components`;
  }
  return result;
}
function alignColumns(rows) {
  return (0, _table().table)(rows, {
    border: (0, _table().getBorderCharacters)('void'),
    columnDefault: {
      paddingLeft: 0,
      paddingRight: 1
    },
    columns: {
      // This is the current range column
      2: {
        alignment: 'right'
      }
    },
    drawHorizontalLine: () => false
  }).split('\n');
}

//# sourceMappingURL=pick-outdated-pkgs.js.map