import { CommunityMain } from '@teambit/community';
import { CompilerMain } from '@teambit/compiler';
import { CLIMain } from '@teambit/cli';
import { Workspace } from '@teambit/workspace';
import { VariantsMain } from '@teambit/variants';
import { Component, ComponentMap } from '@teambit/component';
import { WorkspaceDependencyLifecycleType, DependencyResolverMain, LinkingOptions, LinkResults } from '@teambit/dependency-resolver';
import { ImporterMain } from '@teambit/importer';
import { Logger, LoggerMain } from '@teambit/logger';
import { IssuesMain } from '@teambit/issues';
export declare type WorkspaceLinkOptions = LinkingOptions;
export declare type WorkspaceInstallOptions = {
    addMissingPeers?: boolean;
    variants?: string;
    lifecycleType?: WorkspaceDependencyLifecycleType;
    dedupe: boolean;
    import: boolean;
    copyPeerToRuntimeOnRoot?: boolean;
    copyPeerToRuntimeOnComponents?: boolean;
    updateExisting: boolean;
    savePrefix?: string;
};
export declare type ModulesInstallOptions = Omit<WorkspaceInstallOptions, 'updateExisting' | 'lifecycleType' | 'import'>;
export declare class InstallMain {
    private dependencyResolver;
    private logger;
    private workspace;
    private variants;
    private importer;
    private compiler;
    constructor(dependencyResolver: DependencyResolverMain, logger: Logger, workspace: Workspace, variants: VariantsMain, importer: ImporterMain, compiler: CompilerMain);
    /**
     * Install dependencies for all components in the workspace
     *
     * @returns
     * @memberof Workspace
     */
    install(packages?: string[], options?: WorkspaceInstallOptions): Promise<ComponentMap<string>>;
    private _addPackages;
    private _installModules;
    private _getComponentsManifests;
    /**
     * Updates out-of-date dependencies in the workspace.
     *
     * @param options.all {Boolean} updates all outdated dependencies without showing a prompt.
     */
    updateDependencies(options: {
        all: boolean;
    }): Promise<ComponentMap<string>>;
    addDuplicateComponentAndPackageIssue(components: Component[]): Promise<void>;
    private _getComponentsWithDependencyPolicies;
    private _variantPatternsToDepPolicesDict;
    private _updateVariantsPolicies;
    private _saveManyComponentConfigFiles;
    /**
     * Uninstall the specified packages from dependencies.
     *
     * @param {string[]} the list of packages that should be removed from dependencies.
     */
    uninstallDependencies(packages: string[]): Promise<ComponentMap<string>>;
    linkCoreAspectsAndLegacy(options?: WorkspaceLinkOptions): Promise<LinkResults>;
    link(options?: WorkspaceLinkOptions): Promise<LinkResults>;
    private importObjects;
    /**
     * Generate a filter to pass to the installer
     * This will filter deps which are come from remotes which defined in scope.json
     * those components comes from local remotes, usually doesn't have a package in a registry
     * so no reason to try to install them (it will fail)
     */
    private generateFilterFnForDepsFromLocalRemote;
    private getComponentsDirectory;
    static slots: never[];
    static dependencies: import("@teambit/harmony").Aspect[];
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static provider([dependencyResolver, workspace, loggerExt, variants, cli, community, importer, compiler, issues,]: [
        DependencyResolverMain,
        Workspace,
        LoggerMain,
        VariantsMain,
        CLIMain,
        CommunityMain,
        ImporterMain,
        CompilerMain,
        IssuesMain
    ]): Promise<InstallMain>;
}
export default InstallMain;
