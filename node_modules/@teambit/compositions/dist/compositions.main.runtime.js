"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompositionsMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _devFiles() {
  const data = require("@teambit/dev-files");
  _devFiles = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = _interopRequireDefault(require("@teambit/envs"));
  _envs = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = require("@teambit/graphql");
  _graphql = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@teambit/legacy/dist/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _preview() {
  const data = require("@teambit/preview");
  _preview = function () {
    return data;
  };
  return data;
}
function _schema() {
  const data = require("@teambit/schema");
  _schema = function () {
    return data;
  };
  return data;
}
function _toolboxPath() {
  const data = require("@teambit/toolbox.path.match-patterns");
  _toolboxPath = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = require("@teambit/workspace");
  _workspace = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _composition() {
  const data = require("./composition");
  _composition = function () {
    return data;
  };
  return data;
}
function _compositions() {
  const data = require("./compositions.aspect");
  _compositions = function () {
    return data;
  };
  return data;
}
function _compositions2() {
  const data = require("./compositions.graphql");
  _compositions2 = function () {
    return data;
  };
  return data;
}
function _compositions3() {
  const data = require("./compositions.preview-definition");
  _compositions3 = function () {
    return data;
  };
  return data;
}
/**
 * the component documentation extension.
 */
class CompositionsMain {
  constructor(
  /**
   * Glob pattern to select all composition files
   */
  compositionFilePattern,
  /**
   * Glob pattern to select composition preview files
   */
  previewFilePattern,
  /**
   * envs extension.
   */
  preview,
  /**
   * workspace extension.
   */
  workspace,
  /**
   * schema extension.
   */
  schema, devFiles, envs) {
    this.compositionFilePattern = compositionFilePattern;
    this.previewFilePattern = previewFilePattern;
    this.preview = preview;
    this.workspace = workspace;
    this.schema = schema;
    this.devFiles = devFiles;
    this.envs = envs;
  }

  /**
   * returns an array of doc file paths for a set of components.
   */
  getPreviewFiles(components) {
    return _component().ComponentMap.as(components, component => {
      // this includes non executables, like `button.compositions.module.scss` or `presets.compositions.json`
      const compositionFiles = component.state.filesystem.byGlob(this.compositionFilePattern);

      // select only relevant preview files (.tsx, etc)
      const previewFiles = new Set(component.state.filesystem.byGlob(this.previewFilePattern).map(file => file.relative));
      const files = compositionFiles.filter(file => previewFiles.has(file.relative));
      return files;
    });
  }

  /**
   * checks if a file matches the composition file pattern.
   */
  isCompositionFile(filePath) {
    const {
      includePatterns,
      excludePatterns
    } = (0, _toolboxPath().splitPatterns)(this.compositionFilePattern);
    return (0, _toolboxPath().matchPatterns)(filePath, includePatterns, excludePatterns);
  }

  /**
   * get component compositions.
   */
  getCompositions(component) {
    const entry = component.get(_compositions().CompositionsAspect.id);
    if (!entry) return [];
    const compositions = entry.data.compositions;
    if (!compositions) return [];
    return _composition().Composition.fromArray(compositions);
  }

  /**
   * read composition from the component source code.
   */
  readCompositions(component) {
    const maybeFiles = this.getPreviewFiles([component]).byComponent(component);
    if (!maybeFiles) return [];
    const [, files] = maybeFiles;
    return (0, _utils().flatten)(files.map(file => {
      return this.computeCompositions(component, file);
    }));
  }
  getCompositionFilePattern() {
    return this.compositionFilePattern;
  }
  getComponentDevPatterns(component) {
    const env = this.envs.calculateEnv(component).env;
    const componentEnvCompositionsDevPatterns = env.getCompositionsDevPatterns ? env.getCompositionsDevPatterns(component) : [];
    const componentPatterns = componentEnvCompositionsDevPatterns.concat(this.getCompositionFilePattern());
    return componentPatterns;
  }
  getDevPatternToRegister() {
    return this.getComponentDevPatterns.bind(this);
  }
  async onComponentLoad(component, loadOpts) {
    if ((loadOpts === null || loadOpts === void 0 ? void 0 : loadOpts.loadCompositions) === false) return undefined;
    const compositions = this.readCompositions(component);
    return {
      compositions: compositions.map(composition => composition.toObject())
    };
  }
  computeCompositions(component, file) {
    // :TODO hacked for a specific file extension now until david will take care in the compiler.
    const pathArray = file.path.split('.');
    pathArray[pathArray.length - 1] = 'js';
    const exports = this.schema.parseModule((0, _path().join)(this.workspace.componentDir(component.id), file.relative));
    return exports.map(exportModel => {
      var _exportModel$staticPr;
      const displayName = (_exportModel$staticPr = exportModel.staticProperties) === null || _exportModel$staticPr === void 0 ? void 0 : _exportModel$staticPr.get('compositionName');
      return new (_composition().Composition)(exportModel.identifier, file.relative, typeof displayName === 'string' ? displayName : undefined);
    });
  }
  static async provider([preview, graphql, workspace, schema, devFiles, envs], config) {
    const compositions = new CompositionsMain(config.compositionFilePattern, config.compositionPreviewFilePattern, preview, workspace, schema, devFiles, envs);

    // TODO: use the docs implementation to allow component specific pattern
    devFiles.registerDevPattern(compositions.getDevPatternToRegister());
    graphql.register((0, _compositions2().compositionsSchema)(compositions));
    preview.registerDefinition(new (_compositions3().CompositionPreviewDefinition)(compositions));
    if (workspace) {
      workspace.onComponentLoad(compositions.onComponentLoad.bind(compositions));
    }
    return compositions;
  }
}
exports.CompositionsMain = CompositionsMain;
(0, _defineProperty2().default)(CompositionsMain, "defaultConfig", {
  compositionFilePattern: ['**/*.composition?(s).*'],
  compositionPreviewFilePattern: ['**/*.{t,j}s?(x)']
});
(0, _defineProperty2().default)(CompositionsMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(CompositionsMain, "dependencies", [_preview().PreviewAspect, _graphql().GraphqlAspect, _workspace().WorkspaceAspect, _schema().SchemaAspect, _devFiles().DevFilesAspect, _envs().default]);
_compositions().CompositionsAspect.addRuntime(CompositionsMain);

//# sourceMappingURL=compositions.main.runtime.js.map