"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CommandBarUI = void 0;
function _extends2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
  _extends2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _react() {
  const data = _interopRequireWildcard(require("react"));
  _react = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = _interopRequireDefault(require("lodash.flatten"));
  _lodash = function () {
    return data;
  };
  return data;
}
function _mousetrap() {
  const data = _interopRequireDefault(require("mousetrap"));
  _mousetrap = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _ui() {
  const data = _interopRequireWildcard(require("@teambit/ui"));
  _ui = function () {
    return data;
  };
  return data;
}
function _pubsub() {
  const data = require("@teambit/pubsub");
  _pubsub = function () {
    return data;
  };
  return data;
}
function _reactRouter() {
  const data = require("@teambit/react-router");
  _reactRouter = function () {
    return data;
  };
  return data;
}
function _uiFoundationUi() {
  const data = require("@teambit/ui-foundation.ui.is-browser");
  _uiFoundationUi = function () {
    return data;
  };
  return data;
}
function _explorerUi() {
  const data = require("@teambit/explorer.ui.command-bar");
  _explorerUi = function () {
    return data;
  };
  return data;
}
function _commandBar() {
  const data = require("./command-bar.aspect");
  _commandBar = function () {
    return data;
  };
  return data;
}
function _commandBar2() {
  const data = require("./command-bar.commands");
  _commandBar2 = function () {
    return data;
  };
  return data;
}
function _searchers() {
  const data = require("./searchers");
  _searchers = function () {
    return data;
  };
  return data;
}
function _duplicateCommandError() {
  const data = require("./duplicate-command-error");
  _duplicateCommandError = function () {
    return data;
  };
  return data;
}
function _mousetrapStub() {
  const data = require("./mousetrap-stub");
  _mousetrapStub = function () {
    return data;
  };
  return data;
}
function _keybinding() {
  const data = require("./keybinding");
  _keybinding = function () {
    return data;
  };
  return data;
}
function _commandBarModule() {
  const data = _interopRequireDefault(require("./command-bar.module.scss"));
  _commandBarModule = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const RESULT_LIMIT = 5;
/** Quick launch actions. Use the `addSearcher` slot to extend the available actions */
class CommandBarUI {
  /** Opens the command bar */

  /** Closes the command bar */

  /** Add and autocomplete provider. To support keyboard navigation, each result should have a props `active: boolean`, and `exectue: () => any` */
  addSearcher(...commandSearcher) {
    this.searcherSlot.register(commandSearcher);
    return this;
  }

  /**
   * registers a command
   */
  addCommand(...originalCommands) {
    originalCommands.forEach(({
      id: commandId
    }) => {
      if (this.getCommand(commandId) !== undefined) throw new (_duplicateCommandError().DuplicateCommandError)(commandId);
    });

    // commands could mutate later on, clone to ensure immutability ðŸ‘Œ
    const commands = originalCommands.map(x => ({
      id: x.id,
      displayName: x.displayName,
      action: x.action,
      keybinding: x.keybinding
    }));
    this.commandSlot.register(commands);
    commands.forEach(command => {
      if (command.keybinding) {
        this.addKeybinding(command.keybinding, command.id);
      }
    });
    this.updateCommandsSearcher();
    const updaters = commands.map(command => next => {
      command.action = next;
    });
    return updaters;
  }

  /**
   * executes command by name, if exists.
   * @param commandId
   */
  run(commandId) {
    const commandEntry = this.getCommand(commandId);
    if (!commandEntry) return undefined;
    return commandEntry.action();
  }

  /**
   * executes a keyboard shortcut manually
   */

  getCommand(id) {
    const relevantCommands = this.commandSlot.values().map(commands => commands.find(command => command.id === id)).filter(x => !!x);
    return relevantCommands.pop();
  }
  updateCommandsSearcher() {
    const commands = this.commandSlot.values().flat();
    this.commandSearcher.update(commands);
  }
  addKeybinding(key, command) {
    this.mousetrap.bind(key, this.run.bind(this, command));
  }

  /**
   * Opens and closes the command bar UI.
   */

  constructor(searcherSlot, commandSlot, config) {
    this.searcherSlot = searcherSlot;
    this.commandSlot = commandSlot;
    this.config = config;
    (0, _defineProperty2().default)(this, "mousetrap", _uiFoundationUi().isBrowser ? new (_mousetrap().default)() : new (_mousetrapStub().MousetrapStub)());
    (0, _defineProperty2().default)(this, "commandSearcher", new (_searchers().CommandSearcher)([]));
    (0, _defineProperty2().default)(this, "open", () => {
      var _this$setVisibility;
      (_this$setVisibility = this.setVisibility) === null || _this$setVisibility === void 0 ? void 0 : _this$setVisibility.call(this, true);
      return false; // aka prevent default
    });
    (0, _defineProperty2().default)(this, "close", () => {
      var _this$setVisibility2;
      (_this$setVisibility2 = this.setVisibility) === null || _this$setVisibility2 === void 0 ? void 0 : _this$setVisibility2.call(this, false);
    });
    (0, _defineProperty2().default)(this, "trigger", key => {
      this.mousetrap.trigger(key);
    });
    (0, _defineProperty2().default)(this, "search", (term, limit = RESULT_LIMIT) => {
      const searchers = (0, _lodash().default)(this.searcherSlot.values());
      const searcher = searchers.find(x => x && x.test(term));
      return (searcher === null || searcher === void 0 ? void 0 : searcher.search(term, limit)) || {
        items: []
      };
    });
    (0, _defineProperty2().default)(this, "setVisibility", void 0);
    (0, _defineProperty2().default)(this, "CommandBar", ({
      ResultComponent
    }) => {
      const [visible, setVisibility] = (0, _react().useState)(false);
      this.setVisibility = setVisibility;
      const results = (0, _explorerUi().useSearcher)(this.search, {
        debounce: this.config.debounce
      });
      return /*#__PURE__*/_react().default.createElement(_explorerUi().CommandBar, (0, _extends2().default)({}, results, {
        key: "CommandBarUI",
        className: _commandBarModule().default.commanderUi,
        placeholder: "Search anything or type > to only search commands",
        visible: visible,
        ResultsComponent: ResultComponent,
        onVisibilityChange: setVisibility,
        autofocus: true
      }));
    });
  }
  static async provider([uiUi, pubsubUI], config, [searcherSlot, commandSlots]) {
    const commandBar = new CommandBarUI(searcherSlot, commandSlots, config);
    commandBar.addSearcher(commandBar.commandSearcher);
    commandBar.addCommand({
      id: _commandBar2().commandBarCommands.open,
      action: commandBar.open,
      displayName: 'Open command bar',
      keybinding: _keybinding().openCommandBarKeybinding
    });
    if (pubsubUI) {
      pubsubUI.sub(_commandBar().CommandBarAspect.id, e => {
        const keyboardEvent = new KeyboardEvent(e.type, e.data);
        document.dispatchEvent(keyboardEvent);
      });
    }
    if (uiUi) {
      uiUi.registerHudItem( /*#__PURE__*/_react().default.createElement(commandBar.CommandBar, {
        key: "commandBar"
      }));
    }
    return commandBar;
  }
}
exports.CommandBarUI = CommandBarUI;
(0, _defineProperty2().default)(CommandBarUI, "dependencies", [_ui().default, _pubsub().PubsubAspect, _reactRouter().ReactRouterAspect]);
(0, _defineProperty2().default)(CommandBarUI, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(CommandBarUI, "defaultConfig", {
  debounce: undefined
});
(0, _defineProperty2().default)(CommandBarUI, "runtime", _ui().UIRuntime);
_commandBar().CommandBarAspect.addRuntime(CommandBarUI);

//# sourceMappingURL=command-bar.ui.runtime.js.map