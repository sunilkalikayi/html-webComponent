"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LaneSwitcher = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _repositories() {
  const data = require("@teambit/legacy/dist/scope/repositories");
  _repositories = function () {
    return data;
  };
  return data;
}
function _checkoutVersion() {
  const data = require("@teambit/legacy/dist/consumer/versions-ops/checkout-version");
  _checkoutVersion = function () {
    return data;
  };
  return data;
}
function _manyComponentsWriter() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/many-components-writer"));
  _manyComponentsWriter = function () {
    return data;
  };
  return data;
}
function _mergeVersion() {
  const data = require("@teambit/legacy/dist/consumer/versions-ops/merge-version");
  _mergeVersion = function () {
    return data;
  };
  return data;
}
function _threeWayMerge() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/versions-ops/merge-version/three-way-merge"));
  _threeWayMerge = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
class LaneSwitcher {
  // populated by `this.populateSwitchProps()`
  // populated by `this.populateSwitchProps()`, if default-lane, it's undefined
  constructor(workspace, logger, switchProps, checkoutProps, Lanes) {
    this.workspace = workspace;
    this.logger = logger;
    this.switchProps = switchProps;
    this.checkoutProps = checkoutProps;
    this.Lanes = Lanes;
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "laneIdToSwitch", void 0);
    (0, _defineProperty2().default)(this, "laneToSwitchTo", void 0);
    this.consumer = this.workspace.consumer;
  }
  async switch() {
    this.logger.setStatusLine(`switching lanes`);
    await this.populateSwitchProps();
    const allComponentsStatus = await this.getAllComponentsStatus();
    const componentWithConflict = allComponentsStatus.find(component => component.mergeResults && component.mergeResults.hasConflicts);
    if (componentWithConflict) {
      if (!this.checkoutProps.promptMergeOptions && !this.checkoutProps.mergeStrategy) {
        throw new (_generalError().default)(`automatic merge has failed for component ${componentWithConflict.id.toStringWithoutVersion()}.\nplease use "--manual" to manually merge changes or use "--theirs / --ours" to choose one of the conflicted versions`);
      }
      if (!this.checkoutProps.mergeStrategy) this.checkoutProps.mergeStrategy = await (0, _mergeVersion().getMergeStrategyInteractive)();
    }
    const failedComponents = allComponentsStatus.filter(componentStatus => componentStatus.failureMessage).map(componentStatus => ({
      id: componentStatus.id,
      failureMessage: componentStatus.failureMessage,
      unchangedLegitimately: componentStatus.unchangedLegitimately
    }));
    const succeededComponents = allComponentsStatus.filter(componentStatus => !componentStatus.failureMessage);
    // do not use Promise.all for applyVersion. otherwise, it'll write all components in parallel,
    // which can be an issue when some components are also dependencies of others
    const componentsResults = await (0, _pMapSeries().default)(succeededComponents, ({
      id,
      componentFromFS,
      mergeResults
    }) => {
      return (0, _checkoutVersion().applyVersion)(this.consumer, id, componentFromFS, mergeResults, this.checkoutProps);
    });
    (0, _checkoutVersion().markFilesToBeRemovedIfNeeded)(succeededComponents, componentsResults);
    await this.saveLanesData();
    const componentsWithDependencies = componentsResults.map(c => c.component).filter(c => c);
    const manyComponentsWriter = new (_manyComponentsWriter().default)({
      consumer: this.consumer,
      componentsWithDependencies,
      installNpmPackages: !this.checkoutProps.skipNpmInstall,
      override: true,
      verbose: this.checkoutProps.verbose,
      writeConfig: this.checkoutProps.writeConfig
    });
    await manyComponentsWriter.writeAll();
    await (0, _checkoutVersion().deleteFilesIfNeeded)(componentsResults, this.consumer);
    const appliedVersionComponents = componentsResults.map(c => c.applyVersionResult);
    await this.consumer.onDestroy();
    return {
      components: appliedVersionComponents,
      failedComponents
    };
  }
  async populateSwitchProps() {
    const laneId = await this.consumer.scope.lanes.parseLaneIdFromString(this.switchProps.laneName);
    const localLane = await this.consumer.scope.loadLane(laneId);
    if (laneId.isDefault()) {
      await this.populatePropsAccordingToDefaultLane();
    } else if (localLane) {
      this.populatePropsAccordingToLocalLane(localLane);
    } else {
      await this.populatePropsAccordingToRemoteLane(laneId);
    }
  }
  async populatePropsAccordingToRemoteLane(remoteLaneId) {
    this.laneIdToSwitch = remoteLaneId;
    this.logger.debug(`populatePropsAccordingToRemoteLane, remoteLaneId: ${remoteLaneId.toString()}`);
    if (this.consumer.getCurrentLaneId().isEqual(remoteLaneId)) {
      throw new (_bitError().BitError)(`already checked out to "${remoteLaneId.toString()}"`);
    }
    const remoteLane = await this.Lanes.fetchLaneWithItsComponents(remoteLaneId);
    this.switchProps.laneName = remoteLaneId.name;
    this.switchProps.ids = remoteLane.components.map(l => l.id.changeVersion(l.head.toString()));
    this.switchProps.localTrackedLane = this.consumer.scope.lanes.getAliasByLaneId(remoteLaneId) || undefined;
    this.switchProps.remoteLane = remoteLane;
    this.laneToSwitchTo = remoteLane;
    this.logger.debug(`populatePropsAccordingToRemoteLane, completed`);
  }
  async populatePropsAccordingToDefaultLane() {
    if (!this.consumer.isOnLane()) {
      throw new (_bitError().BitError)(`already checked out to "${this.switchProps.laneName}"`);
    }
    this.switchProps.ids = await this.consumer.getIdsOfDefaultLane();
    this.laneIdToSwitch = _laneId().LaneId.from(_laneId().DEFAULT_LANE, this.consumer.scope.name);
  }
  populatePropsAccordingToLocalLane(localLane) {
    if (this.consumer.getCurrentLaneId().name === this.switchProps.laneName) {
      throw new (_bitError().BitError)(`already checked out to "${this.switchProps.laneName}"`);
    }
    this.switchProps.ids = localLane.components.map(c => c.id.changeVersion(c.head.toString()));
    this.laneIdToSwitch = localLane.toLaneId();
    this.laneToSwitchTo = localLane;
  }
  async getAllComponentsStatus() {
    const {
      ids
    } = this.switchProps;
    const tmp = new (_repositories().Tmp)(this.consumer.scope);
    try {
      const componentsStatusP = ids.map(id => getComponentStatus(this.consumer, id, this.switchProps));
      const componentsStatus = await Promise.all(componentsStatusP);
      await tmp.clear();
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return componentsStatus;
    } catch (err) {
      await tmp.clear();
      throw err;
    }
  }
  async saveLanesData() {
    var _this$laneToSwitchTo;
    const localLaneName = this.switchProps.alias || this.laneIdToSwitch.name;
    if (this.switchProps.remoteLane) {
      if (!this.switchProps.localTrackedLane) {
        this.consumer.scope.lanes.trackLane({
          localLane: localLaneName,
          remoteLane: this.laneIdToSwitch.name,
          remoteScope: this.laneIdToSwitch.scope
        });
      }
    }
    this.consumer.setCurrentLane(this.laneIdToSwitch, !((_this$laneToSwitchTo = this.laneToSwitchTo) !== null && _this$laneToSwitchTo !== void 0 && _this$laneToSwitchTo.isNew));
    this.consumer.bitMap.syncWithLanes(this.laneToSwitchTo);
  }
}
exports.LaneSwitcher = LaneSwitcher;
async function getComponentStatus(consumer, id, switchProps) {
  const componentStatus = {
    id
  };
  const returnFailure = (msg, unchangedLegitimately = false) => {
    componentStatus.failureMessage = msg;
    componentStatus.unchangedLegitimately = unchangedLegitimately;
    return componentStatus;
  };
  const modelComponent = await consumer.scope.getModelComponentIfExist(id);
  if (!modelComponent) {
    return returnFailure(`component ${id.toString()} had never imported`, true);
  }
  const unmerged = consumer.scope.objects.unmergedComponents.getEntry(id.name);
  if (unmerged) {
    return returnFailure(`component ${id.toStringWithoutVersion()} is in during-merge state, please snap/tag it first (or use bit merge --resolve/--abort)`);
  }
  const version = id.version;
  if (!version) {
    return returnFailure(`component doesn't have any snaps on ${_laneId().DEFAULT_LANE}`, true);
  }
  const existingBitMapId = consumer.bitMap.getBitIdIfExist(id, {
    ignoreVersion: true
  });
  const componentOnLane = await modelComponent.loadVersion(version, consumer.scope.objects);
  if (componentOnLane.isRemoved()) {
    return returnFailure(`component has been removed`, true);
  }
  if (!existingBitMapId) {
    if (switchProps.existingOnWorkspaceOnly) {
      return returnFailure(`component ${id.toStringWithoutVersion()} is not in the workspace`, true);
    }
    return {
      componentFromFS: undefined,
      componentFromModel: componentOnLane,
      id,
      mergeResults: null
    };
  }
  if (!existingBitMapId.hasVersion()) {
    // happens when switching from main to a lane and a component was snapped on the lane.
    // in the .bitmap file, the version is "latest" or empty. so we just need to write the component according to the
    // model. we don't care about the componentFromFS
    return {
      componentFromFS: undefined,
      componentFromModel: componentOnLane,
      id,
      mergeResults: null
    };
  }
  const currentlyUsedVersion = existingBitMapId.version;
  if (currentlyUsedVersion === version) {
    return returnFailure(`component ${id.toStringWithoutVersion()} is already at version ${version}`, true);
  }
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  const baseComponent = await modelComponent.loadVersion(currentlyUsedVersion, consumer.scope.objects);
  const component = await consumer.loadComponent(existingBitMapId);
  // don't use `consumer.isModified` here. otherwise, if there are dependency changes, the user can't discard them
  // and won't be able to switch lanes.
  const isModified = await consumer.isComponentSourceCodeModified(baseComponent, component);
  let mergeResults;
  const isHeadSameAsMain = () => {
    const head = modelComponent.getHead();
    if (!head) return false;
    if (!existingBitMapId.version) return false;
    const tagVersion = modelComponent.getTagOfRefIfExists(head);
    const headVersion = tagVersion || head.toString();
    return existingBitMapId.version === headVersion;
  };
  if (isModified) {
    if (!isHeadSameAsMain()) {
      throw new (_generalError().default)(`unable to checkout ${id.toStringWithoutVersion()}, the component is modified and belongs to another lane`);
    }
    const otherComponent = await modelComponent.loadVersion(existingBitMapId.version,
    // we are here because the head is same as main. so, existingBitMapId.version must be set
    consumer.scope.objects);
    mergeResults = await (0, _threeWayMerge().default)({
      consumer,
      otherComponent,
      otherLabel: version,
      currentComponent: component,
      currentLabel: `${currentlyUsedVersion} modified`,
      baseComponent
    });
  }
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  return {
    componentFromFS: component,
    componentFromModel: componentOnLane,
    id,
    mergeResults
  };
}

//# sourceMappingURL=switch-lanes.js.map