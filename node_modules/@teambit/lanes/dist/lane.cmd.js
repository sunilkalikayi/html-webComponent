"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LaneShowCmd = exports.LaneRenameCmd = exports.LaneRemoveReadmeCmd = exports.LaneRemoveCmd = exports.LaneListCmd = exports.LaneImportCmd = exports.LaneCreateCmd = exports.LaneCmd = exports.LaneChangeScopeCmd = exports.LaneAliasCmd = exports.LaneAddReadmeCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _yn() {
  const data = _interopRequireDefault(require("yn"));
  _yn = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _prompts() {
  const data = require("@teambit/legacy/dist/prompts");
  _prompts = function () {
    return data;
  };
  return data;
}
// eslint-disable-next-line max-classes-per-file

class LaneListCmd {
  constructor(lanes, workspace, scope) {
    this.lanes = lanes;
    this.workspace = workspace;
    this.scope = scope;
    (0, _defineProperty2().default)(this, "name", 'list');
    (0, _defineProperty2().default)(this, "description", `list lanes`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['d', 'details', 'show more details on the state of each component in each lane'], ['j', 'json', 'show lanes details in a json format'], ['r', 'remote <remote-scope-name>', 'show remote lanes'], ['', 'merged', 'show merged lanes'], ['', 'not-merged', 'show lanes that are not merged']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "remoteOp", true);
    (0, _defineProperty2().default)(this, "skipWorkspace", true);
  }
  async report(args, laneOptions) {
    const {
      details,
      remote,
      merged,
      notMerged
    } = laneOptions;
    const laneIdStr = (laneId, alias) => {
      if (laneId.isDefault()) return laneId.name;
      if (alias) return `${laneId.toString()} (${alias})`;
      return laneId.toString();
    };
    const lanes = await this.lanes.getLanes({
      remote,
      merged,
      notMerged,
      showDefaultLane: true
    });
    if (merged) {
      const mergedLanes = lanes.filter(l => l.isMerged);
      if (!mergedLanes.length) return _chalk().default.green('None of the lanes is merged');
      return _chalk().default.green(mergedLanes.map(m => m.name).join('\n'));
    }
    if (notMerged) {
      const unmergedLanes = lanes.filter(l => !l.isMerged);
      if (!unmergedLanes.length) return _chalk().default.green('All lanes are merged');
      return _chalk().default.green(unmergedLanes.map(m => m.name).join('\n'));
    }
    const currentLane = this.lanes.getCurrentLaneId() || this.lanes.getDefaultLaneId();
    const laneDataOfCurrentLane = currentLane ? lanes.find(l => currentLane.isEqual(l.id)) : undefined;
    const currentAlias = laneDataOfCurrentLane ? laneDataOfCurrentLane.alias : undefined;
    const currentLaneReadmeComponentStr = outputReadmeComponent(laneDataOfCurrentLane === null || laneDataOfCurrentLane === void 0 ? void 0 : laneDataOfCurrentLane.readmeComponent);
    let currentLaneStr = `current lane - ${_chalk().default.green.green(laneIdStr(currentLane, currentAlias))}`;
    currentLaneStr += currentLaneReadmeComponentStr;
    if (details) {
      const currentLaneComponents = laneDataOfCurrentLane ? outputComponents(laneDataOfCurrentLane.components) : '';
      if (currentLaneStr) {
        currentLaneStr += `\n${currentLaneComponents}`;
      }
    }
    const availableLanes = lanes.filter(l => !currentLane.isEqual(l.id)).map(laneData => {
      const readmeComponentStr = outputReadmeComponent(laneData.readmeComponent);
      if (details) {
        const laneTitle = `> ${_chalk().default.bold(laneIdStr(laneData.id, laneData.alias))}\n`;
        const components = outputComponents(laneData.components);
        return laneTitle + readmeComponentStr.concat('\n') + components;
      }
      return `    > ${_chalk().default.green(laneIdStr(laneData.id, laneData.alias))} (${laneData.components.length} components)${readmeComponentStr}`;
    }).join('\n');
    const outputFooter = () => {
      let footer = '\n';
      if (details) {
        footer += 'You can use --merged and --not-merged to see which of the lanes is fully merged.';
      } else {
        footer += "to get more info on all lanes in workspace use 'bit lane list --details' or 'bit lane show <lane-name>' for a specific lane.";
      }
      if (!remote && this.workspace) footer += `\nswitch lanes using 'bit switch <name>'.`;
      return footer;
    };
    return outputCurrentLane() + outputAvailableLanes() + outputFooter();
    function outputCurrentLane() {
      return currentLaneStr ? `${currentLaneStr}\n` : '';
    }
    function outputAvailableLanes() {
      if (!availableLanes) return '';
      return remote ? `${availableLanes}\n` : `\nAvailable lanes:\n${availableLanes}\n`;
    }
  }
  async json(args, laneOptions) {
    const {
      remote,
      merged = false,
      notMerged = false
    } = laneOptions;
    const lanes = await this.lanes.getLanes({
      remote,
      showDefaultLane: true,
      merged,
      notMerged
    });
    const currentLane = this.lanes.getCurrentLaneNameOrAlias();
    return {
      lanes,
      currentLane
    };
  }
}
exports.LaneListCmd = LaneListCmd;
class LaneShowCmd {
  constructor(lanes, workspace, scope) {
    this.lanes = lanes;
    this.workspace = workspace;
    this.scope = scope;
    (0, _defineProperty2().default)(this, "name", 'show <lane-name>');
    (0, _defineProperty2().default)(this, "description", `show lane details`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['j', 'json', 'show the lane details in json format'], ['r', 'remote <string>', 'show remote lanes']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "remoteOp", true);
    (0, _defineProperty2().default)(this, "skipWorkspace", true);
  }
  async report([name], laneOptions) {
    var _onlyLane$log, _onlyLane$log2, _onlyLane$log3;
    const {
      remote
    } = laneOptions;
    const lanes = await this.lanes.getLanes({
      name,
      remote
    });
    const onlyLane = lanes[0];
    const title = `showing information for ${_chalk().default.bold(onlyLane.id.toString())}\n`;
    const author = `author: ${((_onlyLane$log = onlyLane.log) === null || _onlyLane$log === void 0 ? void 0 : _onlyLane$log.username) || 'N/A'} <${((_onlyLane$log2 = onlyLane.log) === null || _onlyLane$log2 === void 0 ? void 0 : _onlyLane$log2.email) || 'N/A'}>\n`;
    const date = (_onlyLane$log3 = onlyLane.log) !== null && _onlyLane$log3 !== void 0 && _onlyLane$log3.date ? `${new Date(parseInt(onlyLane.log.date)).toLocaleString()}\n` : undefined;
    return title + author + date + outputComponents(onlyLane.components);
  }
  async json([name], laneOptions) {
    const {
      remote
    } = laneOptions;
    const lanes = await this.lanes.getLanes({
      name,
      remote
    });
    return lanes[0];
  }
}
exports.LaneShowCmd = LaneShowCmd;
class LaneCreateCmd {
  constructor(lanes) {
    this.lanes = lanes;
    (0, _defineProperty2().default)(this, "name", 'create <lane-name>');
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'lane-name',
      description: 'the name for the new lane'
    }]);
    (0, _defineProperty2().default)(this, "description", `creates a new lane and switches to it`);
    (0, _defineProperty2().default)(this, "extendedDescription", `a lane created from main (default-lane) is empty until components are snapped.
a lane created from another lane has all the components of the original lane.`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['', 'remote-scope <scope-name>', 'remote scope where this lane will be exported to, default to the defaultScope (can be changed later with "bit lane change-scope")'], ['', 'alias <name>', 'a local alias to refer to this lane, defaults to the <lane-name> (can be added later with "bit lane alias")']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
  }
  async report([name], createLaneOptions) {
    const result = await this.lanes.createLane(name, createLaneOptions);
    const remoteScopeOrDefaultScope = createLaneOptions.remoteScope ? `the remote scope ${_chalk().default.bold(createLaneOptions.remoteScope)}` : `the default-scope ${_chalk().default.bold(result.remoteScope)}. to change it, please run "bit lane change-scope" command`;
    const title = _chalk().default.green(`successfully added and checked out to a new lane ${_chalk().default.bold(result.localLane)}`);
    const remoteScopeOutput = `this lane will be exported to ${remoteScopeOrDefaultScope}`;
    return `${title}\n${remoteScopeOutput}`;
  }
}
exports.LaneCreateCmd = LaneCreateCmd;
class LaneAliasCmd {
  constructor(lanes) {
    this.lanes = lanes;
    (0, _defineProperty2().default)(this, "name", 'alias <lane-name> <alias>');
    (0, _defineProperty2().default)(this, "description", 'adds an alias to a lane');
    (0, _defineProperty2().default)(this, "extendedDescription", `an alias is a name that can be used to refer to a lane. it is saved locally and never reach the remote.
it is useful when having multiple lanes with the same name, but with different remote scopes.`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
  }
  async report([laneName, alias]) {
    const {
      laneId
    } = await this.lanes.aliasLane(laneName, alias);
    return `successfully added the alias ${_chalk().default.bold(alias)} to the lane ${_chalk().default.bold(laneId.toString())}`;
  }
}
exports.LaneAliasCmd = LaneAliasCmd;
class LaneChangeScopeCmd {
  constructor(lanes) {
    this.lanes = lanes;
    (0, _defineProperty2().default)(this, "name", 'change-scope <lane-name> <remote-scope-name>');
    (0, _defineProperty2().default)(this, "description", `changes the remote scope of a lane`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
  }
  async report([localName, remoteScope]) {
    const {
      remoteScopeBefore
    } = await this.lanes.changeScope(localName, remoteScope);
    return `the remote-scope of ${_chalk().default.bold(localName)} has been changed from ${_chalk().default.bold(remoteScopeBefore)} to ${_chalk().default.bold(remoteScope)}`;
  }
}
exports.LaneChangeScopeCmd = LaneChangeScopeCmd;
class LaneRenameCmd {
  constructor(lanes) {
    this.lanes = lanes;
    (0, _defineProperty2().default)(this, "name", 'rename <current-name> <new-name>');
    (0, _defineProperty2().default)(this, "description", `EXPERIMENTAL. change the lane-name locally and on the remote (if exported)`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
  }
  async report([currentName, newName]) {
    const {
      exported,
      exportErr
    } = await this.lanes.rename(currentName, newName);
    const exportedStr = exported ? `and have been exported successfully to the remote` : `however if failed to export the renamed lane to the remote, due to an error: ${(exportErr === null || exportErr === void 0 ? void 0 : exportErr.message) || 'unknown'}`;
    return `the lane ${_chalk().default.bold(currentName)} has been changed to ${_chalk().default.bold(newName)}, ${exportedStr}`;
  }
}
exports.LaneRenameCmd = LaneRenameCmd;
class LaneRemoveCmd {
  constructor(lanes) {
    this.lanes = lanes;
    (0, _defineProperty2().default)(this, "name", 'remove <lanes...>');
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'lanes...',
      description: 'A list of lane names, separated by spaces'
    }]);
    (0, _defineProperty2().default)(this, "description", `remove lanes`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['r', 'remote', 'remove a remote lane (in the lane arg, use remote/lane-id syntax)'], ['f', 'force', 'removes the lane even when the lane was not merged yet'], ['s', 'silent', 'skip confirmation']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
  }
  async report([names], {
    remote = false,
    force = false,
    silent = false
  }) {
    if (!silent) {
      const removePromptResult = await (0, _prompts().approveOperation)();
      // @ts-ignore
      if (!(0, _yn().default)(removePromptResult.shouldProceed)) {
        throw new (_bitError().BitError)('the operation has been canceled');
      }
    }
    const laneResults = await this.lanes.removeLanes(names, {
      remote,
      force
    });
    return _chalk().default.green(`successfully removed the following lane(s): ${_chalk().default.bold(laneResults.join(', '))}`);
  }
}
exports.LaneRemoveCmd = LaneRemoveCmd;
class LaneImportCmd {
  constructor(switchCmd) {
    this.switchCmd = switchCmd;
    (0, _defineProperty2().default)(this, "name", 'import <lane>');
    (0, _defineProperty2().default)(this, "description", `import a remote lane to your workspace`);
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'lane',
      description: 'the remote lane name'
    }]);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['', 'skip-dependency-installation', 'do not install packages of the imported components']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
  }
  async report([lane], {
    skipDependencyInstallation = false
  }) {
    return this.switchCmd.report([lane], {
      getAll: true,
      skipDependencyInstallation
    });
  }
}
exports.LaneImportCmd = LaneImportCmd;
class LaneCmd {
  constructor(lanes, workspace, scope, docsDomain) {
    this.lanes = lanes;
    this.workspace = workspace;
    this.scope = scope;
    (0, _defineProperty2().default)(this, "name", 'lane [lane-name]');
    (0, _defineProperty2().default)(this, "description", 'show lanes details');
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['d', 'details', 'show more details on the state of each component in each lane'], ['j', 'json', 'show lanes details in json format'], ['r', 'remote <string>', 'show remote lanes'], ['', 'merged', 'show merged lanes'], ['', 'not-merged', 'show not merged lanes']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "remoteOp", true);
    (0, _defineProperty2().default)(this, "skipWorkspace", true);
    (0, _defineProperty2().default)(this, "commands", []);
    this.description = `show lanes details
https://${docsDomain}/components/lanes`;
  }
  async report([name], laneOptions) {
    return new LaneListCmd(this.lanes, this.workspace, this.scope).report([name], laneOptions);
  }
}
exports.LaneCmd = LaneCmd;
class LaneRemoveReadmeCmd {
  constructor(lanes) {
    this.lanes = lanes;
    (0, _defineProperty2().default)(this, "name", 'remove-readme [laneName]');
    (0, _defineProperty2().default)(this, "description", 'EXPERIMENTAL. remove lane readme component');
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "skipWorkspace", false);
  }
  async report([laneName]) {
    const {
      result,
      message
    } = await this.lanes.removeLaneReadme(laneName);
    if (result) {
      return _chalk().default.green(`the readme component has been successfully removed from the lane ${laneName || this.lanes.getCurrentLaneName()}`);
    }
    return _chalk().default.red(`${message}\n`);
  }
}
exports.LaneRemoveReadmeCmd = LaneRemoveReadmeCmd;
class LaneAddReadmeCmd {
  constructor(lanes) {
    this.lanes = lanes;
    (0, _defineProperty2().default)(this, "name", 'add-readme <component-name> [lane-name]');
    (0, _defineProperty2().default)(this, "description", 'EXPERIMENTAL. adds a readme component to a lane');
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'component-id',
      description: "the component name or id of the component to use as the lane's readme"
    }, {
      name: 'lane-name',
      description: 'the lane to attach the readme to (defaults to the current lane)'
    }]);
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "skipWorkspace", false);
  }
  async report([componentId, laneName]) {
    const {
      result,
      message
    } = await this.lanes.addLaneReadme(componentId, laneName);
    if (result) return _chalk().default.green(`the component ${componentId} has been successfully added as the readme component for the lane ${laneName || this.lanes.getCurrentLaneName()}`);
    return _chalk().default.red(`${message || ''}\nthe component ${componentId} could not be added as a readme component for the lane ${laneName || this.lanes.getCurrentLaneName()}`);
  }
}
exports.LaneAddReadmeCmd = LaneAddReadmeCmd;
function outputComponents(components) {
  const componentsTitle = `\t${_chalk().default.bold(`components (${components.length})`)}\n`;
  const componentsStr = components.map(c => `\t  ${c.id.toString()} - ${c.head}`).join('\n');
  return componentsTitle + componentsStr;
}
function outputReadmeComponent(component) {
  if (!component) return '';
  return `\n\t${`${_chalk().default.yellow('readme component')}\n\t  ${component.id} - ${component.head || `(unsnapped)\n\t("use bit snap ${component.id.name}" to snap the readme component on the lane before exporting)`}`}\n`;
}

//# sourceMappingURL=lane.cmd.js.map