"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lanesSchema = lanesSchema;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _graphqlTag() {
  const data = _interopRequireDefault(require("graphql-tag"));
  _graphqlTag = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function lanesSchema(lanesMainRuntime) {
  return {
    typeDefs: (0, _graphqlTag().default)`
      type FileDiff {
        filePath: String!
        diffOutput: String
      }

      type FieldsDiff {
        fieldName: String!
        diffOutput: String
      }

      type DiffResults {
        id: String
        hasDiff: Boolean
        filesDiff: [FileDiff]
        fieldsDiff: [FieldsDiff]
      }

      type GetDiffResult {
        newComps: [String]
        compsWithNoChanges: [String]
        toLaneName: String
        compsWithDiff: [DiffResults]
      }

      input DiffOptions {
        color: Boolean
      }

      type LaneId {
        name: String!
        scope: String!
      }

      type Lane {
        id: LaneId!
        hash: String
        components(offset: Int, limit: Int): [Component!]!
        readmeComponent: Component
      }

      # Lane API
      type Lanes {
        id: String!
        list(ids: [String!], offset: Int, limit: Int): [Lane!]!
        diff(from: String!, to: String!, options: DiffOptions): GetDiffResult
        current: Lane
      }

      type Query {
        lanes: Lanes
      }
    `,
    resolvers: {
      Lanes: {
        // need this for Apollo InMemory Caching
        id: () => 'lanes',
        list: async (lanesMain, {
          ids,
          limit,
          offset
        }) => {
          let lanes = [];
          if (!ids || ids.length === 0) {
            lanes = await lanesMain.getLanes({
              showDefaultLane: true
            });
          } else {
            lanes = (0, _lodash().flatten)(await Promise.all(ids.map(id => lanesMain.getLanes({
              name: _laneId().LaneId.parse(id).name
            }))));
          }
          if (limit || offset) {
            lanes = (0, _lodash().slice)(lanes, offset, limit && limit + (offset || 0));
          }
          return lanes;
        },
        current: async lanesMain => {
          const currentLaneName = lanesMain.getCurrentLaneName();
          if (!currentLaneName) return undefined;
          const [currentLane] = await lanesMain.getLanes({
            name: currentLaneName
          });
          return currentLane;
        },
        diff: async (lanesMain, {
          from,
          to,
          options
        }) => {
          const getDiffResults = await lanesMain.getDiff([from, to], options);
          return _objectSpread(_objectSpread({}, getDiffResults), {}, {
            compsWithDiff: getDiffResults.compsWithDiff.map(item => _objectSpread(_objectSpread({}, item), {}, {
              id: item.id.toString()
            }))
          });
        }
      },
      Lane: {
        id: lane => lane.id.toObject(),
        components: async lane => {
          const laneComponents = await lanesMainRuntime.getLaneComponentModels(lane);
          return laneComponents;
        },
        readmeComponent: async lane => {
          const laneReadmeComponent = await lanesMainRuntime.getLaneReadmeComponent(lane);
          return laneReadmeComponent;
        }
      },
      Query: {
        lanes: () => lanesMainRuntime
      }
    }
  };
}

//# sourceMappingURL=lanes.graphql.js.map