"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Lane", {
  enumerable: true,
  get: function () {
    return _models().Lane;
  }
});
exports.default = exports.LanesMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = require("@teambit/scope");
  _scope = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = require("@teambit/graphql");
  _graphql = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = require("@teambit/workspace");
  _workspace = function () {
    return data;
  };
  return data;
}
function _getRemoteByName() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/remotes/get-remote-by-name"));
  _getRemoteByName = function () {
    return data;
  };
  return data;
}
function _lanesModules() {
  const data = require("@teambit/lanes.modules.diff");
  _lanesModules = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _mergeVersion() {
  const data = require("@teambit/legacy/dist/consumer/versions-ops/merge-version");
  _mergeVersion = function () {
    return data;
  };
  return data;
}
function _importer() {
  const data = require("@teambit/importer");
  _importer = function () {
    return data;
  };
  return data;
}
function _community() {
  const data = require("@teambit/community");
  _community = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = _interopRequireDefault(require("@teambit/component"));
  _component = function () {
    return data;
  };
  return data;
}
function _removeLanes() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/lanes/remove-lanes"));
  _removeLanes = function () {
    return data;
  };
  return data;
}
function _models() {
  const data = require("@teambit/legacy/dist/scope/models");
  _models = function () {
    return data;
  };
  return data;
}
function _laneNotFound() {
  const data = require("@teambit/legacy/dist/api/scope/lib/exceptions/lane-not-found");
  _laneNotFound = function () {
    return data;
  };
  return data;
}
function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/scope/component-ops/scope-components-importer"));
  _scopeComponentsImporter = function () {
    return data;
  };
  return data;
}
function _export() {
  const data = require("@teambit/export");
  _export = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _merging() {
  const data = require("@teambit/merging");
  _merging = function () {
    return data;
  };
  return data;
}
function _lanes() {
  const data = require("./lanes.aspect");
  _lanes = function () {
    return data;
  };
  return data;
}
function _lane() {
  const data = require("./lane.cmd");
  _lane = function () {
    return data;
  };
  return data;
}
function _lanes2() {
  const data = require("./lanes.graphql");
  _lanes2 = function () {
    return data;
  };
  return data;
}
function _switch() {
  const data = require("./switch.cmd");
  _switch = function () {
    return data;
  };
  return data;
}
function _switchLanes() {
  const data = require("./switch-lanes");
  _switchLanes = function () {
    return data;
  };
  return data;
}
function _createLane() {
  const data = require("./create-lane");
  _createLane = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class LanesMain {
  constructor(workspace, scope, merging, componentAspect, logger, importer, exporter) {
    this.workspace = workspace;
    this.scope = scope;
    this.merging = merging;
    this.componentAspect = componentAspect;
    this.logger = logger;
    this.importer = importer;
    this.exporter = exporter;
  }
  async getLanes({
    name,
    remote,
    merged,
    showDefaultLane,
    notMerged
  }) {
    var _this$workspace;
    const showMergeData = Boolean(merged || notMerged);
    const consumer = (_this$workspace = this.workspace) === null || _this$workspace === void 0 ? void 0 : _this$workspace.consumer;
    if (remote) {
      const remoteObj = await (0, _getRemoteByName().default)(remote, consumer);
      const lanes = await remoteObj.listLanes(name, showMergeData);
      return lanes;
    }
    if (name === _laneId().DEFAULT_LANE) {
      const defaultLane = await this.getLaneDataOfDefaultLane();
      return defaultLane ? [defaultLane] : [];
    }
    const lanes = await this.scope.legacyScope.lanes.getLanesData(this.scope.legacyScope, name, showMergeData);
    if (showDefaultLane) {
      const defaultLane = await this.getLaneDataOfDefaultLane();
      if (defaultLane) lanes.push(defaultLane);
    }
    return lanes;
  }
  getCurrentLaneName() {
    var _this$getCurrentLaneI;
    return ((_this$getCurrentLaneI = this.getCurrentLaneId()) === null || _this$getCurrentLaneI === void 0 ? void 0 : _this$getCurrentLaneI.name) || null;
  }
  getCurrentLaneNameOrAlias() {
    const currentLaneId = this.getCurrentLaneId();
    if (!currentLaneId) return null;
    const trackingData = this.scope.legacyScope.lanes.getLocalTrackedLaneByRemoteName(currentLaneId.name, currentLaneId.scope);
    return trackingData || currentLaneId.name;
  }
  getCurrentLaneId() {
    if (!this.workspace) return null;
    return this.workspace.consumer.getCurrentLaneId();
  }
  getDefaultLaneId() {
    return _laneId().LaneId.from(_laneId().DEFAULT_LANE, this.scope.name);
  }
  setCurrentLane(laneId, alias, exported) {
    var _this$workspace2;
    (_this$workspace2 = this.workspace) === null || _this$workspace2 === void 0 ? void 0 : _this$workspace2.consumer.setCurrentLane(laneId, exported);
  }
  async createLane(name, {
    remoteScope,
    alias
  } = {}) {
    if (!this.workspace) {
      throw new (_bitError().BitError)(`unable to create a lane outside of Bit workspace`);
    }
    if (alias) {
      (0, _createLane().throwForInvalidLaneName)(alias);
    }
    const scope = remoteScope || this.workspace.defaultScope;
    await (0, _createLane().createLane)(this.workspace.consumer, name, scope);
    const laneId = _laneId().LaneId.from(name, scope);
    this.setCurrentLane(laneId, alias, false);
    const trackLaneData = {
      localLane: alias || name,
      remoteLane: name,
      remoteScope: scope
    };
    this.scope.legacyScope.lanes.trackLane(trackLaneData);
    this.scope.legacyScope.scopeJson.setLaneAsNew(name);
    await this.workspace.consumer.onDestroy();
    return trackLaneData;
  }
  async trackLane(localName, remoteScope, remoteName) {
    if (!this.workspace) {
      throw new (_bitError().BitError)(`unable to track a lane outside of Bit workspace`);
    }
    const laneId = await this.scope.legacyScope.lanes.parseLaneIdFromString(localName);
    const lane = await this.scope.legacyScope.lanes.loadLane(laneId);
    if (!lane) {
      throw new (_bitError().BitError)(`unable to find a local lane "${localName}"`);
    }
    const beforeTrackData = this.scope.legacyScope.lanes.getRemoteTrackedDataByLocalLane(localName);
    const beforeTrackDataCloned = beforeTrackData ? _objectSpread({}, beforeTrackData) : undefined;
    const afterTrackData = {
      localLane: localName,
      remoteLane: remoteName || (beforeTrackData === null || beforeTrackData === void 0 ? void 0 : beforeTrackData.remoteLane) || localName,
      remoteScope
    };
    this.scope.legacyScope.lanes.trackLane(afterTrackData);
    await this.workspace.consumer.onDestroy();
    return {
      beforeTrackData: beforeTrackDataCloned,
      afterTrackData
    };
  }
  async aliasLane(laneName, alias) {
    if (!this.workspace) {
      throw new (_bitError().BitError)(`unable to alias a lane outside of Bit workspace`);
    }
    if (alias.includes(_laneId().LANE_REMOTE_DELIMITER)) {
      throw new (_bitError().BitError)(`an alias cannot include a delimiter "${_laneId().LANE_REMOTE_DELIMITER}"`);
    }
    if (alias === laneName) {
      throw new (_bitError().BitError)(`an alias cannot be the same as the lane name`);
    }
    const laneId = await this.scope.legacyScope.lanes.parseLaneIdFromString(laneName);
    const lane = await this.scope.legacyScope.lanes.loadLane(laneId);
    if (!lane) {
      throw new (_bitError().BitError)(`unable to find a local lane "${laneName}"`);
    }
    const trackData = {
      localLane: alias,
      remoteLane: laneId.name,
      remoteScope: laneId.scope
    };
    const laneNameWithoutScope = laneName.includes(_laneId().LANE_REMOTE_DELIMITER) ? laneName.split(_laneId().LANE_REMOTE_DELIMITER)[1] : laneName;
    this.scope.legacyScope.lanes.removeTrackLane(laneNameWithoutScope);
    this.scope.legacyScope.lanes.trackLane(trackData);
    await this.workspace.consumer.onDestroy();
    return {
      laneId
    };
  }
  async changeScope(laneName, remoteScope) {
    if (!this.workspace) {
      throw new (_bitError().BitError)(`unable to change-scope of a lane outside of Bit workspace`);
    }
    const laneNameWithoutScope = laneName.includes(_laneId().LANE_REMOTE_DELIMITER) ? laneName.split(_laneId().LANE_REMOTE_DELIMITER)[1] : laneName;
    const laneId = await this.scope.legacyScope.lanes.parseLaneIdFromString(laneName);
    const lane = await this.scope.legacyScope.lanes.loadLane(laneId);
    if (!lane) {
      throw new (_bitError().BitError)(`unable to find a local lane "${laneName}"`);
    }
    const remoteScopeBefore = lane.scope;
    lane.scope = remoteScope;
    const newLaneId = _laneId().LaneId.from(laneId.name, remoteScope);
    const trackData = {
      localLane: laneNameWithoutScope,
      remoteLane: laneId.name,
      remoteScope
    };
    this.scope.legacyScope.lanes.trackLane(trackData);
    await this.scope.legacyScope.lanes.saveLane(lane);
    this.workspace.consumer.bitMap.setCurrentLane(newLaneId, false);
    await this.workspace.consumer.onDestroy();
    return {
      remoteScopeBefore
    };
  }

  /**
   * change a lane-name and if possible, export the lane to the remote
   */
  async rename(currentName, newName) {
    if (!this.workspace) {
      throw new (_bitError().BitError)(`unable to rename a lane outside of Bit workspace`);
    }
    (0, _createLane().throwForInvalidLaneName)(newName);
    const existingAliasWithNewName = this.scope.legacyScope.lanes.getRemoteTrackedDataByLocalLane(newName);
    if (existingAliasWithNewName) {
      const remoteIdStr = `${existingAliasWithNewName.remoteLane}/${existingAliasWithNewName.remoteScope}`;
      throw new (_bitError().BitError)(`unable to rename to ${newName}. this name is already used to track: ${remoteIdStr}`);
    }
    const laneNameWithoutScope = currentName.includes(_laneId().LANE_REMOTE_DELIMITER) ? currentName.split(_laneId().LANE_REMOTE_DELIMITER)[1] : currentName;
    const laneId = await this.scope.legacyScope.lanes.parseLaneIdFromString(currentName);
    const lane = await this.scope.legacyScope.lanes.loadLane(laneId);
    if (!lane) {
      throw new (_bitError().BitError)(`unable to find a local lane "${currentName}"`);
    }

    // rename the ref file
    await this.scope.legacyScope.objects.remoteLanes.renameRefByNewLaneName(laneNameWithoutScope, newName, lane.scope);

    // change tracking data
    const afterTrackData = {
      localLane: newName,
      remoteLane: newName,
      remoteScope: lane.scope
    };
    this.scope.legacyScope.lanes.trackLane(afterTrackData);
    this.scope.legacyScope.lanes.removeTrackLane(laneNameWithoutScope);

    // change the lane object
    lane.name = newName;
    await this.scope.legacyScope.lanes.saveLane(lane);

    // change current-lane if needed
    const currentLaneName = this.getCurrentLaneName();
    if (currentLaneName === laneNameWithoutScope) {
      const newLaneId = _laneId().LaneId.from(newName, lane.scope);
      const isExported = this.workspace.consumer.bitMap.isLaneExported;
      this.setCurrentLane(newLaneId, undefined, isExported);
    }

    // export the lane with only the name-change
    const clonedLaneToExport = lane.clone();
    clonedLaneToExport.components = []; // otherwise, it'll export the changes done on the components.
    let exported = false;
    let exportErr;
    try {
      await this.exportLane(clonedLaneToExport);
      exported = true;
    } catch (err) {
      this.logger.error(`unable to export ${lane.id.toString()}: ${err.message}`);
      exportErr = err;
    }
    await this.workspace.consumer.onDestroy();
    return {
      exported,
      exportErr
    };
  }
  async exportLane(lane) {
    await this.exporter.exportMany({
      scope: this.scope.legacyScope,
      laneObject: lane,
      ids: new (_bitId().BitIds)(),
      idsWithFutureScope: new (_bitId().BitIds)(),
      allVersions: false
    });
  }

  /**
   * get a Lane object from the remote.
   * `persistIfNotExists` saves the object in the local scope only if the lane is not there yet.
   * otherwise, it needs some merging mechanism, which is done differently whether it's export or import.
   * see `sources.mergeLane()` for export and `import-components._saveLaneDataIfNeeded()` for import.
   * in this case, because we only bring the lane object and not the components, it's not easy to do the merge.
   */
  async importLaneObject(laneId, persistIfNotExists = true) {
    const legacyScope = this.scope.legacyScope;
    const scopeComponentImporter = _scopeComponentsImporter().default.getInstance(legacyScope);
    const results = await scopeComponentImporter.importLanes([laneId]);
    const laneObject = results[0];
    if (!laneObject) throw new (_laneNotFound().LaneNotFound)(laneId.scope, laneId.name);
    if (persistIfNotExists) {
      const exists = await legacyScope.loadLane(laneId);
      if (!exists) {
        await legacyScope.lanes.saveLane(laneObject);
      }
    }
    return laneObject;
  }

  /**
   * fetch the lane object and its components from the remote.
   * save the objects to the local scope.
   * this method doesn't change anything in the workspace.
   */
  async fetchLaneWithItsComponents(laneId) {
    this.logger.debug(`fetching lane ${laneId.toString()}`);
    if (!this.workspace) {
      throw new (_bitError().BitError)('unable to fetch lanes outside of Bit workspace');
    }
    const lane = await this.importLaneObject(laneId);
    if (!lane) throw new Error(`unable to import lane ${laneId.toString()} from the remote`);
    const importOptions = {
      ids: [],
      objectsOnly: true,
      verbose: false,
      writeConfig: false,
      override: false,
      installNpmPackages: false,
      lanes: {
        laneIds: [laneId],
        lanes: [lane]
      }
    };
    const {
      importedIds
    } = await this.importer.importWithOptions(importOptions);
    this.logger.debug(`fetching lane ${laneId.toString()} done, fetched ${importedIds.length} components`);
    return lane;
  }
  async removeLanes(laneNames, {
    remote,
    force
  }) {
    var _this$workspace3;
    const results = await (0, _removeLanes().default)((_this$workspace3 = this.workspace) === null || _this$workspace3 === void 0 ? void 0 : _this$workspace3.consumer, laneNames, remote, force);
    if (this.workspace) await this.workspace.consumer.onDestroy();
    return results.laneResults;
  }

  /**
   * switch to a different local or remote lane.
   * switching to a remote lane also imports and writes the components of that remote lane.
   * by default, only the components existing on the workspace will be imported from that lane, unless the "getAll"
   * flag is true.
   */
  async switchLanes(laneName, {
    alias,
    merge,
    getAll = false,
    skipDependencyInstallation = false
  }) {
    if (!this.workspace) {
      throw new (_bitError().BitError)(`unable to switch lanes outside of Bit workspace`);
    }
    let mergeStrategy;
    if (merge && typeof merge === 'string') {
      const mergeOptions = Object.keys(_mergeVersion().MergeOptions);
      if (!mergeOptions.includes(merge)) {
        throw new (_bitError().BitError)(`merge must be one of the following: ${mergeOptions.join(', ')}`);
      }
      mergeStrategy = merge;
    }
    if (alias) {
      (0, _createLane().throwForInvalidLaneName)(alias);
    }
    const switchProps = {
      laneName,
      existingOnWorkspaceOnly: !getAll,
      alias
    };
    const checkoutProps = {
      mergeStrategy,
      skipNpmInstall: skipDependencyInstallation,
      verbose: false,
      // not relevant in Harmony
      ignorePackageJson: true,
      // not relevant in Harmony
      ignoreDist: true,
      // not relevant in Harmony
      isLane: true,
      promptMergeOptions: false,
      writeConfig: false,
      reset: false,
      all: false
    };
    return new (_switchLanes().LaneSwitcher)(this.workspace, this.logger, switchProps, checkoutProps, this).switch();
  }

  /**
   * the values array may include zero to two values and will be processed as following:
   * [] => diff between the current lane and default lane. (only inside workspace).
   * [to] => diff between the current lane (or default-lane when in scope) and "to" lane.
   * [from, to] => diff between "from" lane and "to" lane.
   */
  async getDiff(values, diffOptions = {}, pattern) {
    const laneDiffGenerator = new (_lanesModules().LaneDiffGenerator)(this.workspace, this.scope);
    return laneDiffGenerator.generate(values, diffOptions, pattern);
  }
  async getLaneComponentModels(lane) {
    if (!lane) return [];
    const laneComponents = lane.components;
    const host = this.componentAspect.getHost();
    const laneComponentIds = await Promise.all(laneComponents.map(laneComponent => {
      const legacyIdWithVersion = laneComponent.id.changeVersion(laneComponent.head);
      return host.resolveComponentId(legacyIdWithVersion);
    }));
    const components = await host.getMany(laneComponentIds);
    return components;
  }
  async getLaneReadmeComponent(lane) {
    if (!lane) return undefined;
    const laneReadmeComponent = lane.readmeComponent;
    if (!laneReadmeComponent) return undefined;
    const host = this.componentAspect.getHost();
    const laneReadmeComponentId = await host.resolveComponentId(laneReadmeComponent.id.changeVersion(laneReadmeComponent.head));
    const readmeComponent = await host.get(laneReadmeComponentId);
    return readmeComponent;
  }
  async removeLaneReadme(laneName) {
    if (!this.workspace) {
      throw new (_bitError().BitError)('unable to remove the lane readme component outside of Bit workspace');
    }
    const currentLaneName = this.getCurrentLaneName();
    if (!laneName && !currentLaneName) {
      return {
        result: false,
        message: 'unable to remove the lane readme component. Either pass a laneName or switch to a lane'
      };
    }
    const scope = this.workspace.scope.legacyScope;
    const laneId = laneName ? await scope.lanes.parseLaneIdFromString(laneName) : this.getCurrentLaneId();
    const lane = await scope.loadLane(laneId);
    if (!(lane !== null && lane !== void 0 && lane.readmeComponent)) {
      throw new (_bitError().BitError)(`there is no readme component added to the lane ${laneName || currentLaneName}`);
    }
    const readmeComponentId = await this.workspace.resolveComponentId(lane.readmeComponent.id);
    const existingLaneConfig = (await this.workspace.getSpecificComponentConfig(readmeComponentId, _lanes().LanesAspect.id)) || {};
    const remoteLaneIdStr = lane.toLaneId().toString();
    if (existingLaneConfig.readme) {
      delete existingLaneConfig.readme[remoteLaneIdStr];
      await this.workspace.removeSpecificComponentConfig(readmeComponentId, _lanes().LanesAspect.id, false);
      await this.workspace.addSpecificComponentConfig(readmeComponentId, _lanes().LanesAspect.id, existingLaneConfig);
    }
    lane.setReadmeComponent(undefined);
    await scope.lanes.saveLane(lane);
    await this.workspace.bitMap.write();
    return {
      result: true
    };
  }
  async addLaneReadme(readmeComponentIdStr, laneName) {
    if (!this.workspace) {
      throw new (_bitError().BitError)(`unable to track a lane readme component outside of Bit workspace`);
    }
    const readmeComponentId = await this.workspace.resolveComponentId(readmeComponentIdStr);
    const readmeComponentBitId = readmeComponentId._legacy;
    const scope = this.workspace.scope.legacyScope;
    const laneId = laneName ? await scope.lanes.parseLaneIdFromString(laneName) : this.getCurrentLaneId();
    const lane = await scope.loadLane(laneId);
    if (!lane) {
      return {
        result: false,
        message: `cannot find lane ${laneName}`
      };
    }
    lane.setReadmeComponent(readmeComponentBitId);
    await scope.lanes.saveLane(lane);
    const existingLaneConfig = (await this.workspace.getSpecificComponentConfig(readmeComponentId, _lanes().LanesAspect.id)) || {};
    const remoteLaneIdStr = lane.toLaneId().toString();
    if (existingLaneConfig.readme) {
      await this.workspace.addSpecificComponentConfig(readmeComponentId, _lanes().LanesAspect.id, _objectSpread(_objectSpread({}, existingLaneConfig), {}, {
        readme: _objectSpread(_objectSpread({}, existingLaneConfig.readme), {}, {
          [remoteLaneIdStr]: true
        })
      }));
    } else {
      await this.workspace.addSpecificComponentConfig(readmeComponentId, _lanes().LanesAspect.id, _objectSpread(_objectSpread({}, existingLaneConfig), {}, {
        readme: {
          [remoteLaneIdStr]: true
        }
      }));
    }
    await this.workspace.bitMap.write();
    return {
      result: true
    };
  }
  async getLaneDataOfDefaultLane() {
    var _this$workspace4;
    const consumer = (_this$workspace4 = this.workspace) === null || _this$workspace4 === void 0 ? void 0 : _this$workspace4.consumer;
    let bitIds = [];
    if (!consumer) {
      const scopeComponents = await this.scope.list();
      bitIds = scopeComponents.filter(component => component.head).map(component => component.id._legacy);
    } else {
      bitIds = await consumer.getIdsOfDefaultLane();
    }
    return {
      name: _laneId().DEFAULT_LANE,
      remote: null,
      id: this.getDefaultLaneId(),
      components: bitIds.map(bitId => ({
        id: bitId,
        head: bitId.version
      })),
      isMerged: null,
      hash: ''
    };
  }
  static async provider([cli, scope, workspace, graphql, community, merging, component, loggerMain, importer, exporter]) {
    const logger = loggerMain.createLogger(_lanes().LanesAspect.id);
    const lanesMain = new LanesMain(workspace, scope, merging, component, logger, importer, exporter);
    const switchCmd = new (_switch().SwitchCmd)(lanesMain);
    const laneCmd = new (_lane().LaneCmd)(lanesMain, workspace, scope, community.getDocsDomain());
    laneCmd.commands = [new (_lane().LaneListCmd)(lanesMain, workspace, scope), switchCmd, new (_lane().LaneShowCmd)(lanesMain, workspace, scope), new (_lane().LaneCreateCmd)(lanesMain), new (_lane().LaneRemoveCmd)(lanesMain), new (_lane().LaneChangeScopeCmd)(lanesMain), new (_lane().LaneAliasCmd)(lanesMain), new (_lane().LaneRenameCmd)(lanesMain), new (_lanesModules().LaneDiffCmd)(workspace, scope), new (_lane().LaneAddReadmeCmd)(lanesMain), new (_lane().LaneRemoveReadmeCmd)(lanesMain), new (_lane().LaneImportCmd)(switchCmd)];
    cli.register(laneCmd, switchCmd);
    graphql.register((0, _lanes2().lanesSchema)(lanesMain));
    return lanesMain;
  }
}
exports.LanesMain = LanesMain;
(0, _defineProperty2().default)(LanesMain, "slots", []);
(0, _defineProperty2().default)(LanesMain, "dependencies", [_cli().CLIAspect, _scope().ScopeAspect, _workspace().WorkspaceAspect, _graphql().GraphqlAspect, _community().CommunityAspect, _merging().MergingAspect, _component().default, _logger().LoggerAspect, _importer().ImporterAspect, _export().ExportAspect]);
(0, _defineProperty2().default)(LanesMain, "runtime", _cli().MainRuntime);
_lanes().LanesAspect.addRuntime(LanesMain);
var _default = LanesMain;
exports.default = _default;

//# sourceMappingURL=lanes.main.runtime.js.map