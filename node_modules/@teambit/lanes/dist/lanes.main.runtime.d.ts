import { CLIMain } from '@teambit/cli';
import { ScopeMain } from '@teambit/scope';
import { GraphqlMain } from '@teambit/graphql';
import { Workspace } from '@teambit/workspace';
import { LaneDiffResults } from '@teambit/lanes.modules.diff';
import { LaneData } from '@teambit/legacy/dist/scope/lanes/lanes';
import { LaneId } from '@teambit/lane-id';
import { Logger, LoggerMain } from '@teambit/logger';
import { DiffOptions } from '@teambit/legacy/dist/consumer/component-ops/components-diff';
import { MergeStrategy } from '@teambit/legacy/dist/consumer/versions-ops/merge-version';
import { TrackLane } from '@teambit/legacy/dist/scope/scope-json';
import { ImporterMain } from '@teambit/importer';
import type { CommunityMain } from '@teambit/community';
import { Component, ComponentMain } from '@teambit/component';
import { Lane } from '@teambit/legacy/dist/scope/models';
import { ExportMain } from '@teambit/export';
import { MergingMain } from '@teambit/merging';
export { Lane };
export declare type LaneResults = {
    lanes: LaneData[];
    currentLane?: string | null;
};
export declare type CreateLaneOptions = {
    remoteScope?: string;
    alias?: string;
};
export declare type SwitchLaneOptions = {
    alias?: string;
    merge?: MergeStrategy;
    getAll?: boolean;
    skipDependencyInstallation?: boolean;
    verbose?: boolean;
    override?: boolean;
};
export declare class LanesMain {
    private workspace;
    private scope;
    private merging;
    private componentAspect;
    logger: Logger;
    private importer;
    private exporter;
    constructor(workspace: Workspace | undefined, scope: ScopeMain, merging: MergingMain, componentAspect: ComponentMain, logger: Logger, importer: ImporterMain, exporter: ExportMain);
    getLanes({ name, remote, merged, showDefaultLane, notMerged, }: {
        name?: string;
        remote?: string;
        merged?: boolean;
        showDefaultLane?: boolean;
        notMerged?: boolean;
    }): Promise<LaneData[]>;
    getCurrentLaneName(): string | null;
    getCurrentLaneNameOrAlias(): string | null;
    getCurrentLaneId(): LaneId | null;
    getDefaultLaneId(): LaneId;
    setCurrentLane(laneId: LaneId, alias?: string, exported?: boolean): void;
    createLane(name: string, { remoteScope, alias }?: CreateLaneOptions): Promise<TrackLane>;
    trackLane(localName: string, remoteScope: string, remoteName?: string): Promise<{
        beforeTrackData?: TrackLane;
        afterTrackData: TrackLane;
    }>;
    aliasLane(laneName: string, alias: string): Promise<{
        laneId: LaneId;
    }>;
    changeScope(laneName: string, remoteScope: string): Promise<{
        remoteScopeBefore: string;
    }>;
    /**
     * change a lane-name and if possible, export the lane to the remote
     */
    rename(currentName: string, newName: string): Promise<{
        exported: boolean;
        exportErr?: Error;
    }>;
    exportLane(lane: Lane): Promise<void>;
    /**
     * get a Lane object from the remote.
     * `persistIfNotExists` saves the object in the local scope only if the lane is not there yet.
     * otherwise, it needs some merging mechanism, which is done differently whether it's export or import.
     * see `sources.mergeLane()` for export and `import-components._saveLaneDataIfNeeded()` for import.
     * in this case, because we only bring the lane object and not the components, it's not easy to do the merge.
     */
    importLaneObject(laneId: LaneId, persistIfNotExists?: boolean): Promise<Lane>;
    /**
     * fetch the lane object and its components from the remote.
     * save the objects to the local scope.
     * this method doesn't change anything in the workspace.
     */
    fetchLaneWithItsComponents(laneId: LaneId): Promise<Lane>;
    removeLanes(laneNames: string[], { remote, force }: {
        remote: boolean;
        force: boolean;
    }): Promise<string[]>;
    /**
     * switch to a different local or remote lane.
     * switching to a remote lane also imports and writes the components of that remote lane.
     * by default, only the components existing on the workspace will be imported from that lane, unless the "getAll"
     * flag is true.
     */
    switchLanes(laneName: string, { alias, merge, getAll, skipDependencyInstallation }: SwitchLaneOptions): Promise<import("@teambit/legacy/dist/consumer/versions-ops/merge-version").ApplyVersionResults>;
    /**
     * the values array may include zero to two values and will be processed as following:
     * [] => diff between the current lane and default lane. (only inside workspace).
     * [to] => diff between the current lane (or default-lane when in scope) and "to" lane.
     * [from, to] => diff between "from" lane and "to" lane.
     */
    getDiff(values: string[], diffOptions?: DiffOptions, pattern?: string): Promise<LaneDiffResults>;
    getLaneComponentModels(lane: LaneData): Promise<Component[]>;
    getLaneReadmeComponent(lane: LaneData): Promise<Component | undefined>;
    removeLaneReadme(laneName?: string): Promise<{
        result: boolean;
        message?: string;
    }>;
    addLaneReadme(readmeComponentIdStr: string, laneName?: string): Promise<{
        result: boolean;
        message?: string;
    }>;
    private getLaneDataOfDefaultLane;
    static slots: never[];
    static dependencies: import("@teambit/harmony").Aspect[];
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static provider([cli, scope, workspace, graphql, community, merging, component, loggerMain, importer, exporter,]: [
        CLIMain,
        ScopeMain,
        Workspace,
        GraphqlMain,
        CommunityMain,
        MergingMain,
        ComponentMain,
        LoggerMain,
        ImporterMain,
        ExportMain
    ]): Promise<LanesMain>;
}
export default LanesMain;
