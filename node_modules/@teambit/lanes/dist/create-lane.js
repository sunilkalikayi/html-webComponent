"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLane = createLane;
exports.throwForInvalidLaneName = throwForInvalidLaneName;
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _lane() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/scope/models/lane"));
  _lane = function () {
    return data;
  };
  return data;
}
// import { BitIds } from '@teambit/legacy/dist/bit-id';

async function createLane(consumer, laneName, scopeName, remoteLane) {
  const lanes = await consumer.scope.listLanes();
  if (lanes.find(lane => lane.name === laneName)) {
    throw new (_bitError().BitError)(`lane "${laneName}" already exists, to switch to this lane, please use "bit switch" command`);
  }
  throwForInvalidLaneName(laneName);
  const getDataToPopulateLaneObjectIfNeeded = async () => {
    if (remoteLane) return remoteLane.components;
    // when branching from one lane to another, copy components from the origin lane
    // when branching from main, no need to copy anything
    const currentLaneObject = await consumer.getCurrentLaneObject();
    return currentLaneObject ? currentLaneObject.components : [];
  };
  const forkedFrom = await getLaneOrigin(consumer);
  const newLane = remoteLane ? _lane().default.from({
    name: laneName,
    hash: remoteLane.hash().toString(),
    log: remoteLane.log,
    scope: remoteLane.scope,
    forkedFrom
  }) : _lane().default.create(laneName, scopeName, forkedFrom);
  const dataToPopulate = await getDataToPopulateLaneObjectIfNeeded();
  newLane.setLaneComponents(dataToPopulate);
  await consumer.scope.lanes.saveLane(newLane);
  return newLane;
}
async function getLaneOrigin(consumer) {
  const currentLaneId = consumer.bitMap.laneId;
  if (!currentLaneId) return undefined;
  if (consumer.bitMap.isLaneExported) {
    return currentLaneId;
  }
  // current lane is new.
  const currentLane = await consumer.getCurrentLaneObject();
  return currentLane === null || currentLane === void 0 ? void 0 : currentLane.forkedFrom;
}
function throwForInvalidLaneName(laneName) {
  if (!isValidLaneName(laneName)) {
    throw new (_bitError().BitError)(`lane "${laneName}" has invalid characters. lane name can only contain alphanumeric, lowercase characters, and the following ["-", "_", "$", "!"]`);
  }
}
function isValidLaneName(val) {
  if (typeof val !== 'string') return false;
  // @todo: should we allow slash? if so, we should probably replace the lane-delimiter with something else. (maybe ":")
  return /^[$\-_!a-z0-9]+$/.test(val);
}

//# sourceMappingURL=create-lane.js.map