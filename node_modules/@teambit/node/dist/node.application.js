"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NodeApp = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _child_process() {
  const data = require("child_process");
  _child_process = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _toolboxNetwork() {
  const data = require("@teambit/toolbox.network.get-port");
  _toolboxNetwork = function () {
    return data;
  };
  return data;
}
class NodeApp {
  constructor(name, entry, portRange, nodeEnv, logger, deploy) {
    this.name = name;
    this.entry = entry;
    this.portRange = portRange;
    this.nodeEnv = nodeEnv;
    this.logger = logger;
    this.deploy = deploy;
    (0, _defineProperty2().default)(this, "applicationType", 'node');
  }
  async run() {
    var _child$stdout;
    const logger = this.logger;
    const [from, to] = this.portRange;
    const port = await _toolboxNetwork().Port.getPort(from, to);
    const child = (0, _child_process().execFile)('node', [this.entry, port.toString()], error => {
      if (error) {
        // @todo: this is causing uncaughtException in the main process. a better way to handle this would be to use promise.
        // however, since it expects to return a number, it would require a bigger refactor.
        throw error;
      }
    });
    (_child$stdout = child.stdout) === null || _child$stdout === void 0 ? void 0 : _child$stdout.on('data', function (data) {
      logger.console(data.toString());
    });
    return port;
  }
  async build(context) {
    const {
      base
    } = (0, _path().parse)(this.entry);
    const {
      distDir
    } = this.nodeEnv.getCompiler();
    const mainFile = (0, _path().join)(distDir, base);
    const _context = Object.assign(context, {
      mainFile
    });
    return _context;
  }
}
exports.NodeApp = NodeApp;

//# sourceMappingURL=node.application.js.map