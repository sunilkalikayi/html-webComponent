"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PrettierFormatter = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _prettier() {
  const data = _interopRequireDefault(require("prettier"));
  _prettier = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
// import { PrettierOptions } from './prettier.main.runtime';

class PrettierFormatter {
  constructor(logger, options,
  /**
   * reference to the prettier module.
   */
  prettierModule = _prettier().default) {
    this.logger = logger;
    this.options = options;
    this.prettierModule = prettierModule;
    (0, _defineProperty2().default)(this, "displayName", 'Prettier');
  }
  displayConfig() {
    return JSON.stringify(this.options, null, 2);
  }
  async format(context) {
    return this.run(context);
  }
  async check(context) {
    return this.run(context);
  }
  async run(context) {
    const check = !!context.check;
    const longProcessLogger = this.logger.createLongProcessLogger('formatting components', context.components.length);
    const resultsP = (0, _pMapSeries().default)(context.components, async component => {
      longProcessLogger.logProgress(component.id.toString());
      const mergedOpts = this.getOptions(this.options, context);
      const filesP = component.filesystem.files.map(async file => {
        const sourceCode = file.contents.toString('utf8');
        const optsWithFilePath = this.addFilePathToOpts(mergedOpts, file);
        const checkFormatResults = await this.prettierModule.check(sourceCode, optsWithFilePath);
        const formatResults = await this.prettierModule.format(sourceCode, optsWithFilePath);
        const hasIssues = !checkFormatResults;
        const newContent = typeof formatResults === 'string' && hasIssues ? formatResults : undefined;
        if (!check && newContent) {
          file.contents = Buffer.from(newContent);
          await file.write(undefined, true);
        }
        return {
          filePath: file.relative,
          hasIssues,
          newContent
        };
      });
      const files = await Promise.all(filesP);
      return {
        component,
        results: files
      };
    });
    const results = await resultsP;
    return {
      results,
      errors: []
    };
  }

  /**
   * get options for eslint.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getOptions(options, context) {
    return options;
  }
  addFilePathToOpts(options, file) {
    return Object.assign({}, options, {
      filepath: file.path
    });
  }
  version() {
    return this.prettierModule.version;
  }
}
exports.PrettierFormatter = PrettierFormatter;

//# sourceMappingURL=prettier.formatter.js.map