"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFormat = getFormat;
exports.getWinstonLogger = getWinstonLogger;
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _winston() {
  const data = _interopRequireDefault(require("winston"));
  _winston = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../constants");
  _constants = function () {
    return data;
  };
  return data;
}
// Store the extensionsLoggers to prevent create more than one logger for the same extension
// in case the extension developer use api.logger more than once
const extensionsLoggers = new Map();
function getWinstonLogger(logLevel, jsonFormat) {
  const baseFileTransportOpts = {
    filename: _constants().DEBUG_LOG,
    format: jsonFormat ? _winston().default.format.combine(_winston().default.format.timestamp(), _winston().default.format.json()) : getFormat(),
    level: logLevel,
    maxsize: 10 * 1024 * 1024,
    // 10MB
    maxFiles: 10,
    // If true, log files will be rolled based on maxsize and maxfiles, but in ascending order.
    // The filename will always have the most recent log lines. The larger the appended number, the older the log file
    tailable: true
  };
  const winstonLogger = _winston().default.createLogger({
    transports: [new (_winston().default.transports.File)(baseFileTransportOpts)],
    exitOnError: false
  });

  /**
   * Create a logger instance for extension
   * The extension name will be added as label so it will appear in the begining of each log line
   * The logger is cached for each extension so there is no problem to use getLogger few times for the same extension
   * @param {string} extensionName
   */
  const createExtensionLogger = extensionName => {
    // Getting logger from cache
    const existingLogger = extensionsLoggers.get(extensionName);
    if (existingLogger) {
      return existingLogger;
    }
    const extensionFileTransportOpts = Object.assign({}, baseFileTransportOpts, {
      filename: _path().default.join(_constants().GLOBAL_LOGS, 'extensions.log'),
      label: extensionName
    });
    const extLogger = _winston().default.createLogger({
      transports: [new (_winston().default.transports.File)(extensionFileTransportOpts)],
      exceptionHandlers: [new (_winston().default.transports.File)(extensionFileTransportOpts)],
      exitOnError: false
    });
    extensionsLoggers.set(extensionName, extLogger);
    return extLogger;
  };
  return {
    winstonLogger,
    createExtensionLogger
  };
}
function getMetadata(info) {
  if (!Object.keys(info.metadata).length) return '';
  if ((info.level === 'error' || info.level === '\u001b[31merror\u001b[39m') && info.metadata.stack) {
    // this is probably an instance of Error, show the stack nicely and not serialized.
    return `\n${info.metadata.stack}`;
  }
  try {
    return JSON.stringify(info.metadata, null, 2);
  } catch (err) {
    return `logger error: logging failed to stringify the metadata Json. (error: ${err.message})`;
  }
}
function getFormat() {
  return _winston().default.format.combine(_winston().default.format.metadata(), _winston().default.format.colorize(), _winston().default.format.timestamp(), _winston().default.format.splat(),
  // does nothing?
  _winston().default.format.errors({
    stack: true
  }), _winston().default.format.prettyPrint({
    depth: 3,
    colorize: true
  }),
  // does nothing?
  _winston().default.format.printf(info => `${info.timestamp} ${info.level}: ${info.message} ${getMetadata(info)}`));
}