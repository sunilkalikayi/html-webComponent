"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "LoggerLevel", {
  enumerable: true,
  get: function () {
    return _pino().Level;
  }
});
exports.printWarning = exports.default = exports.createExtensionLogger = void 0;
exports.writeLogToScreen = writeLogToScreen;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _serializeError() {
  const data = require("serialize-error");
  _serializeError = function () {
    return data;
  };
  return data;
}
function _stringFormat() {
  const data = _interopRequireDefault(require("string-format"));
  _stringFormat = function () {
    return data;
  };
  return data;
}
function _pino() {
  const data = require("pino");
  _pino = function () {
    return data;
  };
  return data;
}
function _yn() {
  const data = _interopRequireDefault(require("yn"));
  _yn = function () {
    return data;
  };
  return data;
}
function _analytics() {
  const data = require("../analytics/analytics");
  _analytics = function () {
    return data;
  };
  return data;
}
function _globalConfig() {
  const data = require("../api/consumer/lib/global-config");
  _globalConfig = function () {
    return data;
  };
  return data;
}
function _defaultErrorHandler() {
  const data = _interopRequireDefault(require("../cli/default-error-handler"));
  _defaultErrorHandler = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _winstonLogger() {
  const data = require("./winston-logger");
  _winstonLogger = function () {
    return data;
  };
  return data;
}
function _pinoLogger() {
  const data = require("./pino-logger");
  _pinoLogger = function () {
    return data;
  };
  return data;
}
function _profiler() {
  const data = require("./profiler");
  _profiler = function () {
    return data;
  };
  return data;
}
/**
 * leave the Winston for now to get the file-rotation we're missing from Pino and the "profile"
 * functionality.
 * also, Winston should start BEFORE Pino. otherwise, Pino starts creating the debug.log file first
 * and it throws an error if the file doesn't exists on Docker/CI.
 */

const jsonFormat = (0, _yn().default)((0, _globalConfig().getSync)(_constants().CFG_LOG_JSON_FORMAT), {
  default: false
}) || (0, _yn().default)(process.env.JSON_LOGS, {
  default: false
});
const LEVELS = ['fatal', 'error', 'warn', 'info', 'debug', 'trace'];
const logLevel = getLogLevel();

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const {
  winstonLogger,
  createExtensionLogger
} = (0, _winstonLogger().getWinstonLogger)(logLevel, jsonFormat);
exports.createExtensionLogger = createExtensionLogger;
const {
  pinoLogger,
  pinoLoggerConsole
} = (0, _pinoLogger().getPinoLogger)(logLevel, jsonFormat);
/**
 * the method signatures of debug/info/error/etc are similar to Winston.logger.
 * the way how it is formatted in the log file is according to the `customPrint` function above.
 *
 * Note about logging Error objects (with stacktrace).
 * when throwing an error in the code, it shows it formatted nicely in the log. and also in the console when
 * BIT_LOG is used.
 * when using logger.error(error), it shows undefined, because it expects a message as the first parameter.
 * when using logger.error(message, error), it shows the error serialized and unclear.
 * normally, no need to call logger.error(). once an error is thrown, it is already logged.
 */
class BitLogger {
  // 'bit cli' is a daemon as it should never exit the process, unless the user kills it
  /**
   * being set on command-registrar, once the flags are parsed. here, it's a workaround to have
   * it set before the command-registrar is loaded. at this stage we don't know for sure the "-j"
   * is actually "json". that's why this variable is overridden once the command-registrar is up.
   */

  constructor(logger) {
    (0, _defineProperty2().default)(this, "logger", void 0);
    (0, _defineProperty2().default)(this, "profiler", void 0);
    (0, _defineProperty2().default)(this, "isDaemon", false);
    (0, _defineProperty2().default)(this, "shouldWriteToConsole", !process.argv.includes('--json') && !process.argv.includes('-j'));
    this.logger = logger;
    this.profiler = new (_profiler().Profiler)();
  }

  /**
   * @deprecated use trace instead
   */
  silly(message, ...meta) {
    this.logger.trace(message, ...meta);
  }
  trace(message, ...meta) {
    this.logger.trace(message, ...meta);
  }
  debug(message, ...meta) {
    this.logger.debug(message, ...meta);
  }
  warn(message, ...meta) {
    this.logger.warn(message, ...meta);
  }
  info(message, ...meta) {
    this.logger.info(message, ...meta);
  }
  error(message, ...meta) {
    this.logger.error(message, ...meta);
  }
  fatal(message, ...meta) {
    this.logger.fatal(message, ...meta);
  }
  get isJsonFormat() {
    return jsonFormat;
  }

  /**
   * use this instead of calling `console.log()`, this way it won't break commands that don't
   * expect output during the execution.
   */
  console(msg, level = 'info', color) {
    if (!msg) {
      return;
    }
    let messageStr;
    if (msg instanceof Error) {
      const {
        message
      } = (0, _defaultErrorHandler().default)(msg);
      messageStr = message;
    } else {
      messageStr = msg;
    }
    if (!this.shouldWriteToConsole) {
      this[level](messageStr);
      return;
    }
    if (color) {
      try {
        messageStr = _chalk().default.keyword(color)(messageStr);
      } catch (e) {
        this.trace('a wrong color provided to logger.console method');
      }
    }
    pinoLoggerConsole[level](messageStr);
  }

  /**
   * useful to get an idea how long it takes from one point in the code to another point.
   * to use it, choose an id and call `logger.profile(your-id)` before and after the code you want
   * to measure. e.g.
   * ```
   * logger.profile('loadingComponent');
   * consumer.loadComponent(id);
   * logger.profile('loadingComponent');
   * ```
   * once done, the log writes the time it took to execute the code between the two calls.
   * if this is a repeated code it also shows how long this code was executed in total.
   * an example of the output:
   * [2020-12-04 16:24:46.100 -0500] INFO	 (31641): loadingComponent: 14ms. (total repeating 14ms)
   * [2020-12-04 16:24:46.110 -0500] INFO	 (31641): loadingComponent: 18ms. (total repeating 32ms)
   */
  profile(id, console) {
    const msg = this.profiler.profile(id);
    if (!msg) return;
    const fullMsg = `${id}: ${msg}`;
    console ? this.console(fullMsg) : this.info(fullMsg);
  }
  async exitAfterFlush(code = 0, commandName, cliOutput = '') {
    await _analytics().Analytics.sendData();
    const isSuccess = code === 0;
    const level = isSuccess ? 'info' : 'error';
    if (cliOutput) {
      this.logger.info(`[+] CLI-OUTPUT: ${cliOutput}`);
    }
    const msg = isSuccess ? `[*] the command "${commandName}" has been completed successfully` : `[*] the command "${commandName}" has been terminated with an error code ${code}`;
    // this should have been helpful to not miss any log message when using `sync: false` in the
    // Pino opts, but sadly, it doesn't help.
    // const finalLogger = pino.final(pinoLogger);
    // finalLogger[level](msg);
    this.logger[level](msg);
    if (!this.isDaemon) process.exit(code);
  }
  debugAndAddBreadCrumb(category, message, data, extraData) {
    this.addToLoggerAndToBreadCrumb('debug', category, message, data, extraData);
  }
  warnAndAddBreadCrumb(category, message, data, extraData) {
    this.addToLoggerAndToBreadCrumb('warn', category, message, data, extraData);
  }
  errorAndAddBreadCrumb(category, message, data, extraData) {
    this.addToLoggerAndToBreadCrumb('error', category, message, data, extraData);
  }
  addToLoggerAndToBreadCrumb(level, category, message, data, extraData) {
    if (!category) throw new TypeError('addToLoggerAndToBreadCrumb, category is missing');
    if (!message) throw new TypeError('addToLoggerAndToBreadCrumb, message is missing');
    const messageWithData = data ? (0, _stringFormat().default)(message, data) : message;
    this.logger[level](`${category}, ${messageWithData}`, extraData);
    addBreadCrumb(category, message, data, extraData);
  }
  switchToConsoleLogger(level) {
    this.logger = pinoLoggerConsole;
    this.logger.level = level || 'debug';
  }
}
const logger = new BitLogger(pinoLogger);
const printWarning = msg => {
  const cfgNoWarnings = (0, _globalConfig().getSync)(_constants().CFG_NO_WARNINGS);
  if (cfgNoWarnings !== 'true') {
    // eslint-disable-next-line no-console
    console.log(_chalk().default.yellow(`Warning: ${msg}`));
  }
};
exports.printWarning = printWarning;
function addBreadCrumb(category, message, data = {}, extraData) {
  const hashedData = {};
  Object.keys(data).forEach(key => hashedData[key] = _analytics().Analytics.hashData(data[key]));
  const messageWithHashedData = (0, _stringFormat().default)(message, hashedData);
  extraData = extraData instanceof Error ? (0, _serializeError().serializeError)(extraData) : extraData;
  _analytics().Analytics.addBreadCrumb(category, messageWithHashedData, extraData);
}
function determineWritingLogToScreen() {
  /**
   * prefix BIT_LOG to the command, provides the ability to log into the console.
   * two options are available here:
   * 1) use the level. e.g. `BIT_LOG=error bit import`.
   * 2) use the message prefix, e.g. `BIT_LOG=ssh bit import`.
   * 3) use multiple message prefixes, e.g. `BIT_LOG=ssh,env bit import`.
   */
  if (process.env.BIT_LOG) {
    writeLogToScreen(process.env.BIT_LOG);
    return;
  }

  // more common scenario is when the user enters `--log` flag. It can be just "--log", which defaults to info.
  // or it can have a level: `--log=error` or `--log error`: both syntaxes are supported
  if (process.argv.includes('--log')) {
    const level = process.argv.find(arg => LEVELS.includes(arg));
    logger.switchToConsoleLogger(level || 'info');
    return;
  }
  LEVELS.forEach(level => {
    if (process.argv.includes(`--log=${level}`)) {
      logger.switchToConsoleLogger(level);
    }
  });
}
determineWritingLogToScreen();
function getLogLevel() {
  const defaultLevel = 'debug';
  const level = (0, _globalConfig().getSync)(_constants().CFG_LOG_LEVEL) || defaultLevel;
  if (isLevel(level)) return level;
  const levelsStr = LEVELS.join(', ');
  // eslint-disable-next-line no-console
  console.error(`fatal: level "${level}" coming from ${_constants().CFG_LOG_LEVEL} configuration is invalid. permitted levels are: ${levelsStr}`);
  return defaultLevel;
}
function isLevel(maybeLevel) {
  return LEVELS.includes(maybeLevel);
}
function writeLogToScreen(levelOrPrefix = '') {
  if (isLevel(levelOrPrefix)) {
    logger.switchToConsoleLogger(levelOrPrefix);
  }
  // @todo: implement
  // const prefixes = levelOrPrefix.split(',');
  // const filterPrefix = winston.format((info) => {
  //   if (isLevel) return info;
  //   if (prefixes.some((prefix) => info.message.startsWith(prefix))) return info;
  //   return false;
  // });
  // logger.logger.add(
  //   new winston.transports.Console({
  //     level: isLevel ? levelOrPrefix : 'info',
  //     format: winston.format.combine(
  //       filterPrefix(),
  //       winston.format.metadata(),
  //       winston.format.errors({ stack: true }),
  //       winston.format.printf((info) => `${info.message} ${getMetadata(info)}`)
  //     ),
  //   })
  // );
}
var _default = logger;
exports.default = _default;