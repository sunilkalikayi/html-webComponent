import { Logger as PinoLogger, Level } from 'pino';
export { Level as LoggerLevel };
declare const createExtensionLogger: (extensionName: string) => any;
export interface IBitLogger {
    trace(message: string, ...meta: any[]): void;
    debug(message: string, ...meta: any[]): void;
    warn(message: string, ...meta: any[]): void;
    info(message: string, ...meta: any[]): void;
    error(message: string, ...meta: any[]): void;
    fatal(message: string, ...meta: any[]): void;
    console(msg: string): void;
}
/**
 * the method signatures of debug/info/error/etc are similar to Winston.logger.
 * the way how it is formatted in the log file is according to the `customPrint` function above.
 *
 * Note about logging Error objects (with stacktrace).
 * when throwing an error in the code, it shows it formatted nicely in the log. and also in the console when
 * BIT_LOG is used.
 * when using logger.error(error), it shows undefined, because it expects a message as the first parameter.
 * when using logger.error(message, error), it shows the error serialized and unclear.
 * normally, no need to call logger.error(). once an error is thrown, it is already logged.
 */
declare class BitLogger implements IBitLogger {
    logger: PinoLogger;
    private profiler;
    isDaemon: boolean;
    /**
     * being set on command-registrar, once the flags are parsed. here, it's a workaround to have
     * it set before the command-registrar is loaded. at this stage we don't know for sure the "-j"
     * is actually "json". that's why this variable is overridden once the command-registrar is up.
     */
    shouldWriteToConsole: boolean;
    constructor(logger: PinoLogger);
    /**
     * @deprecated use trace instead
     */
    silly(message: string, ...meta: any[]): void;
    trace(message: string, ...meta: any[]): void;
    debug(message: string, ...meta: any[]): void;
    warn(message: string, ...meta: any[]): void;
    info(message: string, ...meta: any[]): void;
    error(message: string, ...meta: any[]): void;
    fatal(message: string, ...meta: any[]): void;
    get isJsonFormat(): any;
    /**
     * use this instead of calling `console.log()`, this way it won't break commands that don't
     * expect output during the execution.
     */
    console(msg?: string | Error, level?: Level, color?: string): void;
    /**
     * useful to get an idea how long it takes from one point in the code to another point.
     * to use it, choose an id and call `logger.profile(your-id)` before and after the code you want
     * to measure. e.g.
     * ```
     * logger.profile('loadingComponent');
     * consumer.loadComponent(id);
     * logger.profile('loadingComponent');
     * ```
     * once done, the log writes the time it took to execute the code between the two calls.
     * if this is a repeated code it also shows how long this code was executed in total.
     * an example of the output:
     * [2020-12-04 16:24:46.100 -0500] INFO	 (31641): loadingComponent: 14ms. (total repeating 14ms)
     * [2020-12-04 16:24:46.110 -0500] INFO	 (31641): loadingComponent: 18ms. (total repeating 32ms)
     */
    profile(id: string, console?: boolean): void;
    exitAfterFlush(code: number | undefined, commandName: string, cliOutput?: string): Promise<void>;
    debugAndAddBreadCrumb(category: string, message: string, data?: Record<string, any>, extraData?: Record<string, any>): void;
    warnAndAddBreadCrumb(category: string, message: string, data?: Record<string, any>, extraData?: Record<string, any>): void;
    errorAndAddBreadCrumb(category: string, message: string, data?: Record<string, any>, extraData?: Record<string, any>): void;
    private addToLoggerAndToBreadCrumb;
    switchToConsoleLogger(level?: Level): void;
}
declare const logger: BitLogger;
export declare const printWarning: (msg: string) => void;
export declare function writeLogToScreen(levelOrPrefix?: string): void;
export { createExtensionLogger };
export default logger;
