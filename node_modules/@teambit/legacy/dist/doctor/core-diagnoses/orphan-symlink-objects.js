"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DIAGNOSIS_NAME = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _consumer() {
  const data = require("../../consumer");
  _consumer = function () {
    return data;
  };
  return data;
}
function _models() {
  const data = require("../../scope/models");
  _models = function () {
    return data;
  };
  return data;
}
function _diagnosis() {
  const data = _interopRequireDefault(require("../diagnosis"));
  _diagnosis = function () {
    return data;
  };
  return data;
}
const DIAGNOSIS_NAME = 'check orphan refs';
exports.DIAGNOSIS_NAME = DIAGNOSIS_NAME;
class OrphanSymlinkObjects extends _diagnosis().default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2().default)(this, "name", DIAGNOSIS_NAME);
    (0, _defineProperty2().default)(this, "description", 'checks for empty internal refs in local workspace');
    (0, _defineProperty2().default)(this, "category", 'internal store');
  }
  _formatSymptoms(bareResult) {
    if (!bareResult.data) throw new Error('OrphanSymlinkObjects, bareResult.data is missing');
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return `the following refs points to non-existing components "${bareResult.data.orphanSymlinks.toString()}"`;
  }
  _formatManualTreat(bareResult) {
    if (!bareResult.data) throw new Error('OrphanSymlinkObjects, bareResult.data is missing');
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return `please delete the following paths:\n${bareResult.data.objectsToDelete.join('\n')}`;
  }
  async _runExamine() {
    const consumer = await (0, _consumer().loadConsumer)();
    const symlinks = await consumer.scope.objects.list([_models().Symlink]);
    const orphanSymlinks = new (_bitId().BitIds)();
    const objectsToDelete = [];
    await Promise.all(symlinks.map(async symlink => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const realComponentId = symlink.getRealComponentId();
      const realModelComponent = _models().ModelComponent.fromBitId(realComponentId);
      const foundComponent = await consumer.scope.objects.load(realModelComponent.hash());
      if (!foundComponent) {
        orphanSymlinks.push(realComponentId);
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        objectsToDelete.push(consumer.scope.objects.objectPath(symlink.hash()));
      }
    }));
    return {
      valid: orphanSymlinks.length === 0,
      data: {
        orphanSymlinks,
        objectsToDelete
      }
    };
  }
}
exports.default = OrphanSymlinkObjects;