"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _clone2() {
  const data = _interopRequireDefault(require("ramda/src/clone"));
  _clone2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _util() {
  const data = require("util");
  _util = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function errors() {
  const data = _interopRequireWildcard(require("./exceptions"));
  errors = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/*
 * Setting up block level variable to store class state
 * set's to null by default.
 */
let instance = null;

/**
 * A class which manage all the hooks
 * This is a singelton class which expose getInstance method
 * This class used for register new hooks, actions for existing hooks and trigger hooks
 */
class HooksManager {
  constructor() {
    (0, _defineProperty2().default)(this, "hooks", new Map());
    if (!instance) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      instance = this;
    }

    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return instance;
  }

  /**
   * Initialize the default hooks
   */
  static init() {
    const self = new HooksManager();
    _constants().HOOKS_NAMES.forEach(hookName => self.hooks.set(hookName, []));
  }

  /**
   * Get the instance of the HooksManager
   * @return {HooksManager} instance of the HooksManager
   *
   */
  static getInstance() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return instance;
  }

  /**
   * register new hook name
   * @param {string} hookName
   * @param {boolean} throwIfExist - whether to throw an error if the hook name already exists
   * @return {boolean} whether the hook has been registerd
   */
  registerNewHook(hookName, context = {}, throwIfExist = false) {
    if (this.hooks.has(hookName)) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const contextMsg = context.extension ? `from ${context.extension}` : '';
      _logger().default.warn(`trying to register an already existing hook ${hookName} ${contextMsg}`);
      if (throwIfExist) {
        throw new (errors().HookAlreadyExists)(hookName);
      }
      return false;
    }
    this.hooks.set(hookName, []);
    return true;
  }

  /**
   * Register action to an existing hook
   * @param {string} hookName - hook to register action to
   * @param {HookAction} hookAction - The action to register to the hook
   * @param {boolean} throwIfNotExist - whether to throw an exception in case the hook doesn't exists
   * @return {boolean} whether the action has been registerd successfully
   */
  registerActionToHook(hookName, hookAction, context = {}, throwIfNotExist = false) {
    if (!this.hooks.has(hookName)) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const contextMsg = context.extension ? `from ${context.extension}` : '';
      _logger().default.warn(`trying to register to a non existing hook ${hookName} ${contextMsg}`);
      if (throwIfNotExist) {
        throw new (errors().HookNotExists)(hookName);
      }
      return false;
    }
    this.hooks.get(hookName).push(hookAction);
    return true;
  }

  /**
   * Trigger a hook - run all the actions registerd to this hook
   * The actions will be run in parallel and the errors will be aggregated
   * @param {string} hookName - The hook name to trigger
   * @return {HookFailures} Aggregated errors of the actions failures
   */
  async triggerHook(hookName, args = {}, headers = {}, context = {}
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  ) {
    const resultErrors = [];
    if (!this.hooks.has(hookName)) {
      _logger().default.warn(`trying to trigger a non existing hook ${hookName}`);
      throw new (errors().HookNotExists)(hookName);
    }
    if (process.env.BIT_LOG) {
      // this is disabled by default due to performance implications
      // prefix your command with "BIT_LOG=*" to log all args and headers
      _logger().default.info(`triggering hook ${hookName} with args:\n ${_stringifyIfNeeded(_stripArgs(args))} \n and headers \n ${_stringifyIfNeeded(_stripHeaders(headers))} \n and context ${_stringifyIfNeeded(context)}`);
    } else {
      _logger().default.info(`triggering hook ${hookName}`);
    }
    const actions = this.hooks.get(hookName);
    const actionsP = actions.map(action => {
      // Catch errors in order to aggregate them
      // Wrap in a promise in case the action doesn't return a promise
      return Promise.resolve().then(() => {
        _logger().default.info(`running action ${action.name} on hook ${hookName}`);
        return action.run(args, headers, context);
      }).catch(e => {
        _logger().default.error(`running action ${action.name} on hook ${hookName} failed, err:`, e);
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        resultErrors.push({
          [action.name]: e
        });
      });
    });
    await Promise.all(actionsP);
    return resultErrors;
  }
}
exports.default = HooksManager;
function _stringifyIfNeeded(val) {
  return typeof val === 'string' ? val : (0, _util().inspect)(val, {
    depth: 5
  });
}

/**
 * Remove some data from the logs (because it's too verbose or because it's sensitive)
 * @param {Object} args
 */
function _stripArgs(args) {
  // Create deep clone
  const res = (0, _clone2().default)(args);
  if (res.componentObjects) {
    res.componentObjects = res.componentObjects.length;
  }
  if (res.objectList) {
    res.objectList = args.objectList.count ? args.objectList.count() : undefined;
  }
  return res;
}

/**
 * Remove some data from the logs (because it's too verbose or because it's sensitive)
 * @param {Object} headers
 */
function _stripHeaders(headers) {
  if (!headers) return;
  // Create deep clone
  const res = (0, _clone2().default)(headers);
  if (res.context && res.context.pubSshKey) {
    const key = res.context.pubSshKey;
    res.context.pubSshKey = `last 70 characters: ${key.slice(key.length - 70)}`;
  }
  return res;
}