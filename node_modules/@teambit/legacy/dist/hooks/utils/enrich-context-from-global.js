"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = enrichContextFromGlobal;
function _gitconfig() {
  const data = _interopRequireDefault(require("gitconfig"));
  _gitconfig = function () {
    return data;
  };
  return data;
}
function _yn() {
  const data = _interopRequireDefault(require("yn"));
  _yn = function () {
    return data;
  };
  return data;
}
function globalConfig() {
  const data = _interopRequireWildcard(require("../../api/consumer/lib/global-config"));
  globalConfig = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// import fs from 'fs-extra';

/**
 * Add more keys to the context which will be passed to hooks
 * @param {Object} context
 */
function enrichContextFromGlobal(context = {}) {
  _logger().default.debug('enrich context from global config');
  const getContextToEnrich = () => {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (!enrichContextFromGlobal.context) {
      const username = globalConfig().getSync(_constants().CFG_USER_NAME_KEY);
      const email = globalConfig().getSync(_constants().CFG_USER_EMAIL_KEY);
      // const sshKeyFile = globalConfig.getSync(CFG_SSH_KEY_FILE_KEY);
      const token = globalConfig().getSync(_constants().CFG_USER_TOKEN_KEY);
      // const pubSshKeyFile = sshKeyFile ? `${sshKeyFile}.pub` : undefined;
      // const pubSshKey = _getSshPubKey(pubSshKeyFile);
      const repo = (0, _yn().default)(globalConfig().getSync(_constants().CFG_REPOSITORY_REPORTING_KEY), {
        default: true
      }) ? _gitconfig().default.fetchRepo() : undefined;
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // enrichContextFromGlobal.context = { username, email, pubSshKey, token, repo };
      enrichContextFromGlobal.context = {
        username,
        email,
        token,
        repo
      };
    }
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return enrichContextFromGlobal.context;
  };
  const contextToEnrich = getContextToEnrich();
  Object.assign(context, contextToEnrich);
}

// function _getSshPubKey(pubSshKeyFile = `${DEFAULT_SSH_KEY_FILE}.pub`) {
//   logger.debug(`reading ssh public key from ${pubSshKeyFile}`);
//   if (!fs.pathExistsSync(pubSshKeyFile)) {
//     return null;
//   }
//   const buf = fs.readFileSync(pubSshKeyFile);
//   return buf.toString();
// }