"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _uniqBy2() {
  const data = _interopRequireDefault(require("ramda/src/uniqBy"));
  _uniqBy2 = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = _interopRequireDefault(require("../bit-id/bit-id"));
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _foreach() {
  const data = _interopRequireDefault(require("../utils/object/foreach"));
  _foreach = function () {
    return data;
  };
  return data;
}
function _resolveLatestVersion() {
  const data = _interopRequireDefault(require("../utils/resolveLatestVersion"));
  _resolveLatestVersion = function () {
    return data;
  };
  return data;
}
class BitIds extends Array {
  serialize() {
    return this.map(bitId => bitId.toString());
  }

  /**
   * Resolve an id with latest to specific version
   * This used to get the real version from the flatten deps by the deps ids
   *
   * @param {BitId} idWithLatest - A bit id object with latest version
   * @returns {BitId} - The bit id found in the array (with actual version)
   * @memberof BitIds
   */
  resolveVersion(idWithLatest) {
    return (0, _resolveLatestVersion().default)(this, idWithLatest);
  }
  has(bitId) {
    return Boolean(this.search(bitId));
  }
  hasWithoutVersion(bitId) {
    return Boolean(this.searchWithoutVersion(bitId));
  }
  hasWithoutScope(bitId) {
    return Boolean(this.searchWithoutScope(bitId));
  }
  hasWithoutScopeAndVersion(bitId) {
    return Boolean(this.searchWithoutScopeAndVersion(bitId));
  }
  hasWithoutScopeAndVersionAsString(bitIdStr) {
    return Boolean(this.find(id => id.name === bitIdStr));
  }
  search(bitId) {
    return this.find(id => id.hasSameName(bitId) && id.hasSameScope(bitId) && id.hasSameVersion(bitId));
  }
  searchWithoutVersion(bitId) {
    return this.find(id => id.hasSameName(bitId) && id.hasSameScope(bitId));
  }
  searchWithoutScopeAndVersion(bitId) {
    return this.find(id => id.hasSameName(bitId));
  }
  searchWithoutScope(bitId) {
    return this.find(id => id.hasSameName(bitId) && id.hasSameVersion(bitId));
  }
  searchStrWithoutVersion(idStr) {
    return this.find(id => id.toStringWithoutVersion() === idStr);
  }
  searchStrWithoutScopeAndVersion(idStr) {
    return this.find(id => id.toStringWithoutScopeAndVersion() === idStr);
  }
  filterExact(bitId) {
    return this.filter(id => id.hasSameName(bitId) && id.hasSameScope(bitId) && id.hasSameVersion(bitId));
  }
  filterWithoutVersion(bitId) {
    return this.filter(id => id.hasSameName(bitId) && id.hasSameScope(bitId));
  }
  filterWithoutScopeAndVersion(bitId) {
    return this.filter(id => id.hasSameName(bitId));
  }
  removeIfExist(bitId) {
    return BitIds.fromArray(this.filter(id => !id.isEqual(bitId)));
  }

  /**
   * Return ids which are on the current instance and not in the passed list
   * @param bitIds
   */
  difference(bitIds) {
    return BitIds.fromArray(this.filter(id => !bitIds.search(id)));
  }
  removeIfExistWithoutVersion(bitId) {
    return BitIds.fromArray(this.filter(id => !id.isEqualWithoutVersion(bitId)));
  }
  removeMultipleIfExistWithoutVersion(bitIds) {
    return BitIds.fromArray(this.filter(id => !bitIds.hasWithoutVersion(id)));
  }
  toObject() {
    return this.reduce((acc, bitId) => {
      acc[bitId.toString()] = bitId;
      return acc;
    }, {});
  }

  /**
   * make sure to pass only bit ids you know they have scope, otherwise, you'll get invalid bit ids.
   * this is mainly useful for remote commands where it is impossible to have a component without scope.
   */
  static deserialize(array = []) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return new BitIds(...array.map(id => _bitId().default.parse(id, true)));
  }
  static deserializeObsolete(array = []) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return new BitIds(...array.map(id => _bitId().default.parseObsolete(id)));
  }
  toString() {
    return this.map(id => id.toString()).join(', ');
  }
  toGroupByScopeName(idsWithDefaultScope) {
    return this.reduce((acc, current) => {
      const getScopeName = () => {
        if (current.scope) return current.scope;
        const idWithDefaultScope = idsWithDefaultScope.searchWithoutScopeAndVersion(current);
        return idWithDefaultScope ? idWithDefaultScope.scope : null;
      };
      const scopeName = getScopeName();
      if (!scopeName) {
        throw new Error(`toGroupByScopeName() expect ids to have a scope name, got ${current.toString()}`);
      }
      if (acc[scopeName]) acc[scopeName].push(current);else acc[scopeName] = new BitIds(current);
      return acc;
    }, {});
  }
  findDuplicationsIgnoreVersion() {
    const duplications = {};
    this.forEach(id => {
      const sameIds = this.filterWithoutVersion(id);
      if (sameIds.length > 1) {
        duplications[id.toStringWithoutVersion()] = sameIds;
      }
    });
    return duplications;
  }
  add(bitIds) {
    bitIds.forEach(bitId => {
      if (!this.search(bitId)) this.push(bitId);
    });
  }
  static fromObject(dependencies) {
    const array = [];
    (0, _foreach().default)(dependencies, (version, id) => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      array.push(_bitId().default.parse(id, true, version)); // bit.json has only imported dependencies, they all have scope
    });

    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return new BitIds(...array);
  }
  static fromArray(ids) {
    // don't do `new BitIds(...ids);`, it'll throw "Maximum call stack size exceeded" for large number if ids.
    const bitIds = new BitIds();
    ids.forEach(id => bitIds.push(id));
    return bitIds;
  }
  static uniqFromArray(bitIds) {
    const uniq = (0, _uniqBy2().default)(JSON.stringify, bitIds);
    return BitIds.fromArray(uniq);
  }
  throwForDuplicationIgnoreVersion() {
    this.forEach(bitId => {
      const found = this.filterWithoutVersion(bitId);
      if (found.length > 1) {
        throw new Error(`bitIds has "${bitId.toStringWithoutVersion()}" duplicated as following:
${found.map(id => id.toString()).join('\n')}`);
      }
    });
  }
  toVersionLatest() {
    return BitIds.fromArray(this.map(id => id.changeVersion(_constants().LATEST_BIT_VERSION)));
  }
  clone() {
    const cloneIds = this.map(id => id.clone());
    return new BitIds(...cloneIds);
  }
}
exports.default = BitIds;