"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _laneNotFound() {
  const data = require("../../api/scope/lib/exceptions/lane-not-found");
  _laneNotFound = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _objects() {
  const data = require("../objects");
  _objects = function () {
    return data;
  };
  return data;
}
function _componentsIndex() {
  const data = require("../objects/components-index");
  _componentsIndex = function () {
    return data;
  };
  return data;
}
class Lanes {
  constructor(objects, scopeJson) {
    (0, _defineProperty2().default)(this, "objects", void 0);
    (0, _defineProperty2().default)(this, "scopeJson", void 0);
    this.objects = objects;
    this.scopeJson = scopeJson;
  }
  async listLanes() {
    return this.listLanesBackwardCompatible();

    // @todo: remove the above after all the lanes are migrated to the new format (2022-06-01 will be a good time to do so)
    return await this.objects.listObjectsFromIndex(_componentsIndex().IndexType.lanes);
  }

  /** don't use it outside of Lanes. Use scope.loadLane instead */
  async loadLane(id) {
    var _this$scopeJson$lanes;
    if (id.isDefault()) return null; // main lane is not saved
    const filter = lane => lane.toLaneId().isEqual(id);
    const hash = this.objects.getHashFromIndex(_componentsIndex().IndexType.lanes, filter);
    if (!hash) return null;
    const lane = await this.objects.load(new (_objects().Ref)(hash));
    lane.isNew = Boolean((_this$scopeJson$lanes = this.scopeJson.lanes.new) === null || _this$scopeJson$lanes === void 0 ? void 0 : _this$scopeJson$lanes.find(l => l === lane.name));
    return lane;
  }
  async saveLane(laneObject) {
    await this.objects.writeObjectsToTheFS([laneObject]);
  }
  getAliasByLaneId(laneId) {
    return this.getLocalTrackedLaneByRemoteName(laneId.name, laneId.scope);
  }
  getDefaultLaneId() {
    return _laneId().LaneId.from(_laneId().DEFAULT_LANE, this.scopeJson.name);
  }
  getLocalTrackedLaneByRemoteName(remoteLane, remoteScope) {
    const trackedLane = this.scopeJson.lanes.tracking.find(t => t.remoteLane === remoteLane && t.remoteScope === remoteScope);
    return trackedLane ? trackedLane.localLane : null;
  }
  getRemoteScopeByLocalLane(localLane) {
    const trackedLane = this.scopeJson.lanes.tracking.find(t => t.localLane === localLane);
    return trackedLane ? trackedLane.remoteScope : null;
  }
  getRemoteTrackedDataByLocalLane(localLane) {
    return this.scopeJson.lanes.tracking.find(t => t.localLane === localLane);
  }
  trackLane(trackLaneData) {
    this.scopeJson.trackLane(trackLaneData);
  }
  removeTrackLane(localLane) {
    this.scopeJson.removeTrackLane(localLane);
  }
  async removeLanes(scope, lanes, force, currentLaneName) {
    const existingLanes = await this.listLanes();
    const lanesToRemove = lanes.map(laneName => {
      if (laneName === _laneId().DEFAULT_LANE) throw new (_bitError().BitError)(`unable to remove the default lane "${_laneId().DEFAULT_LANE}"`);
      if (laneName === currentLaneName) throw new (_bitError().BitError)(`unable to remove the currently used lane "${laneName}"`);
      const existingLane = existingLanes.find(l => l.name === laneName);
      if (!existingLane) throw new (_laneNotFound().LaneNotFound)(scope.name, laneName);
      return existingLane;
    });
    if (!force) {
      await Promise.all(lanesToRemove.map(async laneObj => {
        const isFullyMerged = await laneObj.isFullyMerged(scope);
        if (!isFullyMerged) {
          throw new (_bitError().BitError)(`unable to remove ${laneObj.name} lane, it is not fully merged. to disregard this error, please use --force flag`);
        }
      }));
    }
    await this.objects.deleteObjectsFromFS(lanesToRemove.map(l => l.hash()));
    const compIdsFromDeletedLanes = _bitId().BitIds.uniqFromArray(lanesToRemove.map(l => l.toBitIds()).flat());
    const notDeletedLanes = existingLanes.filter(l => !lanes.includes(l.name));
    const compIdsFromNonDeletedLanes = _bitId().BitIds.uniqFromArray(notDeletedLanes.map(l => l.toBitIds()).flat());
    const pendingDeleteCompIds = compIdsFromDeletedLanes.filter(id => !compIdsFromNonDeletedLanes.hasWithoutVersion(id));
    const modelComponents = await Promise.all(pendingDeleteCompIds.map(id => scope.getModelComponentIfExist(id)));
    const modelComponentsWithoutHead = (0, _lodash().compact)(modelComponents).filter(comp => !comp.hasHead());
    if (modelComponentsWithoutHead.length) {
      const idsStr = modelComponentsWithoutHead.map(comp => comp.id()).join(', ');
      _logger().default.debug(`lanes, deleting the following orphaned components: ${idsStr}`);
      await this.objects.deleteObjectsFromFS(modelComponentsWithoutHead.map(comp => comp.hash()));
    }
    return lanes;
  }

  /**
   * the name can be a full lane-id or only the lane-name, which can be the alias (local-lane) or the remote-name.
   */
  async parseLaneIdFromString(name) {
    if (name.includes(_laneId().LANE_REMOTE_DELIMITER)) {
      return _laneId().LaneId.parse(name);
    }
    // the name is only the lane-name without the scope. search for lanes with the same name
    if (name === _laneId().DEFAULT_LANE) {
      return _laneId().LaneId.from(_laneId().DEFAULT_LANE, this.scopeJson.name);
    }
    const trackedData = this.getRemoteTrackedDataByLocalLane(name);
    if (trackedData) {
      return _laneId().LaneId.from(trackedData.remoteLane, trackedData.remoteScope);
    }
    const allLanes = await this.listLanes();
    const foundWithSameName = allLanes.filter(lane => lane.name === name);
    if (foundWithSameName.length === 0) {
      throw new (_bitError().BitError)(`unable to find a lane with the name "${name}"`);
    }
    if (foundWithSameName.length > 1) {
      throw new (_bitError().BitError)(`found more than one lane with the name "${name}", please specify the scope in a form of "<scope>${_laneId().LANE_REMOTE_DELIMITER}<name>"`);
    }
    return foundWithSameName[0].toLaneId();
  }
  async getLanesData(scope, name, mergeData) {
    const getLaneDataOfLane = async laneObject => {
      var _laneObject$readmeCom;
      const laneName = laneObject.name;
      const alias = this.getLocalTrackedLaneByRemoteName(laneName, laneObject.scope);
      return {
        name: laneName,
        remote: laneObject.toLaneId().toString(),
        id: laneObject.toLaneId(),
        alias: alias !== laneName ? alias : null,
        components: laneObject.components.map(c => ({
          id: c.id,
          head: c.head.toString()
        })),
        log: laneObject.log,
        isMerged: mergeData ? await laneObject.isFullyMerged(scope) : null,
        readmeComponent: laneObject.readmeComponent && {
          id: laneObject.readmeComponent.id,
          head: (_laneObject$readmeCom = laneObject.readmeComponent.head) === null || _laneObject$readmeCom === void 0 ? void 0 : _laneObject$readmeCom.toString()
        },
        hash: laneObject.hash().toString()
      };
    };
    if (name) {
      const laneId = await this.parseLaneIdFromString(name);
      const laneObject = await this.loadLane(laneId);
      if (!laneObject) throw new (_bitError().BitError)(`lane "${name}" was not found`);
      return [await getLaneDataOfLane(laneObject)];
    }
    const lanesObjects = await this.listLanes();
    const lanes = await Promise.all(lanesObjects.map(laneObject => getLaneDataOfLane(laneObject)));
    return lanes;
  }
  async listLanesBackwardCompatible() {
    const lanes = await this.objects.listObjectsFromIndex(_componentsIndex().IndexType.lanes);
    const oldLanes = lanes.filter(lane => !lane.scope);
    if (oldLanes.length) await this.fixOldLanesToIncludeScope(oldLanes);
    return lanes;
  }
  async fixOldLanesToIncludeScope(lanes) {
    _logger().default.warn(`lanes, fixOldLanesToIncludeScope: ${lanes.map(l => l.id.toString()).join(', ')}`);
    lanes.forEach(lane => {
      const trackLaneData = this.getRemoteTrackedDataByLocalLane(lane.name);
      if (trackLaneData) {
        lane.scope = trackLaneData.remoteScope;
      } else {
        lane.scope = this.scopeJson.name;
      }
    });
    await this.objects.deleteObjectsFromFS(lanes.map(l => l.hash()));
    await this.objects.writeObjectsToTheFS(lanes);
  }
}
exports.default = Lanes;