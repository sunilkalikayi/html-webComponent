import { LaneId } from '@teambit/lane-id';
import { Mutex } from 'async-mutex';
import { BitId } from '../../bit-id';
import { Lane, ModelComponent } from '../models';
import { LaneComponent } from '../models/lane';
import { Ref } from '../objects';
declare type Lanes = {
    [laneName: string]: LaneComponent[];
};
/**
 * each lane holds components and hashes, which are the heads of the remote
 */
export default class RemoteLanes {
    basePath: string;
    remotes: {
        [remoteName: string]: Lanes;
    };
    writeMutex: Mutex;
    constructor(scopePath: string);
    addEntry(remoteLaneId: LaneId, componentId: BitId, head?: Ref): Promise<void>;
    private pushToRemoteLane;
    addEntriesFromModelComponents(remoteLaneId: LaneId, components: ModelComponent[]): Promise<void>;
    getRef(remoteLaneId: LaneId, bitId: BitId): Promise<Ref | null>;
    getRemoteLane(remoteLaneId: LaneId): Promise<LaneComponent[]>;
    getRefsFromAllLanesOnScope(scopeName: string, bitId: BitId): Promise<Ref[]>;
    getRefsFromAllLanes(bitId: BitId): Promise<Ref[]>;
    getRemoteBitIds(remoteLaneId: LaneId): Promise<BitId[]>;
    loadRemoteLane(remoteLaneId: LaneId): Promise<void>;
    getAllRemoteLaneIds(): Promise<LaneId[]>;
    getAllRemoteLaneIdsOfScope(scopeName: string): Promise<LaneId[]>;
    syncWithLaneObject(remoteName: string, lane: Lane): Promise<void>;
    private composeRemoteLanePath;
    write(): Promise<void>;
    renameRefByNewScopeName(laneName: string, oldScopeName: string, newScopeName: string): Promise<void>;
    renameRefByNewLaneName(oldLaneName: string, newLaneName: string, scopeName: string): Promise<void>;
    private writeRemoteLanes;
    private writeRemoteLaneFile;
}
export {};
