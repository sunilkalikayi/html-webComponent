"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _asyncMutex() {
  const data = require("async-mutex");
  _asyncMutex = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _objects() {
  const data = require("../objects");
  _objects = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * each lane holds components and hashes, which are the heads of the remote
 */
class RemoteLanes {
  constructor(scopePath) {
    (0, _defineProperty2().default)(this, "basePath", void 0);
    (0, _defineProperty2().default)(this, "remotes", void 0);
    (0, _defineProperty2().default)(this, "writeMutex", new (_asyncMutex().Mutex)());
    this.basePath = _path().default.join(scopePath, _constants().REMOTE_REFS_DIR);
    this.remotes = {};
  }
  async addEntry(remoteLaneId, componentId, head) {
    if (!remoteLaneId) throw new TypeError('addEntry expects to get remoteLaneId');
    if (!head) return; // do nothing
    const remoteLane = await this.getRemoteLane(remoteLaneId);
    this.pushToRemoteLane(remoteLane, componentId, head);
  }
  pushToRemoteLane(remoteLane, componentId, head) {
    const existingComponent = remoteLane.find(n => n.id.isEqualWithoutVersion(componentId));
    if (existingComponent) {
      existingComponent.head = head;
    } else {
      remoteLane.push({
        id: componentId,
        head
      });
    }
  }
  async addEntriesFromModelComponents(remoteLaneId, components) {
    const remoteLane = await this.getRemoteLane(remoteLaneId);
    components.forEach(component => {
      if (!component.remoteHead) return;
      this.pushToRemoteLane(remoteLane, component.toBitId(), component.remoteHead);
    });
  }
  async getRef(remoteLaneId, bitId) {
    if (!remoteLaneId) throw new TypeError('getEntry expects to get remoteLaneId');
    if (!this.remotes[remoteLaneId.scope] || !this.remotes[remoteLaneId.scope][remoteLaneId.name]) {
      await this.loadRemoteLane(remoteLaneId);
    }
    const remoteLane = this.remotes[remoteLaneId.scope][remoteLaneId.name];
    const existingComponent = remoteLane.find(n => n.id.isEqualWithoutVersion(bitId));
    if (!existingComponent) return null;
    return existingComponent.head;
  }
  async getRemoteLane(remoteLaneId) {
    if (!this.remotes[remoteLaneId.scope] || !this.remotes[remoteLaneId.scope][remoteLaneId.name]) {
      await this.loadRemoteLane(remoteLaneId);
    }
    return this.remotes[remoteLaneId.scope][remoteLaneId.name];
  }
  async getRefsFromAllLanesOnScope(scopeName, bitId) {
    const allLaneIdOfScope = await this.getAllRemoteLaneIdsOfScope(scopeName);
    const results = await (0, _pMapSeries().default)(allLaneIdOfScope, laneId => this.getRef(laneId, bitId));
    return (0, _lodash().compact)(results);
  }
  async getRefsFromAllLanes(bitId) {
    const allLaneIds = await this.getAllRemoteLaneIds();
    const results = await (0, _pMapSeries().default)(allLaneIds, laneId => this.getRef(laneId, bitId));
    return (0, _lodash().compact)(results);
  }
  async getRemoteBitIds(remoteLaneId) {
    const remoteLane = await this.getRemoteLane(remoteLaneId);
    return remoteLane.map(item => item.id.changeVersion(item.head.toString()));
  }
  async loadRemoteLane(remoteLaneId) {
    const remoteName = remoteLaneId.scope;
    const laneName = remoteLaneId.name;
    const remoteLanePath = this.composeRemoteLanePath(remoteName, laneName);
    try {
      const remoteFile = await _fsExtra().default.readJson(remoteLanePath);
      if (!this.remotes[remoteName]) this.remotes[remoteName] = {};
      this.remotes[remoteName][laneName] = remoteFile.map(({
        id,
        head
      }) => ({
        id: new (_bitId().BitId)({
          scope: id.scope,
          name: id.name
        }),
        head: new (_objects().Ref)(head)
      }));
    } catch (err) {
      if (err.code === 'ENOENT') {
        if (!this.remotes[remoteName]) this.remotes[remoteName] = {};
        this.remotes[remoteName][laneName] = [];
        return;
      }
      throw err;
    }
  }
  async getAllRemoteLaneIds() {
    const matches = await (0, _utils().glob)(_path().default.join('*', '*'), {
      cwd: this.basePath
    });
    // in the future, lane-name might have slashes, so until the first slash is the scope.
    // the rest are the name
    return matches.map(match => match.split(_path().default.sep)).map(([head, ...tail]) => _laneId().LaneId.from(tail.join('/'), head)).filter(remoteLaneId => !remoteLaneId.isDefault() && remoteLaneId.name !== _constants().PREVIOUS_DEFAULT_LANE);
  }
  async getAllRemoteLaneIdsOfScope(scopeName) {
    const matches = await (0, _utils().glob)(_path().default.join('*'), {
      cwd: _path().default.join(this.basePath, scopeName)
    });
    return matches.map(match => _laneId().LaneId.from(match, scopeName)).filter(laneId => !laneId.isDefault());
  }
  async syncWithLaneObject(remoteName, lane) {
    const remoteLaneId = _laneId().LaneId.from(lane.name, remoteName);
    if (!this.remotes[remoteName] || !this.remotes[remoteName][lane.name]) {
      await this.loadRemoteLane(remoteLaneId);
    }
    await Promise.all(lane.components.map(component => this.addEntry(remoteLaneId, component.id, component.head)));
  }
  composeRemoteLanePath(remoteName, laneName) {
    return _path().default.join(this.basePath, remoteName, laneName);
  }
  async write() {
    await this.writeMutex.runExclusive(() => Promise.all(Object.keys(this.remotes).map(remoteName => this.writeRemoteLanes(remoteName))));
  }
  async renameRefByNewScopeName(laneName, oldScopeName, newScopeName) {
    const remoteLaneId = _laneId().LaneId.from(laneName, oldScopeName);
    const remoteLane = await this.getRemoteLane(remoteLaneId);
    this.remotes[newScopeName] = _objectSpread(_objectSpread({}, this.remotes[newScopeName]), {}, {
      [laneName]: remoteLane
    });
    delete this.remotes[oldScopeName][laneName];
  }
  async renameRefByNewLaneName(oldLaneName, newLaneName, scopeName) {
    const remoteLaneId = _laneId().LaneId.from(oldLaneName, scopeName);
    const remoteLane = await this.getRemoteLane(remoteLaneId);
    this.remotes[scopeName] = _objectSpread(_objectSpread({}, this.remotes[scopeName]), {}, {
      [newLaneName]: remoteLane
    });
    delete this.remotes[scopeName][oldLaneName];
  }
  async writeRemoteLanes(remoteName) {
    return Promise.all(Object.keys(this.remotes[remoteName]).map(laneName => this.writeRemoteLaneFile(remoteName, laneName)));
  }
  async writeRemoteLaneFile(remoteName, laneName) {
    const obj = this.remotes[remoteName][laneName].map(({
      id,
      head
    }) => ({
      id: {
        scope: id.scope,
        name: id.name
      },
      head: head.toString()
    }));
    return _fsExtra().default.outputFile(this.composeRemoteLanePath(remoteName, laneName), JSON.stringify(obj, null, 2));
  }
}
exports.default = RemoteLanes;