"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _without2() {
  const data = _interopRequireDefault(require("ramda/src/without"));
  _without2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _objects() {
  const data = require("../objects");
  _objects = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const UNMERGED_FILENAME = 'unmerged.json';
class UnmergedComponents {
  constructor(filePath, unmerged) {
    (0, _defineProperty2().default)(this, "filePath", void 0);
    (0, _defineProperty2().default)(this, "unmerged", void 0);
    (0, _defineProperty2().default)(this, "hasChanged", false);
    this.filePath = filePath;
    this.unmerged = unmerged;
  }
  static async load(scopePath) {
    const filePath = _path().default.join(scopePath, UNMERGED_FILENAME);
    let unmerged;
    try {
      const fileContent = await _fsExtra().default.readJson(filePath);
      unmerged = fileContent.map(item => _objectSpread(_objectSpread({}, item), {}, {
        head: _objects().Ref.from(item.head),
        laneId: item.laneId ? new (_laneId().LaneId)(item.laneId) : undefined
      }));
    } catch (err) {
      if (err.code === 'ENOENT') {
        unmerged = [];
      } else {
        throw err;
      }
    }
    return new UnmergedComponents(filePath, unmerged);
  }
  addEntry(unmergedComponent) {
    const existingComponent = this.getEntry(unmergedComponent.id.name);
    if (existingComponent) {
      throw new Error(`unable to add an unmerged component, a component with the same name already exist. name ${existingComponent.id.name}, scope: ${existingComponent.id.scope}`);
    }
    this.unmerged.push(unmergedComponent);
    this.hasChanged = true;
  }
  getEntry(componentName) {
    return this.unmerged.find(u => u.id.name === componentName);
  }
  getComponents() {
    return this.unmerged;
  }
  removeComponent(componentName) {
    const found = this.getEntry(componentName);
    if (!found) return false;
    this.unmerged = (0, _without2().default)([found], this.unmerged);
    this.hasChanged = true;
    return true;
  }
  removeMultipleComponents(componentNames) {
    const found = (0, _lodash().compact)(componentNames.map(comp => this.getEntry(comp)));
    if (!found.length) return false;
    this.unmerged = (0, _without2().default)(found, this.unmerged);
    this.hasChanged = true;
    return true;
  }
  async write() {
    if (!this.hasChanged) return;
    await _fsExtra().default.outputFile(this.filePath, JSON.stringify(this.toObject(), null, 2));
  }
  toObject() {
    return this.unmerged.map(item => _objectSpread(_objectSpread({}, item), {}, {
      head: item.head.toString(),
      laneId: item.laneId.toObject()
    }));
  }
  static buildSnapMessage(unmergedComponent) {
    return `merge ${unmergedComponent.laneId.toString()}`;
  }
}
exports.default = UnmergedComponents;