import { Graph as GraphLib } from 'graphlib';
import { BitId } from '../../bit-id';
import Component from '../../consumer/component';
import Consumer from '../../consumer/consumer';
import { ModelComponent, Version } from '../models';
import Scope from '../scope';
export default class Graph extends GraphLib {
    getSuccessorsByEdgeTypeRecursively(bitId: string, successorsList?: string[], visited?: {
        [key: string]: boolean;
    }): string[];
    /**
     * e.g. a graph has edges of "dependencies" and "devDependencies" and you want a new graph of the
     * dependencies only.
     */
    getSubGraphByEdgeType(edgeType: string): Graph;
    findSuccessorsInGraph(ids: string[]): Component[];
    /**
     * helps finding the versions of bit-ids using the components stored in the graph
     */
    getBitIdsIncludeVersionsFromGraph(ids: BitId[], graph: Graph): BitId[];
    toString(): Object;
    toGraphOfIds(): Graph;
    static buildGraphFromScope(scope: Scope): Promise<Graph>;
    static _addDependenciesToGraph(id: BitId, graph: Graph, component: Version | Component): void;
    static addScopeComponentsAsNodes(allModelComponents: ModelComponent[], graph: Graph, workspaceComponents?: Component[], onlyLatest?: boolean): Promise<void>;
    static buildGraphFromWorkspace(consumer: Consumer, onlyLatest?: boolean): Promise<Graph>;
    findCycles(): string[][];
}
