"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _graphlib() {
  const data = _interopRequireWildcard(require("graphlib"));
  _graphlib = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _componentsList() {
  const data = _interopRequireDefault(require("../../consumer/component/components-list"));
  _componentsList = function () {
    return data;
  };
  return data;
}
function _dependencies() {
  const data = require("../../consumer/component/dependencies/dependencies");
  _dependencies = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _traverseVersions() {
  const data = require("../component-ops/traverse-versions");
  _traverseVersions = function () {
    return data;
  };
  return data;
}
function _idNotFoundInGraph() {
  const data = require("../exceptions/id-not-found-in-graph");
  _idNotFoundInGraph = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class DependencyGraph {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  constructor(graph) {
    (0, _defineProperty2().default)(this, "graph", void 0);
    (0, _defineProperty2().default)(this, "scopeName", void 0);
    this.graph = graph;
  }
  setScopeName(scopeName) {
    this.scopeName = scopeName;
  }
  hasCircular() {
    return !_graphlib().default.alg.isAcyclic(this.graph);
  }
  static async loadAllVersions(scope) {
    const graph = await DependencyGraph.buildGraphWithAllVersions(scope);
    return new DependencyGraph(graph);
  }
  static async loadLatest(scope) {
    const graph = await DependencyGraph.buildGraphFromScope(scope);
    return new DependencyGraph(graph);
  }
  static loadFromString(str) {
    const graph = _graphlib().default.json.read(str);
    // when getting a graph from a remote scope, the class BitId is gone and only the object is received
    graph.nodes().forEach(node => {
      const id = graph.node(node);
      if (!(id instanceof _bitId().BitId)) {
        graph.setNode(node, new (_bitId().BitId)(id));
      }
    });
    return new DependencyGraph(graph);
  }

  /**
   * @todo: refactor this to work with the newer method `buildGraphFromScope`.
   */
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  static async buildGraphWithAllVersions(scope) {
    const graph = new (_graphlib().Graph)({
      compound: true
    });
    const depObj = {};
    const allComponents = await scope.list();
    // build all nodes. a node is either a Version object or Component object.
    // each Version node has a parent of Component node. Component node doesn't have a parent.
    await Promise.all(allComponents.map(async component => {
      graph.setNode(component.id(), component);
      await Promise.all(Object.keys(component.versionsIncludeOrphaned).map(async version => {
        const componentVersion = await component.loadVersion(version, scope.objects, false);
        if (!componentVersion) return;
        const idWithVersion = `${component.id()}${_constants().VERSION_DELIMITER}${version}`;
        graph.setNode(idWithVersion, componentVersion);
        graph.setParent(idWithVersion, component.id());
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        componentVersion.id = component.toBitId();
        depObj[idWithVersion] = componentVersion;
      }));
    }));
    // set all edges
    // @todo: currently the label is "require". Change it to be "direct" and "indirect" depends on whether it comes from
    // flattenedDependencies or from dependencies.
    Object.keys(depObj).forEach(id => depObj[id].flattenedDependencies.forEach(dep => graph.setEdge(id, dep.toString(), 'require')));
    return graph;
  }
  static async buildIdsGraphWithAllVersions(scope) {
    const modelComponents = await scope.list();
    const graph = new (_graphlib().Graph)();
    await (0, _pMapSeries().default)(modelComponents, async modelComp => {
      const versionsInfo = await (0, _traverseVersions().getAllVersionsInfo)({
        modelComponent: modelComp,
        repo: scope.objects,
        throws: false
      });
      versionsInfo.forEach(versionInfo => {
        if (!versionInfo.version) return;
        const id = modelComp.toBitId().changeVersion(versionInfo.tag || versionInfo.ref.toString());
        DependencyGraph._addDependenciesToGraph(id, graph, versionInfo.version);
      });
    });
    return graph;
  }

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  static async buildGraphFromScope(scope) {
    const graph = new (_graphlib().Graph)();
    const allModelComponents = await scope.list();
    const buildGraphP = allModelComponents.map(async modelComponent => {
      const buildVersionP = modelComponent.listVersionsIncludeOrphaned().map(async versionNum => {
        const version = await modelComponent.loadVersion(versionNum, scope.objects, false);
        if (!version) {
          // a component might be in the scope with only the latest version
          return;
        }
        const id = modelComponent.toBitId().changeVersion(versionNum);
        this._addDependenciesToGraph(id, graph, version);
      });
      await Promise.all(buildVersionP);
    });
    await Promise.all(buildGraphP);
    return graph;
  }

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  static async buildGraphFromWorkspace(consumer, onlyLatest = false, reverse = false) {
    const componentsList = new (_componentsList().default)(consumer);
    const workspaceComponents = await componentsList.getFromFileSystem();
    const graph = new (_graphlib().Graph)();
    const allModelComponents = await consumer.scope.list();
    const buildGraphP = allModelComponents.map(async modelComponent => {
      const latestVersion = modelComponent.latest();
      const buildVersionP = modelComponent.listVersionsIncludeOrphaned().map(async versionNum => {
        if (onlyLatest && latestVersion !== versionNum) return;
        const id = modelComponent.toBitId().changeVersion(versionNum);
        const componentFromWorkspace = workspaceComponents.find(comp => comp.id.isEqual(id));
        // if the same component exists in the workspace, use it as it might be modified
        const version = componentFromWorkspace || (await modelComponent.loadVersion(versionNum, consumer.scope.objects, false));
        if (!version) {
          // a component might be in the scope with only the latest version (happens when it's a nested dep)
          return;
        }
        this._addDependenciesToGraph(id, graph, version, reverse);
      });
      await Promise.all(buildVersionP);
    });
    await Promise.all(buildGraphP);
    workspaceComponents.forEach(component => {
      const id = component.id;
      this._addDependenciesToGraph(id, graph, component, reverse);
    });
    return graph;
  }

  /**
   * ignore nested dependencies. build the graph from only imported and authored components
   * according to currently used versions (.bitmap versions).
   * returns a graph that each node is a BitId object.
   */
  static async buildGraphFromCurrentlyUsedComponents(consumer) {
    const componentsList = new (_componentsList().default)(consumer);
    const workspaceComponents = await componentsList.getComponentsFromFS();
    const graph = new (_graphlib().Graph)();
    workspaceComponents.forEach(component => {
      const id = component.id;
      this._addDependenciesToGraph(id, graph, component);
    });
    return graph;
  }
  static _addDependenciesToGraph(id, graph, component, reverse = false) {
    const idStr = id.toString();
    // save the full BitId of a string id to be able to retrieve it later with no confusion
    if (!graph.hasNode(idStr)) graph.setNode(idStr, id);
    Object.entries(component.depsIdsGroupedByType).forEach(([depType, depIds]) => {
      depIds.forEach(dependencyId => {
        const depIdStr = dependencyId.toString();
        if (!graph.hasNode(depIdStr)) graph.setNode(depIdStr, dependencyId);
        if (reverse) {
          graph.setEdge(depIdStr, idStr, depType);
        } else {
          graph.setEdge(idStr, depIdStr, depType);
        }
      });
    });
  }
  static buildFromNodesAndEdges(nodes, edges) {
    const graph = new (_graphlib().Graph)();
    nodes.forEach(node => graph.setNode(node.idStr, node.bitId));
    edges.forEach(edge => graph.setEdge(edge.src, edge.target, edge.depType));
    return graph;
  }

  /**
   * returns a new Graph that has only nodes that are related to the given id.
   * (meaning, they're either dependents or dependencies)
   */
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  getSubGraphOfConnectedComponents(id) {
    const connectedGraphs = _graphlib().default.alg.components(this.graph);
    const idWithVersion = this._getIdWithLatestVersion(id);
    const graphWithId = connectedGraphs.find(graph => graph.includes(idWithVersion.toString()));
    if (!graphWithId) {
      throw new Error(`${id.toString()} is missing from the dependency graph`);
    }
    return this.graph.filterNodes(node => graphWithId.includes(node));
  }
  getDependenciesInfo(id) {
    const idWithVersion = this._getIdWithLatestVersion(id);
    const dijkstraResults = _graphlib().default.alg.dijkstra(this.graph, idWithVersion.toString());
    const dependencies = [];
    Object.keys(dijkstraResults).forEach(idStr => {
      const distance = dijkstraResults[idStr].distance;
      if (distance === Infinity || distance === 0) {
        // there is no dependency or it's the same component (distance zero)
        return;
      }
      const predecessor = dijkstraResults[idStr].predecessor;
      const dependencyType = this.graph.edge(predecessor, idStr);
      dependencies.push({
        id: this.graph.node(idStr),
        depth: distance,
        parent: predecessor,
        dependencyType: _dependencies().DEPENDENCIES_TYPES_UI_MAP[dependencyType]
      });
    });
    dependencies.sort((a, b) => a.depth - b.depth);
    return dependencies;
  }
  getDependenciesAsObjectTree(id) {
    const label = id;
    const children = this.graph.outEdges(id);
    if (!children || children.length === 0) {
      return {
        label
      };
    }
    const nodes = children.map(child => this.getDependenciesAsObjectTree(child.w));
    return {
      label,
      nodes
    };
  }
  getDependentsInfo(id) {
    const idWithVersion = this._getIdWithLatestVersion(id);
    const edgeFunc = v => this.graph.inEdges(v);
    // @ts-ignore (incorrect types in @types/graphlib)
    const dijkstraResults = _graphlib().default.alg.dijkstra(this.graph, idWithVersion.toString(), undefined, edgeFunc);
    const dependents = [];
    Object.keys(dijkstraResults).forEach(idStr => {
      const distance = dijkstraResults[idStr].distance;
      if (distance === Infinity || distance === 0) {
        // there is no dependency or it's the same component (distance zero)
        return;
      }
      const predecessor = dijkstraResults[idStr].predecessor;
      const dependencyType = this.graph.edge(idStr, predecessor);
      dependents.push({
        id: this.graph.node(idStr),
        depth: distance,
        parent: predecessor,
        dependencyType: _dependencies().DEPENDENCIES_TYPES_UI_MAP[dependencyType]
      });
    });
    dependents.sort((a, b) => a.depth - b.depth);
    return dependents;
  }
  getDependentsForAllVersions(id) {
    const allBitIds = this.graph.nodes().map(idStr => this.graph.node(idStr));
    const idWithAllVersions = allBitIds.filter(bitId => bitId.hasSameName(id) && bitId.hasSameScope(id));
    const dependentsIds = idWithAllVersions.map(idWithVer => this.getDependentsInfo(idWithVer)).flat().map(depInfo => depInfo.id);
    return _bitId().BitIds.uniqFromArray(dependentsIds);
  }
  _getIdWithLatestVersion(id) {
    if (id.hasVersion()) {
      return id;
    }
    const nodes = this.graph.nodes();
    const ids = nodes.filter(n => n.startsWith(id.toString()));
    if (!ids.length) {
      throw new (_idNotFoundInGraph().IdNotFoundInGraph)(id.toString());
    }
    const bitIds = ids.map(idStr => this.graph.node(idStr));
    return (0, _utils().getLatestVersionNumber)(_bitId().BitIds.fromArray(bitIds), id);
  }
  getComponent(id) {
    return this.graph.node(id.toStringWithoutVersion());
  }
  getImmediateDependentsPerId(id, returnNodeValue = false) {
    const nodeEdges = this.graph.inEdges(id.toString());
    if (!nodeEdges) return [];
    const idsStr = nodeEdges.map(node => node.v);
    return returnNodeValue ? idsStr.map(idStr => this.graph.node(idStr)) : idsStr;
  }
  getImmediateDependenciesPerId(id) {
    const nodeEdges = this.graph.outEdges(id.toString());
    if (!nodeEdges) return [];
    return nodeEdges.map(node => node.v);
  }
  serialize(graph = this.graph) {
    return _graphlib().default.json.write(graph);
  }
}
exports.default = DependencyGraph;