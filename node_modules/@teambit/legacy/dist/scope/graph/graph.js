"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _forEach2() {
  const data = _interopRequireDefault(require("ramda/src/forEach"));
  _forEach2 = function () {
    return data;
  };
  return data;
}
function _uniq2() {
  const data = _interopRequireDefault(require("ramda/src/uniq"));
  _uniq2 = function () {
    return data;
  };
  return data;
}
function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));
  _flatten2 = function () {
    return data;
  };
  return data;
}
function _graphlib() {
  const data = _interopRequireWildcard(require("graphlib"));
  _graphlib = function () {
    return data;
  };
  return data;
}
function _componentsList() {
  const data = _interopRequireDefault(require("../../consumer/component/components-list"));
  _componentsList = function () {
    return data;
  };
  return data;
}
function _index() {
  const data = require("../index");
  _index = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class Graph extends _graphlib().Graph {
  getSuccessorsByEdgeTypeRecursively(bitId, successorsList = [], visited = {}) {
    const successors = this.successors(bitId) || [];
    if (successors.length > 0 && !visited[bitId]) {
      successors.forEach(successor => {
        visited[bitId] = true;
        successorsList.push(successor);
        return this.getSuccessorsByEdgeTypeRecursively(successor, successorsList, visited);
      });
    }
    return successorsList;
  }

  /**
   * e.g. a graph has edges of "dependencies" and "devDependencies" and you want a new graph of the
   * dependencies only.
   */
  getSubGraphByEdgeType(edgeType) {
    const newGraph = new Graph();
    newGraph.setNodes(this.nodes());
    this.edges().forEach(edge => {
      const edgeLabel = this.edge(edge);
      if (edgeLabel === edgeType) {
        newGraph.setEdge(edge.v, edge.w, edgeType);
      }
    });
    return newGraph;
  }
  findSuccessorsInGraph(ids) {
    const dependenciesFromAllIds = (0, _flatten2().default)(ids.map(id => this.getSuccessorsByEdgeTypeRecursively(id)));
    const components = (0, _uniq2().default)([...dependenciesFromAllIds, ...ids]).map(id => this.node(id)).filter(val => val);
    return components;
  }

  /**
   * helps finding the versions of bit-ids using the components stored in the graph
   */
  getBitIdsIncludeVersionsFromGraph(ids, graph) {
    const components = graph.nodes().map(n => graph.node(n));
    return ids.map(id => {
      const component = components.find(c => c.id.isEqual(id)) || components.find(c => c.id.isEqualWithoutVersion(id));
      if (!component) throw new Error(`unable to find ${id.toString()} in the graph`);
      return component.id;
    });
  }
  toString() {
    return _graphlib().default.json.write(this);
  }
  toGraphOfIds() {
    const graph = new Graph();
    this.nodes().forEach(node => graph.setNode(node, node));
    this.edges().forEach(edge => graph.setEdge(edge.v, edge.w, undefined, edge.name));
    return graph;
  }

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  static async buildGraphFromScope(scope) {
    const graph = new Graph();
    const allModelComponents = await scope.list();
    await this.addScopeComponentsAsNodes(allModelComponents, graph);
  }
  static _addDependenciesToGraph(id, graph, component) {
    const idStr = id.toString();
    // save the full BitId of a string id to be able to retrieve it later with no confusion
    if (!graph.hasNode(idStr)) graph.setNode(idStr, id);
    Object.entries(component.depsIdsGroupedByType).forEach(([depType, depIds]) => {
      depIds.forEach(dependencyId => {
        const depIdStr = dependencyId.toString();
        if (!graph.hasNode(depIdStr)) graph.setNode(depIdStr, dependencyId);
        graph.setEdge(idStr, depIdStr, depType);
      });
    });
  }
  static async addScopeComponentsAsNodes(allModelComponents, graph, workspaceComponents, onlyLatest = false) {
    const scope = await (0, _index().loadScope)(process.cwd());
    await Promise.all(allModelComponents.map(async modelComponent => {
      const latestVersion = modelComponent.latest();
      const buildVersionP = modelComponent.listVersionsIncludeOrphaned().map(async versionNum => {
        if (onlyLatest && latestVersion !== versionNum) return;
        const id = modelComponent.toBitId().changeVersion(versionNum);
        const componentFromWorkspace = workspaceComponents ? workspaceComponents.find(comp => comp.id.isEqual(id)) : undefined;
        if (!componentFromWorkspace) {
          const componentVersion = await scope.getConsumerComponentIfExist(id);
          if (componentVersion) {
            // a component might be in the scope with only the latest version (happens when it's a nested dep)
            graph.setNode(componentVersion.id.toString(), componentVersion);
          }
        }
      });
      await Promise.all(buildVersionP);
    }));
  }
  static async buildGraphFromWorkspace(consumer, onlyLatest = false) {
    const componentsList = new (_componentsList().default)(consumer);
    const allModelComponents = await consumer.scope.list();
    const workspaceComponents = await componentsList.getFromFileSystem();
    const graph = new Graph();
    workspaceComponents.forEach(component => {
      const id = component.id.toString();
      graph.setNode(id, component);
    });
    await this.addScopeComponentsAsNodes(allModelComponents, graph, workspaceComponents, onlyLatest);
    (0, _forEach2().default)(componentId => {
      const component = graph.node(componentId);
      Object.entries(component.depsIdsGroupedByType).forEach(([depType, depIds]) => {
        depIds.forEach(dependencyId => {
          const depIdStr = dependencyId.toString();
          if (graph.hasNode(depIdStr)) {
            graph.setEdge(componentId, depIdStr, depType);
          }
        });
      });
    }, graph.nodes());
    return graph;
  }
  findCycles() {
    return _graphlib().default.alg.findCycles(this);
  }
}
exports.default = Graph;