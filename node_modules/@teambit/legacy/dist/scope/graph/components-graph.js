"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildComponentsGraph = buildComponentsGraph;
exports.buildComponentsGraphCombined = buildComponentsGraphCombined;
exports.buildComponentsGraphForComponentsAndVersion = buildComponentsGraphForComponentsAndVersion;
exports.buildGraphFromComponentsObjects = buildGraphFromComponentsObjects;
exports.buildOneGraphForComponentsAndMultipleVersions = buildOneGraphForComponentsAndMultipleVersions;
exports.buildOneGraphForComponentsUsingScope = buildOneGraphForComponentsUsingScope;
exports.topologicalSortComponentDependencies = topologicalSortComponentDependencies;
function _tail2() {
  const data = _interopRequireDefault(require("ramda/src/tail"));
  _tail2 = function () {
    return data;
  };
  return data;
}
function _graphlib() {
  const data = _interopRequireWildcard(require("graphlib"));
  _graphlib = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _graph() {
  const data = _interopRequireDefault(require("./graph"));
  _graph = function () {
    return data;
  };
  return data;
}
function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("../component-ops/scope-components-importer"));
  _scopeComponentsImporter = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function buildComponentsGraph(components) {
  const graphDeps = new (_graphlib().Graph)();
  const graphDevDeps = new (_graphlib().Graph)();
  const graphExtensionDeps = new (_graphlib().Graph)();
  components.forEach(component => {
    _setGraphEdges(component.id, component.dependencies, graphDeps);
    _setGraphEdges(component.id, component.devDependencies, graphDevDeps);
    _setGraphEdges(component.id, component.extensionDependencies, graphExtensionDeps);
  });
  return {
    graphDeps,
    graphDevDeps,
    graphExtensionDeps
  };
}

/**
 * one graph of the given components. it doesn't fetch/load anything. it builds the graph with the
 * given data. the node is a BitId and the edge has the label of the dependency type. it can be
 * either "dependencies" or "devDependencies".
 */
function buildComponentsGraphCombined(components) {
  const graph = new (_graph().default)();
  components.forEach(component => {
    _setGraphEdges(component.id, component.dependencies, graph);
    _setGraphEdges(component.id, component.devDependencies, graph, 'devDependencies');
    _setGraphEdges(component.id, component.extensionDependencies, graph, 'devDependencies');
  });
  return graph;
}
function buildComponentsGraphForComponentsAndVersion(components) {
  const graphDeps = new (_graphlib().Graph)();
  const graphDevDeps = new (_graphlib().Graph)();
  const graphExtensionDeps = new (_graphlib().Graph)();
  components.forEach(({
    component,
    version,
    versionStr
  }) => {
    const bitId = component.toBitId().changeVersion(versionStr);
    _setGraphEdges(bitId, version.dependencies, graphDeps);
    _setGraphEdges(bitId, version.devDependencies, graphDevDeps);
    _setGraphEdges(bitId, version.extensionDependencies, graphExtensionDeps);
  });
  return {
    graphDeps,
    graphDevDeps,
    graphExtensionDeps
  };
}
function buildOneGraphForComponentsAndMultipleVersions(components) {
  const graph = new (_graph().default)();
  components.forEach(({
    component,
    version
  }) => {
    const bitId = component.toBitId().changeVersion(undefined);
    const idStr = bitId.toString();
    if (!graph.hasNode(idStr)) graph.setNode(idStr, bitId);
    version.getAllDependencies().forEach(dependency => {
      const depId = dependency.id.changeVersion(undefined);
      const depIdStr = depId.toString();
      if (!graph.hasNode(depIdStr)) graph.setNode(depIdStr, depId);
      graph.setEdge(idStr, depIdStr);
    });
  });
  return graph;
}

/**
 * returns one graph that includes all dependencies types. each edge has a label of the dependency
 * type. the nodes content is the Component object.
 */
async function buildOneGraphForComponentsUsingScope(ids, scope, direction = 'normal') {
  const components = await scope.getManyConsumerComponents(ids);
  const allFlattened = components.map(component => component.getAllFlattenedDependencies()).flat();
  const scopeComponentImporter = new (_scopeComponentsImporter().default)(scope);
  await scopeComponentImporter.importMany({
    ids: _bitId().BitIds.uniqFromArray(allFlattened)
  });
  const dependencies = await scope.getManyConsumerComponents(allFlattened);
  const allComponents = [...components, ...dependencies];
  return buildGraphFromComponentsObjects(allComponents, direction);
}
function buildGraphFromComponentsObjects(components, direction = 'normal', ignoreIds = new (_bitId().BitIds)()) {
  const graph = new (_graph().default)();
  // set vertices
  components.forEach(component => {
    const idStr = component.id.toString();
    if (!graph.hasNode(idStr)) graph.setNode(idStr, component);
  });

  // set edges
  const setEdge = (compId, depId, depType) => {
    const depIdStr = depId.toString();
    if (direction === 'normal') {
      graph.setEdge(compId.toString(), depIdStr, depType);
    } else {
      graph.setEdge(depIdStr, compId.toString(), depType);
    }
  };
  components.forEach(component => {
    Object.entries(component.depsIdsGroupedByType).forEach(([depType, depIds]) => {
      depIds.forEach(depId => {
        if (ignoreIds.has(depId)) return;
        if (!graph.hasNode(depId.toString())) {
          throw new Error(`buildGraphFromComponentsObjects: missing node of ${depId.toString()}`);
        }
        setEdge(component.id, depId, depType);
      });
    });
  });

  // uncomment to print the graph content
  // console.log('graph', graphLib.json.write(graph))

  return graph;
}
function _setGraphEdges(bitId, dependencies, graph, label = 'dependencies') {
  const id = bitId.toString();
  dependencies.get().forEach(dependency => {
    const depId = dependency.id.toString();
    // save the full BitId of a string id to be able to retrieve it later with no confusion
    if (!graph.hasNode(id)) graph.setNode(id, bitId);
    if (!graph.hasNode(depId)) graph.setNode(depId, dependency.id);
    graph.setEdge(id, depId, label);
  });
}

/**
 * throw for cyclic dependencies
 * it sorts only "dependencies", not "devDependencies" (nor compiler/tester dependencies).
 */
function topologicalSortComponentDependencies(componentWithDependencies) {
  const {
    graphDeps
  } = buildComponentsGraph([componentWithDependencies.component, ...componentWithDependencies.allDependencies]);
  const componentId = componentWithDependencies.component.id.toString();
  let sortedComponents;
  if (!_graphlib().default.alg.isAcyclic(graphDeps)) {
    const circle = _graphlib().default.alg.findCycles(graphDeps);
    throw new (_generalError().default)(`unable to topological sort dependencies of ${componentId}, it has the following cyclic dependencies\n${circle}`);
  }
  try {
    sortedComponents = _graphlib().default.alg.topsort(graphDeps);
    const sortedComponentsIds = sortedComponents.map(s => graphDeps.node(s));
    const sortedDependenciesIds = (0, _tail2().default)(sortedComponentsIds); // the first one is the component itself
    const dependencies = sortedDependenciesIds.map(depId => {
      const matchDependency = componentWithDependencies.dependencies.find(dependency => dependency.id.isEqual(depId));
      if (!matchDependency) throw new Error(`topologicalSortComponentDependencies, ${depId.toString()} is missing`);
      return matchDependency;
    });
    componentWithDependencies.dependencies = dependencies;
  } catch (err) {
    throw new (_generalError().default)(`unable to topological sort dependencies of ${componentId}. Original error: ${err.message}`);
  }
}