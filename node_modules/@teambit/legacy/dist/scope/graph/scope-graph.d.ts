import { Graph } from 'graphlib';
import { BitId, BitIds } from '../../bit-id';
import Component from '../../consumer/component/consumer-component';
import Consumer from '../../consumer/consumer';
import { ModelComponent, Version } from '../models';
import Scope from '../scope';
export declare type DependenciesInfo = {
    id: BitId;
    depth: number;
    parent: string;
    dependencyType: string;
};
export default class DependencyGraph {
    graph: Graph;
    scopeName: string;
    constructor(graph: Graph);
    setScopeName(scopeName: string): void;
    hasCircular(): boolean;
    static loadAllVersions(scope: Scope): Promise<DependencyGraph>;
    static loadLatest(scope: Scope): Promise<DependencyGraph>;
    static loadFromString(str: object): DependencyGraph;
    /**
     * @todo: refactor this to work with the newer method `buildGraphFromScope`.
     */
    static buildGraphWithAllVersions(scope: Scope): Promise<Graph>;
    static buildIdsGraphWithAllVersions(scope: Scope): Promise<Graph>;
    static buildGraphFromScope(scope: Scope): Promise<Graph>;
    static buildGraphFromWorkspace(consumer: Consumer, onlyLatest?: boolean, reverse?: boolean): Promise<Graph>;
    /**
     * ignore nested dependencies. build the graph from only imported and authored components
     * according to currently used versions (.bitmap versions).
     * returns a graph that each node is a BitId object.
     */
    static buildGraphFromCurrentlyUsedComponents(consumer: Consumer): Promise<Graph>;
    static _addDependenciesToGraph(id: BitId, graph: Graph, component: Version | Component, reverse?: boolean): void;
    static buildFromNodesAndEdges(nodes: Array<{
        idStr: string;
        bitId: BitId;
    }>, edges: Array<{
        src: string;
        target: string;
        depType: string;
    }>): Graph;
    /**
     * returns a new Graph that has only nodes that are related to the given id.
     * (meaning, they're either dependents or dependencies)
     */
    getSubGraphOfConnectedComponents(id: BitId): Graph;
    getDependenciesInfo(id: BitId): DependenciesInfo[];
    getDependenciesAsObjectTree(id: string): Record<string, any>;
    getDependentsInfo(id: BitId): DependenciesInfo[];
    getDependentsForAllVersions(id: BitId): BitIds;
    _getIdWithLatestVersion(id: BitId): BitId;
    getComponent(id: BitId): ModelComponent;
    getImmediateDependentsPerId(id: BitId, returnNodeValue?: boolean): Array<string | Component | BitId>;
    getImmediateDependenciesPerId(id: BitId): string[];
    serialize(graph?: Graph): Object;
}
