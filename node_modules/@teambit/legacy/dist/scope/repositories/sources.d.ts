import { BitId, BitIds } from '../../bit-id';
import ConsumerComponent from '../../consumer/component';
import ComponentObjects from '../component-objects';
import ComponentNeedsUpdate from '../exceptions/component-needs-update';
import { ModelComponent, Symlink, Version } from '../models';
import Lane from '../models/lane';
import { ComponentProps } from '../models/model-component';
import { BitObject, Ref } from '../objects';
import Repository from '../objects/repository';
import Scope from '../scope';
export declare type ComponentTree = {
    component: ModelComponent;
    objects: BitObject[];
};
export declare type LaneTree = {
    lane: Lane;
    objects: BitObject[];
};
export declare type ComponentDef = {
    id: BitId;
    component: ModelComponent | null | undefined;
};
export declare type MergeResult = {
    mergedComponent: ModelComponent;
    mergedVersions: string[];
};
export default class SourceRepository {
    scope: Scope;
    /**
     * if a component Version has build-status of "pending" or "failed", it goes to the remote to ask
     * for the component again, in case it was re-built.
     * to avoid too many trips to the remotes with the same components, we cache the results for a
     * small period of time (currently, 1 min).
     */
    private cacheUnBuiltIds;
    constructor(scope: Scope);
    objects(): Repository;
    getMany(ids: BitId[] | BitIds, versionShouldBeBuilt?: boolean): Promise<ComponentDef[]>;
    /**
     * get component (local or external) from the scope.
     * if the id has a version but the Version object doesn't exist, it returns undefined.
     *
     * if versionShouldBeBuilt is true, it also verified that not only the version exists but it also
     * built successfully. otherwise, if the build failed or pending, the server may have a newer
     * version of this Version object, so we return undefined, to signal the importer that it needs
     * to be fetched from the remote again.
     */
    get(bitId: BitId, versionShouldBeBuilt?: boolean): Promise<ModelComponent | undefined>;
    isUnBuiltInCache(bitId: BitId): boolean;
    _findComponent(component: ModelComponent): Promise<ModelComponent | undefined>;
    _findComponentBySymlink(symlink: Symlink): Promise<ModelComponent | undefined>;
    getObjects(id: BitId): Promise<ComponentObjects>;
    findOrAddComponent(props: ComponentProps): Promise<ModelComponent>;
    /**
     * given a consumer-component object, returns the Version representation.
     * useful for saving into the model or calculation the hash for comparing with other Version object.
     * among other things, it reverts the path manipulation that was done when a component was loaded
     * from the filesystem. it adds the originallySharedDir and strip the wrapDir.
     *
     * warning: Do not change anything on the consumerComponent instance! Only use its clone.
     *
     * @see model-components.toConsumerComponent() for the opposite action. (converting Version to
     * ConsumerComponent).
     */
    consumerComponentToVersion(consumerComponent: ConsumerComponent): Promise<{
        version: Version;
        files: any;
    }>;
    put({ component, objects }: ComponentTree): ModelComponent;
    putObjects(objects: BitObject[]): void;
    /**
     * remove specified component versions from component.
     * if all versions of a component were deleted, delete also the component.
     * it doesn't persist anything to the filesystem.
     * (repository.persist() needs to be called at the end of the operation)
     */
    removeComponentVersions(component: ModelComponent, versions: string[], allVersionsObjects: Version[], lane: Lane | null, removeOnlyHead?: boolean): void;
    /**
     * needed during untag.
     * given all removed versions, find the new head by traversing the versions objects until finding a parent
     * that was not removed. this is the new head of the component.
     */
    private findHeadInExistingVersions;
    /**
     * get hashes needed for removing a component from a local scope.
     */
    getRefsForComponentRemoval(bitId: BitId, includeVersions?: boolean): Promise<Ref[]>;
    /**
     * this gets called only during export. for import, the merge is different, see
     * objects-writable-stream.mergeModelComponent()
     *
     * it doesn't save anything to the file-system.
     * only if the returned mergedVersions is not empty, the mergedComponent has changed.
     *
     * when dealing with lanes, exporting/importing lane's components, this function doesn't do much
     * if any. that's because the head is not saved on the ModelComponent but on the lane object.
     * to rephrase with other words,
     * this function merges an incoming modelComponent with an existing modelComponent, so if all
     * changes where done on a lane, this function will not do anything because modelComponent
     * hasn't changed.
     */
    merge(incomingComp: ModelComponent, versionObjects: Version[]): Promise<MergeResult>;
    private getMergedSnaps;
    private throwForMissingVersions;
    mergeComponents(components: ModelComponent[], versions: Version[]): Promise<{
        mergeResults: MergeResult[];
        errors: Error[];
    }>;
    /**
     * the merge is needed only when both, local lane and remote lane have the same component with
     * a different head.
     * the different head can be a result of one component is ahead of the other (fast-forward is
     *  possible), or they both have diverged.
     *
     * 1a) fast-forward case, existing is ahead. existing has snapA => snapB, incoming has snapA.
     * we can just ignore the incoming.
     *
     * 1b) fast-forward case, incoming is ahead. existing has snapA, incoming has snapA => snapB.
     * we should update the existing head according to the incoming.
     *
     * 2) true-merge case, existing has snapA => snapB, incoming has snapA => snapC.
     *
     * in case this is a remote (the incoming component comes as a result of export):
     * throw an error telling the client to pull the lane from the remote in order to merge the
     * new snaps. the client during the merge process will create a snap-merge that is going to be
     * the new head, which eventually becoming the case 1b.
     *
     * in case this is a local (the incoming component comes as a result of import):
     * do not update the lane object. only save the data on the refs/remote/lane-name.
     *
     * keep in mind that this method may merge another non-checked out lane during "fetch" operation, so avoid mutating
     * the ModelComponent object with data from this lane object.
     */
    mergeLane(lane: Lane, isImport: boolean, // otherwise, it's coming from export
    versionObjects?: Version[], // for export, some versions don't exist locally yet.
    componentObjects?: ModelComponent[]): Promise<{
        mergeResults: MergeResult[];
        mergeErrors: ComponentNeedsUpdate[];
        mergeLane: Lane;
    }>;
}
