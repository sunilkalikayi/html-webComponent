"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectsReadableGenerator = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _stream() {
  const data = require("stream");
  _stream = function () {
    return data;
  };
  return data;
}
function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));
  _showDoctorError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _traverseVersions() {
  const data = require("../component-ops/traverse-versions");
  _traverseVersions = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("../exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
class ObjectsReadableGenerator {
  constructor(repo) {
    this.repo = repo;
    (0, _defineProperty2().default)(this, "readable", void 0);
    (0, _defineProperty2().default)(this, "pushed", []);
    this.readable = new (_stream().Readable)({
      objectMode: true,
      read() {}
    });
  }
  async pushObjectsToReadable(componentsWithOptions) {
    try {
      await this.pushScopeMeta();
      await (0, _pMapSeries().default)(componentsWithOptions, async componentWithOptions => this.pushComponentObjects(componentWithOptions));
      _logger().default.debug(`pushObjectsToReadable, pushed ${this.pushed.length} objects`);
      this.readable.push(null);
    } catch (err) {
      this.readable.destroy(err);
    }
  }
  async pushLanes(lanesToFetch) {
    try {
      await Promise.all(lanesToFetch.map(async laneToFetch => {
        const laneBuffer = await laneToFetch.compress();
        this.push({
          ref: laneToFetch.hash(),
          buffer: laneBuffer
        });
      }));
      this.readable.push(null);
    } catch (err) {
      this.readable.destroy(err);
    }
  }
  async pushObjects(refs, scope) {
    try {
      await (0, _pMapSeries().default)(refs, async ref => {
        const objectItem = await this.getObjectGracefully(ref, scope);
        if (objectItem) this.push(objectItem);
      });
      this.readable.push(null);
    } catch (err) {
      this.readable.destroy(err);
    }
  }
  async getObjectGracefully(ref, scope) {
    try {
      return await scope.getObjectItem(ref);
    } catch (err) {
      _logger().default.warn(`getObjectGracefully: failed retrieving an object ${ref.toString()} from the filesystem.\n${err.message}`);
      return null;
    }
  }
  async pushScopeMeta() {
    const scopeMeta = await this.repo.getScopeMetaObject();
    this.push(scopeMeta);
  }
  push(obj) {
    const hashStr = obj.ref.toString();
    if (this.pushed.includes(hashStr)) {
      return;
    }
    _logger().default.trace('ObjectsReadableGenerator.push', hashStr);
    this.readable.push(obj);
    this.pushed.push(hashStr);
  }
  pushManyObjects(objects) {
    objects.map(obj => this.push(obj));
  }
  async pushComponentObjects(componentWithOptions) {
    const {
      component,
      collectParents,
      collectArtifacts,
      collectParentsUntil
    } = componentWithOptions;
    const version = await component.loadVersion(componentWithOptions.version, this.repo, false);
    if (!version) throw new (_showDoctorError().default)(`failed loading version ${componentWithOptions.version} of ${component.id()}`);
    if (collectParentsUntil && version.hash().isEqual(collectParentsUntil)) {
      return;
    }
    const collectVersionObjects = async ver => {
      const versionRefs = ver.refsWithOptions(false, collectArtifacts);
      const missingVersionRefs = versionRefs.filter(ref => !this.pushed.includes(ref.toString()));
      const versionObjects = await ver.collectManyObjects(this.repo, missingVersionRefs);
      const versionData = {
        ref: ver.hash(),
        buffer: await ver.asRaw(this.repo),
        type: ver.getType()
      };
      return [...versionObjects, versionData];
    };
    try {
      if (!this.pushed.includes(component.hash().toString())) {
        const componentData = {
          ref: component.hash(),
          buffer: await component.asRaw(this.repo),
          type: component.getType()
        };
        this.push(componentData);
      }
      const allVersions = [version];
      if (collectParents) {
        const allParentsHashes = await (0, _traverseVersions().getAllVersionHashesMemoized)({
          modelComponent: component,
          repo: this.repo,
          startFrom: version.hash(),
          stopAt: collectParentsUntil ? [collectParentsUntil] : undefined
        });
        const missingParentsHashes = allParentsHashes.filter(h => !h.isEqual(version.hash()));
        const parentVersions = await (0, _pMapSeries().default)(missingParentsHashes, parentHash => parentHash.load(this.repo));
        allVersions.push(...parentVersions);
        // note: don't bring the head. otherwise, component-delta of the head won't bring all history of this comp.
      }

      await (0, _pMapSeries().default)(allVersions, async ver => {
        const versionObjects = await collectVersionObjects(ver);
        this.pushManyObjects(versionObjects);
      });
    } catch (err) {
      _logger().default.error(`component-version.toObjects ${componentWithOptions.component.id()} got an error`, err);
      // @ts-ignore
      const originalVersionHash = component.getRef(componentWithOptions.version).toString();
      const currentVersionHash = version.hash().toString();
      if (originalVersionHash !== currentVersionHash) {
        throw new (_exceptions().HashMismatch)(component.id(), componentWithOptions.version, originalVersionHash, currentVersionHash);
      }
      throw err;
    }
  }
}
exports.ObjectsReadableGenerator = ObjectsReadableGenerator;