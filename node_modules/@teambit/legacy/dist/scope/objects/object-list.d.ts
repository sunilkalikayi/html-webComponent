/// <reference types="node" />
import { Readable } from 'stream';
import { BitObject } from '.';
import { BitObjectList } from './bit-object-list';
import Ref from './ref';
export declare type ObjectItem = {
    ref: Ref;
    buffer: Buffer;
    type?: string;
    scope?: string;
};
export declare const FETCH_FORMAT_OBJECT_LIST = "ObjectList";
/**
 * Stream.Readable that operates with objectMode, while each 'data' event emits one ObjectItem object.
 */
export declare type ObjectItemsStream = Readable;
export declare class ObjectList {
    objects: ObjectItem[];
    constructor(objects?: ObjectItem[]);
    count(): number;
    static mergeMultipleInstances(objectLists: ObjectList[]): ObjectList;
    mergeObjectList(objectList: ObjectList): void;
    static fromJsonString(jsonStr: string): ObjectList;
    toJsonString(): string;
    toTar(): NodeJS.ReadableStream;
    toReadableStream(): ObjectItemsStream;
    static fromTar(packStream: NodeJS.ReadableStream): Promise<ObjectList>;
    static fromTarToObjectStream(packStream: NodeJS.ReadableStream): ObjectItemsStream;
    static fromObjectStreamToTar(readable: Readable, scopeName: string): any;
    static fromReadableStream(readable: ObjectItemsStream): Promise<ObjectList>;
    /**
     * the opposite of this.combineScopeAndHash
     */
    static extractScopeAndHash(name: string): {
        scope?: string;
        ref: Ref;
    };
    /**
     * the opposite of this.extractScopeAndHash
     */
    static combineScopeAndHash(objectItem: ObjectItem): string;
    addIfNotExist(objectItems: ObjectItem[]): void;
    toBitObjects(): Promise<BitObjectList>;
    static fromBitObjects(bitObjects: BitObject[]): Promise<ObjectList>;
    addScopeName(scopeName: string): void;
    splitByScopeName(): {
        [scopeName: string]: ObjectList;
    };
    /**
     * helps debugging
     */
    toConsoleLog(): void;
}
