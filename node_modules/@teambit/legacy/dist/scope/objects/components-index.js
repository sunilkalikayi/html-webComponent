"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.LaneItem = exports.IndexType = exports.ComponentItem = void 0;
function _without2() {
  const data = _interopRequireDefault(require("ramda/src/without"));
  _without2 = function () {
    return data;
  };
  return data;
}
function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));
  _flatten2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _asyncMutex() {
  const data = require("async-mutex");
  _asyncMutex = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _invalidIndexJson() {
  const data = _interopRequireDefault(require("../exceptions/invalid-index-json"));
  _invalidIndexJson = function () {
    return data;
  };
  return data;
}
function _models() {
  const data = require("../models");
  _models = function () {
    return data;
  };
  return data;
}
function _lane() {
  const data = _interopRequireDefault(require("../models/lane"));
  _lane = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/* eslint max-classes-per-file: 0 */

const COMPONENTS_INDEX_FILENAME = 'index.json';
class ComponentItem {
  constructor(id, isSymlink, hash) {
    this.id = id;
    this.isSymlink = isSymlink;
    this.hash = hash;
  }
  toIdentifierString() {
    const scope = this.id.scope ? `${this.id.scope}/` : '';
    return `component "${scope}${this.id.name}"`;
  }
}
exports.ComponentItem = ComponentItem;
class LaneItem {
  constructor(id, hash) {
    this.id = id;
    this.hash = hash;
  }
  toIdentifierString() {
    const scope = this.id.scope ? `${this.id.scope}/` : '';
    return `lane "${scope}${this.id.name}"`;
  }
  toLaneId() {
    return new (_laneId().LaneId)({
      name: this.id.name,
      scope: this.id.scope
    });
  }
}
exports.LaneItem = LaneItem;
let IndexType;
exports.IndexType = IndexType;
(function (IndexType) {
  IndexType["components"] = "components";
  IndexType["lanes"] = "lanes";
})(IndexType || (exports.IndexType = IndexType = {}));
class ScopeIndex {
  constructor(indexPath, index = {
    [IndexType.components]: [],
    [IndexType.lanes]: []
  }) {
    (0, _defineProperty2().default)(this, "indexPath", void 0);
    (0, _defineProperty2().default)(this, "index", void 0);
    (0, _defineProperty2().default)(this, "writeIndexMutex", new (_asyncMutex().Mutex)());
    this.indexPath = indexPath;
    this.index = index;
  }
  static async load(basePath) {
    const indexPath = this._composePath(basePath);
    try {
      const indexRaw = await _fsExtra().default.readJson(indexPath);
      const getIndexWithBackwardCompatibility = () => {
        if (Array.isArray(indexRaw)) {
          return {
            [IndexType.components]: indexRaw,
            [IndexType.lanes]: []
          };
        }
        return indexRaw;
      };
      const indexObject = getIndexWithBackwardCompatibility();
      const index = {
        [IndexType.components]: indexObject[IndexType.components].map(c => new ComponentItem(c.id, c.isSymlink, c.hash)),
        [IndexType.lanes]: indexObject[IndexType.lanes].map(l => new LaneItem(l.id, l.hash))
      };
      return new ScopeIndex(indexPath, index);
    } catch (err) {
      if (err.message.includes('Unexpected token')) {
        throw new (_invalidIndexJson().default)(indexPath, err.message);
      }
      throw err;
    }
  }
  static create(basePath) {
    const indexPath = this._composePath(basePath);
    return new ScopeIndex(indexPath);
  }
  static async reset(basePath) {
    const indexPath = this._composePath(basePath);
    _logger().default.debug(`ComponentsIndex, deleting the index file at ${indexPath}`);
    await _fsExtra().default.remove(indexPath);
  }
  async write() {
    // write only one at a time to avoid corrupting the json file.
    await this.writeIndexMutex.runExclusive(() => _fsExtra().default.writeJson(this.indexPath, this.index, {
      spaces: 2
    }));
  }
  getAll() {
    return (0, _flatten2().default)(Object.values(this.index));
  }
  getHashes(indexType) {
    // @ts-ignore how to tell TS that all this.index.prop are array?
    return this.index[indexType].map(indexItem => indexItem.hash);
  }
  getHashesByQuery(indexType, filter) {
    // @ts-ignore how to tell TS that all this.index.prop are array?
    return this.index[indexType].filter(filter).map(indexItem => indexItem.hash);
  }
  getHashesIncludeSymlinks() {
    return this.index.components.map(indexItem => indexItem.hash);
  }
  addMany(bitObjects) {
    const added = bitObjects.map(bitObject => this.addOne(bitObject));
    return added.some(oneAdded => oneAdded); // return true if one of the objects was added
  }

  addOne(bitObject) {
    if (!(bitObject instanceof _models().ModelComponent) && !(bitObject instanceof _models().Symlink) && !(bitObject instanceof _lane().default)) return false;
    const hash = bitObject.hash().toString();
    if (bitObject instanceof _lane().default) {
      const found = this.find(hash);
      if (found) {
        if (found.toLaneId().isEqual(bitObject.toLaneId())) return false;
        found.id = bitObject.toLaneId();
      } else {
        const laneItem = new LaneItem(bitObject.toLaneId(), hash);
        this.index.lanes.push(laneItem);
      }
      return true;
    }
    if (bitObject instanceof _models().ModelComponent || bitObject instanceof _models().Symlink) {
      if (this._exist(hash)) return false;
      const componentItem = new ComponentItem({
        scope: bitObject.scope || null,
        name: bitObject.name
      }, bitObject instanceof _models().Symlink, hash);
      this.index.components.push(componentItem);
    }
    return true;
  }
  removeMany(refs) {
    const removed = refs.map(ref => this.removeOne(ref.toString()));
    return removed.some(removedOne => removedOne); // return true if one of the objects was removed
  }

  removeOne(hash) {
    for (const entity of Object.keys(IndexType)) {
      const found = this.index[entity].find(indexItem => indexItem.hash === hash);
      if (found) {
        this.index[entity] = (0, _without2().default)([found], this.index[entity]);
        return true;
      }
    }
    return false;
  }
  async deleteFile() {
    _logger().default.debug(`ComponentsIndex, deleting the index file at ${this.indexPath}`);
    await _fsExtra().default.remove(this.indexPath);
  }
  getPath() {
    return this.indexPath;
  }
  /**
   * it's obviously not accurate. a local path might include 'bithub' as part of the path as well.
   * however, it's needed only for suppressing the error message when the indexJson is outdate,
   * so if it happens on a local scope it's okay.
   * for other purposes, don't rely on this.
   */
  isFileOnBitHub() {
    return this.indexPath.includes('/bithub/') || this.indexPath.includes('/tmp/scope-fs/');
  }
  find(hash) {
    for (const entity of Object.keys(IndexType)) {
      const found = this.index[entity].find(indexItem => indexItem.hash === hash);
      if (found) return found;
    }
    return null;
  }
  _exist(hash) {
    return Boolean(this.find(hash));
  }
  static _composePath(basePath) {
    return path().join(basePath, COMPONENTS_INDEX_FILENAME);
  }
}
exports.default = ScopeIndex;