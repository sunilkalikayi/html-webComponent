"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _zlib() {
  const data = require("zlib");
  _zlib = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _objectRegistrar() {
  const data = require("../object-registrar");
  _objectRegistrar = function () {
    return data;
  };
  return data;
}
function _ref() {
  const data = _interopRequireDefault(require("./ref"));
  _ref = function () {
    return data;
  };
  return data;
}
function parse(buffer) {
  const firstNullByteLocation = buffer.indexOf(_constants().NULL_BYTE);
  const headers = buffer.slice(0, firstNullByteLocation).toString();
  const contents = buffer.slice(firstNullByteLocation + 1, buffer.length);
  const [type, hash] = headers.split(_constants().SPACE_DELIMITER);
  if (!_objectRegistrar().typesObj[type]) throw new Error(`BitObject: unable to find subclass "${type}"`);
  return _objectRegistrar().typesObj[type].parse(contents, hash);
}
class BitObject {
  constructor() {
    (0, _defineProperty2().default)(this, "validateBeforePersist", true);
  }
  // validate the object before persisting
  id() {
    throw new Error('id() was not implemented...');
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  toBuffer(pretty) {
    throw new Error('toBuffer() was not implemented...');
  }
  refs() {
    return [];
  }
  getType() {
    return this.constructor.name;
  }
  getHeader(buffer) {
    return `${this.getType()} ${this.hash().toString()} ${buffer.toString().length}${_constants().NULL_BYTE}`;
  }
  async collectRefs(repo) {
    const refsCollection = [];
    const objectType = this.getType();
    const objectId = objectType === 'Component' ? `Component ${this.id()}` : objectType;
    async function addRefs(object) {
      const refs = object.refs();
      let objs;
      try {
        objs = await Promise.all(refs.map(ref => ref.load(repo, true)));
      } catch (err) {
        if (err.code === 'ENOENT') {
          throw new Error(`failed finding an object file required by ${object.constructor.name} object, originated from ${objectId}
path: ${err.path}`);
        }
        throw err;
      }

      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      refsCollection.push(...refs);
      await Promise.all(objs.map(obj => addRefs(obj)));
    }
    await addRefs(this);
    return refsCollection;
  }
  async collectRaw(repo) {
    const refs = await this.collectRefs(repo);
    return repo.loadManyRaw(refs);
  }
  asRaw(repo) {
    return repo.loadRaw(this.hash());
  }
  collect(repo) {
    const objects = [];
    function addRefs(object) {
      const objs = object.refs().map(ref => {
        return ref.loadSync(repo);
      });
      objects.push(...objs);
      objs.forEach(obj => addRefs(obj));
    }
    addRefs(this);
    return objects;
  }

  /**
   * indexing method
   */
  hash() {
    // console.log(`sha ${sha1(this.id())}, id ${this.id()}`); // uncomment when debugging hash issues
    return new (_ref().default)(BitObject.makeHash(this.id()));
  }
  compress() {
    return (0, _utils().deflate)(this.serialize());
  }
  serialize() {
    const buffer = this.toBuffer();
    return Buffer.concat([Buffer.from(this.getHeader(buffer)), buffer]);
  }

  /**
   * see `this.parseSync` for the sync version
   */
  static async parseObject(fileContents, filePath) {
    const buffer = await (0, _utils().inflate)(fileContents, filePath);
    return parse(buffer);
  }

  // static parse(fileContents: Buffer, types: { [key: string]: Function }): Promise<BitObject> {
  //   return Promise.resolve(parse(fileContents, types));
  // }

  /**
   * prefer using `this.parseObject()`, unless it must be sync.
   */
  static parseSync(fileContents) {
    const buffer = (0, _zlib().inflateSync)(fileContents);
    return parse(buffer);
  }
  static makeHash(str) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return (0, _utils().sha1)(str);
  }
}
exports.default = BitObject;