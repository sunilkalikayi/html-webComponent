/// <reference types="node" />
import { Mutex } from 'async-mutex';
import { PathOsBasedAbsolute } from '../../utils/path';
import RemoteLanes from '../lanes/remote-lanes';
import UnmergedComponents from '../lanes/unmerged-components';
import { ScopeJson } from '../scope-json';
import ScopeIndex, { IndexType } from './components-index';
import BitObject from './object';
import { ObjectItem, ObjectList } from './object-list';
import BitRawObject from './raw-object';
import Ref from './ref';
import { ContentTransformer } from './repository-hooks';
import { Types } from '../object-registrar';
export default class Repository {
    objects: {
        [key: string]: BitObject;
    };
    objectsToRemove: Ref[];
    scopeJson: ScopeJson;
    onRead: ContentTransformer;
    onPersist: ContentTransformer;
    scopePath: string;
    scopeIndex: ScopeIndex;
    private cache;
    remoteLanes: RemoteLanes;
    unmergedComponents: UnmergedComponents;
    persistMutex: Mutex;
    constructor(scopePath: string, scopeJson: ScopeJson);
    static load({ scopePath, scopeJson }: {
        scopePath: string;
        scopeJson: ScopeJson;
    }): Promise<Repository>;
    static create({ scopePath, scopeJson }: {
        scopePath: string;
        scopeJson: ScopeJson;
    }): Repository;
    static reset(scopePath: string): Promise<void>;
    static getPathByScopePath(scopePath: string): string;
    static onPostObjectsPersist: () => Promise<void>;
    ensureDir(): Promise<void>;
    getPath(): string;
    getBackupPath(dirName?: string): string;
    getLicense(): Promise<string>;
    getScopeMetaObject(): Promise<ObjectItem>;
    objectPath(ref: Ref): string;
    has(ref: Ref): Promise<boolean>;
    load(ref: Ref, throws?: boolean, preferInMemoryObjects?: boolean): Promise<BitObject>;
    /**
     * this is restricted to provide objects according to the given types. Otherwise, big scopes (>1GB) could crush.
     * example usage: `this.list([ModelComponent, Symlink, Lane])`
     */
    list(types: Types): Promise<BitObject[]>;
    listRefs(cwd?: string): Promise<Array<Ref>>;
    listRawObjects(): Promise<any>;
    listObjectsFromIndex(indexType: IndexType, filter?: Function): Promise<BitObject[]>;
    getHashFromIndex(indexType: IndexType, filter: Function): string | null;
    _getBitObjectsByHashes(hashes: string[]): Promise<BitObject[]>;
    loadOptionallyCreateScopeIndex(): Promise<ScopeIndex>;
    loadRaw(ref: Ref): Promise<Buffer>;
    loadManyRaw(refs: Ref[]): Promise<ObjectItem[]>;
    loadManyRawIgnoreMissing(refs: Ref[]): Promise<ObjectItem[]>;
    loadRawObject(ref: Ref): Promise<BitRawObject>;
    /**
     * prefer using `this.load()` for an async version, which also writes to the cache
     */
    loadSync(ref: Ref, throws?: boolean): BitObject;
    setCache(object: BitObject): this;
    getCache(ref: Ref): BitObject | undefined;
    removeFromCache(ref: Ref): void;
    clearCache(): void;
    backup(dirName?: string): void;
    add(object: BitObject | null | undefined): Repository;
    addMany(objects: BitObject[]): Repository;
    removeObject(ref: Ref): void;
    removeManyObjects(refs: Ref[]): void;
    findMany(refs: Ref[]): Promise<BitObject[]>;
    /**
     * important! use this method only for commands that are non running on an http server.
     *
     * it's better to remove/delete objects directly and not using the `objects` member.
     * it helps to avoid multiple processes running concurrently on an http server.
     *
     * persist objects changes (added and removed) into the filesystem
     * do not call this function multiple times in parallel, otherwise, it'll damage the index.json file.
     * call this function only once after you added and removed all applicable objects.
     */
    persist(validate?: boolean): Promise<void>;
    writeRemoteLanes(): Promise<void>;
    /**
     * this is especially critical for http server, where one process lives long and serves multiple
     * exports. without this, the objects get accumulated over time and being rewritten over and over
     * again.
     */
    private clearObjects;
    /**
     * normally, the validation step takes place just before the acutal writing of the file.
     * however, this can be an issue where a component has an invalid version. the component could
     * be saved before validating the version (see #1727). that's why we validate here before writing
     * anything to the filesystem.
     * the open question here is whether should we validate again before the actual writing or it
     * should be enough to validate here?
     * for now, it does validate again before saving, only to be 100% sure nothing happens in a few
     * lines of code until the actual writing. however, if the performance penalty is noticeable, we
     * can easily revert it by changing `bitObject.validateBeforePersist = false` line run regardless
     * the `validate` argument.
     */
    validateObjects(validate: boolean, objects: BitObject[]): void;
    deleteObjectsFromFS(refs: Ref[]): Promise<void>;
    deleteRecordsFromUnmergedComponents(componentNames: string[]): Promise<void>;
    /**
     * write all objects to the FS and index the components/lanes/symlink objects
     */
    writeObjectsToTheFS(objects: BitObject[]): Promise<void>;
    /**
     * do not call this method directly. always call this.removeObject() and once done with all objects,
     * call this.persist()
     */
    _deleteOne(ref: Ref): Promise<boolean>;
    /**
     * always prefer this.persist() or this.writeObjectsToTheFS()
     * this method doesn't write to scopeIndex. so using this method for ModelComponent or
     * Symlink makes the index outdated.
     */
    _writeOne(object: BitObject): Promise<boolean>;
    writeObjectsToPendingDir(objectList: ObjectList, pendingDir: PathOsBasedAbsolute): Promise<void>;
    readObjectsFromPendingDir(pendingDir: PathOsBasedAbsolute): Promise<ObjectList>;
    private hashPath;
}
