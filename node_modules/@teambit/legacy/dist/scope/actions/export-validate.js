"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExportValidate = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _glob() {
  const data = _interopRequireDefault(require("glob"));
  _glob = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _exportScopeComponents() {
  const data = require("../component-ops/export-scope-components");
  _exportScopeComponents = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _serverIsBusy() {
  const data = _interopRequireDefault(require("../exceptions/server-is-busy"));
  _serverIsBusy = function () {
    return data;
  };
  return data;
}
const NUM_OF_RETRIES = 60;
const WAIT_BEFORE_RETRY_IN_MS = 1000;

/**
 * do not save anything. just make sure the objects can be merged and there are no conflicts.
 * once done, clear the objects from the memory so then they won't be used by mistake later on.
 * this also makes sure that non-external dependencies are not missing.
 */
class ExportValidate {
  constructor() {
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "clientId", void 0);
  }
  async execute(scope, options) {
    this.scope = scope;
    this.clientId = options.clientId;
    if (options.isResumingExport && !this.clientIdExistsInPendingDir()) {
      // when resuming export, some scopes may have the objects persisted already and as such, the
      // pending-dir was deleted.
      return;
    }
    await this.waitIfNeeded();
    const objectList = await scope.readObjectsFromPendingDir(options.clientId);
    try {
      await (0, _exportScopeComponents().mergeObjects)(scope, objectList, true); // if fails, it throws merge-conflict/component-not-found
    } catch (err) {
      scope.objects.clearCache(); // we don't want to persist anything by mistake.
      throw err;
    }
    scope.objects.clearCache();
  }
  async waitIfNeeded() {
    let clientQueue = this.getClientsQueue();
    if (clientQueue[0] === this.clientId) return; // it's your turn
    _logger().default.debug(`export-validate, waitIfNeeded - ${clientQueue.length} clients in queue (including current)`);
    for (let i = 0; i < NUM_OF_RETRIES; i += 1) {
      _logger().default.debug(`export-validate, waitIfNeeded - ${i} out of ${NUM_OF_RETRIES}`);
      // eslint-disable-next-line no-await-in-loop
      await this.sleep(WAIT_BEFORE_RETRY_IN_MS);
      clientQueue = this.getClientsQueue();
      if (clientQueue[0] === this.clientId) {
        break;
      }
    }
    if (clientQueue[0] === this.clientId) return; // it's your turn
    throw new (_serverIsBusy().default)(clientQueue.length, clientQueue[0]);
  }
  getPendingDir() {
    return _path().default.join(this.scope.path, _constants().PENDING_OBJECTS_DIR);
  }
  async sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  clientIdExistsInPendingDir() {
    const clientsIds = this.getClientIdsDirs();
    return clientsIds.includes(this.clientId);
  }
  getClientsQueue() {
    const clientsIds = this.getClientIdsDirs();
    if (!clientsIds.length) {
      throw new Error(`pending-dir of "${this.scope.name}" doesn't have any data`);
    }
    if (!clientsIds.includes(this.clientId)) {
      throw new Error(`pending-dir of "${this.scope.name}" doesn't have the client ${this.clientId} data`);
    }
    return clientsIds.sort();
  }
  getClientIdsDirs() {
    const cwd = this.getPendingDir();
    return _glob().default.sync('*', {
      cwd
    });
  }
}
exports.ExportValidate = ExportValidate;