"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.multipleVersionDependenciesToConsumer = multipleVersionDependenciesToConsumer;
function _bitId() {
  const data = require("../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _componentDependencies() {
  const data = _interopRequireDefault(require("./component-dependencies"));
  _componentDependencies = function () {
    return data;
  };
  return data;
}
function _dependenciesNotFound() {
  const data = require("./exceptions/dependencies-not-found");
  _dependenciesNotFound = function () {
    return data;
  };
  return data;
}
class VersionDependencies {
  constructor(component, dependencies, version) {
    this.component = component;
    this.dependencies = dependencies;
    this.version = version;
  }
  get allDependencies() {
    return this.dependencies;
  }
  get allDependenciesIds() {
    return _bitId().BitIds.fromArray(this.dependencies.map(dep => dep.id));
  }
  getMissingDependencies() {
    const allDepsIds = this.allDependenciesIds;
    return this.version.flattenedDependencies.filter(id => !allDepsIds.has(id));
  }
  throwForMissingDependencies() {
    const missing = this.getMissingDependencies();
    if (missing.length) {
      throw new (_dependenciesNotFound().DependenciesNotFound)(this.component.id.toString(), missing.map(m => m.toString()));
    }
  }
  async toConsumer(repo) {
    const depToConsumer = dep => dep.toConsumer(repo);
    const dependenciesP = Promise.all(this.dependencies.map(depToConsumer));
    const componentP = this.component.toConsumer(repo);
    const [component, dependencies] = await Promise.all([componentP, dependenciesP]);
    return new (_componentDependencies().default)({
      component,
      dependencies,
      devDependencies: [],
      extensionDependencies: [],
      missingDependencies: this.getMissingDependencies()
    });
  }
}
exports.default = VersionDependencies;
async function multipleVersionDependenciesToConsumer(versionDependencies, repo) {
  const flattenedCompVer = {};
  const flattenedConsumerComp = {};
  versionDependencies.forEach(verDep => {
    const allComps = [verDep.component, ...verDep.dependencies];
    allComps.forEach(compVer => {
      flattenedCompVer[compVer.id.toString()] = compVer;
    });
  });
  await Promise.all(Object.keys(flattenedCompVer).map(async idStr => {
    flattenedConsumerComp[idStr] = await flattenedCompVer[idStr].toConsumer(repo);
  }));
  return versionDependencies.map(verDep => {
    return new (_componentDependencies().default)({
      component: flattenedConsumerComp[verDep.component.id.toString()],
      dependencies: verDep.dependencies.map(d => flattenedConsumerComp[d.id.toString()]),
      devDependencies: [],
      extensionDependencies: [],
      missingDependencies: verDep.getMissingDependencies()
    });
  });
}