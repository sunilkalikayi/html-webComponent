"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectFetcher = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _stream() {
  const data = require("stream");
  _stream = function () {
    return data;
  };
  return data;
}
function _util() {
  const data = require("util");
  _util = function () {
    return data;
  };
  return data;
}
function _pMap() {
  const data = _interopRequireDefault(require("p-map"));
  _pMap = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("../../cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("../exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _errorFromRemote() {
  const data = require("../exceptions/error-from-remote");
  _errorFromRemote = function () {
    return data;
  };
  return data;
}
function _exceptions2() {
  const data = require("../network/exceptions");
  _exceptions2 = function () {
    return data;
  };
  return data;
}
function _objectsWritableStream() {
  const data = require("./objects-writable-stream");
  _objectsWritableStream = function () {
    return data;
  };
  return data;
}
function _writeComponentsQueue() {
  const data = require("./write-components-queue");
  _writeComponentsQueue = function () {
    return data;
  };
  return data;
}
function _writeObjectsQueue() {
  const data = require("./write-objects-queue");
  _writeObjectsQueue = function () {
    return data;
  };
  return data;
}
function _scopeComponentsImporter() {
  const data = require("../component-ops/scope-components-importer");
  _scopeComponentsImporter = function () {
    return data;
  };
  return data;
}
function _concurrency() {
  const data = require("../../utils/concurrency");
  _concurrency = function () {
    return data;
  };
  return data;
}
function _scopeNotFoundOrDenied() {
  const data = require("../../remotes/exceptions/scope-not-found-or-denied");
  _scopeNotFoundOrDenied = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * due to the use of streams, this is memory efficient and can handle easily GBs of objects.
 * this class first fetches objects from remotes and as soon as the remote returns a stream, it
 * pipes it into the Writable stream, which in turn, adds the objects into the queue, which writes
 * them into the filesystem.
 *
 * the immutable objects (such as files/versions) are processed with a high concurrency, see
 * WriteObjectsQueue. the mutable objects, such as components, are written serially mostly because
 * two remotes can bring the same component and if both components executing the "merge" operation
 * at the same time, the result is unpredictable. (see model-component-merger).
 */
class ObjectFetcher {
  constructor(repo, scope, remotes, fetchOptions, ids, lanes = [], context = {}, throwOnUnavailableScope = true) {
    this.repo = repo;
    this.scope = scope;
    this.remotes = remotes;
    this.fetchOptions = fetchOptions;
    this.ids = ids;
    this.lanes = lanes;
    this.context = context;
    this.throwOnUnavailableScope = throwOnUnavailableScope;
    (0, _defineProperty2().default)(this, "failedScopes", {});
  }
  async fetchFromRemoteAndWrite() {
    this.fetchOptions = _objectSpread({
      type: 'component',
      withoutDependencies: true,
      includeArtifacts: false,
      allowExternal: Boolean(this.lanes.length)
    }, this.fetchOptions);
    const idsGrouped = this.lanes.length ? (0, _scopeComponentsImporter().groupByLanes)(this.ids, this.lanes) : (0, _scopeComponentsImporter().groupByScopeName)(this.ids);
    const scopes = Object.keys(idsGrouped);
    _logger().default.debug(`[-] Running fetch on ${scopes.length} remote(s), to get ${this.ids.length} id(s), with the following options`, this.fetchOptions);
    const objectsQueue = new (_writeObjectsQueue().WriteObjectsQueue)();
    const componentsQueue = new (_writeComponentsQueue().WriteComponentsQueue)();
    this.showProgress(objectsQueue, componentsQueue);
    await (0, _pMap().default)(scopes, async scopeName => {
      const readableStream = await this.fetchFromSingleRemote(scopeName, idsGrouped[scopeName]);
      if (!readableStream) return;
      await this.writeFromSingleRemote(readableStream, scopeName, objectsQueue, componentsQueue);
    }, {
      concurrency: (0, _concurrency().concurrentFetchLimit)()
    });
    if (Object.keys(this.failedScopes).length) {
      const failedScopesErr = Object.keys(this.failedScopes).map(failedScope => `${failedScope} - ${this.failedScopes[failedScope].message}`);
      throw new Error(`unexpected network error has occurred during fetching scopes: ${Object.keys(this.failedScopes).join(', ')}
server responded with the following error messages:
${failedScopesErr.join('\n')}`);
    }
    await Promise.all([objectsQueue.onIdle(), componentsQueue.onIdle()]);
    _logger().default.debug(`[-] fetchFromRemoteAndWrite, completed writing ${objectsQueue.added} objects`);
    _loader().default.start('all objects were processed and written to the filesystem successfully');
    await this.repo.writeRemoteLanes();
  }
  async fetchFromSingleRemote(scopeName, ids) {
    // when importing directly from a remote scope, throw for ScopeNotFound. otherwise, when
    // fetching flattened dependencies (withoutDependencies=true), ignore this error
    const shouldThrowOnUnavailableScope = this.throwOnUnavailableScope && !this.fetchOptions.withoutDependencies;
    let remote;
    try {
      remote = await this.remotes.resolve(scopeName, this.scope);
    } catch (err) {
      if (err instanceof _scopeNotFoundOrDenied().ScopeNotFoundOrDenied) {
        throw new Error(`unable to import the following component(s): ${ids.join(', ')}.
the remote scope "${scopeName}" was not found`);
      }
      throw err;
    }
    try {
      return await remote.fetch(ids, this.fetchOptions, this.context);
    } catch (err) {
      if (err instanceof _exceptions().ScopeNotFound && !shouldThrowOnUnavailableScope) {
        _logger().default.error(`failed accessing the scope "${scopeName}". continuing without this scope.`);
      } else if (err instanceof _exceptions2().UnexpectedNetworkError) {
        _logger().default.error(`failed fetching from ${scopeName}`, err);
        this.failedScopes[scopeName] = err;
      } else {
        throw err;
      }
      return null;
    }
  }
  async writeFromSingleRemote(objectsStream, scopeName, objectsQueue, componentsQueue) {
    const writable = new (_objectsWritableStream().ObjectsWritable)(this.repo, this.scope.sources, scopeName, objectsQueue, componentsQueue);
    const pipelinePromise = (0, _util().promisify)(_stream().pipeline);
    // add an error listener for the ObjectList to differentiate between errors coming from the
    // remote and errors happening inside the Writable.
    let readableError;
    objectsStream.on('error', err => {
      readableError = err;
    });
    try {
      await pipelinePromise(objectsStream, writable);
    } catch (err) {
      if (readableError) {
        if (!readableError.message) {
          _logger().default.error(`error coming from a remote has no message, please fix!`, readableError);
        }
        throw new (_errorFromRemote().ErrorFromRemote)(scopeName, readableError.message || 'unknown error');
      }
      // the error is coming from the writable, no need to treat it specially. just throw it.
      throw err;
    }
  }
  showProgress(objectsQueue, componentsQueue) {
    let objectsAdded = 0;
    let objectsCompleted = 0;
    let componentsAdded = 0;
    let componentsCompleted = 0;
    objectsQueue.getQueue().on('add', () => {
      objectsAdded += 1;
      if (objectsAdded % 100 === 0) {
        _loader().default.start(`Downloaded ${objectsAdded} objects, ${componentsAdded} components. Processed successfully ${objectsCompleted} objects, ${componentsCompleted} components`);
      }
    });
    objectsQueue.getQueue().on('next', () => {
      objectsCompleted += 1;
      if (objectsAdded % 100 === 0) {
        _loader().default.start(`Downloaded ${objectsAdded} objects, ${componentsAdded} components. Processed successfully ${objectsCompleted} objects, ${componentsCompleted} components`);
      }
    });
    componentsQueue.getQueue().on('add', () => {
      componentsAdded += 1;
    });
    componentsQueue.getQueue().on('next', () => {
      componentsCompleted += 1;
    });
  }
}
exports.ObjectFetcher = ObjectFetcher;