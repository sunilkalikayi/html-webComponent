"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectsWritable = void 0;
function _stream() {
  const data = require("stream");
  _stream = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _objects() {
  const data = require("../objects");
  _objects = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _modelComponentsMerger() {
  const data = require("../component-ops/model-components-merger");
  _modelComponentsMerger = function () {
    return data;
  };
  return data;
}
function _models() {
  const data = require("../models");
  _models = function () {
    return data;
  };
  return data;
}
/**
 * first, write all immutable objects, such as files/sources/versions into the filesystem, as they arrive.
 * even if the process will crush later and the component-object won't be written, there is no
 * harm of writing these objects.
 * then, merge the component objects and write them to the filesystem. the index.json is written
 * as well to make sure they're indexed immediately, even if the process crushes on the next remote.
 * finally, take care of the lanes. the remote-lanes are not written at this point, only once all
 * remotes are processed. see @writeManyObjectListToModel.
 */
class ObjectsWritable extends _stream().Writable {
  constructor(repo, sources, remoteName, objectsQueue, componentsQueue) {
    super({
      objectMode: true
    });
    this.repo = repo;
    this.sources = sources;
    this.remoteName = remoteName;
    this.objectsQueue = objectsQueue;
    this.componentsQueue = componentsQueue;
  }
  async _write(obj, _, callback) {
    _logger().default.trace('ObjectsWritable.write', obj.ref);
    if (!obj.ref || !obj.buffer) {
      return callback(new Error('objectItem expected to have "ref" and "buffer" props'));
    }
    try {
      await this.writeObjectToFs(obj);
      return callback();
    } catch (err) {
      return callback(err);
    }
  }
  async writeObjectToFs(obj) {
    const bitObject = await _objects().BitObject.parseObject(obj.buffer);
    if (bitObject instanceof _models().Lane) {
      throw new Error('ObjectsWritable does not support lanes');
    }
    if (bitObject instanceof _models().ModelComponent) {
      await this.componentsQueue.addComponent(bitObject.id(), () => this.writeComponentObject(bitObject));
    } else {
      await this.objectsQueue.addImmutableObject(obj.ref.toString(), () => this.writeImmutableObject(bitObject));
    }
  }
  async writeImmutableObject(bitObject) {
    await this.repo.writeObjectsToTheFS([bitObject]);
  }
  async writeComponentObject(modelComponent) {
    const component = await this.mergeModelComponent(modelComponent, this.remoteName);
    const componentIsPersistPendingAlready = this.repo.objects[component.hash().toString()];
    if (componentIsPersistPendingAlready) {
      // this happens during tag/snap, when all objects are waiting in the repo.objects and only once the tag/snap is
      // completed, all objects are persisted at once. we don't want the import process to interfere and save
      // components objects during the tag/snap.
      return;
    }
    await this.repo.writeObjectsToTheFS([component]);
    await this.repo.remoteLanes.addEntriesFromModelComponents(_laneId().LaneId.from(_laneId().DEFAULT_LANE, this.remoteName), [component]);
  }

  /**
   * merge the imported component with the existing component in the local scope.
   * when importing a component, save the remote head into the remote main ref file.
   * unless this component arrived as a cache of the dependent, which its head might be wrong
   */
  async mergeModelComponent(incomingComp, remoteName) {
    const isIncomingFromOrigin = remoteName === incomingComp.scope;
    const existingComp = await this.sources._findComponent(incomingComp);
    if (!existingComp || existingComp && incomingComp.isEqual(existingComp)) {
      if (isIncomingFromOrigin) incomingComp.remoteHead = incomingComp.head;
      return incomingComp;
    }
    const modelComponentMerger = new (_modelComponentsMerger().ModelComponentMerger)(existingComp, incomingComp, true, isIncomingFromOrigin);
    const {
      mergedComponent
    } = await modelComponentMerger.merge();
    if (isIncomingFromOrigin) mergedComponent.remoteHead = incomingComp.head;
    return mergedComponent;
  }
}
exports.ObjectsWritable = ObjectsWritable;