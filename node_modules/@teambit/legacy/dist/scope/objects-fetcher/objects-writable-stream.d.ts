/// <reference types="node" />
import { Writable } from 'stream';
import { Repository } from '../objects';
import { SourceRepository } from '../repositories';
import { ObjectItem } from '../objects/object-list';
import { WriteObjectsQueue } from './write-objects-queue';
import { WriteComponentsQueue } from './write-components-queue';
/**
 * first, write all immutable objects, such as files/sources/versions into the filesystem, as they arrive.
 * even if the process will crush later and the component-object won't be written, there is no
 * harm of writing these objects.
 * then, merge the component objects and write them to the filesystem. the index.json is written
 * as well to make sure they're indexed immediately, even if the process crushes on the next remote.
 * finally, take care of the lanes. the remote-lanes are not written at this point, only once all
 * remotes are processed. see @writeManyObjectListToModel.
 */
export declare class ObjectsWritable extends Writable {
    private repo;
    private sources;
    private remoteName;
    private objectsQueue;
    private componentsQueue;
    constructor(repo: Repository, sources: SourceRepository, remoteName: string, objectsQueue: WriteObjectsQueue, componentsQueue: WriteComponentsQueue);
    _write(obj: ObjectItem, _: any, callback: Function): Promise<any>;
    private writeObjectToFs;
    private writeImmutableObject;
    private writeComponentObject;
    /**
     * merge the imported component with the existing component in the local scope.
     * when importing a component, save the remote head into the remote main ref file.
     * unless this component arrived as a cache of the dependent, which its head might be wrong
     */
    private mergeModelComponent;
}
