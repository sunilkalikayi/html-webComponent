import { BitId } from '@teambit/legacy-bit-id';
import { Scope } from '..';
import { FETCH_OPTIONS } from '../../api/scope/lib/fetch';
import { Remotes } from '../../remotes';
import { Repository } from '../objects';
import { Lane } from '../models';
/**
 * due to the use of streams, this is memory efficient and can handle easily GBs of objects.
 * this class first fetches objects from remotes and as soon as the remote returns a stream, it
 * pipes it into the Writable stream, which in turn, adds the objects into the queue, which writes
 * them into the filesystem.
 *
 * the immutable objects (such as files/versions) are processed with a high concurrency, see
 * WriteObjectsQueue. the mutable objects, such as components, are written serially mostly because
 * two remotes can bring the same component and if both components executing the "merge" operation
 * at the same time, the result is unpredictable. (see model-component-merger).
 */
export declare class ObjectFetcher {
    private repo;
    private scope;
    private remotes;
    private fetchOptions;
    private ids;
    private lanes;
    private context;
    private throwOnUnavailableScope;
    private failedScopes;
    constructor(repo: Repository, scope: Scope, remotes: Remotes, fetchOptions: Partial<FETCH_OPTIONS>, ids: BitId[], lanes?: Lane[], context?: {}, throwOnUnavailableScope?: boolean);
    fetchFromRemoteAndWrite(): Promise<void>;
    private fetchFromSingleRemote;
    private writeFromSingleRemote;
    private showProgress;
}
