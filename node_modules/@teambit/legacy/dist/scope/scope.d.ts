import { LaneId } from '@teambit/lane-id';
import { BitId, BitIds } from '../bit-id';
import { BitIdStr } from '../bit-id/bit-id';
import Component from '../consumer/component/consumer-component';
import { ExtensionDataEntry } from '../consumer/config';
import Consumer from '../consumer/consumer';
import { MigrationResult } from '../migration/migration-helper';
import { PathOsBasedAbsolute } from '../utils/path';
import ScopeComponentsImporter from './component-ops/scope-components-importer';
import ComponentVersion from './component-version';
import DependencyGraph from './graph/scope-graph';
import Lanes from './lanes/lanes';
import { ModelComponent, Symlink, Version } from './models';
import Lane from './models/lane';
import { ComponentLog } from './models/model-component';
import { BitObject, BitRawObject, Ref, Repository } from './objects';
import RemovedObjects from './removed-components';
import { Tmp } from './repositories';
import SourcesRepository from './repositories/sources';
import { ScopeJson } from './scope-json';
import VersionDependencies from './version-dependencies';
import { ObjectItem, ObjectList } from './objects/object-list';
declare type HasIdOpts = {
    includeSymlink?: boolean;
    includeOrphaned?: boolean;
    includeVersion?: boolean;
};
export declare type ScopeDescriptor = {
    name: string;
};
export declare type ScopeProps = {
    path: string;
    scopeJson: ScopeJson;
    created?: boolean;
    tmp?: Tmp;
    sources?: SourcesRepository;
    objects: Repository;
    isBare?: boolean;
};
export declare type IsolateOptions = {
    directory: string | null | undefined;
    write_bit_dependencies: boolean | null | undefined;
    links: boolean | null | undefined;
    install_packages: boolean | null | undefined;
    installPeerDependencies: boolean | null | undefined;
    no_package_json: boolean | null | undefined;
    override: boolean | null | undefined;
};
export declare type ComponentsAndVersions = {
    component: ModelComponent;
    version: Version;
    versionStr: string;
};
export declare type LegacyOnTagResult = {
    id: BitId;
    builderData: ExtensionDataEntry;
};
export declare type IsolateComponentsOptions = {
    packageManagerConfigRootDir?: string;
};
export default class Scope {
    created: boolean;
    scopeJson: ScopeJson;
    tmp: Tmp;
    path: string;
    isBare: boolean;
    scopeImporter: ScopeComponentsImporter;
    sources: SourcesRepository;
    objects: Repository;
    _dependencyGraph: DependencyGraph;
    lanes: Lanes;
    /**
     * normally, the data about the current-lane is saved in .bitmap. the reason for having this prop here is that we
     * need this data when loading model-component, which gets called in multiple places where the consumer is not passed.
     * another instance this is needed is for bit-sign, this way when loading aspects and fetching dists, it'll go to lane-scope.
     */
    currentLaneId?: LaneId;
    constructor(scopeProps: ScopeProps);
    static onPostExport: (ids: BitId[], lanes: Lane[]) => Promise<void>;
    /**
     * import components to the `Scope.
     */
    import(ids: BitIds, cache?: boolean, reFetchUnBuiltVersion?: boolean, lanes?: Lane[]): Promise<VersionDependencies[]>;
    getDependencyGraph(): Promise<DependencyGraph>;
    get groupName(): string | null | undefined;
    get name(): string;
    get isLegacy(): boolean;
    setCurrentLaneId(laneId?: LaneId): void;
    getPath(): string;
    getComponentsPath(): string;
    /**
     * Get the relative components path inside the scope
     * (components such as compilers / testers / extensions)
     * currently components
     */
    static getComponentsRelativePath(): string;
    /**
     * Get a relative (to scope) path to a specific component such as compiler / tester / extension
     * Support getting the latest installed version
     * @param {BitId} id
     */
    static getComponentRelativePath(id: BitId, scopePath?: string): string;
    getBitPathInComponentsDir(id: BitId): string;
    /**
     * Running migration process for scope to update the stores (bit objects) to the current version
     *
     * @param {any} verbose - print debug logs
     * @returns {Object} - wether the process run and wether it successeded
     * @memberof Consumer
     */
    migrate(verbose: boolean): Promise<MigrationResult>;
    describe(): ScopeDescriptor;
    toConsumerComponents(components: ModelComponent[]): Promise<Component[]>;
    hasId(id: BitId, opts: HasIdOpts): Promise<boolean>;
    list(): Promise<ModelComponent[]>;
    listIncludesSymlinks(): Promise<Array<ModelComponent | Symlink>>;
    listIncludeRemoteHead(laneId: LaneId): Promise<ModelComponent[]>;
    listLocal(): Promise<ModelComponent[]>;
    listLanes(): Promise<Lane[]>;
    loadLane(id: LaneId): Promise<Lane | null>;
    loadLaneByHash(ref: Ref): Promise<Lane | null>;
    /**
     * sadly, there are not good tests for this. it pretty complex to create them as it involves multiple scopes and
     * packages installations. be careful when changing this.
     * the goal is to check whether a given id with the given version exits on the given lane or it's on main.
     * it's needed for importing artifacts to know whether the artifact could be found on the origin scope or on the
     * lane-scope
     */
    isIdOnLane(id: BitId, lane?: Lane | null): Promise<boolean>;
    latestVersions(componentIds: BitId[], throwOnFailure?: boolean): Promise<BitIds>;
    getObject(hash: string): Promise<BitObject>;
    getRawObject(hash: string): Promise<BitRawObject>;
    getObjectItems(refs: Ref[]): Promise<ObjectItem[]>;
    getObjectItem(ref: Ref): Promise<ObjectItem>;
    getModelComponentIfExist(id: BitId): Promise<ModelComponent | undefined>;
    getCurrentLaneObject(): Promise<Lane | null>;
    /**
     * Remove components from scope
     * @force Boolean - remove component from scope even if other components use it
     */
    removeMany(bitIds: BitIds, force: boolean, consumer?: Consumer, fromLane?: boolean): Promise<RemovedObjects>;
    /**
     * for each one of the given components, find its dependents
     */
    getDependentsBitIds(bitIds: BitIds, returnResultsWithVersion?: boolean): Promise<{
        [key: string]: BitId[];
    }>;
    /**
     * split bit array to found and missing components (incase user misspelled id)
     */
    filterFoundAndMissingComponents(bitIds: BitIds): Promise<{
        missingComponents: BitIds;
        foundComponents: BitIds;
    }>;
    /**
     * load components from the model and return them as ComponentVersion array.
     * if a component is not available locally, it'll just ignore it without throwing any error.
     */
    loadLocalComponents(ids: BitIds): Promise<ComponentVersion[]>;
    loadComponentLogs(id: BitId, shortHash?: boolean, startFrom?: string): Promise<ComponentLog[]>;
    loadAllVersions(id: BitId): Promise<Component[]>;
    /**
     * get ModelComponent instance per bit-id.
     * it throws an error if the component wasn't found.
     * @see getModelComponentIfExist to not throw an error
     * @see getModelComponentIgnoreScope to ignore the scope name
     */
    getModelComponent(id: BitId): Promise<ModelComponent>;
    /**
     * the id can be either with or without a scope-name.
     * in case the component is saved in the model only with the scope (imported), it loads all
     * components and search for it.
     * it throws an error if the component wasn't found.
     */
    getModelComponentIgnoreScope(id: BitId): Promise<ModelComponent>;
    /**
     * throws if component was not found
     */
    getConsumerComponent(id: BitId): Promise<Component>;
    getManyConsumerComponents(ids: BitId[]): Promise<Component[]>;
    /**
     * return undefined if component was not found
     */
    getConsumerComponentIfExist(id: BitId): Promise<Component | undefined>;
    getVersionInstance(id: BitId): Promise<Version>;
    getComponentsAndVersions(ids: BitIds, defaultToLatestVersion?: boolean): Promise<ComponentsAndVersions[]>;
    isComponentInScope(id: BitId): Promise<boolean>;
    /**
     * Creates a symlink object with the local-scope which links to the real-object of the remote-scope
     * This way, local components that have dependencies to the exported component won't break.
     */
    createSymlink(id: BitId, remote: string): Repository;
    ensureDir(): Promise<this>;
    /**
     * find the components in componentsPool which one of their dependencies include in potentialDependencies
     */
    findDirectDependentComponents(componentsPool: BitIds, potentialDependencies: BitIds): Promise<BitIds>;
    loadModelComponentByIdStr(id: string): Promise<ModelComponent>;
    getParsedId(id: BitIdStr): Promise<BitId>;
    /**
     * returns the main ids of the given lane
     */
    getDefaultLaneIdsFromLane(lane: Lane): Promise<BitId[]>;
    writeObjectsToPendingDir(objectList: ObjectList, clientId: string): Promise<void>;
    readObjectsFromPendingDir(clientId: string): Promise<ObjectList>;
    removePendingDir(clientId: string): Promise<void>;
    static ensure(path: PathOsBasedAbsolute, name?: string | null, groupName?: string | null): Promise<Scope>;
    static ensureScopeJson(path: PathOsBasedAbsolute, name?: string | null | undefined, groupName?: string | null | undefined): ScopeJson;
    static scopeCache: {
        [path: string]: Scope;
    };
    static reset(path: PathOsBasedAbsolute, resetHard: boolean): Promise<void>;
    static load(absPath: string, useCache?: boolean): Promise<Scope>;
}
export {};
