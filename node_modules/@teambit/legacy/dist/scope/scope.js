"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _isNil2() {
  const data = _interopRequireDefault(require("ramda/src/isNil"));
  _isNil2 = function () {
    return data;
  };
  return data;
}
function _reject2() {
  const data = _interopRequireDefault(require("ramda/src/reject"));
  _reject2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function pathLib() {
  const data = _interopRequireWildcard(require("path"));
  pathLib = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _semver() {
  const data = _interopRequireDefault(require("semver"));
  _semver = function () {
    return data;
  };
  return data;
}
function _analytics() {
  const data = require("../analytics/analytics");
  _analytics = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("../cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
function _loaderMessages() {
  const data = require("../cli/loader/loader-messages");
  _loaderMessages = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _migrationHelper() {
  const data = _interopRequireDefault(require("../migration/migration-helper"));
  _migrationHelper = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _removeModelComponents() {
  const data = _interopRequireDefault(require("./component-ops/remove-model-components"));
  _removeModelComponents = function () {
    return data;
  };
  return data;
}
function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("./component-ops/scope-components-importer"));
  _scopeComponentsImporter = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _scopeGraph() {
  const data = _interopRequireDefault(require("./graph/scope-graph"));
  _scopeGraph = function () {
    return data;
  };
  return data;
}
function _lanes() {
  const data = _interopRequireDefault(require("./lanes/lanes"));
  _lanes = function () {
    return data;
  };
  return data;
}
function _scopeMigrator() {
  const data = _interopRequireDefault(require("./migrations/scope-migrator"));
  _scopeMigrator = function () {
    return data;
  };
  return data;
}
function _scopeMigratorManifest() {
  const data = _interopRequireDefault(require("./migrations/scope-migrator-manifest"));
  _scopeMigratorManifest = function () {
    return data;
  };
  return data;
}
function _models() {
  const data = require("./models");
  _models = function () {
    return data;
  };
  return data;
}
function _objects() {
  const data = require("./objects");
  _objects = function () {
    return data;
  };
  return data;
}
function _componentsIndex() {
  const data = require("./objects/components-index");
  _componentsIndex = function () {
    return data;
  };
  return data;
}
function _repositories() {
  const data = require("./repositories");
  _repositories = function () {
    return data;
  };
  return data;
}
function _sources() {
  const data = _interopRequireDefault(require("./repositories/sources"));
  _sources = function () {
    return data;
  };
  return data;
}
function _scopeJson() {
  const data = require("./scope-json");
  _scopeJson = function () {
    return data;
  };
  return data;
}
function _clientIdInUse() {
  const data = _interopRequireDefault(require("./exceptions/client-id-in-use"));
  _clientIdInUse = function () {
    return data;
  };
  return data;
}
function _unexpectedPackageName() {
  const data = require("../consumer/exceptions/unexpected-package-name");
  _unexpectedPackageName = function () {
    return data;
  };
  return data;
}
function _getDivergeData() {
  const data = require("./component-ops/get-diverge-data");
  _getDivergeData = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const removeNils = (0, _reject2().default)(_isNil2().default);
const pathHasScope = (0, _utils().pathHasAll)([_constants().OBJECTS_DIR, _constants().SCOPE_JSON]);
class Scope {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // cache DependencyGraph instance

  /**
   * normally, the data about the current-lane is saved in .bitmap. the reason for having this prop here is that we
   * need this data when loading model-component, which gets called in multiple places where the consumer is not passed.
   * another instance this is needed is for bit-sign, this way when loading aspects and fetching dists, it'll go to lane-scope.
   */

  constructor(scopeProps) {
    var _scopeProps$isBare;
    (0, _defineProperty2().default)(this, "created", false);
    (0, _defineProperty2().default)(this, "scopeJson", void 0);
    (0, _defineProperty2().default)(this, "tmp", void 0);
    (0, _defineProperty2().default)(this, "path", void 0);
    (0, _defineProperty2().default)(this, "isBare", false);
    (0, _defineProperty2().default)(this, "scopeImporter", void 0);
    (0, _defineProperty2().default)(this, "sources", void 0);
    (0, _defineProperty2().default)(this, "objects", void 0);
    (0, _defineProperty2().default)(this, "_dependencyGraph", void 0);
    (0, _defineProperty2().default)(this, "lanes", void 0);
    (0, _defineProperty2().default)(this, "currentLaneId", void 0);
    this.path = scopeProps.path;
    this.scopeJson = scopeProps.scopeJson;
    this.created = scopeProps.created || false;
    this.tmp = scopeProps.tmp || new (_repositories().Tmp)(this);
    this.sources = scopeProps.sources || new (_sources().default)(this);
    this.objects = scopeProps.objects;
    this.lanes = new (_lanes().default)(this.objects, this.scopeJson);
    this.isBare = (_scopeProps$isBare = scopeProps.isBare) !== null && _scopeProps$isBare !== void 0 ? _scopeProps$isBare : false;
    this.scopeImporter = _scopeComponentsImporter().default.getInstance(this);
  }
  // enable extensions to hook after the export process

  /**
   * import components to the `Scope.
   */
  async import(ids, cache = true, reFetchUnBuiltVersion = true, lanes) {
    return this.scopeImporter.importMany({
      ids,
      cache,
      throwForDependencyNotFound: false,
      reFetchUnBuiltVersion,
      lanes
    });
  }
  async getDependencyGraph() {
    if (!this._dependencyGraph) {
      this._dependencyGraph = await _scopeGraph().default.loadAllVersions(this);
    }
    return this._dependencyGraph;
  }

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  get groupName() {
    if (!this.scopeJson.groupName) return null;
    return this.scopeJson.groupName;
  }
  get name() {
    return this.scopeJson.name;
  }
  get isLegacy() {
    const harmonyScopeJsonPath = (0, _scopeJson().getHarmonyPath)(this.path);
    return !_fsExtra().default.existsSync(harmonyScopeJsonPath);
  }
  setCurrentLaneId(laneId) {
    if (!laneId) return;
    if (laneId.isDefault()) return;
    this.currentLaneId = laneId;
  }
  getPath() {
    return this.path;
  }
  getComponentsPath() {
    return pathLib().join(this.path, Scope.getComponentsRelativePath());
  }

  /**
   * Get the relative components path inside the scope
   * (components such as compilers / testers / extensions)
   * currently components
   */
  static getComponentsRelativePath() {
    return _constants().BITS_DIRNAME;
  }

  /**
   * Get a relative (to scope) path to a specific component such as compiler / tester / extension
   * Support getting the latest installed version
   * @param {BitId} id
   */
  static getComponentRelativePath(id, scopePath) {
    if (!id.scope) {
      throw new Error('could not find id.scope');
    }
    const relativePath = pathLib().join(id.name, id.scope);
    if (!id.getVersion().latest) {
      if (!id.version) {
        // brought closer because flow can't deduce if it's done in the beginning.
        throw new Error('could not find id.version');
      }
      return pathLib().join(relativePath, id.version);
    }
    if (!scopePath) {
      throw new Error(`could not find the latest version of ${id.toString()} without the scope path`);
    }
    const componentFullPath = pathLib().join(scopePath, Scope.getComponentsRelativePath(), relativePath);
    if (!_fsExtra().default.existsSync(componentFullPath)) return '';
    const versions = (0, _utils().readDirSyncIgnoreDsStore)(componentFullPath);
    const latestVersion = _semver().default.maxSatisfying(versions, '*', {
      includePrerelease: true
    });
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return pathLib().join(relativePath, latestVersion);
  }
  getBitPathInComponentsDir(id) {
    return pathLib().join(this.getComponentsPath(), id.toFullPath());
  }

  /**
   * Running migration process for scope to update the stores (bit objects) to the current version
   *
   * @param {any} verbose - print debug logs
   * @returns {Object} - wether the process run and wether it successeded
   * @memberof Consumer
   */
  async migrate(verbose) {
    _logger().default.trace('scope.migrate, running migration process for scope');
    if (verbose) console.log('running migration process for scope'); // eslint-disable-line
    // We start to use this process after version 0.10.9, so we assume the scope is in the last production version
    const scopeVersion = this.scopeJson.get('version') || '0.10.9';
    if (_semver().default.gte(scopeVersion, _constants().BIT_VERSION)) {
      const upToDateMsg = 'scope version is up to date';
      if (verbose) console.log(upToDateMsg); // eslint-disable-line
      _logger().default.trace(`scope.migrate, ${upToDateMsg}`);
      return {
        run: false
      };
    }
    _loader().default.start(_loaderMessages().BEFORE_MIGRATION);
    _logger().default.debugAndAddBreadCrumb('scope.migrate', `start scope migration. scope version ${scopeVersion}, bit version ${_constants().BIT_VERSION}`);
    const migrations = (0, _migrationHelper().default)(_constants().BIT_VERSION, scopeVersion, _scopeMigratorManifest().default, verbose);
    const rawObjects = migrations.length ? await this.objects.listRawObjects() : [];
    // @ts-ignore
    const resultObjects = await (0, _scopeMigrator().default)(migrations, rawObjects, verbose);
    if (!(0, _isEmpty2().default)(resultObjects.newObjects) || !(0, _isEmpty2().default)(resultObjects.refsToRemove)) {
      // Add the new / updated objects
      this.objects.addMany(resultObjects.newObjects);
      // Remove old objects
      this.objects.removeManyObjects(resultObjects.refsToRemove);
      // Persists new / remove objects
      const validateBeforePersist = false;
      await this.objects.persist(validateBeforePersist);
    }

    // Update the scope version
    this.scopeJson.set('version', _constants().BIT_VERSION);
    _logger().default.debugAndAddBreadCrumb('scope.migrate', `updating scope version to version ${_constants().BIT_VERSION}`);
    await this.scopeJson.write(this.getPath());
    _loader().default.stop();
    return {
      run: true,
      success: true
    };
  }
  describe() {
    return {
      name: this.name
    };
  }
  toConsumerComponents(components) {
    return Promise.all(components.filter(comp => !(comp instanceof _models().Symlink))
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    .map(c => c.toConsumerComponent(c.latestExisting(this.objects).toString(), this.name, this.objects)));
  }
  async hasId(id, opts) {
    const filter = comp => {
      const symlinkCond = opts.includeSymlink ? true : !comp.isSymlink;
      const idMatch = comp.id.scope === id.scope && comp.id.name === id.name;
      return symlinkCond && idMatch;
    };
    const modelComponentList = await this.objects.listObjectsFromIndex(_componentsIndex().IndexType.components, filter);
    if (!modelComponentList || !modelComponentList.length) return false;
    if (!opts.includeVersion || !id.version) return true;
    if (id.getVersion().latest) return true;
    const modelComponent = modelComponentList[0];
    if (opts.includeOrphaned) {
      return modelComponent.hasTagIncludeOrphaned(id.version);
    }
    return modelComponent.hasTag(id.version);
  }
  async list() {
    const filter = comp => !comp.isSymlink;
    const results = await this.objects.listObjectsFromIndex(_componentsIndex().IndexType.components, filter);
    results.forEach(result => {
      if (!(result instanceof _models().ModelComponent)) {
        throw new Error(`fatal: wrong hash in the index.json file. expect ${result.hash()} to be a ModelComponent, got ${result.constructor.name}.
please share your "(.git/bit|.bit)/index.json" file with Bit team to investigate the issue.
once done, to continue working, please run "bit cc"`);
      }
    });
    return results;
  }
  async listIncludesSymlinks() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return this.objects.listObjectsFromIndex(_componentsIndex().IndexType.components);
  }
  async listIncludeRemoteHead(laneId) {
    const components = await this.list();
    const lane = laneId.isDefault() ? null : await this.loadLane(laneId);
    await Promise.all(components.map(component => component.populateLocalAndRemoteHeads(this.objects, lane)));
    return components;
  }
  async listLocal() {
    const listResults = await this.list();
    return listResults.filter(result => !result.scope || result.scope === this.name);
  }
  async listLanes() {
    return this.lanes.listLanes();
  }
  async loadLane(id) {
    return this.lanes.loadLane(id);
  }
  async loadLaneByHash(ref) {
    const lane = await this.objects.load(ref);
    return lane;
  }

  /**
   * sadly, there are not good tests for this. it pretty complex to create them as it involves multiple scopes and
   * packages installations. be careful when changing this.
   * the goal is to check whether a given id with the given version exits on the given lane or it's on main.
   * it's needed for importing artifacts to know whether the artifact could be found on the origin scope or on the
   * lane-scope
   */
  async isIdOnLane(id, lane) {
    if (!lane) return false;
    const laneIds = lane.toBitIds();
    if (laneIds.has(id)) return true; // in the lane with the same version
    const laneIdWithDifferentVersion = laneIds.searchWithoutVersion(id);
    if (!laneIdWithDifferentVersion) return false; // not in the lane at all
    // component is in the lane object but with a different version.
    // we have to figure out whether the current version exists on the lane or not.
    const component = await this.getModelComponent(id);
    if (!component.head) return true; // it's not on main. must be on a lane. (even if it was forked from another lane, current lane must have all objects)
    if (component.head.toString() === id.version) return false; // it's on main
    // get the diverge between main and the lane. (in this context, main is "remote", lane is "local").
    const divergeData = await (0, _getDivergeData().getDivergeData)({
      repo: this.objects,
      modelComponent: component,
      remoteHead: component.head,
      checkedOutLocalHead: _objects().Ref.from(laneIdWithDifferentVersion.version)
    });
    // if the snap found "locally", then it's on the lane.
    return Boolean(divergeData.snapsOnLocalOnly.find(snap => snap.toString() === id.version));
  }
  async latestVersions(componentIds, throwOnFailure = true) {
    componentIds = componentIds.map(componentId => componentId.changeVersion(undefined));
    const components = await this.sources.getMany(componentIds);
    const ids = components.map(component => {
      const getVersion = () => {
        if (component.component) {
          return component.component.latest();
        }
        if (throwOnFailure) throw new (_exceptions().ComponentNotFound)(component.id.toString());
        return _constants().DEFAULT_BIT_VERSION;
      };
      const version = getVersion();
      return component.id.changeVersion(version);
    });
    return _bitId().BitIds.fromArray(ids);
  }
  getObject(hash) {
    return new (_objects().Ref)(hash).load(this.objects);
  }
  getRawObject(hash) {
    return this.objects.loadRawObject(new (_objects().Ref)(hash));
  }
  getObjectItems(refs) {
    return Promise.all(refs.map(async ref => ({
      ref,
      buffer: await this.objects.loadRaw(ref)
    })));
  }
  async getObjectItem(ref) {
    return {
      ref,
      buffer: await this.objects.loadRaw(ref)
    };
  }
  async getModelComponentIfExist(id) {
    return this.sources.get(id);
  }
  async getCurrentLaneObject() {
    return this.currentLaneId ? this.loadLane(this.currentLaneId) : null;
  }

  /**
   * Remove components from scope
   * @force Boolean - remove component from scope even if other components use it
   */
  async removeMany(bitIds, force, consumer, fromLane) {
    _logger().default.debug(`scope.removeMany ${bitIds.toString()} with force flag: ${force.toString()}`);
    _analytics().Analytics.addBreadCrumb('removeMany', `scope.removeMany ${_analytics().Analytics.hashData(bitIds)} with force flag: ${force.toString()}`);
    const currentLane = await (consumer === null || consumer === void 0 ? void 0 : consumer.getCurrentLaneObject());
    const removeComponents = new (_removeModelComponents().default)(this, bitIds, force, consumer, currentLane, fromLane);
    return removeComponents.remove();
  }

  /**
   * for each one of the given components, find its dependents
   */
  async getDependentsBitIds(bitIds, returnResultsWithVersion = false) {
    _logger().default.debug(`scope.getDependentsBitIds, bitIds: ${bitIds.toString()}`);
    const idsGraph = await _scopeGraph().default.buildIdsGraphWithAllVersions(this);
    _logger().default.debug(`scope.getDependentsBitIds, idsGraph the graph was built successfully`);
    const dependencyGraph = new (_scopeGraph().default)(idsGraph);
    const dependentsGraph = bitIds.reduce((acc, current) => {
      const dependents = dependencyGraph.getDependentsForAllVersions(current);
      if (dependents.length) {
        const dependentsIds = dependents.map(id => returnResultsWithVersion ? id : id.changeVersion(undefined));
        acc[current.toStringWithoutVersion()] = _bitId().BitIds.uniqFromArray(dependentsIds);
      }
      return acc;
    }, {});
    return dependentsGraph;
  }

  /**
   * split bit array to found and missing components (incase user misspelled id)
   */
  async filterFoundAndMissingComponents(bitIds) {
    const missingComponents = new (_bitId().BitIds)();
    const foundComponents = new (_bitId().BitIds)();
    const resultP = bitIds.map(async id => {
      const component = await this.getModelComponentIfExist(id);
      if (!component) missingComponents.push(id);else foundComponents.push(id);
    });
    await Promise.all(resultP);
    return {
      missingComponents,
      foundComponents
    };
  }

  /**
   * load components from the model and return them as ComponentVersion array.
   * if a component is not available locally, it'll just ignore it without throwing any error.
   */
  async loadLocalComponents(ids) {
    const componentsObjects = await this.sources.getMany(ids);
    const components = componentsObjects.map(componentObject => {
      const component = componentObject.component;
      if (!component) return null;
      const version = componentObject.id.hasVersion() ? componentObject.id.version : component.latest();
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return component.toComponentVersion(version);
    });
    return removeNils(components);
  }
  async loadComponentLogs(id, shortHash = false, startFrom) {
    var _componentModel$getRe;
    const componentModel = await this.getModelComponentIfExist(id);
    if (!componentModel) return [];
    const startFromRef = startFrom ? (_componentModel$getRe = componentModel.getRef(startFrom)) !== null && _componentModel$getRe !== void 0 ? _componentModel$getRe : undefined : undefined;
    const logs = await componentModel.collectLogs(this.objects, shortHash, startFromRef);
    return logs;
  }
  loadAllVersions(id) {
    return this.getModelComponentIfExist(id).then(componentModel => {
      if (!componentModel) throw new (_exceptions().ComponentNotFound)(id.toString());
      return componentModel.collectVersions(this.objects);
    });
  }

  /**
   * get ModelComponent instance per bit-id.
   * it throws an error if the component wasn't found.
   * @see getModelComponentIfExist to not throw an error
   * @see getModelComponentIgnoreScope to ignore the scope name
   */
  async getModelComponent(id) {
    const component = await this.getModelComponentIfExist(id);
    if (component) {
      return component;
    }
    throw new (_exceptions().ComponentNotFound)(id.toString());
  }

  /**
   * the id can be either with or without a scope-name.
   * in case the component is saved in the model only with the scope (imported), it loads all
   * components and search for it.
   * it throws an error if the component wasn't found.
   */
  async getModelComponentIgnoreScope(id) {
    const component = await this.getModelComponentIfExist(id);
    if (component) return component;
    if (!id.scope) {
      // search for the complete ID
      const components = await this.list();
      const foundComponent = components.filter(c => c.toBitId().isEqualWithoutScopeAndVersion(id));
      if (foundComponent.length) return (0, _utils().first)(foundComponent);
    }
    throw new (_exceptions().ComponentNotFound)(id.toString());
  }

  /**
   * throws if component was not found
   */
  async getConsumerComponent(id) {
    const modelComponent = await this.getModelComponent(id);
    // $FlowFixMe version must be set
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const componentVersion = modelComponent.toComponentVersion(id.version);
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return componentVersion.toConsumer(this.objects);
  }
  async getManyConsumerComponents(ids) {
    return Promise.all(ids.map(id => this.getConsumerComponent(id)));
  }

  /**
   * return undefined if component was not found
   */
  async getConsumerComponentIfExist(id) {
    const modelComponent = await this.getModelComponentIfExist(id);
    if (!modelComponent) return undefined;
    // $FlowFixMe version must be set
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const componentVersion = modelComponent.toComponentVersion(id.version);
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return componentVersion.toConsumer(this.objects);
  }
  async getVersionInstance(id) {
    if (!id.hasVersion()) throw new TypeError(`scope.getVersionInstance - id ${id.toString()} is missing the version`);
    const component = await this.getModelComponent(id);
    return component.loadVersion(id.version, this.objects);
  }
  async getComponentsAndVersions(ids, defaultToLatestVersion = false) {
    const componentsObjects = await this.sources.getMany(ids);
    const componentsAndVersionsP = componentsObjects.map(async componentObjects => {
      if (!componentObjects.component) return null;
      const component = componentObjects.component;
      const getVersionStr = () => {
        var _componentObjects$com;
        if (componentObjects.id.hasVersion()) return componentObjects.id.getVersion().toString();
        if (!defaultToLatestVersion) throw new Error(`getComponentsAndVersions expect ${componentObjects.id.toString()} to have a version`);
        return (_componentObjects$com = componentObjects.component) === null || _componentObjects$com === void 0 ? void 0 : _componentObjects$com.latest();
      };
      const versionStr = getVersionStr();
      const version = await component.loadVersion(versionStr, this.objects);
      return {
        component,
        version,
        versionStr
      };
    });
    const componentsAndVersions = await Promise.all(componentsAndVersionsP);
    return removeNils(componentsAndVersions);
  }
  async isComponentInScope(id) {
    const comp = await this.sources.get(id);
    return Boolean(comp);
  }

  /**
   * Creates a symlink object with the local-scope which links to the real-object of the remote-scope
   * This way, local components that have dependencies to the exported component won't break.
   */
  createSymlink(id, remote) {
    const symlink = new (_models().Symlink)({
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      scope: id.scope,
      name: id.name,
      realScope: remote
    });
    return this.objects.add(symlink);
  }
  ensureDir() {
    _fsExtra().default.ensureDirSync(this.getComponentsPath());
    return this.tmp.ensureDir().then(() => this.scopeJson.write(this.getPath())).then(() => this.objects.ensureDir()).then(() => this);
  }

  /**
   * find the components in componentsPool which one of their dependencies include in potentialDependencies
   */
  async findDirectDependentComponents(componentsPool, potentialDependencies) {
    const componentsVersions = await this.loadLocalComponents(componentsPool);
    const dependentsP = componentsVersions.map(async componentVersion => {
      const component = await componentVersion.getVersion(this.objects);
      const found = component.getAllDependencies().find(dependency => potentialDependencies.searchWithoutVersion(dependency.id));
      return found ? componentVersion : null;
    });
    const dependents = await Promise.all(dependentsP);
    const dependentsWithoutNull = removeNils(dependents);
    return _bitId().BitIds.fromArray(dependentsWithoutNull.map(c => c.id));
  }
  async loadModelComponentByIdStr(id) {
    // Remove the version before hashing since hashing with the version number will result a wrong hash
    const idWithoutVersion = _bitId().BitId.getStringWithoutVersion(id);
    const ref = _objects().Ref.from(_objects().BitObject.makeHash(idWithoutVersion));
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return this.objects.load(ref);
  }
  async getParsedId(id) {
    if (id.startsWith('@')) {
      throw new (_unexpectedPackageName().UnexpectedPackageName)(id);
    }
    const component = await this.loadModelComponentByIdStr(id);
    const idHasScope = Boolean(component && component.scope);
    if (idHasScope) {
      const bitId = component.toBitId();
      const version = _bitId().BitId.getVersionOnlyFromString(id);
      return bitId.changeVersion(version || _constants().LATEST);
    }
    const [idWithoutVersion] = id.toString().split('@');
    if (idWithoutVersion.includes('.')) {
      // we allow . only on scope names, so if it has . it must be with scope name
      return _bitId().BitId.parse(id, true);
    }
    const idSplit = id.split('/');
    if (idSplit.length === 1) {
      // it doesn't have any slash, so the id doesn't include the scope-name
      return _bitId().BitId.parse(id, false);
    }
    const maybeScope = idSplit[0];
    const isRemoteConfiguredLocally = this.scopeJson.remotes[maybeScope];
    if (isRemoteConfiguredLocally) {
      return _bitId().BitId.parse(id, true);
    }
    // it's probably new, we assume it doesn't have scope.
    return _bitId().BitId.parse(id, false);
  }

  /**
   * returns the main ids of the given lane
   */
  async getDefaultLaneIdsFromLane(lane) {
    const laneIds = lane.toBitIds();
    const modelComponents = await Promise.all(laneIds.map(id => this.getModelComponent(id)));
    return (0, _lodash().compact)(modelComponents.map(c => {
      if (!c.head) return null; // probably the component was never merged to main
      return c.toBitId().changeVersion(c.head.toString());
    }));
  }
  async writeObjectsToPendingDir(objectList, clientId) {
    const pendingDir = pathLib().join(this.path, _constants().PENDING_OBJECTS_DIR, clientId);
    if (_fsExtra().default.pathExistsSync(pendingDir)) {
      throw new (_clientIdInUse().default)(clientId);
    }
    await this.objects.writeObjectsToPendingDir(objectList, pendingDir);
  }
  async readObjectsFromPendingDir(clientId) {
    // @todo: implement the wait() mechanism.
    const pendingDir = pathLib().join(this.path, _constants().PENDING_OBJECTS_DIR, clientId);
    return this.objects.readObjectsFromPendingDir(pendingDir);
  }
  async removePendingDir(clientId) {
    const pendingDir = pathLib().join(this.path, _constants().PENDING_OBJECTS_DIR, clientId);
    try {
      await _fsExtra().default.remove(pendingDir); // no error is thrown if not exists
    } catch (err) {
      if (err.code === 'ENOTEMPTY') {
        // it rarely happens, but when it does, the export gets stuck. it's probably a bug with fs-extra.
        // a workaround is to try again after a second.
        // see this: https://github.com/jprichardson/node-fs-extra/issues/532
        await new Promise(resolve => setTimeout(resolve, 1000));
        await _fsExtra().default.remove(pendingDir);
      } else {
        throw err;
      }
    }
  }
  static ensure(path, name, groupName) {
    if (pathHasScope(path)) return this.load(path);
    const scopeJson = Scope.ensureScopeJson(path, name, groupName);
    const repository = _objects().Repository.create({
      scopePath: path,
      scopeJson
    });
    return Promise.resolve(new Scope({
      path,
      created: true,
      scopeJson,
      objects: repository
    }));
  }
  static ensureScopeJson(path, name, groupName) {
    if (!name) name = (0, _utils().currentDirName)();
    if (name === _constants().CURRENT_UPSTREAM) {
      throw new (_generalError().default)(`the name "${_constants().CURRENT_UPSTREAM}" is a reserved word, please use another name`);
    }
    const scopeJson = new (_scopeJson().ScopeJson)({
      name,
      groupName,
      version: _constants().BIT_VERSION
    });
    return scopeJson;
  }
  static async reset(path, resetHard) {
    await _objects().Repository.reset(path);
    if (resetHard) {
      _logger().default.info(`deleting the whole scope at ${path}`);
      await _fsExtra().default.emptyDir(path);
    }
    Scope.scopeCache = {};
  }
  static async load(absPath, useCache = true) {
    let scopePath = (0, _utils().propogateUntil)(absPath);
    let isBare = true;
    if (!scopePath) throw new (_exceptions().ScopeNotFound)(absPath);
    if (_fsExtra().default.existsSync(pathLib().join(scopePath, _constants().BIT_HIDDEN_DIR))) {
      scopePath = pathLib().join(scopePath, _constants().BIT_HIDDEN_DIR);
      isBare = false;
    }
    if (scopePath.endsWith(pathLib().join(_constants().DOT_GIT_DIR, _constants().BIT_GIT_DIR)) || scopePath.endsWith(pathLib().join(_constants().BIT_HIDDEN_DIR))) {
      isBare = false;
    }
    if (useCache && Scope.scopeCache[scopePath]) {
      _logger().default.debug(`scope.load, found scope at ${scopePath} from cache`);
      return Scope.scopeCache[scopePath];
    }
    const scopeJsonPath = (0, _scopeJson().getPath)(scopePath);
    const scopeJsonExist = _fsExtra().default.existsSync(scopeJsonPath);
    let scopeJson;
    if (scopeJsonExist) {
      scopeJson = await _scopeJson().ScopeJson.loadFromFile(scopeJsonPath);
    } else {
      scopeJson = Scope.ensureScopeJson(scopePath);
    }
    const objects = await _objects().Repository.load({
      scopePath,
      scopeJson
    });
    const scope = new Scope({
      path: scopePath,
      scopeJson,
      objects,
      isBare
    });
    Scope.scopeCache[scopePath] = scope;
    return scope;
  }
}
exports.default = Scope;
(0, _defineProperty2().default)(Scope, "onPostExport", void 0);
(0, _defineProperty2().default)(Scope, "scopeCache", {});