/// <reference types="node" />
import { LaneId } from '@teambit/lane-id';
import { Scope } from '..';
import { BitId, BitIds } from '../../bit-id';
import { BitObject, Ref, Repository } from '../objects';
export declare type Log = {
    date: string;
    username?: string;
    email?: string;
};
export declare type LaneProps = {
    name: string;
    scope: string;
    log: Log;
    components?: LaneComponent[];
    hash: string;
    readmeComponent?: LaneReadmeComponent;
    forkedFrom?: LaneId;
};
export declare type LaneComponent = {
    id: BitId;
    head: Ref;
};
export declare type LaneReadmeComponent = {
    id: BitId;
    head: Ref | null;
};
export default class Lane extends BitObject {
    name: string;
    scope: string;
    components: LaneComponent[];
    log: Log;
    readmeComponent?: LaneReadmeComponent;
    forkedFrom?: LaneId;
    _hash: string;
    isNew: boolean;
    constructor(props: LaneProps);
    id(): string;
    hash(): Ref;
    refs(): Ref[];
    validateBeforePersisting(str: string): void;
    toObject(): any;
    static from(props: LaneProps): Lane;
    static create(name: string, scope: string, forkedFrom?: LaneId): Lane;
    static parse(contents: string, hash: string): Lane;
    toBuffer(pretty?: boolean): Buffer;
    addComponent(component: LaneComponent): void;
    removeComponent(id: BitId): boolean;
    getComponentByName(bitId: BitId): LaneComponent | undefined;
    getComponent(id: BitId): LaneComponent | undefined;
    getComponentHead(bitId: BitId): Ref | null;
    setLaneComponents(laneComponents: LaneComponent[]): void;
    setReadmeComponent(id?: BitId): void;
    isFullyMerged(scope: Scope): Promise<boolean>;
    getMergedAndUnmergedIds(scope: Scope): Promise<{
        merged: BitId[];
        unmerged: BitId[];
    }>;
    toBitIds(): BitIds;
    toLaneId(): LaneId;
    collectObjectsById(repo: Repository): Promise<Array<{
        id: BitId;
        objects: BitObject[];
    }>>;
    validate(): void;
    clone(): Lane;
}
