"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _forEachObjIndexed2() {
  const data = _interopRequireDefault(require("ramda/src/forEachObjIndexed"));
  _forEachObjIndexed2 = function () {
    return data;
  };
  return data;
}
function _clone2() {
  const data = _interopRequireDefault(require("ramda/src/clone"));
  _clone2 = function () {
    return data;
  };
  return data;
}
function _equals2() {
  const data = _interopRequireDefault(require("ramda/src/equals"));
  _equals2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function semver() {
  const data = _interopRequireWildcard(require("semver"));
  semver = function () {
    return data;
  };
  return data;
}
function _componentVersion() {
  const data = require("@teambit/component-version");
  _componentVersion = function () {
    return data;
  };
  return data;
}
function _uuid() {
  const data = require("uuid");
  _uuid = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = _interopRequireDefault(require("../../consumer/component"));
  _component = function () {
    return data;
  };
  return data;
}
function _sources() {
  const data = require("../../consumer/component/sources");
  _sources = function () {
    return data;
  };
  return data;
}
function _componentOverrides() {
  const data = _interopRequireDefault(require("../../consumer/config/component-overrides"));
  _componentOverrides = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));
  _showDoctorError = function () {
    return data;
  };
  return data;
}
function _validationError() {
  const data = _interopRequireDefault(require("../../error/validation-error"));
  _validationError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _findDuplications() {
  const data = _interopRequireDefault(require("../../utils/array/find-duplications"));
  _findDuplications = function () {
    return data;
  };
  return data;
}
function _componentObjects() {
  const data = _interopRequireDefault(require("../component-objects"));
  _componentObjects = function () {
    return data;
  };
  return data;
}
function _getDivergeData() {
  const data = require("../component-ops/get-diverge-data");
  _getDivergeData = function () {
    return data;
  };
  return data;
}
function _traverseVersions() {
  const data = require("../component-ops/traverse-versions");
  _traverseVersions = function () {
    return data;
  };
  return data;
}
function _componentVersion2() {
  const data = _interopRequireDefault(require("../component-version"));
  _componentVersion2 = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("../exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _objects() {
  const data = require("../objects");
  _objects = function () {
    return data;
  };
  return data;
}
function _scopeMeta() {
  const data = _interopRequireDefault(require("./scopeMeta"));
  _scopeMeta = function () {
    return data;
  };
  return data;
}
function _semverHelper() {
  const data = require("../../utils/semver-helper");
  _semverHelper = function () {
    return data;
  };
  return data;
}
function _artifactFiles() {
  const data = require("../../consumer/component/sources/artifact-files");
  _artifactFiles = function () {
    return data;
  };
  return data;
}
function _componentSchema() {
  const data = require("../../consumer/component/component-schema");
  _componentSchema = function () {
    return data;
  };
  return data;
}
function _noHeadNoVersion() {
  const data = require("../exceptions/no-head-no-version");
  _noHeadNoVersion = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const VERSION_ZERO = '0.0.0';

/**
 * we can't rename the class as ModelComponent because old components are already saved in the model
 * with 'Component' in their headers. see object-registrar.types()
 */
// TODO: FIX me .parser
// @ts-ignore
class Component extends _objects().BitObject {
  /**
   * @deprecated moved to the Version object inside teambit/deprecation aspect
   */

  /**
   * @deprecated since 0.12.6 (long long ago :) probably can be removed)
   */

  // doesn't get saved in the scope, used to easier access the remote main head
  /**
   * doesn't get saved in the scope, used to easier access the local snap head data
   * when checked out to a lane, this prop is either Ref or null. otherwise (when on main), this prop is undefined.
   */

  /**
   * doesn't get saved in the scope, used to easier access the remote snap head data
   * when checked out to a lane, this prop is either Ref or null. otherwise (when on main), this prop is undefined.
   */

  // doesn't get saved in the scope.
  // doesn't get saved in the scope, used to improve performance of loading the lane data

  constructor(props) {
    super();
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "name", void 0);
    (0, _defineProperty2().default)(this, "versions", void 0);
    (0, _defineProperty2().default)(this, "orphanedVersions", void 0);
    (0, _defineProperty2().default)(this, "lang", void 0);
    (0, _defineProperty2().default)(this, "deprecated", void 0);
    (0, _defineProperty2().default)(this, "bindingPrefix", void 0);
    (0, _defineProperty2().default)(this, "local", void 0);
    (0, _defineProperty2().default)(this, "state", void 0);
    (0, _defineProperty2().default)(this, "scopesList", void 0);
    (0, _defineProperty2().default)(this, "head", void 0);
    (0, _defineProperty2().default)(this, "remoteHead", void 0);
    (0, _defineProperty2().default)(this, "laneHeadLocal", void 0);
    (0, _defineProperty2().default)(this, "laneHeadRemote", void 0);
    (0, _defineProperty2().default)(this, "laneId", void 0);
    (0, _defineProperty2().default)(this, "laneDataIsPopulated", false);
    (0, _defineProperty2().default)(this, "schema", void 0);
    (0, _defineProperty2().default)(this, "divergeData", void 0);
    if (!props.name) throw new TypeError('Model Component constructor expects to get a name parameter');
    this.scope = props.scope || null;
    this.name = props.name;
    this.versions = props.versions || {};
    this.orphanedVersions = props.orphanedVersions || {};
    this.lang = props.lang || _constants().DEFAULT_LANGUAGE;
    this.deprecated = props.deprecated || false;
    this.bindingPrefix = props.bindingPrefix || _constants().DEFAULT_BINDINGS_PREFIX;
    this.local = props.local;
    this.state = props.state || {};
    this.scopesList = props.scopesList || [];
    this.head = props.head;
    this.schema = props.schema;
  }
  get versionArray() {
    return Object.values(this.versions);
  }
  setVersion(tag, ref) {
    this.versions[tag] = ref;
    delete this.orphanedVersions[tag]; // just in case it's there.
  }

  setOrphanedVersion(tag, ref) {
    if (this.versions[tag]) {
      throw new Error(`unable to save orphanedVersion "${tag}" for "${this.id()}" because this tag is already part of the versions prop`);
    }
    this.orphanedVersions[tag] = ref;
  }
  getRef(version) {
    if ((0, _componentVersion().isHash)(version)) {
      return new (_objects().Ref)(version);
    }
    return this.versionsIncludeOrphaned[version];
  }
  getHeadStr() {
    return this.head ? this.head.toString() : null;
  }
  getHead() {
    return this.head;
  }

  /**
   * returns the head hash. regardless of whether current lane is the default or not.
   * if on a lane, it returns the head of the component on the lane.
   */
  getHeadRegardlessOfLane() {
    return this.laneHeadLocal || this.getHead();
  }
  getHeadAsTagIfExist() {
    if (!this.head) return undefined;
    return this.getTagOfRefIfExists(this.head) || this.head.toString();
  }
  hasHead() {
    return Boolean(this.head);
  }
  setHead(head) {
    this.head = head;
  }
  listVersions(sort) {
    const versions = Object.keys(this.versions);
    if (!sort) return versions;
    if (sort === 'ASC') {
      return versions.sort(semver().compare);
    }
    return versions.sort(semver().compare).reverse();
  }
  listVersionsIncludeOrphaned(sort) {
    const versions = Object.keys(this.versionsIncludeOrphaned);
    if (!sort) return versions;
    if (sort === 'ASC') {
      return versions.sort(semver().compare);
    }
    return versions.sort(semver().compare).reverse();
  }
  async hasVersion(version, repo, includeOrphaned = true) {
    if ((0, _componentVersion().isTag)(version)) {
      return includeOrphaned ? this.hasTagIncludeOrphaned(version) : this.hasTag(version);
    }
    const allHashes = await (0, _traverseVersions().getAllVersionHashes)({
      modelComponent: this,
      repo,
      throws: false
    });
    return allHashes.some(hash => hash.toString() === version);
  }
  hasTag(version) {
    return Boolean(this.versions[version]);
  }
  get versionsIncludeOrphaned() {
    // for bit-bin with 266 components, it takes about 1,700ms. don't use lodash.merge, it's much faster
    // but mutates `this.versions`.
    return _objectSpread(_objectSpread({}, this.versions), this.orphanedVersions);
  }
  hasTagIncludeOrphaned(version) {
    return Boolean(this.versions[version] || this.orphanedVersions[version]);
  }

  /**
   * whether the head is a snap (not a tag)
   */
  isHeadSnap() {
    const tagsHashes = this.versionArray.map(ref => ref.toString());
    return this.head && !tagsHashes.includes(this.head.toString());
  }

  /**
   * add a new remote if it is not there already
   */
  addScopeListItem(scopeListItem) {
    if (!scopeListItem.name || !scopeListItem.url || !scopeListItem.date) {
      throw new TypeError(`model-component.addRemote get an invalid remote. name: ${scopeListItem.name}, url: ${scopeListItem.url}, date: ${scopeListItem.date}`);
    }
    if (!this.scopesList.find(r => r.url === scopeListItem.url)) {
      this.scopesList.push(scopeListItem);
    }
  }

  /**
   * on main - it checks local-head vs remote-head.
   * on lane - it checks local-head on lane vs remote-head on lane.
   * however, to get an accurate `divergeData.snapsOnLocalOnly`, the above is not enough.
   * for example, comp-a@snap-x from lane-a is merged into lane-b. we don't want this snap-x to be "local", because
   * then, bit-status will show it as "staged" and bit-reset will remove it unexpectedly.
   * if we only check by the local-head and remote-head on lane, it'll be local because the remote-head of lane-b is empty.
   * to address this, we search all remote-refs files for this bit-id and during the local history traversal, if a hash
   * is found there, it'll stop the traversal and not mark it as remote.
   * in this example, during the merge, lane-a was fetched, and the remote-ref of this lane has snap-x as the head.
   */
  async setDivergeData(repo, throws = true, fromCache = true) {
    if (!this.divergeData || !fromCache) {
      const remoteHead = (this.laneId ? this.laneHeadRemote : this.remoteHead) || null;
      let otherRemoteHeads;
      if (this.laneId) {
        otherRemoteHeads = await repo.remoteLanes.getRefsFromAllLanes(this.toBitId());
        if (this.remoteHead) otherRemoteHeads.push(this.remoteHead);
      }
      this.divergeData = await (0, _getDivergeData().getDivergeData)({
        repo,
        modelComponent: this,
        remoteHead,
        throws,
        otherRemoteHeads
      });
    }
  }
  getDivergeData() {
    if (!this.divergeData) throw new Error(`getDivergeData() expects divergeData to be populate, please use this.setDivergeData() for id: ${this.id()}`);
    return this.divergeData;
  }
  async populateLocalAndRemoteHeads(repo, lane) {
    this.setLaneHeadLocal(lane);
    if (lane) this.laneId = lane.toLaneId();
    if (this.scope) {
      if (lane) {
        // const remoteToCheck = lane.isNew && lane.forkedFrom ? lane.forkedFrom : lane.toLaneId();
        // this.laneHeadRemote = await repo.remoteLanes.getRef(remoteToCheck, this.toBitId());
        this.laneHeadRemote = await repo.remoteLanes.getRef(lane.toLaneId(), this.toBitId());
      }
      // we need also the remote head of main, otherwise, the diverge-data assumes all versions are local
      this.remoteHead = await repo.remoteLanes.getRef(_laneId().LaneId.from(_laneId().DEFAULT_LANE, this.scope), this.toBitId());
    }
  }
  setLaneHeadLocal(lane) {
    if (lane) {
      this.laneHeadLocal = lane.getComponentHead(this.toBitId());
    }
  }

  /**
   * returns only the versions that exist in both components (regardless whether the hash are the same)
   * e.g. this.component = [0.0.1, 0.0.2, 0.0.3], other component = [0.0.3, 0.0.4]. it returns only [0.0.3].
   * also, in case it is coming from 'bit import', the version must be locally changed.
   * otherwise, it doesn't matter whether the hashes are different.
   */
  _getComparableVersionsObjects(otherComponent,
  // in case of merging, the otherComponent is the existing component, and "this" is the incoming component
  local) {
    const otherLocalVersion = otherComponent.getLocalVersions();
    const otherComponentVersions = (0, _utils().filterObject)(otherComponent.versions, (val, key) => Object.keys(this.versions).includes(key) && (!local || otherLocalVersion.includes(key)));
    const thisComponentVersions = (0, _utils().filterObject)(this.versions, (val, key) => Object.keys(otherComponentVersions).includes(key) && (!local || otherLocalVersion.includes(key)));
    return {
      thisComponentVersions,
      otherComponentVersions
    };
  }
  compatibleWith(component, local) {
    const {
      thisComponentVersions,
      otherComponentVersions
    } = this._getComparableVersionsObjects(component, local);
    return (0, _equals2().default)(thisComponentVersions, otherComponentVersions);
  }
  diffWith(component, local) {
    const {
      thisComponentVersions,
      otherComponentVersions
    } = this._getComparableVersionsObjects(component, local);
    return Object.keys(thisComponentVersions).filter(version => thisComponentVersions[version].hash !== otherComponentVersions[version].hash);
  }
  isEmpty() {
    return (0, _utils().empty)(this.versions) && !this.hasHead();
  }
  latest() {
    if (this.isEmpty() && !this.laneHeadLocal) return VERSION_ZERO;
    const head = this.getHeadRegardlessOfLane();
    if (head) {
      return this.getTagOfRefIfExists(head) || head.toString();
    }
    // backward compatibility. components created before v15 have main without head
    // @ts-ignore
    return semver().maxSatisfying(this.listVersions(), '*', {
      includePrerelease: true
    });
  }

  /**
   * a user can be checked out to a lane, in which case, `this.laneHeadLocal` and `this.laneHeadRemote`
   * may be populated.
   * `this.head` may not be populated, e.g. when a component was created on
   * this lane and never got snapped on main.
   * it's impossible that `this.head.isEqual(this.laneHeadLocal)`, because when snapping it's either
   * on main, which goes to this.head OR on a lane, which goes to this.laneHeadLocal.
   */
  async latestIncludeRemote(repo) {
    const latestLocally = this.latest();
    const remoteHead = this.laneHeadRemote;
    if (!remoteHead) return latestLocally;
    if (!this.getHeadRegardlessOfLane()) {
      return remoteHead.toString(); // user never merged the remote version, so remote is the latest
    }

    // either a user is on main or a lane, check whether the remote is ahead of the local
    await this.setDivergeData(repo, false);
    const divergeData = this.getDivergeData();
    return divergeData.isRemoteAhead() ? remoteHead.toString() : latestLocally;
  }
  latestVersion() {
    if ((0, _utils().empty)(this.versions)) return VERSION_ZERO;
    return (0, _semverHelper().getLatestVersion)(this.listVersions());
  }

  // @todo: make it readable, it's a mess
  isLatestGreaterThan(version) {
    if (!version) throw TypeError('isLatestGreaterThan expect to get a Version');
    const latest = this.latest();
    if (this.isEmpty() && !this.laneHeadRemote) {
      return false; // in case a snap was created on another lane
    }

    if ((0, _componentVersion().isTag)(latest) && (0, _componentVersion().isTag)(version)) {
      return semver().gt(latest, version);
    }
    if (latest === version) return false;
    const latestRef = this.getRef(latest);
    if (!latestRef) throw new Error('isLatestGreaterThan, latestRef was not found');
    const latestHash = latestRef.toString();
    const versionRef = this.getRef(version);
    if (!versionRef) return true; // probably a child
    const versionHash = versionRef.toString();
    if (latestHash === versionHash) return false;
    return true;
  }

  /**
   * Return the lateset version which actuall exists in the scope
   * (exists means the object itself exists)
   * This relevant for cases when the component version array has few versions
   * but we don't have all the refs in the object
   *
   * @returns {number}
   * @memberof Component
   */
  latestExisting(repository) {
    if ((0, _utils().empty)(this.versions)) return VERSION_ZERO;
    const versions = this.listVersions('ASC');
    let version = null;
    let versionStr = null;
    while (!version && versions && versions.length) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      versionStr = versions.pop();
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      version = this.loadVersionSync(versionStr, repository, false);
    }
    return versionStr || VERSION_ZERO;
  }

  /**
   * get component log and sort by the timestamp in ascending order (from the earliest to the latest)
   */
  async collectLogs(repo, shortHash = false, startFrom) {
    const versionsInfo = await (0, _traverseVersions().getAllVersionsInfo)({
      modelComponent: this,
      repo,
      throws: false,
      startFrom
    });
    const getRef = ref => shortHash ? ref.toShortString() : ref.toString();
    const results = versionsInfo.map(versionInfo => {
      const log = versionInfo.version ? versionInfo.version.log : {
        message: '<no-data-available>'
      };
      return _objectSpread(_objectSpread({}, log), {}, {
        // @ts-ignore
        username: (log === null || log === void 0 ? void 0 : log.username) || 'unknown',
        // @ts-ignore
        email: (log === null || log === void 0 ? void 0 : log.email) || 'unknown',
        tag: versionInfo.tag,
        hash: getRef(versionInfo.ref),
        parents: versionInfo.parents.map(parent => getRef(parent)),
        onLane: versionInfo.onLane
      });
    });
    // sort from earliest to latest
    const sorted = results.sort((a, b) => {
      // @ts-ignore
      if (a.date && b.date) return a.date - b.date;
      return 0;
    });
    return sorted;
  }
  collectVersions(repo) {
    return Promise.all(this.listVersions().map(versionNum => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return this.toConsumerComponent(versionNum, this.scope, repo);
    }));
  }
  getTagOfRefIfExists(ref, allTags = this.versionsIncludeOrphaned) {
    return Object.keys(allTags).find(versionRef => allTags[versionRef].isEqual(ref));
  }
  switchHashesWithTagsIfExist(refs) {
    // cache the this.versionsIncludeOrphaned results into "allTags", looks strange but it improved
    // the performance on bit-bin with 188 components during source.merge in 4 seconds.
    const allTags = this.versionsIncludeOrphaned;
    return refs.map(ref => this.getTagOfRefIfExists(ref, allTags) || ref.toString());
  }

  /**
   * if exactVersion is defined, add exact version instead of using the semver mechanism
   */
  getVersionToAdd(releaseType = _constants().DEFAULT_BIT_RELEASE_TYPE, exactVersion, incrementBy, preReleaseId) {
    if (exactVersion && this.versions[exactVersion]) {
      throw new (_exceptions().VersionAlreadyExists)(exactVersion, this.id());
    }
    return exactVersion || this.version(releaseType, incrementBy, preReleaseId);
  }
  isEqual(component, considerOrphanedVersions = true) {
    if (this.hasHead() && !component.hasHead() || !this.hasHead() && component.hasHead()) {
      return false; // only one of them has head
    }

    if (this.head && component.head && !this.head.isEqual(component.head)) {
      return false; // the head is not equal.
    }
    // the head is equal or they both don't have head. check the versions
    if (this.versionArray.length !== component.versionArray.length) {
      return false;
    }
    const hasSameVersions = Object.keys(this.versions).every(tag => component.versions[tag] && component.versions[tag].isEqual(this.versions[tag]));
    if (considerOrphanedVersions) {
      if (Object.keys(this.orphanedVersions).length !== Object.keys(component.orphanedVersions).length) {
        return false;
      }
      const hasSameOrphanedVersions = Object.keys(this.orphanedVersions).every(tag => component.orphanedVersions[tag] && component.orphanedVersions[tag].isEqual(this.orphanedVersions[tag]));
      if (!hasSameOrphanedVersions) {
        return false;
      }
    }
    return hasSameVersions;
  }
  getSnapToAdd() {
    return (0, _utils().sha1)((0, _uuid().v4)());
  }
  addVersion(version, versionToAdd, lane, repo) {
    if (lane) {
      if ((0, _componentVersion().isTag)(versionToAdd)) {
        throw new (_generalError().default)('unable to tag when checked out to a lane, please switch to main, merge the lane and then tag again');
      }
      const currentBitId = this.toBitId();
      const versionToAddRef = _objects().Ref.from(versionToAdd);
      const existingComponentInLane = lane.getComponentByName(currentBitId);
      const currentHead = existingComponentInLane && existingComponentInLane.head || this.getHead();
      if (currentHead && !currentHead.isEqual(versionToAddRef)) {
        version.addAsOnlyParent(currentHead);
      }
      lane.addComponent({
        id: currentBitId,
        head: versionToAddRef
      });
      if (lane.readmeComponent && lane.readmeComponent.id.isEqualWithoutScopeAndVersion(currentBitId)) {
        lane.setReadmeComponent(currentBitId);
      }
      repo.add(lane);
      this.laneHeadLocal = versionToAddRef;
      return versionToAdd;
    }
    // user on main
    const head = this.getHead();
    if (head && head.toString() !== versionToAdd &&
    // happens with auto-snap
    !this.hasTag(versionToAdd)) {
      // happens with auto-tag
      // if this is a tag and this tag exists, the same version was added before with a different hash.
      // adding the current head into the parent will result in a non-exist hash in the parent.
      // if this is a hash and it's the same hash as the current head, adding it as a parent
      // results in a parent and a version has the same hash.
      // @todo: fix it in a more elegant way
      version.addAsOnlyParent(head);
    }
    if (!version.isLegacy) this.setHead(version.hash());
    if ((0, _componentVersion().isTag)(versionToAdd)) {
      this.setVersion(versionToAdd, version.hash());
    }
    this.markVersionAsLocal(versionToAdd);
    return versionToAdd;
  }
  version(releaseType = _constants().DEFAULT_BIT_RELEASE_TYPE, incrementBy = 1, preReleaseId) {
    // if (preRelease) releaseType = 'prerelease';
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const increment = ver => semver().inc(ver, releaseType, undefined, preReleaseId);
    const latest = this.latestVersion();
    if (!latest) {
      const isPreReleaseLike = ['prerelease', 'premajor', 'preminor', 'prepatch'].includes(releaseType);
      return isPreReleaseLike ? increment(_constants().DEFAULT_BIT_VERSION) : _constants().DEFAULT_BIT_VERSION;
    }
    let result = increment(latest);
    if (incrementBy === 1) return result;
    for (let i = 1; i < incrementBy; i += 1) {
      result = increment(result);
    }
    return result;
  }
  id() {
    return this.scope ? [this.scope, this.name].join('/') : this.name;
  }
  toBitId() {
    return new (_bitId().BitId)({
      scope: this.scope,
      name: this.name
    });
  }
  toBitIdWithLatestVersion() {
    return new (_bitId().BitId)({
      scope: this.scope,
      name: this.name,
      version: this.latest()
    });
  }
  toBitIdWithHead() {
    var _this$head;
    return new (_bitId().BitId)({
      scope: this.scope,
      name: this.name,
      version: (_this$head = this.head) === null || _this$head === void 0 ? void 0 : _this$head.toString()
    });
  }
  toBitIdWithLatestVersionAllowNull() {
    const id = this.toBitIdWithLatestVersion();
    return id.version === VERSION_ZERO ? id.changeVersion(undefined) : id;
  }
  toObject() {
    function versions(vers) {
      const obj = {};
      (0, _utils().forEach)(vers, (ref, version) => {
        obj[version] = ref.toString();
      });
      return obj;
    }
    const componentObject = {
      name: this.name,
      scope: this.scope,
      versions: versions(this.versions),
      lang: this.lang,
      deprecated: this.deprecated,
      bindingPrefix: this.bindingPrefix,
      remotes: this.scopesList,
      schema: this.schema
    };
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (this.local) componentObject.local = this.local;
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (!(0, _lodash().isEmpty)(this.state)) componentObject.state = this.state;
    // @ts-ignore
    if (!(0, _lodash().isEmpty)(this.orphanedVersions)) componentObject.orphanedVersions = versions(this.orphanedVersions);
    const headStr = this.getHeadStr();
    // @ts-ignore
    if (headStr) componentObject.head = headStr;
    return componentObject;
  }
  async loadVersion(versionStr, repository, throws = true, preferInMemoryObjects = false) {
    const versionRef = this.getRef(versionStr);
    if (!versionRef) throw new (_exceptions().VersionNotFound)(versionStr, this.id());
    const version = await repository.load(versionRef, false, preferInMemoryObjects);
    if (!version && throws) throw new (_exceptions().VersionNotFoundOnFS)(versionStr, this.id());
    return version;
  }
  loadVersionSync(version, repository, throws = true) {
    const versionRef = this.getRef(version);
    if (!versionRef) throw new (_exceptions().VersionNotFound)(version, this.id());
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return versionRef.loadSync(repository, throws);
  }
  async collectVersionsObjects(repo, versions, ignoreMissingArtifacts) {
    const refsWithoutArtifacts = [];
    const artifactsRefs = [];
    const artifactsRefsFromExportedVersions = [];
    const locallyChangedVersions = await this.getLocalTagsOrHashes(repo);
    const locallyChangedHashes = locallyChangedVersions.map(v => (0, _componentVersion().isTag)(v) ? this.versionsIncludeOrphaned[v].hash : v);
    const versionsRefs = versions.map(version => this.getRef(version));
    refsWithoutArtifacts.push(...versionsRefs);
    // @ts-ignore
    const versionsObjects = await Promise.all(versionsRefs.map(versionRef => versionRef.load(repo)));
    versionsObjects.forEach(versionObject => {
      const refs = versionObject.refsWithOptions(false, false);
      refsWithoutArtifacts.push(...refs);
      const refsFromExtensions = (0, _artifactFiles().getRefsFromExtensions)(versionObject.extensions);
      locallyChangedHashes.includes(versionObject.hash.toString()) ? artifactsRefs.push(...refsFromExtensions) : artifactsRefsFromExportedVersions.push(...refsFromExtensions);
    });
    const loadedRefs = [];
    try {
      const loaded = await repo.loadManyRaw(refsWithoutArtifacts);
      loadedRefs.push(...loaded);
    } catch (err) {
      if (err.code === 'ENOENT') {
        throw new Error(`unable to find an object file "${err.path}"
for a component "${this.id()}", versions: ${versions.join(', ')}`);
      }
      throw err;
    }
    try {
      const loaded = ignoreMissingArtifacts ? await repo.loadManyRawIgnoreMissing(artifactsRefs) : await repo.loadManyRaw(artifactsRefs);
      loadedRefs.push(...loaded);
      // ignore missing artifacts when exporting old versions that were exported in the past and are now exported to a
      // different scope. this is happening for example when exporting a lane that has components from different
      // remotes. it's ok to not have all artifacts from the other remotes to this remote.
      const loadedExportedArtifacts = await repo.loadManyRawIgnoreMissing(artifactsRefsFromExportedVersions);
      loadedRefs.push(...loadedExportedArtifacts);
    } catch (err) {
      if (err.code === 'ENOENT') {
        throw new Error(`unable to find an artifact object file "${err.path}"
for a component "${this.id()}", versions: ${versions.join(', ')}
consider using --ignore-missing-artifacts flag if you're sure the artifacts are in the remote`);
      }
      throw err;
    }
    return loadedRefs;
  }
  async collectObjects(repo) {
    try {
      const [rawComponent, objects] = await Promise.all([this.asRaw(repo), this.collectRaw(repo)]);
      return new (_componentObjects().default)(rawComponent, objects.map(o => o.buffer));
    } catch (err) {
      if (err.code === 'ENOENT') {
        throw new Error(`fatal: an object of "${this.id()}" was not found at ${err.path}\nplease try to re-import the component`);
      }
      throw err;
    }
  }

  /**
   * to delete a version from a component, don't call this method directly. Instead, use sources.removeVersion()
   */
  removeVersion(version) {
    const objectRef = this.getRef(version);
    if (!objectRef) throw new Error(`removeVersion failed finding version ${version}`);
    if (objectRef) delete this.versions[version];
    if (this.state.versions && this.state.versions[version]) delete this.state.versions[version];
    return objectRef || _objects().Ref.from(version);
  }
  toComponentVersion(versionStr) {
    const versionParsed = (0, _componentVersion().versionParser)(versionStr);
    const versionNum = versionParsed.latest ? this.latest() : versionParsed.resolve(this.listVersionsIncludeOrphaned());
    if (versionNum === VERSION_ZERO) {
      throw new (_noHeadNoVersion().NoHeadNoVersion)(this.id());
    }
    if ((0, _componentVersion().isTag)(versionNum) && !this.hasTagIncludeOrphaned(versionNum)) {
      throw new (_showDoctorError().default)(`the version ${versionNum} of "${this.id()}" does not exist in ${this.listVersionsIncludeOrphaned().join('\n')}, versions array.`);
    }
    return new (_componentVersion2().default)(this, versionNum);
  }
  async isDeprecated(repo) {
    // backward compatibility
    if (this.deprecated) {
      return true;
    }
    const head = this.getHeadRegardlessOfLane();
    if (!head) {
      // it's legacy, or new. If legacy, the "deprecated" prop should do. if it's new, the workspace should
      // have the answer.
      return false;
    }
    const version = await repo.load(head);
    if (!version) {
      // the head Version doesn't exist locally, there is no way to know whether it's deprecated
      return null;
    }
    const deprecationAspect = version.extensions.findCoreExtension(_constants().Extensions.deprecation);
    if (!deprecationAspect) {
      return false;
    }
    return deprecationAspect.config.deprecate;
  }
  async isRemoved(repo) {
    const head = this.getHeadRegardlessOfLane();
    if (!head) {
      // it's new or only on lane
      return false;
    }
    const version = await repo.load(head);
    if (!version) {
      // the head Version doesn't exist locally, there is no way to know whether it's removed
      return false;
    }
    return version.isRemoved();
  }
  async isLaneReadmeOf(repo) {
    const head = this.getHeadRegardlessOfLane();
    if (!head) {
      // we dont support lanes in legacy
      return [];
    }
    const version = await repo.load(head);
    if (!version) {
      // the head Version doesn't exist locally, there is no way to know whether it is a lane readme component
      return [];
    }
    const lanesAspect = version.extensions.findCoreExtension(_constants().Extensions.lanes);
    if (!lanesAspect || !lanesAspect.config.readme) {
      return [];
    }
    return Object.keys(lanesAspect.config.readme);
  }
  /**
   * convert a ModelComponent of a specific version to ConsumerComponent
   * when it's being called from the Consumer, some manipulation are done on the component, such
   * as stripping the originallySharedDir and adding wrapDir.
   * when it's being called from the Scope, no manipulations are done.
   *
   * @see sources.consumerComponentToVersion() for the opposite action.
   */
  async toConsumerComponent(versionStr, scopeName, repository) {
    _logger().default.trace(`model-component, converting ${this.id()}, version: ${versionStr} to ConsumerComponent`);
    const componentVersion = this.toComponentVersion(versionStr);
    const version = await componentVersion.getVersion(repository);
    const loadFileInstance = ClassName => async file => {
      const loadP = file.file.load(repository);
      const content = await loadP;
      if (!content) throw new (_showDoctorError().default)(`failed loading file ${file.relativePath} from the model of ${this.id()}@${versionStr}`);
      return new ClassName({
        base: '.',
        path: file.relativePath,
        contents: content.contents,
        test: file.test
      });
    };
    const filesP = version.files ? Promise.all(version.files.map(loadFileInstance(_sources().SourceFile))) : null;
    // @todo: this is weird. why the scopeMeta would be taken from the current scope and not he component scope?
    const scopeMetaP = scopeName ? _scopeMeta().default.fromScopeName(scopeName).load(repository) : Promise.resolve();
    const log = version.log || null;
    // @ts-ignore
    const [files, scopeMeta] = await Promise.all([filesP, scopeMetaP]);
    const extensions = version.extensions.clone();
    const bindingPrefix = this.bindingPrefix === 'bit' ? '@bit' : this.bindingPrefix;
    // when generating a new ConsumerComponent out of Version, it is critical to make sure that
    // all objects are cloned and not copied by reference. Otherwise, every time the
    // ConsumerComponent instance is changed, the Version will be changed as well, and since
    // the Version instance is saved in the Repository._cache, the next time a Version instance
    // is retrieved, it'll be different than the first time.
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const consumerComponent = new (_component().default)({
      name: this.name,
      version: componentVersion.version,
      scope: this.scope,
      lang: this.lang,
      bindingPrefix,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      mainFile: version.mainFile || null,
      dependencies: version.dependencies.getClone(),
      devDependencies: version.devDependencies.getClone(),
      flattenedDependencies: version.flattenedDependencies.clone(),
      packageDependencies: (0, _clone2().default)(version.packageDependencies),
      devPackageDependencies: (0, _clone2().default)(version.devPackageDependencies),
      peerPackageDependencies: (0, _clone2().default)(version.peerPackageDependencies),
      // @ts-ignore
      files,
      docs: version.docs,
      // @ts-ignore
      license: scopeMeta ? _sources().License.deserialize(scopeMeta.license) : undefined,
      // todo: make sure we have license in case of local scope
      log,
      overrides: _componentOverrides().default.loadFromScope(version.overrides),
      packageJsonChangedProps: (0, _clone2().default)(version.packageJsonChangedProps),
      deprecated: this.deprecated,
      removed: version.isRemoved(),
      scopesList: (0, _clone2().default)(this.scopesList),
      schema: version.schema,
      extensions,
      buildStatus: version.buildStatus
    });
    return consumerComponent;
  }

  // @todo: make sure it doesn't have the same ref twice, once as a version and once as a head
  refs() {
    const versions = Object.values(this.versionsIncludeOrphaned);
    if (this.head) versions.push(this.head);
    return versions;
  }
  replaceRef(oldRef, newRef) {
    const replace = (value, key) => {
      if (value === oldRef.hash) {
        // @ts-ignore
        this.versions[key] = newRef.hash;
      }
    };
    (0, _forEachObjIndexed2().default)(replace, this.versions);
  }
  validateBeforePersisting(componentStr) {
    _logger().default.trace(`validating component object: ${this.hash().hash} ${this.id()}`);
    const component = Component.parse(componentStr);
    component.validate();
  }
  toBuffer(pretty) {
    const args = (0, _utils().getStringifyArgs)(pretty);
    const obj = this.toObject();
    const str = JSON.stringify(obj, ...args);
    if (this.validateBeforePersist) this.validateBeforePersisting(str);
    return Buffer.from(str);
  }

  /**
   * Clear data that is relevant only for the local scope and should not be moved to the remote scope
   */
  clearStateData() {
    this.local = false; // backward compatibility for components created before 0.12.6
    this.state = {};
  }
  markVersionAsLocal(version) {
    if (!this.state.versions) this.state = {
      versions: {}
    };
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (!this.state.versions[version]) this.state.versions[version] = {};
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    this.state.versions[version].local = true;
  }

  /**
   * local versions that are not exported on the main lane.
   * @see `this.getLocalTagsOrHashes()`, to get local snaps on the current lane
   */
  getLocalVersions() {
    if ((0, _lodash().isEmpty)(this.state) || (0, _lodash().isEmpty)(this.state.versions)) return [];
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return Object.keys(this.state.versions).filter(version => this.state.versions[version].local);
  }
  hasLocalTag(tag) {
    const localVersions = this.getLocalVersions();
    return localVersions.includes(tag);
  }
  async hasLocalVersion(repo, version) {
    const localVersions = await this.getLocalTagsOrHashes(repo);
    return localVersions.includes(version);
  }
  async getLocalTagsOrHashes(repo) {
    await this.setDivergeData(repo);
    const divergeData = this.getDivergeData();
    const localHashes = divergeData.snapsOnLocalOnly;
    if (!localHashes.length) return [];
    return this.switchHashesWithTagsIfExist(localHashes).reverse(); // reverse to get the older first
  }

  getLocalHashes() {
    const divergeData = this.getDivergeData();
    const localHashes = divergeData.snapsOnLocalOnly;
    if (!localHashes.length) return [];
    return localHashes.reverse(); // reverse to get the older first
  }

  /**
   * for most cases, use `isLocallyChanged`, which takes into account lanes.
   * this is for cases when we only care about the versions exist in the `state` prop.
   */
  isLocallyChangedRegardlessOfLanes() {
    return Boolean(this.getLocalVersions().length);
  }

  /**
   * whether the component was locally changed, either by adding a new snap/tag or by merging
   * components from different lanes.
   */
  async isLocallyChanged(repo, lane) {
    if (lane) await this.populateLocalAndRemoteHeads(repo, lane);
    await this.setDivergeData(repo);
    return this.getDivergeData().isLocalAhead();
  }
  static parse(contents) {
    const rawComponent = JSON.parse(contents);
    return Component.from({
      name: rawComponent.box ? `${rawComponent.box}/${rawComponent.name}` : rawComponent.name,
      scope: rawComponent.scope,
      versions: (0, _utils().mapObject)(rawComponent.versions, val => _objects().Ref.from(val)),
      lang: rawComponent.lang,
      deprecated: rawComponent.deprecated,
      bindingPrefix: rawComponent.bindingPrefix,
      local: rawComponent.local,
      state: rawComponent.state,
      orphanedVersions: (0, _utils().mapObject)(rawComponent.orphanedVersions || {}, val => _objects().Ref.from(val)),
      scopesList: rawComponent.remotes,
      head: rawComponent.head ? _objects().Ref.from(rawComponent.head) : undefined,
      schema: rawComponent.schema || (rawComponent.head ? _componentSchema().SchemaName.Harmony : _componentSchema().SchemaName.Legacy)
    });
  }
  static from(props) {
    return new Component(props);
  }
  static fromBitId(bitId) {
    if (bitId.box) throw new Error('component.fromBitId, bitId should not have the "box" property populated');
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return new Component({
      name: bitId.name,
      scope: bitId.scope
    });
  }
  get isLegacy() {
    return !this.schema || this.schema === _componentSchema().SchemaName.Legacy;
  }
  validate() {
    const message = `unable to save Component object "${this.id()}"`;
    if (!this.name) throw new (_generalError().default)(`${message} the name is missing`);
    if (this.state && this.state.versions) {
      Object.keys(this.state.versions).forEach(version => {
        if ((0, _componentVersion().isTag)(version) && !this.hasTag(version)) {
          throw new (_validationError().default)(`${message}, the version ${version} is marked as staged but is not available`);
        }
      });
    }
    const hashDuplications = (0, _findDuplications().default)(this.versionArray.map(v => v.toString()));
    if (hashDuplications.length) {
      throw new (_validationError().default)(`${message}, the following hash(es) are duplicated ${hashDuplications.join(', ')}`);
    }
    Object.keys(this.orphanedVersions).forEach(version => {
      if (this.versions[version]) {
        throw new (_validationError().default)(`${message}, the version "${version}" exists in orphanedVersions but it exits also in "versions" prop`);
      }
    });
    if (!this.isLegacy && !this.head && this.versionArray.length) {
      // legacy don't have head. also, when snapping on a lane the first time, there is no head.
      // tags are done on default lane only, so if there are versions (tag), it must have head
      throw new (_validationError().default)(`${message}, the "head" prop is missing`);
    }
  }
}
exports.default = Component;