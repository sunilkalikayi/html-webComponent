"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _uuid() {
  const data = require("uuid");
  _uuid = function () {
    return data;
  };
  return data;
}
function _componentVersion() {
  const data = require("@teambit/component-version");
  _componentVersion = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _validationError() {
  const data = _interopRequireDefault(require("../../error/validation-error"));
  _validationError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _traverseVersions() {
  const data = require("../component-ops/traverse-versions");
  _traverseVersions = function () {
    return data;
  };
  return data;
}
function _objects() {
  const data = require("../objects");
  _objects = function () {
    return data;
  };
  return data;
}
function globalConfig() {
  const data = _interopRequireWildcard(require("../../api/consumer/lib/global-config"));
  globalConfig = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class Lane extends _objects().BitObject {
  // reason for the underscore prefix is that we already have hash as a method
  // doesn't get saved in the object. only needed for in-memory instance
  constructor(props) {
    super();
    (0, _defineProperty2().default)(this, "name", void 0);
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "components", void 0);
    (0, _defineProperty2().default)(this, "log", void 0);
    (0, _defineProperty2().default)(this, "readmeComponent", void 0);
    (0, _defineProperty2().default)(this, "forkedFrom", void 0);
    (0, _defineProperty2().default)(this, "_hash", void 0);
    (0, _defineProperty2().default)(this, "isNew", false);
    if (!props.name) throw new TypeError('Lane constructor expects to get a name parameter');
    this.name = props.name;
    this.scope = props.scope;
    this.components = props.components || [];
    this.log = props.log || {};
    this._hash = props.hash;
    this.readmeComponent = props.readmeComponent;
    this.forkedFrom = props.forkedFrom;
  }
  id() {
    return this.scope + _laneId().LANE_REMOTE_DELIMITER + this.name;
  }
  hash() {
    if (!this._hash) {
      throw new Error('hash is missing from a Lane object');
    }
    return new (_objects().Ref)(this._hash);
  }
  refs() {
    return this.components.map(c => c.head);
  }
  validateBeforePersisting(str) {
    _logger().default.debug(`validating lane object: ${this.hash().toString()} ${this.id()}`);
    const lane = Lane.parse(str, this.hash().toString());
    lane.validate();
  }
  toObject() {
    var _this$readmeComponent, _this$readmeComponent2;
    const obj = (0, _utils().filterObject)({
      name: this.name,
      scope: this.scope,
      components: this.components.map(component => ({
        id: {
          scope: component.id.scope,
          name: component.id.name
        },
        head: component.head.toString()
      })),
      log: this.log,
      readmeComponent: this.readmeComponent && {
        id: {
          scope: this.readmeComponent.id.scope,
          name: this.readmeComponent.id.name
        },
        head: (_this$readmeComponent = (_this$readmeComponent2 = this.readmeComponent.head) === null || _this$readmeComponent2 === void 0 ? void 0 : _this$readmeComponent2.toString()) !== null && _this$readmeComponent !== void 0 ? _this$readmeComponent : null
      },
      forkedFrom: this.forkedFrom && this.forkedFrom.toObject()
    }, val => !!val);
    return obj;
  }
  static from(props) {
    return new Lane(props);
  }
  static create(name, scope, forkedFrom) {
    const log = {
      date: Date.now().toString(),
      username: globalConfig().getSync(_constants().CFG_USER_NAME_KEY),
      email: globalConfig().getSync(_constants().CFG_USER_EMAIL_KEY)
    };
    return new Lane({
      name,
      scope,
      hash: (0, _utils().sha1)((0, _uuid().v4)()),
      log,
      forkedFrom
    });
  }
  static parse(contents, hash) {
    const laneObject = JSON.parse(contents);
    return Lane.from({
      name: laneObject.name,
      scope: laneObject.scope,
      log: laneObject.log,
      components: laneObject.components.map(component => ({
        id: new (_bitId().BitId)({
          scope: component.id.scope,
          name: component.id.name
        }),
        head: new (_objects().Ref)(component.head)
      })),
      readmeComponent: laneObject.readmeComponent && {
        id: new (_bitId().BitId)({
          scope: laneObject.readmeComponent.id.scope,
          name: laneObject.readmeComponent.id.name
        }),
        head: laneObject.readmeComponent.head && new (_objects().Ref)(laneObject.readmeComponent.head)
      },
      forkedFrom: laneObject.forkedFrom && _laneId().LaneId.from(laneObject.forkedFrom.name, laneObject.forkedFrom.scope),
      hash: laneObject.hash || hash
    });
  }
  toBuffer(pretty) {
    const args = (0, _utils().getStringifyArgs)(pretty);
    const obj = this.toObject();
    const str = JSON.stringify(obj, ...args);
    if (this.validateBeforePersist) this.validateBeforePersisting(str);
    return Buffer.from(str);
  }
  addComponent(component) {
    const existsComponent = this.getComponentByName(component.id);
    if (existsComponent) {
      existsComponent.id = component.id;
      existsComponent.head = component.head;
    } else {
      _logger().default.debug(`Lane.addComponent, adding component ${component.id.toString()} to lane ${this.id()}`);
      this.components.push(component);
    }
  }
  removeComponent(id) {
    const existsComponent = this.getComponentByName(id);
    if (!existsComponent) return false;
    this.components = this.components.filter(c => !c.id.isEqualWithoutScopeAndVersion(id));
    return true;
  }
  getComponentByName(bitId) {
    return this.components.find(c => c.id.isEqualWithoutScopeAndVersion(bitId));
  }
  getComponent(id) {
    return this.components.find(c => c.id.isEqualWithoutVersion(id));
  }
  getComponentHead(bitId) {
    const found = this.components.find(c => c.id.isEqual(bitId));
    if (found) return found.head;
    return null;
  }
  setLaneComponents(laneComponents) {
    // this gets called when adding lane-components from other lanes/remotes, so it's better to
    // clone the objects to not change the original data.
    this.components = laneComponents.map(c => ({
      id: c.id.clone(),
      head: c.head.clone()
    }));
  }
  setReadmeComponent(id) {
    if (!id) {
      this.readmeComponent = undefined;
      return;
    }
    const readmeComponent = this.getComponentByName(id);
    if (!readmeComponent) {
      this.readmeComponent = {
        id,
        head: null
      };
    } else {
      this.readmeComponent = readmeComponent;
    }
  }
  async isFullyMerged(scope) {
    const {
      unmerged
    } = await this.getMergedAndUnmergedIds(scope);
    return unmerged.length === 0;
  }
  async getMergedAndUnmergedIds(scope) {
    const merged = [];
    const unmerged = [];
    await Promise.all(this.components.map(async component => {
      const modelComponent = await scope.getModelComponentIfExist(component.id);
      if (!modelComponent) {
        unmerged.push(component.id);
        return;
      }
      const startTraverseFrom = modelComponent.getHead() || null; // it's important to have it as null and not as undefined, see hasVersionByRef
      const headExist = await (0, _traverseVersions().hasVersionByRef)(modelComponent, component.head, scope.objects, startTraverseFrom);
      if (headExist) merged.push(component.id);else unmerged.push(component.id);
    }));
    return {
      merged,
      unmerged
    };
  }
  toBitIds() {
    return _bitId().BitIds.fromArray(this.components.map(c => c.id.changeVersion(c.head.toString())));
  }
  toLaneId() {
    return new (_laneId().LaneId)({
      scope: this.scope,
      name: this.name
    });
  }
  collectObjectsById(repo) {
    return Promise.all(this.components.map(async component => {
      const headVersion = await component.head.load(repo);
      const objects = [headVersion, ...headVersion.collect(repo)];
      return {
        id: component.id,
        objects
      };
    }));
  }
  validate() {
    const message = `unable to save Lane object "${this.id()}"`;
    // validate that the head
    this.components.forEach(component => {
      if (this.components.filter(c => c.id.name === component.id.name).length > 1) {
        throw new (_validationError().default)(`${message}, the following component is duplicated "${component.id.name}"`);
      }
      if (!(0, _componentVersion().isHash)(component.head.hash)) {
        throw new (_validationError().default)(`${message}, lane component ${component.id.toStringWithoutVersion()} head should be a hash, got ${component.head.hash}`);
      }
    });
    if (this.name === _laneId().DEFAULT_LANE) {
      throw new (_generalError().default)(`${message}, this name is reserved as the default lane`);
    }
    if (this.name === _constants().PREVIOUS_DEFAULT_LANE) {
      throw new (_generalError().default)(`${message}, this name is reserved as the old default lane`);
    }
  }
  clone() {
    return new Lane(_objectSpread(_objectSpread({}, this), {}, {
      hash: this._hash,
      components: [...this.components]
    }));
  }
}
exports.default = Lane;