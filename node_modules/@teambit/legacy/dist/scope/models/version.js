"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _is2() {
  const data = _interopRequireDefault(require("ramda/src/is"));
  _is2 = function () {
    return data;
  };
  return data;
}
function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));
  _flatten2 = function () {
    return data;
  };
  return data;
}
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _componentVersion() {
  const data = require("@teambit/component-version");
  _componentVersion = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _componentSchema() {
  const data = require("../../consumer/component/component-schema");
  _componentSchema = function () {
    return data;
  };
  return data;
}
function _dependencies() {
  const data = require("../../consumer/component/dependencies");
  _dependencies = function () {
    return data;
  };
  return data;
}
function _sources() {
  const data = require("../../consumer/component/sources");
  _sources = function () {
    return data;
  };
  return data;
}
function _artifactFiles() {
  const data = require("../../consumer/component/sources/artifact-files");
  _artifactFiles = function () {
    return data;
  };
  return data;
}
function _extensionData() {
  const data = require("../../consumer/config/extension-data");
  _extensionData = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _versionInvalid() {
  const data = _interopRequireDefault(require("../exceptions/version-invalid"));
  _versionInvalid = function () {
    return data;
  };
  return data;
}
function _objects() {
  const data = require("../objects");
  _objects = function () {
    return data;
  };
  return data;
}
function _versionValidator() {
  const data = _interopRequireDefault(require("../version-validator"));
  _versionValidator = function () {
    return data;
  };
  return data;
}
function _bootstrap() {
  const data = require("../../bootstrap");
  _bootstrap = function () {
    return data;
  };
  return data;
}
/**
 * Represent a version model in the scope
 */
class Version extends _objects().BitObject {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  // reason for the underscore prefix is that we already have hash as a method

  // when a component is squashed during lane-merge
  // when a component from a lane was created with the same name/scope as main, this ref points to the component of the lane

  // can help debugging errors when validating Version object

  constructor(props) {
    super();
    (0, _defineProperty2().default)(this, "mainFile", void 0);
    (0, _defineProperty2().default)(this, "files", void 0);
    (0, _defineProperty2().default)(this, "log", void 0);
    (0, _defineProperty2().default)(this, "docs", void 0);
    (0, _defineProperty2().default)(this, "dependencies", void 0);
    (0, _defineProperty2().default)(this, "devDependencies", void 0);
    (0, _defineProperty2().default)(this, "flattenedDependencies", void 0);
    (0, _defineProperty2().default)(this, "packageDependencies", void 0);
    (0, _defineProperty2().default)(this, "devPackageDependencies", void 0);
    (0, _defineProperty2().default)(this, "peerPackageDependencies", void 0);
    (0, _defineProperty2().default)(this, "bindingPrefix", void 0);
    (0, _defineProperty2().default)(this, "schema", void 0);
    (0, _defineProperty2().default)(this, "overrides", void 0);
    (0, _defineProperty2().default)(this, "packageJsonChangedProps", void 0);
    (0, _defineProperty2().default)(this, "_hash", void 0);
    (0, _defineProperty2().default)(this, "parents", void 0);
    (0, _defineProperty2().default)(this, "squashed", void 0);
    (0, _defineProperty2().default)(this, "unrelated", void 0);
    (0, _defineProperty2().default)(this, "extensions", void 0);
    (0, _defineProperty2().default)(this, "buildStatus", void 0);
    (0, _defineProperty2().default)(this, "componentId", void 0);
    (0, _defineProperty2().default)(this, "bitVersion", void 0);
    this.mainFile = props.mainFile;
    this.files = props.files;
    this.log = props.log;
    this.dependencies = new (_dependencies().Dependencies)(props.dependencies);
    this.devDependencies = new (_dependencies().Dependencies)(props.devDependencies);
    this.docs = props.docs;
    this.flattenedDependencies = props.flattenedDependencies || new (_bitId().BitIds)();
    this.packageDependencies = props.packageDependencies || {};
    this.devPackageDependencies = props.devPackageDependencies || {};
    this.peerPackageDependencies = props.peerPackageDependencies || {};
    this.bindingPrefix = props.bindingPrefix;
    this.schema = props.schema;
    this.overrides = props.overrides || {};
    this.packageJsonChangedProps = props.packageJsonChangedProps || {};
    // @ts-ignore yes, props.hash can be undefined here, but it gets populated as soon as Version is created
    this._hash = props.hash;
    this.parents = props.parents || [];
    this.squashed = props.squashed;
    this.unrelated = props.unrelated;
    this.extensions = props.extensions || _extensionData().ExtensionDataList.fromArray([]);
    this.buildStatus = props.buildStatus;
    this.componentId = props.componentId;
    this.bitVersion = props.bitVersion;
    this.validateVersion();
  }
  validateVersion() {
    const nonEmptyFields = ['mainFile', 'files'];
    nonEmptyFields.forEach(field => {
      if (!this[field]) {
        throw new (_versionInvalid().default)(`failed creating a version object, the field "${field}" can't be empty`);
      }
    });
  }
  id() {
    const obj = this.toObject();

    // @todo: remove the entire dependencies.relativePaths from the ID (it's going to be a breaking change)
    const getDependencies = deps => {
      const clonedDependencies = deps.cloneAsString();
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return clonedDependencies.map(dependency => {
        return {
          id: dependency.id,
          relativePaths: dependency.relativePaths.map(relativePath => {
            return {
              sourceRelativePath: relativePath.sourceRelativePath,
              destinationRelativePath: relativePath.destinationRelativePath
            };
          })
        };
      });
    };
    const getExtensions = extensions => {
      const sortedConfigOnly = extensions.sortById().toConfigArray();
      return sortedConfigOnly;
    };
    const filterFunction = (val, key) => {
      if (key === 'devDependencies' || key === 'extensionDependencies' || key === 'devPackageDependencies' || key === 'peerPackageDependencies' || key === 'overrides' || key === 'extensions') {
        return !(0, _isEmpty2().default)(val);
      }
      return !!val;
    };
    return JSON.stringify((0, _utils().filterObject)({
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      mainFile: obj.mainFile,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      files: obj.files,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      log: obj.log,
      dependencies: getDependencies(this.dependencies),
      devDependencies: getDependencies(this.devDependencies),
      extensionDependencies: getDependencies(this.extensionDependencies),
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageDependencies: obj.packageDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      devPackageDependencies: obj.devPackageDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      peerPackageDependencies: obj.peerPackageDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      bindingPrefix: obj.bindingPrefix,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      overrides: obj.overrides,
      extensions: getExtensions(this.extensions)
    }, filterFunction));
  }
  calculateHash() {
    return new (_objects().Ref)(_objects().BitObject.makeHash(this.id()));
  }
  hash() {
    if (!this._hash) {
      throw new Error('hash is missing from a Version object');
    }
    return new (_objects().Ref)(this._hash);
  }
  get extensionDependencies() {
    return new (_dependencies().Dependencies)(this.extensions.extensionsBitIds.map(id => new (_dependencies().Dependency)(id, [])));
  }
  getAllFlattenedDependencies() {
    return _bitId().BitIds.fromArray([...this.flattenedDependencies]);
  }
  getAllDependencies() {
    return [...this.dependencies.dependencies, ...this.devDependencies.dependencies, ...this.extensionDependencies.dependencies];
  }
  get depsIdsGroupedByType() {
    return {
      dependencies: this.dependencies.getAllIds(),
      devDependencies: this.devDependencies.getAllIds(),
      extensionDependencies: this.extensions.extensionsBitIds
    };
  }
  getAllDependenciesCloned() {
    const dependencies = [...this.dependencies.getClone(), ...this.devDependencies.getClone()];
    return new (_dependencies().Dependencies)(dependencies);
  }
  getAllDependenciesIds() {
    const allDependencies = (0, _flatten2().default)(Object.values(this.depsIdsGroupedByType));
    return _bitId().BitIds.fromArray(allDependencies);
  }
  getDependenciesIdsExcludeExtensions() {
    return _bitId().BitIds.fromArray([...this.dependencies.getAllIds(), ...this.devDependencies.getAllIds()]);
  }
  updateFlattenedDependency(currentId, newId) {
    const getUpdated = flattenedDependencies => {
      const updatedIds = flattenedDependencies.map(depId => {
        if (depId.isEqual(currentId)) return newId;
        return depId;
      });
      return _bitId().BitIds.fromArray(updatedIds);
    };
    this.flattenedDependencies = getUpdated(this.flattenedDependencies);
  }
  refs() {
    return this.refsWithOptions();
  }
  refsWithOptions(includeParents = true, includeArtifacts = true) {
    const allRefs = [];
    const extractRefsFromFiles = files => {
      const refs = files ? files.map(file => file.file) : [];
      return refs;
    };
    const files = extractRefsFromFiles(this.files);
    allRefs.push(...files);
    if (includeParents) {
      allRefs.push(...this.parents);
    }
    if (includeArtifacts) {
      const artifacts = (0, _artifactFiles().getRefsFromExtensions)(this.extensions);
      allRefs.push(...artifacts);
    }
    return allRefs;
  }
  refsWithoutParents() {
    const extractRefsFromFiles = files => {
      const refs = files ? files.map(file => file.file) : [];
      return refs;
    };
    const files = extractRefsFromFiles(this.files);
    const artifacts = (0, _artifactFiles().getRefsFromExtensions)(this.extensions);
    return [...files, ...artifacts].filter(ref => ref);
  }
  async collectManyObjects(repo, refs) {
    return repo.loadManyRaw(refs);
  }
  toObject() {
    const _convertFileToObject = file => {
      return {
        file: file.file.toString(),
        relativePath: file.relativePath,
        name: file.name,
        test: file.test
      };
    };
    return (0, _utils().filterObject)({
      files: this.files ? this.files.map(_convertFileToObject) : null,
      mainFile: this.mainFile,
      bindingPrefix: this.bindingPrefix || _constants().DEFAULT_BINDINGS_PREFIX,
      schema: this.schema,
      log: {
        message: this.log.message,
        date: this.log.date,
        username: this.log.username,
        email: this.log.email
      },
      docs: this.docs,
      dependencies: this.dependencies.cloneAsObject(),
      devDependencies: this.devDependencies.cloneAsObject(),
      flattenedDependencies: this.flattenedDependencies.map(dep => dep.serialize()),
      extensions: this.extensions.toModelObjects(),
      packageDependencies: this.packageDependencies,
      devPackageDependencies: this.devPackageDependencies,
      peerPackageDependencies: this.peerPackageDependencies,
      overrides: this.overrides,
      buildStatus: this.buildStatus,
      packageJsonChangedProps: this.packageJsonChangedProps,
      parents: this.parents.map(p => p.toString()),
      squashed: this.squashed ? {
        previousParents: this.squashed.previousParents.map(p => p.toString()),
        laneId: this.squashed.laneId.toObject()
      } : undefined,
      unrelated: this.unrelated ? {
        head: this.unrelated.head.toString(),
        laneId: this.unrelated.laneId.toObject()
      } : undefined,
      bitVersion: this.bitVersion
    }, val => !!val);
  }
  validateBeforePersisting(versionStr) {
    _logger().default.trace(`validating version object, hash: ${this.hash().hash}`);
    const version = Version.parse(versionStr, this._hash);
    version.validate();
  }
  toBuffer(pretty) {
    const obj = this.toObject();
    const args = (0, _utils().getStringifyArgs)(pretty);
    const str = JSON.stringify(obj, ...args);
    if (this.validateBeforePersist) this.validateBeforePersisting(str);
    return Buffer.from(str);
  }
  /**
   * used by the super class BitObject
   */
  static parse(contents, hash) {
    const contentParsed = JSON.parse(contents);
    const {
      mainFile,
      files,
      bindingPrefix,
      schema,
      log,
      docs,
      dependencies,
      devDependencies,
      flattenedDependencies,
      flattenedDevDependencies,
      devPackageDependencies,
      peerPackageDependencies,
      packageDependencies,
      overrides,
      packageJsonChangedProps,
      extensions,
      buildStatus,
      parents,
      squashed,
      unrelated,
      bitVersion
    } = contentParsed;
    const _getDependencies = (deps = []) => {
      if (deps.length && (0, _is2().default)(String, (0, _utils().first)(deps))) {
        // backward compatibility
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        return deps.map(dependency => ({
          id: _bitId().BitId.parseObsolete(dependency)
        }));
      }
      const getRelativePath = relativePath => {
        if (relativePath.importSpecifiers) {
          // backward compatibility. Before the massive validation was added, an item of
          // relativePath.importSpecifiers array could be missing the mainFile property, which is
          // an invalid ImportSpecifier. (instead the mainFile it had another importSpecifiers object).
          relativePath.importSpecifiers = relativePath.importSpecifiers.filter(importSpecifier => importSpecifier.mainFile);
          if (!relativePath.importSpecifiers.length) delete relativePath.importSpecifiers;
        }
        return relativePath;
      };
      return deps.map(dependency => {
        return {
          id: _bitId().BitId.parseBackwardCompatible(dependency.id),
          relativePaths: Array.isArray(dependency.relativePaths) ? dependency.relativePaths.map(getRelativePath) : dependency.relativePaths
        };
      });
    };
    const _getFlattenedDependencies = (deps = []) => {
      return deps.map(dep => _bitId().BitId.parseBackwardCompatible(dep));
    };
    const _groupFlattenedDependencies = () => {
      // support backward compatibility. until v15, there was both flattenedDependencies and
      // flattenedDevDependencies. since then, these both were grouped to one flattenedDependencies
      const flattenedDeps = _getFlattenedDependencies(flattenedDependencies);
      const flattenedDevDeps = _getFlattenedDependencies(flattenedDevDependencies);
      return _bitId().BitIds.fromArray([...flattenedDeps, ...flattenedDevDeps]);
    };
    const parseFile = file => {
      return {
        file: _objects().Ref.from(file.file),
        relativePath: file.relativePath,
        name: file.name,
        test: file.test
      };
    };
    const _getExtensions = (exts = []) => {
      if (exts.length) {
        const newExts = exts.map(extension => {
          if (extension.extensionId) {
            const extensionId = new (_bitId().BitId)(extension.extensionId);
            const entry = new (_extensionData().ExtensionDataEntry)(undefined, extensionId, undefined, extension.config, extension.data);
            return entry;
          }
          const entry = new (_extensionData().ExtensionDataEntry)(extension.id, undefined, extension.name, extension.config, extension.data);
          return entry;
        });
        return _extensionData().ExtensionDataList.fromModelObject(newExts);
      }
      return new (_extensionData().ExtensionDataList)();
    };
    return new Version({
      mainFile,
      files: files ? files.map(parseFile) : null,
      bindingPrefix: bindingPrefix || null,
      schema: schema || undefined,
      log: {
        message: log.message,
        date: log.date,
        username: log.username,
        email: log.email
      },
      docs,
      dependencies: _getDependencies(dependencies),
      devDependencies: _getDependencies(devDependencies),
      flattenedDependencies: _groupFlattenedDependencies(),
      devPackageDependencies,
      peerPackageDependencies,
      packageDependencies,
      overrides,
      packageJsonChangedProps,
      hash,
      parents: parents ? parents.map(p => _objects().Ref.from(p)) : [],
      squashed: squashed ? {
        previousParents: squashed.previousParents.map(r => _objects().Ref.from(r)),
        laneId: new (_laneId().LaneId)(squashed.laneId)
      } : undefined,
      unrelated: unrelated ? {
        head: _objects().Ref.from(unrelated.head),
        laneId: new (_laneId().LaneId)(unrelated.laneId)
      } : undefined,
      extensions: _getExtensions(extensions),
      buildStatus,
      bitVersion
    });
  }

  /**
   * used by raw-object.toRealObject()
   */
  static from(versionProps, hash) {
    return Version.parse(JSON.stringify(versionProps), hash);
  }

  /**
   * Create version model object from consumer component
   * @param {*} param0
   */
  static fromComponent({
    component,
    files
  }) {
    const parseFile = file => {
      return {
        file: file.file.hash(),
        relativePath: file.relativePath,
        name: file.name,
        test: file.test
      };
    };
    if (!component.log) throw new Error('Version.fromComponent - component.log is missing');
    const version = new Version({
      mainFile: component.mainFile,
      files: files.map(parseFile),
      bindingPrefix: component.bindingPrefix,
      log: component.log,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      docs: component.docs,
      dependencies: component.dependencies.get(),
      devDependencies: component.devDependencies.get(),
      packageDependencies: component.packageDependencies,
      devPackageDependencies: component.devPackageDependencies,
      peerPackageDependencies: component.peerPackageDependencies,
      flattenedDependencies: component.flattenedDependencies,
      schema: component.schema,
      overrides: component.overrides.componentOverridesData,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageJsonChangedProps: component.packageJsonChangedProps,
      extensions: component.extensions,
      buildStatus: component.buildStatus,
      componentId: component.id,
      bitVersion: (0, _bootstrap().getHarmonyVersion)(true)
    });
    if ((0, _componentVersion().isHash)(component.version)) {
      version._hash = component.version;
    } else {
      version.setNewHash();
    }
    return version;
  }
  setNewHash() {
    // @todo: after v15 is deployed, this can be changed to generate a random uuid
    this._hash = this.calculateHash().toString();
  }
  get ignoreSharedDir() {
    return !(0, _componentSchema().isSchemaSupport)(_componentSchema().SchemaFeature.sharedDir, this.schema);
  }
  get isLegacy() {
    return !this.schema || this.schema === _componentSchema().SchemaName.Legacy;
  }
  setDist(dist) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    this.dist = dist ? {
      file: dist.hash(),
      name: _constants().DEFAULT_BUNDLE_FILENAME
    } : null;
  }
  hasParent(ref) {
    return this.parents.find(p => p.toString() === ref.toString());
  }
  addParent(ref) {
    if (this.isLegacy) return;
    if (this.hasParent(ref)) {
      return; // make sure to not add twice
    }

    this.parents.push(ref);
  }
  setSquashed(squashData) {
    this.squashed = squashData;
  }
  addAsOnlyParent(ref) {
    if (this.isLegacy) return;
    this.parents = [ref];
  }
  removeParent(ref) {
    this.parents = this.parents.filter(p => p.toString() !== ref.toString());
  }
  modelFilesToSourceFiles(repository) {
    return Promise.all(this.files.map(file => _sources().SourceFile.loadFromSourceFileModel(file, repository)));
  }
  isRemoved() {
    var _this$extensions$find, _this$extensions$find2;
    return Boolean((_this$extensions$find = this.extensions.findCoreExtension(_constants().Extensions.remove)) === null || _this$extensions$find === void 0 ? void 0 : (_this$extensions$find2 = _this$extensions$find.config) === null || _this$extensions$find2 === void 0 ? void 0 : _this$extensions$find2.removed);
  }

  /**
   * Validate the version model properties, to make sure we are not inserting something
   * in the wrong format
   */
  validate() {
    (0, _versionValidator().default)(this);
  }
}
exports.default = Version;