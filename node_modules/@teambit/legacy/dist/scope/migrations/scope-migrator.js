"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = migrate;
function _values2() {
  const data = _interopRequireDefault(require("ramda/src/values"));
  _values2 = function () {
    return data;
  };
  return data;
}
function _forEach2() {
  const data = _interopRequireDefault(require("ramda/src/forEach"));
  _forEach2 = function () {
    return data;
  };
  return data;
}
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _objects() {
  const data = require("../objects");
  _objects = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
let globalVerbose = false;
const refsIndex = {};

/**
 * Running migration process for scope
 * @param {string} scopeVersion - The current scope version
 * @param {Object} migratonManifest - A manifest which define what migrations to run
 * @param {BitRawObject} objects - Scope's raw objects
 * @param {boolean} verbose - print logs
 */
async function migrate(migrations, objects, verbose = false) {
  globalVerbose = verbose;
  const result = {
    newObjects: {},
    refsToRemove: []
  };
  if ((0, _isEmpty2().default)(migrations)) {
    const noMigrationMsg = 'there are no migrations to run, leaving the scope as is with no changes';
    _logger().default.debug(noMigrationMsg);
    if (verbose) console.log(noMigrationMsg); // eslint-disable-line
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return result;
  }
  (0, _forEach2().default)(_runAllMigrationsForObject(migrations), objects);
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  (0, _forEach2().default)(_getRealObjectWithUpdatedRefs(result, refsIndex), objects);
  result.newObjects = (0, _values2().default)(result.newObjects);
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  return result;
}

/**
 * Runs all the migrations for all the versions for a given object
 * @param {VersionMigrations[]} migrations
 */
const _runAllMigrationsForObject = migrations => rawObject => {
  // Make sure we got a rawObject (we might get a null object in case of corrupted object)
  if (!rawObject) {
    return null;
  }
  _logger().default.debug(`start updating object ${rawObject.ref} (${rawObject.id})`);
  // Skip Source files since we don't want the migration to run over them
  if (rawObject.type === 'Source') return null;
  // Add refs to index
  _addObjectRefsToIndex(refsIndex, rawObject);
  return (0, _forEach2().default)(_runAllVersionMigrationsForObject(rawObject), migrations);
};

/**
 * Runs all the the migration in specific version on object
 * @param {BitRawObject} rawObject - object to run migration on
 */
const _runAllVersionMigrationsForObject = rawObject => migrations => {
  const versionNumber = Object.keys(migrations)[0];
  _logger().default.debug(`updating object ${rawObject.ref} (${rawObject.id}) to version ${versionNumber}`);
  const migrationForObjectType = migrations[versionNumber][rawObject.type];
  // There is no migration for this type of object for this version
  if (!migrationForObjectType) return rawObject;
  return (0, _forEach2().default)(_runOneMigrationForObject(rawObject), migrationForObjectType);
};

/**
 * Run specific migration function on an object
 * @param {BitRawObject} rawObject
 */
const _runOneMigrationForObject = rawObject => migration => {
  _logger().default.debug(`running migration: ${migration.name} on object ${rawObject.ref} (${rawObject.id})`);
  if (globalVerbose) console.log(`running migration: ${migration.name} on object ${rawObject.ref} (${rawObject.id})`);
  try {
    const migratedContent = migration.migrate(rawObject.getParsedContent());
    rawObject.parsedContent = migratedContent;
    return migratedContent;
  } catch (err) {
    _logger().default.error(`FAILED - running migration: ${migration.name} on object ${rawObject.ref} (${rawObject.id})`);
    throw err;
  }
};

/**
 * Adds all the refs from the raw object to a global index
 * To improve performence in case we need to update objet in case the id of the ref has been changed
 * @param {BitRawObject} rawObject
 */
// @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
// @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
function _addObjectRefsToIndex(index, rawObject) {
  const refs = rawObject.refs();
  refs.forEach(ref => {
    index[ref] = rawObject;
  });
}

/**
 * Update a refrence for an object and return the parsed real object
 * @param {*} index - refs index in order to update refs if needed
 * @param {*} oldRef
 * @param {*} newRef
 */
// @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
// @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
const _updateRefsForObjects = (index, oldRef, newRef) => {
  // If the object doesn't has a dependent object return null
  // This object reference won't be update anywhere
  if (!index[oldRef]) {
    _logger().default.warn(`the object ref: ${oldRef} has been updated to: ${newRef} but there is no reference to this object`);
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return null;
  }
  const realObject = index[oldRef].toRealObject();
  if (oldRef !== newRef) {
    // Get the dependent object and replace the ref to the new one
    _logger().default.debug(`replacing reference for ${realObject.id()} old ref was: ${oldRef} new ref is: ${newRef}`);
    if (globalVerbose) {
      console.log(`replacing reference for ${realObject.id()} old ref was: ${oldRef} new ref is: ${newRef}`);
    }
    realObject.replaceRef(new (_objects().Ref)(oldRef), new (_objects().Ref)(newRef));
  }
  return realObject;
};

/**
 * Get the real object and update refs if needed
 * The result will be added to the result cache
 * @param {ScopeMigrationResultCache} result - results cache
 * @param {{ [string]: BitRawObject}} index - refs index in order to update refs if needed
 */
const _getRealObjectWithUpdatedRefs = (result, index) => object => {
  // Make sure we got a rawObject (we might get a null object in case of corrupted object)
  if (!object) {
    return null;
  }
  const realObject = object.toRealObject();
  // Make sure to not ovveride result we already put during the updte ref process
  if (result.newObjects[realObject.hash().hash]) return null;
  result.newObjects[realObject.hash().hash] = realObject;
  // Check if we need to update ref
  if (realObject.hash().hash !== object.ref) {
    result.refsToRemove.push(new (_objects().Ref)(object.ref));
    const dependentObject = _updateRefsForObjects(index, object.ref, realObject.hash().hash);
    // Update the dependent object only if found one
    if (dependentObject) {
      result.newObjects[dependentObject.hash().hash] = dependentObject;
    }
  }
};