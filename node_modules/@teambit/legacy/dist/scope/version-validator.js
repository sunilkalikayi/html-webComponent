"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateVersionInstance;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _forEachObjIndexed2() {
  const data = _interopRequireDefault(require("ramda/src/forEachObjIndexed"));
  _forEachObjIndexed2 = function () {
    return data;
  };
  return data;
}
function _packageJsonValidator() {
  const data = require("package-json-validator");
  _packageJsonValidator = function () {
    return data;
  };
  return data;
}
function _semver() {
  const data = require("semver");
  _semver = function () {
    return data;
  };
  return data;
}
function _validateNpmPackageName() {
  const data = _interopRequireDefault(require("validate-npm-package-name"));
  _validateNpmPackageName = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _componentSchema() {
  const data = require("../consumer/component/component-schema");
  _componentSchema = function () {
    return data;
  };
  return data;
}
function _dependencies() {
  const data = require("../consumer/component/dependencies");
  _dependencies = function () {
    return data;
  };
  return data;
}
function _dependencies2() {
  const data = require("../consumer/component/dependencies/dependencies");
  _dependencies2 = function () {
    return data;
  };
  return data;
}
function _packageJsonFile() {
  const data = _interopRequireDefault(require("../consumer/component/package-json-file"));
  _packageJsonFile = function () {
    return data;
  };
  return data;
}
function _artifactFiles() {
  const data = require("../consumer/component/sources/artifact-files");
  _artifactFiles = function () {
    return data;
  };
  return data;
}
function _componentOverrides() {
  const data = require("../consumer/config/component-overrides");
  _componentOverrides = function () {
    return data;
  };
  return data;
}
function _consumerOverrides() {
  const data = require("../consumer/config/consumer-overrides");
  _consumerOverrides = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _validateType() {
  const data = _interopRequireDefault(require("../utils/validate-type"));
  _validateType = function () {
    return data;
  };
  return data;
}
function _versionInvalid() {
  const data = _interopRequireDefault(require("./exceptions/version-invalid"));
  _versionInvalid = function () {
    return data;
  };
  return data;
}
/**
 * make sure a Version instance is correct. throw an exceptions if it is not.
 */
function validateVersionInstance(version) {
  const message = `unable to save Version object${version.componentId ? ` of "${version.componentId.toString()}"` : ''}`;
  const validateBitId = (bitId, field, validateVersion = true, validateScope = true) => {
    if (validateVersion && !bitId.hasVersion()) {
      throw new (_versionInvalid().default)(`${message}, the ${field} ${bitId.toString()} does not have a version`);
    }
    if (validateScope && !bitId.scope) {
      throw new (_versionInvalid().default)(`${message}, the ${field} ${bitId.toString()} does not have a scope`);
    }
  };
  const _validatePackageDependencyValue = (packageValue, packageName) => {
    // don't use semver.valid and semver.validRange to validate the package version because it
    // can be also a URL, Git URL or Github URL. see here: https://docs.npmjs.com/files/package.json#dependencies
    (0, _validateType().default)(message, packageValue, `version of "${packageName}"`, 'string');
  };

  /**
   * Validate that the package name and version are valid
   * @param {*} packageName
   * @param {*} packageVersion
   */
  const _validatePackageDependency = (packageVersion, packageName) => {
    const packageNameValidateResult = (0, _validateNpmPackageName().default)(packageName);
    if (!packageNameValidateResult.validForNewPackages && !packageNameValidateResult.validForOldPackages) {
      const errors = packageNameValidateResult.errors || [];
      throw new (_versionInvalid().default)(`${packageName} is invalid package name, errors:  ${errors.join()}`);
    }
    _validatePackageDependencyValue(packageVersion, packageName);
  };
  const _validatePackageDependencies = packageDependencies => {
    (0, _validateType().default)(message, packageDependencies, 'packageDependencies', 'object');
    (0, _forEachObjIndexed2().default)(_validatePackageDependency, packageDependencies);
  };
  const validateFile = (file, field) => {
    (0, _validateType().default)(message, file, field, 'object');
    if (!(0, _utils().isValidPath)(file.relativePath)) {
      throw new (_versionInvalid().default)(`${message}, the ${field} ${file.relativePath} is invalid`);
    }
    if (!file.name && field !== 'artifact') {
      throw new (_versionInvalid().default)(`${message}, the ${field} ${file.relativePath} is missing the name attribute`);
    }
    const ref = field === 'artifact' ? file.ref : file.file;
    if (!ref) throw new (_versionInvalid().default)(`${message}, the ${field} ${file.relativePath} is missing the hash`);
    if (file.name) (0, _validateType().default)(message, file.name, `${field}.name`, 'string');
    (0, _validateType().default)(message, ref, `${field}.file`, 'object');
    (0, _validateType().default)(message, ref.hash, `${field}.file.hash`, 'string');
  };
  const _validateExtension = extension => {
    if (extension.extensionId) {
      validateBitId(extension.extensionId, `extensions.${extension.extensionId.toString()}`, true, false);
    }
    // Make sure we don't insert the remove sign ("-") by mistake to the models
    if (extension.config) {
      (0, _validateType().default)(message, extension.config, 'extension.config', 'object');
    }
  };
  const validateArtifacts = extensions => {
    const artifactsFiles = (0, _artifactFiles().getArtifactsFiles)(extensions);
    artifactsFiles.forEach(artifacts => {
      artifacts.refs.map(artifact => validateFile(artifact, 'artifact'));
      const filesPaths = artifacts.refs.map(artifact => artifact.relativePath);
      const duplicateArtifacts = filesPaths.filter(file => filesPaths.filter(f => file.toLowerCase() === f.toLowerCase()).length > 1);
      if (duplicateArtifacts.length) {
        throw new (_versionInvalid().default)(`${message} the following artifact files are duplicated ${duplicateArtifacts.join(', ')}`);
      }
    });
  };
  const validateNoDuplicateExtensionEntry = extensions => {
    const existingMap = new Map();
    const duplications = [];
    extensions.forEach(ext => {
      const stringId = ext.stringId;
      if (!stringId) {
        return;
      }
      if (existingMap.has(stringId)) {
        duplications.push(stringId);
      } else {
        existingMap.set(stringId, true);
      }
    });
    if (duplications.length) {
      // a bug causing duplicate aspects was fixed in https://github.com/teambit/bit/pull/6567
      // all Version objects snapped before 0.0.882 might have this bug. ignore them.
      if (!version.bitVersion || (0, _semver().lt)(version.bitVersion, '0.0.882')) {
        return;
      }
      throw new (_versionInvalid().default)(`${message} the following extensions entries are duplicated ${duplications.join(', ')}`);
    }
  };
  const _validateExtensions = extensions => {
    if (extensions) {
      validateNoDuplicateExtensionEntry(extensions);
      extensions.map(_validateExtension);
      validateArtifacts(extensions);
    }
  };
  if (!version.mainFile) throw new (_versionInvalid().default)(`${message}, the mainFile is missing`);
  if (!(0, _utils().isValidPath)(version.mainFile)) {
    throw new (_versionInvalid().default)(`${message}, the mainFile ${version.mainFile} is invalid`);
  }
  if (!version.files || !version.files.length) throw new (_versionInvalid().default)(`${message}, the files are missing`);
  let foundMainFile = false;
  (0, _validateType().default)(message, version.files, 'files', 'array');
  const filesPaths = [];
  version.files.forEach(file => {
    validateFile(file, 'file');
    filesPaths.push(file.relativePath);
    if (file.relativePath === version.mainFile) foundMainFile = true;
  });
  if (!foundMainFile) {
    throw new (_versionInvalid().default)(`${message}, unable to find the mainFile ${version.mainFile} in the following files list: ${filesPaths.join(', ')}`);
  }
  const duplicateFiles = filesPaths.filter(file => filesPaths.filter(f => file.toLowerCase() === f.toLowerCase()).length > 1);
  if (duplicateFiles.length) {
    throw new (_versionInvalid().default)(`${message} the following files are duplicated ${duplicateFiles.join(', ')}`);
  }
  _validatePackageDependencies(version.packageDependencies);
  _validatePackageDependencies(version.devPackageDependencies);
  _validatePackageDependencies(version.peerPackageDependencies);
  _validateExtensions(version.extensions);
  _dependencies2().DEPENDENCIES_TYPES.forEach(dependenciesType => {
    if (!(version[dependenciesType] instanceof _dependencies().Dependencies)) {
      throw new (_versionInvalid().default)(`${message}, ${dependenciesType} must be an instance of Dependencies, got ${typeof version[dependenciesType]}`);
    }
  });
  version.dependencies.validate(version.componentId);
  version.devDependencies.validate(version.componentId);
  if (!version.dependencies.isEmpty() && !version.flattenedDependencies.length) {
    throw new (_versionInvalid().default)(`${message}, it has dependencies but its flattenedDependencies is empty`);
  }
  const validateFlattenedDependencies = dependencies => {
    (0, _validateType().default)(message, dependencies, 'dependencies', 'array');
    dependencies.forEach(dependency => {
      if (dependency.constructor.name !== _bitId().BitId.name) {
        throw new (_versionInvalid().default)(`${message}, a flattenedDependency expected to be BitId, got ${typeof dependency}`);
      }
      if (!dependency.hasVersion()) {
        throw new (_versionInvalid().default)(`${message}, the flattenedDependency ${dependency.toString()} does not have a version`);
      }
    });
  };
  validateFlattenedDependencies(version.flattenedDependencies);
  // extensions can be duplicate with other dependencies type. e.g. "test" can have "compile" as a
  // dependency and extensionDependency. we can't remove it from extDep, otherwise, the ext won't
  // be running
  const allDependenciesIds = version.getDependenciesIdsExcludeExtensions();
  const depsDuplications = allDependenciesIds.findDuplicationsIgnoreVersion();
  if (!(0, _isEmpty2().default)(depsDuplications)) {
    const duplicationStr = Object.keys(depsDuplications).map(id => `"${id}" shows as the following: ${depsDuplications[id].map(depId => depId.toString()).join(', ')} `).join('\n');
    throw new (_generalError().default)(`some dependencies are duplicated, see details below.
if you added a dependency to "overrides" configuration with a plus sign, make sure to add it with a minus sign in the other dependency type
for example, { dependencies: { "bar/foo": "+" }, devDependencies: { "bar/foo": "-" } }

${duplicationStr}`);
    // todo: once decided how to address duplicate dependencies, remove the line above and uncomment the line below
    // throw new VersionInvalid(`${message}, some dependencies are duplicated:\n${duplicationStr}`);
  }

  if (!version.log) throw new (_versionInvalid().default)(`${message}, the log object is missing`);
  (0, _validateType().default)(message, version.log, 'log', 'object');
  if (version.bindingPrefix) {
    (0, _validateType().default)(message, version.bindingPrefix, 'bindingPrefix', 'string');
  }
  const npmSpecs = _packageJsonValidator().PJV.getSpecMap('npm');
  const validatePackageJsonField = (fieldName, fieldValue) => {
    if (!npmSpecs[fieldName]) {
      // it's not a standard package.json field, can't validate
      return null;
    }
    const validateResult = _packageJsonValidator().PJV.validateType(fieldName, npmSpecs[fieldName], fieldValue);
    if (!validateResult.length) return null;
    return validateResult.join(', ');
  };
  const validateOverrides = (fieldValue, fieldName) => {
    const field = `overrides.${fieldName}`;
    if (_constants().DEPENDENCIES_FIELDS.includes(fieldName)) {
      (0, _validateType().default)(message, fieldValue, field, 'object');
      Object.keys(fieldValue).forEach(key => {
        (0, _validateType().default)(message, key, `property name of ${field}`, 'string');
        _validatePackageDependencyValue(fieldValue[key], key);
      });
    } else if (!_consumerOverrides().nonPackageJsonFields.includes(fieldName)) {
      const result = validatePackageJsonField(fieldName, fieldValue);
      if (result) {
        throw new (_versionInvalid().default)(`${message}, "${field}" is a package.json field but is not compliant with npm requirements. ${result}`);
      }
    }
  };
  Object.keys(version.overrides).forEach(field => {
    if (_componentOverrides().componentOverridesForbiddenFields.includes(field)) {
      throw new (_versionInvalid().default)(`${message}, the "overrides" has a forbidden key "${field}"`);
    }
    validateOverrides(version.overrides[field], field);
  });
  (0, _validateType().default)(message, version.packageJsonChangedProps, 'packageJsonChangedProps', 'object');
  const forbiddenPackageJsonProps = _packageJsonFile().default.propsNonUserChangeable();
  Object.keys(version.packageJsonChangedProps).forEach(prop => {
    (0, _validateType().default)(message, prop, 'property name of packageJson', 'string');
    if (forbiddenPackageJsonProps.includes(prop)) {
      throw new (_versionInvalid().default)(`${message}, the packageJsonChangedProps should not override the prop ${prop}`);
    }
    const result = validatePackageJsonField(prop, version.packageJsonChangedProps[prop]);
    if (result) {
      throw new (_versionInvalid().default)(`${message}, the generated package.json field "${prop}" is not compliant with npm requirements. ${result}`);
    }
  });
  if (version.parents) {
    version.parents.forEach(parent => {
      if (parent.isEqual(version.hash())) {
        throw new (_versionInvalid().default)(`${message}, its parent has the same hash as itself: ${parent.toString()}`);
      }
    });
  }
  const schema = version.schema || _componentSchema().SchemaName.Legacy;
  if (!version.isLegacy) {
    const fieldsForSchemaCheck = ['compiler', 'tester', 'dists', 'mainDistFile'];
    const fieldsForSchemaCheckNotEmpty = ['customResolvedPaths', 'compilerPackageDependencies', 'testerPackageDependencies'];
    fieldsForSchemaCheck.forEach(field => {
      if (version[field]) {
        throw new (_versionInvalid().default)(`${message}, the ${field} field is not permitted according to schema "${schema}"`);
      }
    });
    fieldsForSchemaCheckNotEmpty.forEach(field => {
      if (version[field] && !(0, _isEmpty2().default)(version[field])) {
        throw new (_versionInvalid().default)(`${message}, the ${field} field is cannot have values according to schema "${schema}"`);
      }
    });
    ['dependencies', 'devDependencies'].forEach(dependenciesField => {
      const deps = version[dependenciesField];
      deps.dependencies.forEach(dep => {
        if (dep.relativePaths.length) {
          throw new (_versionInvalid().default)(`${message}, the ${dependenciesField} should not have relativePaths according to schema "${schema}"`);
        }
      });
    });
  }
  if (version.isLegacy) {
    // mainly to make sure that all Harmony components are saved with schema
    // if they don't have schema, they'll fail on this test
    if (version.extensions && version.extensions.some(e => e.name && e.name === 'teambit.pipelines/builder')) {
      throw new (_versionInvalid().default)(`${message}, the extensions should not include "teambit.pipelines/builder" as of the schema "${schema}"`);
    }
  }
}