"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllVersionHashes = getAllVersionHashes;
exports.getAllVersionHashesByVersionsObjects = getAllVersionHashesByVersionsObjects;
exports.getAllVersionHashesMemoized = void 0;
exports.getAllVersionsInfo = getAllVersionsInfo;
exports.getAllVersionsObjects = getAllVersionsObjects;
exports.hasVersionByRef = hasVersionByRef;
function _memoizee() {
  const data = _interopRequireDefault(require("memoizee"));
  _memoizee = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("../exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
/**
 * the snaps are saved as DAG (Direct Acyclic Graph).
 * each snap has `parents` prop.
 * when this is the first snap, the `parents` is empty.
 * the followed snap has the first snap as a parent.
 * in case of a merge between lanes, the `parents` have two snaps from the two lanes.
 *
 * traverse all versions is not cheap. it must load the Version object to extract the `parents`
 * data. so, we plan to cache it. once this is cached, we'll change the implementation of a few
 * methods here.
 */

/**
 * by default it starts the traverse from the head or lane-head, unless "startFrom" is passed.
 * if versionObjects passed, use it instead of loading from the repo.
 */
async function getAllVersionsInfo({
  modelComponent,
  repo,
  throws = true,
  versionObjects,
  startFrom,
  stopAt
}) {
  var _modelComponent$getHe;
  const results = [];
  const isAlreadyProcessed = ref => {
    return Boolean(results.find(result => result.ref.isEqual(ref)));
  };
  const getVersionObj = async ref => {
    if (!versionObjects && !repo) {
      throw new TypeError('getAllVersionsInfo expect to get either repo or versionObjects');
    }
    const foundInVersionObjects = versionObjects === null || versionObjects === void 0 ? void 0 : versionObjects.find(v => v.hash().isEqual(ref));
    if (foundInVersionObjects) return foundInVersionObjects;
    if (repo) return await ref.load(repo);
    return undefined;
  };
  const getRefToStartFrom = () => {
    if (typeof startFrom !== 'undefined') return startFrom;
    return modelComponent.getHeadRegardlessOfLane();
  };
  const laneHead = getRefToStartFrom();
  const headOnMain = (_modelComponent$getHe = modelComponent.getHead()) === null || _modelComponent$getHe === void 0 ? void 0 : _modelComponent$getHe.toString();
  let foundOnMain = (laneHead === null || laneHead === void 0 ? void 0 : laneHead.toString()) === headOnMain;
  if (!laneHead) {
    return results;
  }
  const headInfo = {
    ref: laneHead,
    tag: modelComponent.getTagOfRefIfExists(laneHead),
    parents: [],
    onLane: !foundOnMain
  };
  const shouldStop = ref => Boolean(stopAt === null || stopAt === void 0 ? void 0 : stopAt.find(r => r.isEqual(ref)));
  const head = await getVersionObj(laneHead);
  if (head) {
    if (shouldStop(head.hash())) {
      return [];
    }
    headInfo.version = head;
    headInfo.parents = head.parents;
  } else {
    headInfo.error = new (_exceptions().HeadNotFound)(modelComponent.id(), laneHead.toString());
    if (throws) throw headInfo.error;
  }
  results.push(headInfo);
  const addParentsRecursively = async version => {
    await (0, _pMapSeries().default)(version.parents, async parent => {
      if (shouldStop(parent)) {
        return;
      }
      if (isAlreadyProcessed(parent)) {
        // happens when there are two parents at some point, and then they merged
        return;
      }
      const parentVersion = await getVersionObj(parent);
      if (!foundOnMain) foundOnMain = (parentVersion === null || parentVersion === void 0 ? void 0 : parentVersion._hash) === headOnMain;
      const versionInfo = {
        ref: parent,
        tag: modelComponent.getTagOfRefIfExists(parent),
        isPartOfHistory: true,
        parents: (parentVersion === null || parentVersion === void 0 ? void 0 : parentVersion.parents) || [],
        onLane: !foundOnMain
      };
      if (parentVersion) {
        versionInfo.version = parentVersion;
      } else {
        versionInfo.error = versionInfo.tag ? new (_exceptions().VersionNotFound)(versionInfo.tag, modelComponent.id()) : new (_exceptions().ParentNotFound)(modelComponent.id(), version.hash().toString(), parent.toString());
        if (throws) throw versionInfo.error;
      }
      results.push(versionInfo);
      if (parentVersion) await addParentsRecursively(parentVersion);
    });
  };
  if (head) await addParentsRecursively(head);
  return results;
}
async function getAllVersionsObjects(modelComponent, repo, throws = true) {
  const allVersionsInfo = await getAllVersionsInfo({
    modelComponent,
    repo,
    throws
  });
  return allVersionsInfo.map(a => a.version).filter(a => a);
}
async function getAllVersionHashesByVersionsObjects(modelComponent, versionObjects, throws = true) {
  const allVersionsInfo = await getAllVersionsInfo({
    modelComponent,
    throws,
    versionObjects
  });
  return allVersionsInfo.map(v => v.ref).filter(ref => ref);
}
async function getAllVersionHashes(options) {
  const allVersionsInfo = await getAllVersionsInfo(options);
  return allVersionsInfo.map(v => v.ref).filter(ref => ref);
}
const getAllVersionHashesMemoized = (0, _memoizee().default)(getAllVersionHashes, {
  normalizer: args => JSON.stringify(args[0]),
  promise: true,
  maxAge: 1 // 1ms is good. it's only for consecutive calls while this function is still in process. we don't want to cache the results.
});
exports.getAllVersionHashesMemoized = getAllVersionHashesMemoized;
async function hasVersionByRef(modelComponent, ref, repo, startFrom) {
  const allVersionHashes = await getAllVersionHashes({
    modelComponent,
    repo,
    startFrom
  });
  return allVersionHashes.some(hash => hash.isEqual(ref));
}