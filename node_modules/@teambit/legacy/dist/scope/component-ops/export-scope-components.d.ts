import { BitIds } from '../../bit-id';
import { Remote } from '../../remotes';
import { Lane } from '../models';
import Scope from '../scope';
import { ObjectList } from '../objects/object-list';
import { MergeResult } from '../repositories/sources';
/**
 * ** Legacy and "bit sign" Only **
 *
 * @TODO there is no real difference between bare scope and a working directory scope - let's adjust terminology to avoid confusions in the future
 * saves a component into the objects directory of the remote scope, then, resolves its
 * dependencies, saves them as well. Finally runs the build process if needed on an isolated
 * environment.
 */
export declare function exportManyBareScope(scope: Scope, objectList: ObjectList): Promise<BitIds>;
declare type RemotesForPersist = {
    remote: Remote;
    exportedIds?: string[];
};
/**
 * save objects into the scope.
 */
export declare function saveObjects(scope: Scope, objectList: ObjectList): Promise<BitIds>;
declare type MergeObjectsResult = {
    mergedIds: BitIds;
    mergedComponentsResults: MergeResult[];
    mergedLanes: Lane[];
};
/**
 * merge components into the scope.
 *
 * a component might have multiple versions that some where merged and some were not.
 * the BitIds returned here includes the versions that were merged. so it could contain multiple
 * ids of the same component with different versions
 */
export declare function mergeObjects(scope: Scope, objectList: ObjectList, throwForMissingDeps?: boolean): Promise<MergeObjectsResult>;
export declare function validateRemotes(remotes: Remote[], clientId: string, isResumingExport?: boolean): Promise<void>;
export declare function persistRemotes(manyObjectsPerRemote: RemotesForPersist[], clientId: string): Promise<void>;
export declare function resumeExport(scope: Scope, exportId: string, remotes: string[]): Promise<string[]>;
export declare function removePendingDirs(pushedRemotes: Remote[], clientId: string): Promise<void>;
export {};
