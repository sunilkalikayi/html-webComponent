"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModelComponentMerger = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("../exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _componentNeedsUpdate() {
  const data = _interopRequireDefault(require("../exceptions/component-needs-update"));
  _componentNeedsUpdate = function () {
    return data;
  };
  return data;
}
/**
 * the base component to save is the existingComponent because it might contain local data that
 * is not available in the remote component, such as the "state"/"orphanedVersions" properties.
 */
class ModelComponentMerger {
  constructor(existingComponent, incomingComponent, isImport, isIncomingFromOrigin,
  // import: incoming from original scope. export: component belong to current scope
  existingHeadIsMissingInIncomingComponent // needed for export only
  ) {
    this.existingComponent = existingComponent;
    this.incomingComponent = incomingComponent;
    this.isImport = isImport;
    this.isIncomingFromOrigin = isIncomingFromOrigin;
    this.existingHeadIsMissingInIncomingComponent = existingHeadIsMissingInIncomingComponent;
    (0, _defineProperty2().default)(this, "mergedVersions", []);
    (0, _defineProperty2().default)(this, "isExport", void 0);
    this.isExport = !this.isImport;
  }

  /**
   * merge the existing component with the data from the incoming component.
   * in case of a conflict, it throws MergeConflict.
   */
  async merge() {
    _logger().default.debug(`model-component-merger.merge component ${this.incomingComponent.id()}`);
    this.throwComponentNeedsUpdateIfNeeded();
    const locallyChanged = this.existingComponent.isLocallyChangedRegardlessOfLanes();
    this.throwMergeConflictIfNeeded(locallyChanged);
    this.replaceTagHashIfDifferentOnIncoming();
    this.moveTagToOrphanedIfNotExistOnOrigin();
    this.addNonExistTagFromIncoming();
    this.addOrphanedVersionFromIncoming();
    this.setHead(locallyChanged);
    this.deleteOrphanedVersionsOnExport();
    return {
      mergedComponent: this.existingComponent,
      mergedVersions: this.mergedVersions
    };
  }
  deleteOrphanedVersionsOnExport() {
    // makes sure that components received with orphanedVersions, this property won't be saved
    if (this.isExport) this.existingComponent.orphanedVersions = {};
  }
  setHead(locallyChanged) {
    const incomingHead = this.incomingComponent.getHead();
    if (!incomingHead) {
      return;
    }
    if (this.isIncomingFromOrigin && !locallyChanged) {
      this.existingComponent.setHead(incomingHead);
    }
  }
  throwMergeConflictIfNeeded(locallyChanged) {
    if (!this.isIncomingFromOrigin) {
      return; // if it's not from origin, the tag is not going to save in "versions" anyway.
    }

    if (this.isImport && !locallyChanged) {
      // since the component wasn't change, we don't mind replacing it with what we got from the remote
      return;
    }
    if (!this.incomingComponent.compatibleWith(this.existingComponent, this.isImport)) {
      const conflictVersions = this.incomingComponent.diffWith(this.existingComponent, this.isImport);
      throw new (_exceptions().MergeConflict)(this.incomingComponent.id(), conflictVersions);
    }
  }
  throwComponentNeedsUpdateIfNeeded() {
    if (this.isExport && this.existingHeadIsMissingInIncomingComponent && this.incomingComponent.compatibleWith(this.existingComponent, this.isImport) // otherwise, it should throw MergeConflict below
    ) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      throw new (_componentNeedsUpdate().default)(this.incomingComponent.id(), this.existingComponent.head.toString());
    }
  }
  replaceTagHashIfDifferentOnIncoming() {
    if (!this.isIncomingFromOrigin) {
      return; // no need to replace. the existing is the correct one.
    }
    // in case the existing version hash is different than incoming version hash, use the incoming
    // version because we hold the incoming component from a remote as the source of truth
    Object.keys(this.existingComponent.versions).forEach(existingVersion => {
      if (this.incomingComponent.versions[existingVersion] && !this.existingComponent.versions[existingVersion].isEqual(this.incomingComponent.versions[existingVersion])) {
        this.existingComponent.setVersion(existingVersion, this.incomingComponent.versions[existingVersion]);
        this.mergedVersions.push(existingVersion);
      }
    });
  }
  moveTagToOrphanedIfNotExistOnOrigin() {
    Object.keys(this.existingComponent.versions).forEach(existingVersion => {
      if (!this.incomingComponent.versions[existingVersion] && this.isImport && this.isIncomingFromOrigin && !this.existingComponent.hasLocalTag(existingVersion)) {
        const ref = this.existingComponent.versions[existingVersion];
        delete this.existingComponent.versions[existingVersion];
        this.existingComponent.setOrphanedVersion(existingVersion, ref);
      }
    });
  }
  addNonExistTagFromIncoming() {
    // in case the incoming component has versions that are not in the existing component, copy them
    Object.keys(this.incomingComponent.versions).forEach(incomingVersion => {
      if (this.existingComponent.versions[incomingVersion]) {
        return;
      }
      if (this.isIncomingFromOrigin) {
        // it's legit, add the tag
        this.existingComponent.setVersion(incomingVersion, this.incomingComponent.versions[incomingVersion]);
      } else {
        // happens when retrieved from the cache of the remote.
        this.existingComponent.setOrphanedVersion(incomingVersion, this.incomingComponent.versions[incomingVersion]);
      }
      this.mergedVersions.push(incomingVersion);
    });
  }

  /**
   * a remote may have a version not in the "versions" array but in the "orphanedVersions".
   * it happens when it got that version not from the original remote but from a cache of a
   * different remote. locally, we need this data to not throw an error later about missing objects
   */
  addOrphanedVersionFromIncoming() {
    if (this.isExport) {
      return; // we shouldn't get any orphaned during export.
    }

    Object.keys(this.incomingComponent.orphanedVersions).forEach(incomingVersion => {
      if (this.existingComponent.versions[incomingVersion]) return; // no need to have the orphaned
      this.existingComponent.setOrphanedVersion(incomingVersion, this.incomingComponent.orphanedVersions[incomingVersion]);
      this.mergedVersions.push(incomingVersion);
    });
  }
}
exports.ModelComponentMerger = ModelComponentMerger;