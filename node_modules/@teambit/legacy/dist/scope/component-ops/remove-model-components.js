"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _models() {
  const data = require("../models");
  _models = function () {
    return data;
  };
  return data;
}
function _removedComponents() {
  const data = _interopRequireDefault(require("../removed-components"));
  _removedComponents = function () {
    return data;
  };
  return data;
}
/**
 * remove components from the model.
 *
 * previously, this class also removed dependencies from the scope, see https://github.com/teambit/bit/pull/5380 for
 * more details.
 */
class RemoveModelComponents {
  constructor(scope, bitIds, force, consumer, currentLane, fromLane) {
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "bitIds", void 0);
    (0, _defineProperty2().default)(this, "force", void 0);
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "currentLane", null);
    (0, _defineProperty2().default)(this, "fromLane", void 0);
    this.scope = scope;
    this.bitIds = bitIds;
    this.force = force;
    this.consumer = consumer;
    this.currentLane = currentLane;
    this.fromLane = fromLane;
  }
  async remove() {
    const {
      missingComponents,
      foundComponents
    } = await this.scope.filterFoundAndMissingComponents(this.bitIds);
    _logger().default.debug(`RemoveModelComponents.remove, found ${foundComponents.length} components to remove`);
    const dependentBits = await this.scope.getDependentsBitIds(foundComponents);
    _logger().default.debug(`RemoveModelComponents.remove, found ${Object.keys(dependentBits).length} dependents`);
    if (Object.keys(dependentBits).length && !this.force) {
      // some of the components have dependents, don't remove them
      return new (_removedComponents().default)({
        missingComponents,
        dependentBits
      });
    }
    const removedFromLane = [];
    const removalDataWithNulls = await (0, _pMapSeries().default)(foundComponents, bitId => {
      if (this.currentLane && this.fromLane) {
        const result = this.currentLane.removeComponent(bitId);
        if (result) {
          // component was found on the lane.
          removedFromLane.push(bitId);
          return null;
        }
        // component was not found on lane. it's ok, it might be on main. continue with the component removal.
      }

      return this.getRemoveSingleData(bitId);
    });
    const removalData = (0, _lodash().compact)(removalDataWithNulls);
    _logger().default.debug(`RemoveModelComponents.remove, got removalData`);
    const compIds = new (_bitId().BitIds)(...removalData.map(x => x.compId));
    const refsToRemoveAll = removalData.map(removed => removed.refsToRemove).flat();
    if (removedFromLane.length) {
      await this.scope.objects.writeObjectsToTheFS([this.currentLane]);
    }
    await this.scope.objects.deleteObjectsFromFS(refsToRemoveAll);
    await this.scope.objects.deleteRecordsFromUnmergedComponents(compIds.map(id => id.name));
    return new (_removedComponents().default)({
      removedComponentIds: compIds,
      missingComponents,
      removedFromLane: _bitId().BitIds.fromArray(removedFromLane)
    });
  }
  async getRemoveSingleData(bitId) {
    _logger().default.debug(`scope.removeSingle ${bitId.toString()}`);
    const component = (await this.scope.getModelComponent(bitId)).toComponentVersion();
    const componentsRefs = await this.getDataForRemovingComponent(bitId);
    const version = Object.keys(component.component.versions).length <= 1 ? _constants().LATEST_BIT_VERSION : bitId.version;
    return {
      compId: bitId.changeVersion(version),
      refsToRemove: componentsRefs
    };
  }
  async getDataForRemovingComponent(id) {
    const componentList = await this.scope.listIncludesSymlinks();
    const symlink = componentList.find(component => component instanceof _models().Symlink && id.isEqualWithoutScopeAndVersion(component.toBitId()));
    const refs = await this.scope.sources.getRefsForComponentRemoval(id);
    if (symlink) refs.push(symlink.hash());
    return refs;
  }
}
exports.default = RemoveModelComponents;