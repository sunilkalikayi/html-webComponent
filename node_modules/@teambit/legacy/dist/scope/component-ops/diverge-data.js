"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DivergeData = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
class DivergeData {
  constructor(snapsOnLocalOnly, snapsOnRemoteOnly, commonSnapBeforeDiverge, err) {
    (0, _defineProperty2().default)(this, "snapsOnLocalOnly", void 0);
    (0, _defineProperty2().default)(this, "snapsOnRemoteOnly", void 0);
    (0, _defineProperty2().default)(this, "commonSnapBeforeDiverge", void 0);
    (0, _defineProperty2().default)(this, "err", void 0);
    this.snapsOnLocalOnly = snapsOnLocalOnly || [];
    this.snapsOnRemoteOnly = snapsOnRemoteOnly || [];
    this.commonSnapBeforeDiverge = commonSnapBeforeDiverge || null;
    this.err = err;
  }
  /**
   * when a local and remote history have diverged, a true merge is needed.
   */
  isDiverged() {
    return Boolean(this.snapsOnLocalOnly.length && this.snapsOnRemoteOnly.length);
  }

  /**
   * when a local is ahead of the remote, no merge is needed.
   */
  isLocalAhead() {
    return Boolean(this.snapsOnLocalOnly.length);
  }

  /**
   * when a remote is ahead of the local, but local has no new commits, a fast-forward merge is possible.
   */
  isRemoteAhead() {
    return Boolean(this.snapsOnRemoteOnly.length);
  }
}
exports.DivergeData = DivergeData;