"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.string.trim.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessagePerComponentFetcher = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _openEditor() {
  const data = _interopRequireDefault(require("open-editor"));
  _openEditor = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _child_process() {
  const data = require("child_process");
  _child_process = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("../../cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
const DEFAULT_MESSAGE = 'DEFAULT:';
const DEFAULT_AUTO_TAG_MESSAGE = 'DEFAULT-AUTO-TAG:';
const formatId = id => `${id}:`;
const addSpace = str => `${str} `;
const DEFAULT_EDITOR = 'vim';
class MessagePerComponentFetcher {
  constructor(idsToTag, idsToAutoTag) {
    (0, _defineProperty2().default)(this, "idsToTagObject", void 0);
    (0, _defineProperty2().default)(this, "idsToAutoTagObject", void 0);
    this.idsToTagObject = idsToTag.toObject();
    this.idsToAutoTagObject = idsToAutoTag.toObject();
  }
  async getMessagesFromEditor(tmp, editor) {
    const template = this.getTemplate();
    const templateFilePath = await tmp.save(template);
    const editorName = typeof editor === 'string' ? editor : undefined;
    await this.openEditor(templateFilePath, editorName);
    const afterSave = await _fsExtra().default.readFile(templateFilePath, 'utf-8');
    if (template === afterSave) {
      throw new Error(`no changes have been done to the messages templates. consider using "--message" flag instead`);
    }
    await tmp.remove(templateFilePath);
    return this.parseFileWithMessages(afterSave);
  }
  getTemplate() {
    const idsToTag = this.getIdsToTagStr();
    const idsToAutoTag = this.getIdsToAutoTagStr();
    const idsStr = ids => ids.map(formatId).map(addSpace).join('\n');
    const getAutoTagTemplate = () => {
      if (!idsToAutoTag.length) return '';
      return `
# The following components will be auto-tagged (due to dependencies bump)
# You can leave the following default message to avoid setting messages for these components
${DEFAULT_AUTO_TAG_MESSAGE} bump dependencies versions
${idsStr(idsToAutoTag)}
`;
    };
    return `# Please set the messages for the following components.
# You can enter a default-message to be applied to all empty components. this is optional.
${addSpace(DEFAULT_MESSAGE)}
${idsStr(idsToTag)}
${getAutoTagTemplate()}
`;
  }
  parseFileWithMessages(messagesFileContent) {
    let defaultMessage = null;
    let defaultAutoTagMessage = null;
    const results = [];
    const idsToTagStr = this.getIdsToTagStr();
    const idsToAutoTagStr = this.getIdsToAutoTagStr();
    const messagesSplit = messagesFileContent.split('\n');

    // there are 4 sections in the template file. these 4 variables keep track in what section we're at.
    let startedDefaultMessage = false;
    let startedIdsToTag = false;
    let startedAutoTagDefaultMessage = false;
    let startedIdsToAutoTag = false;
    messagesSplit.forEach(line => {
      line = line.trim();
      if (!line) {
        return; // an empty line
      }

      if (line.startsWith('#')) {
        return; // it's a comment
      }

      if (line.startsWith(DEFAULT_MESSAGE)) {
        defaultMessage = line.replace(DEFAULT_MESSAGE, '').trim();
        startedDefaultMessage = true;
        return;
      }
      const idToTag = idsToTagStr.find(id => line.startsWith(formatId(id)));
      const removeId = id => line.replace(formatId(id), '').trim();
      if (idToTag) {
        startedIdsToTag = true;
        const msg = removeId(idToTag) || defaultMessage;
        if (!msg) {
          throw new Error(`error: "${idToTag}" has no message and the default-message was not set`);
        }
        results.push({
          id: this.idsToTagObject[idToTag],
          msg
        });
        return;
      }
      if (line.startsWith(DEFAULT_AUTO_TAG_MESSAGE)) {
        startedAutoTagDefaultMessage = true;
        defaultAutoTagMessage = line.replace(DEFAULT_AUTO_TAG_MESSAGE, '').trim();
        return;
      }
      const idToAutoTag = idsToAutoTagStr.find(id => line.startsWith(formatId(id)));
      if (idToAutoTag) {
        startedIdsToAutoTag = true;
        const msg = removeId(idToAutoTag) || defaultAutoTagMessage;
        if (!msg) {
          throw new Error(`error: "${idToTag}" has no message and the default-auto-message was not set`);
        }
        results.push({
          id: this.idsToAutoTagObject[idToAutoTag],
          msg
        });
        return;
      }
      // must be another line of one of the strings above. let's figure out what was it.
      // the template starts with the default-message, followed by the ids to tag, followed by the
      // auto-tag-default-message, followed by the ids to auto-tag.
      if (!startedDefaultMessage) {
        throw new Error(`error: the following line was added "${line}". please add the messages to the ids and default fields only`);
      }
      if (!startedIdsToTag) {
        defaultMessage += `\n${line}`;
        return;
      }
      if (!startedAutoTagDefaultMessage) {
        const lastEnteredId = results[results.length - 1];
        lastEnteredId.msg += `\n${line}`;
        return;
      }
      if (!startedIdsToAutoTag) {
        defaultAutoTagMessage += `\n${line}`;
        return;
      }
      const lastEnteredId = results[results.length - 1];
      lastEnteredId.msg += `\n${line}`;
    });
    return results;
  }
  async openEditor(templateFilePath, editor) {
    const file = {
      file: templateFilePath,
      column: DEFAULT_MESSAGE.length + 1,
      line: 3
    };
    const editorFromEnvVar = process.env.EDITOR || process.env.VISUAL; // taken from env-editor package
    if (!editorFromEnvVar && !editor) {
      editor = DEFAULT_EDITOR;
    }
    const editorData = _openEditor().default.make([file], {
      editor
    });
    if (!editorData.isTerminalEditor) {
      throw new Error(`your editor "${editorData.binary}" is not a terminal editor. either set $EDITOR in your env variable or pass "--editor" with a terminal editor (e.g. "nano", "vim")`);
    }
    _loader().default.stop();
    return new Promise((resolve, reject) => {
      const editorProcess = (0, _child_process().spawn)(editorData.binary, editorData.arguments, {
        stdio: 'inherit'
      });
      editorProcess.on('exit', code => {
        if (code === 0) {
          resolve('completed');
        } else {
          reject(new Error(`${editor} had non zero exit code: ${code}`));
        }
      });
    });
  }
  getIdsToTagStr() {
    return Object.keys(this.idsToTagObject);
  }
  getIdsToAutoTagStr() {
    return Object.keys(this.idsToAutoTagObject);
  }
}
exports.MessagePerComponentFetcher = MessagePerComponentFetcher;