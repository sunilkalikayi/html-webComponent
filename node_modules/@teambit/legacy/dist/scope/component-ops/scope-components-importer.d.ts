import { Mutex } from 'async-mutex';
import { LaneId } from '@teambit/lane-id';
import { Scope } from '..';
import { BitId, BitIds } from '../../bit-id';
import ConsumerComponent from '../../consumer/component';
import ComponentVersion from '../component-version';
import { Lane } from '../models';
import { Repository } from '../objects';
import SourcesRepository from '../repositories/sources';
import VersionDependencies from '../version-dependencies';
import { BitObjectList } from '../objects/bit-object-list';
declare type HashesPerRemote = {
    [remoteName: string]: string[];
};
export default class ScopeComponentsImporter {
    scope: Scope;
    sources: SourcesRepository;
    repo: Repository;
    fetchWithDepsMutex: Mutex;
    constructor(scope: Scope);
    static getInstance(scope: Scope): ScopeComponentsImporter;
    /**
     * ensure the given ids and their dependencies are in the scope.
     * if they belong to this scope and are not exist, throw ComponentNotFound.
     * if they are external, fetch them from their remotes by calling this.getExternalMany(), which
     * fetches these components and all their flattened dependencies.
     *
     * keep in mind that as a rule, an indirect dependency should be fetched from its dependent
     * remote first and not from its original scope because it might not be available anymore in the
     * original scope but it must be available in the dependent scope.
     * to ensure we ask getExternalMany for the direct dependency only, the following is done for
     * each one of the components:
     * 1. get the component object.
     * 1.a. If It's a local component and not exists, throw ComponentNotFound.
     * 1.b. If it's an external component and not exists, put it in the externalsToFetch array.
     * 2. If all flattened exist locally - exit.
     * 3. otherwise, go to each one of the direct dependencies and do the following:
     * 3. a. Load the component. (Again, if it's local and not found, throw. Otherwise, put it in the externalsToFetch array).
     * 3. b. If all flattened exists locally - exit the loop.
     * 3. c. otherwise, put it in the externalsToFetch array.
     */
    importMany({ ids, cache, throwForDependencyNotFound, throwForSeederNotFound, reFetchUnBuiltVersion, lanes, ignoreMissingHead, }: {
        ids: BitIds;
        cache?: boolean;
        throwForDependencyNotFound?: boolean;
        throwForSeederNotFound?: boolean;
        reFetchUnBuiltVersion?: boolean;
        lanes?: Lane[];
        ignoreMissingHead?: boolean;
    }): Promise<VersionDependencies[]>;
    /**
     * as opposed to importMany, which imports from dependents only.
     * needed mostly for cases when importMany doesn't work due to corrupted cache or the cache
     * doesn't exist yet.
     *
     * the downside is that a flattened-dependency could be on a dependent only and not on the
     * original scope, so it won't be retrieved by this method, however, next time the component is
     * imported,
     */
    importManyFromOriginalScopes(ids: BitIds): Promise<VersionDependencies[]>;
    /**
     * checks whether the given components has all history.
     * if not, it fetches the history from their remotes without deps.
     */
    importMissingHistory(bitIds: BitIds): Promise<void>;
    importWithoutDeps(ids: BitIds, cache?: boolean, lanes?: Lane[]): Promise<ComponentVersion[]>;
    /**
     * delta between the local head and the remote head. mainly to improve performance
     */
    importManyDeltaWithoutDeps(ids: BitIds, allHistory?: boolean, lane?: Lane, ignoreMissingHead?: boolean): Promise<void>;
    importLanes(remoteLaneIds: LaneId[]): Promise<Lane[]>;
    /**
     * currently used for import artifacts, but can be used to import any arbitrary array of hashes.
     * it takes care to remove any duplications and check whether the object exists locally before
     * going to the remote.
     * just make sure not to use it for components/lanes, as they require a proper "merge" before
     * persisting them to the filesystem. this method is good for immutable objects.
     */
    importManyObjects(groupedHashes: HashesPerRemote): Promise<void>;
    private throwForMissingObjects;
    fetchWithoutDeps(ids: BitIds, allowExternal: boolean, ignoreMissingHead?: boolean): Promise<ComponentVersion[]>;
    fetchWithDeps(ids: BitIds, allowExternal: boolean, onlyIfBuild?: boolean): Promise<VersionDependencies[]>;
    /**
     * get ConsumerComponent by bitId. if the component was not found locally, import it from a remote scope
     */
    loadRemoteComponent(id: BitId): Promise<ConsumerComponent>;
    loadComponent(id: BitId, localOnly?: boolean): Promise<ConsumerComponent>;
    /**
     * get a single component from a remote without saving it locally
     */
    getRemoteComponent(id: BitId): Promise<BitObjectList | null | undefined>;
    /**
     * get components from a remote without saving it locally
     */
    getManyRemoteComponents(ids: BitId[]): Promise<BitObjectList>;
    private multipleStreamsToBitObjects;
    private getVersionFromComponentDef;
    private multipleCompsDefsToVersionDeps;
    /**
     * get multiple components from remotes with their dependencies.
     * never checks if exist locally. always fetches from remote and then, save into the model.
     */
    private getExternalMany;
    private getExternalManyWithoutDeps;
    private _getComponentVersion;
    /**
     * once we discover that a component is external, no need to dig deeper to its dependencies, we
     * just add it to `externalsToFetch` array. later, its dependencies will be fetched from the
     * dependent remote.
     * the recursive is needed for locals. if this component is local, we need to know what
     * components to ask for from the remote. we iterate over the direct dependencies and if some of
     * them are local as well, we need to iterate over their dependencies and so on.
     */
    private findMissingExternalsRecursively;
    /**
     * convert ids to VersionDependencies with performance in mind.
     * it doesn't go to any remote and it fetches each component only once.
     */
    private bitIdsToVersionDeps;
    private throwIfExternalFound;
}
export declare function groupByScopeName(ids: Array<BitId | LaneId>): {
    [scopeName: string]: string[];
};
export declare function groupByLanes(ids: BitId[], lanes: Lane[]): {
    [scopeName: string]: string[];
};
export {};
