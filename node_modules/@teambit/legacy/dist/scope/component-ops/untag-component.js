"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getComponentsWithOptionToUntag = getComponentsWithOptionToUntag;
exports.removeLocalVersion = removeLocalVersion;
exports.removeLocalVersionsForAllComponents = removeLocalVersionsForAllComponents;
exports.removeLocalVersionsForMultipleComponents = removeLocalVersionsForMultipleComponents;
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _componentsList() {
  const data = _interopRequireDefault(require("../../consumer/component/components-list"));
  _componentsList = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
/**
 * If not specified version, remove all local versions.
 */
async function removeLocalVersion(scope, id, lane, head, force = false) {
  const component = await scope.getModelComponentIgnoreScope(id);
  await component.setDivergeData(scope.objects);
  const idStr = id.toString();
  const localVersions = component.getLocalHashes();
  if (!localVersions.length) throw new (_generalError().default)(`unable to untag ${idStr}, the component is not staged`);
  const headRef = component.getHeadRegardlessOfLane();
  if (!headRef) {
    throw new Error(`unable to reset ${idStr}, it has not head`);
  }
  if (head && !localVersions.find(v => v.isEqual(headRef))) {
    throw new Error(`unable to reset ${idStr}, the head ${headRef.toString()} is exported`);
  }
  const versionsToRemove = head ? [headRef] : localVersions;
  const versionsToRemoveStr = component.switchHashesWithTagsIfExist(versionsToRemove);
  if (!force) {
    const dependencyGraph = await scope.getDependencyGraph();
    versionsToRemoveStr.forEach(versionToRemove => {
      const idWithVersion = component.toBitId().changeVersion(versionToRemove);
      const dependents = dependencyGraph.getImmediateDependentsPerId(idWithVersion);
      if (dependents.length) {
        throw new (_bitError().BitError)(`unable to reset ${idStr}, the version ${versionToRemove} has the following dependent(s) ${dependents.join(', ')}`);
      }
    });
  }
  const allVersionsObjects = await Promise.all(versionsToRemoveStr.map(localVer => component.loadVersion(localVer, scope.objects)));
  scope.sources.removeComponentVersions(component, versionsToRemoveStr, allVersionsObjects, lane, head);
  return {
    id,
    versions: versionsToRemoveStr,
    component
  };
}
async function removeLocalVersionsForAllComponents(consumer, lane, head) {
  const componentsToUntag = await getComponentsWithOptionToUntag(consumer);
  const force = true; // when removing local versions from all components, no need to check if the component is used as a dependency
  return removeLocalVersionsForMultipleComponents(componentsToUntag, lane, head, force, consumer.scope);
}
async function removeLocalVersionsForMultipleComponents(componentsToUntag, lane, head,
// @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
force, scope) {
  if (!componentsToUntag.length) {
    throw new (_generalError().default)(`no components found to untag on your workspace`);
  }
  // if only head is removed, there is risk of deleting dependencies version without their dependents.
  if (!force && head) {
    const dependencyGraph = await scope.getDependencyGraph();
    const candidateComponentsIds = componentsToUntag.map(component => {
      const bitId = component.toBitId();
      const headRef = component.getHeadRegardlessOfLane();
      if (!headRef) throw new Error(`component ${bitId.toString()} does not have head. it should not be a candidate for reset`);
      return bitId.changeVersion(component.getTagOfRefIfExists(headRef) || headRef.toString());
    });
    const candidateComponentsIdsStr = candidateComponentsIds.map(id => id.toString());
    candidateComponentsIds.forEach(bitId => {
      const dependents = dependencyGraph.getImmediateDependentsPerId(bitId);
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const dependentsNotCandidates = dependents.filter(dependent => !candidateComponentsIdsStr.includes(dependent));
      if (dependentsNotCandidates.length) {
        throw new (_generalError().default)(
        // $FlowFixMe
        `unable to untag ${bitId}, the version ${bitId.version} has the following dependent(s) ${dependents.join(', ')}`);
      }
    });
  }
  _logger().default.debug(`found ${componentsToUntag.length} components to untag`);
  return Promise.all(componentsToUntag.map(component => removeLocalVersion(scope, component.toBitId(), lane, head, force)));
}
async function getComponentsWithOptionToUntag(consumer) {
  const componentList = new (_componentsList().default)(consumer);
  const laneObj = await consumer.getCurrentLaneObject();
  const components = await componentList.listExportPendingComponents(laneObj);
  return components;
}