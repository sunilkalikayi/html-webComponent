import { ModelComponent } from '../models';
/**
 * the base component to save is the existingComponent because it might contain local data that
 * is not available in the remote component, such as the "state"/"orphanedVersions" properties.
 */
export declare class ModelComponentMerger {
    private existingComponent;
    private incomingComponent;
    private isImport;
    private isIncomingFromOrigin;
    private existingHeadIsMissingInIncomingComponent?;
    mergedVersions: string[];
    isExport: boolean;
    constructor(existingComponent: ModelComponent, incomingComponent: ModelComponent, isImport: boolean, isIncomingFromOrigin: boolean, // import: incoming from original scope. export: component belong to current scope
    existingHeadIsMissingInIncomingComponent?: boolean | undefined);
    /**
     * merge the existing component with the data from the incoming component.
     * in case of a conflict, it throws MergeConflict.
     */
    merge(): Promise<{
        mergedComponent: ModelComponent;
        mergedVersions: string[];
    }>;
    private deleteOrphanedVersionsOnExport;
    private setHead;
    private throwMergeConflictIfNeeded;
    private throwComponentNeedsUpdateIfNeeded;
    private replaceTagHashIfDifferentOnIncoming;
    private moveTagToOrphanedIfNotExistOnOrigin;
    private addNonExistTagFromIncoming;
    /**
     * a remote may have a version not in the "versions" array but in the "orphanedVersions".
     * it happens when it got that version not from the original remote but from a cache of a
     * different remote. locally, we need this data to not throw an error later about missing objects
     */
    private addOrphanedVersionFromIncoming;
}
