"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDivergeData = getDivergeData;
function _difference2() {
  const data = _interopRequireDefault(require("ramda/src/difference"));
  _difference2 = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("../exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _noCommonSnap() {
  const data = require("../exceptions/no-common-snap");
  _noCommonSnap = function () {
    return data;
  };
  return data;
}
function _divergeData() {
  const data = require("./diverge-data");
  _divergeData = function () {
    return data;
  };
  return data;
}
function _traverseVersions() {
  const data = require("./traverse-versions");
  _traverseVersions = function () {
    return data;
  };
  return data;
}
/**
 * traversing the snaps history is not cheap, so we first try to avoid it and if not possible,
 * traverse by the local head, if it finds the remote head, no need to traverse by the remote
 * head. (it also means that we can do fast-forward and no need for snap-merge).
 *
 * one exception is when at some point, there are two parents. because then, if traversing from one parent doesn't find
 * the remote head, all the snaps from this parent will be considered local incorrectly. we need to traverse also the
 * remote to be able to do the diff between the local snaps and the remote snaps.
 */
async function getDivergeData({
  repo,
  modelComponent,
  remoteHead,
  otherRemoteHeads,
  // when remoteHead empty, instead of returning all local snaps, stop if found one of these snaps
  checkedOutLocalHead,
  // in case locally on the workspace it has a different version
  throws = true,
  // otherwise, save the error instance in the `DivergeData` object,
  versionObjects // relevant for remote-scope where during export the data is not in the repo yet.
}) {
  const isOnLane = modelComponent.laneHeadLocal || modelComponent.laneHeadLocal === null;
  const localHead = checkedOutLocalHead || (isOnLane ? modelComponent.laneHeadLocal : modelComponent.getHead());
  if (!remoteHead) {
    if (localHead) {
      const allLocalHashes = await (0, _traverseVersions().getAllVersionHashes)({
        modelComponent,
        repo,
        throws: false,
        versionObjects,
        stopAt: otherRemoteHeads
      });
      return new (_divergeData().DivergeData)(allLocalHashes);
    }
    return new (_divergeData().DivergeData)();
  }
  if (!localHead) {
    const allRemoteHashes = await (0, _traverseVersions().getAllVersionHashes)({
      modelComponent,
      repo,
      throws: false,
      startFrom: remoteHead,
      versionObjects
    });
    return new (_divergeData().DivergeData)([], allRemoteHashes);
  }
  const getVersionObj = async ref => {
    return (versionObjects === null || versionObjects === void 0 ? void 0 : versionObjects.find(v => v.hash().isEqual(ref))) || (await repo.load(ref));
  };
  if (remoteHead.isEqual(localHead)) {
    // no diverge they're the same
    return new (_divergeData().DivergeData)();
  }
  const existOnRemote = ref => [remoteHead, ...(otherRemoteHeads || [])].find(r => r.isEqual(ref));
  const snapsOnLocal = [];
  const snapsOnRemote = [];
  let remoteHeadExistsLocally = false;
  let localHeadExistsRemotely = false;
  let commonSnapBeforeDiverge;
  let hasMultipleParents = false;
  let error;
  const addParentsRecursively = async (version, snaps, isLocal) => {
    var _version$unrelated, _version$unrelated2;
    if (isLocal && existOnRemote(version.hash())) {
      remoteHeadExistsLocally = true;
      return;
    }
    if (!isLocal && version.hash().isEqual(localHead)) {
      localHeadExistsRemotely = true;
      return;
    }
    if (isLocal && (_version$unrelated = version.unrelated) !== null && _version$unrelated !== void 0 && _version$unrelated.head.isEqual(remoteHead)) {
      remoteHeadExistsLocally = true;
      snaps.push(version.hash());
      return;
    }
    if (!isLocal && (_version$unrelated2 = version.unrelated) !== null && _version$unrelated2 !== void 0 && _version$unrelated2.head.isEqual(localHead)) {
      localHeadExistsRemotely = true;
      snaps.push(version.hash());
      return;
    }
    if (!isLocal && !commonSnapBeforeDiverge) {
      const snapExistLocally = snapsOnLocal.find(snap => snap.isEqual(version.hash()));
      if (snapExistLocally) commonSnapBeforeDiverge = snapExistLocally;
    }
    snaps.push(version.hash());
    if (version.parents.length > 1) hasMultipleParents = true;
    await Promise.all(version.parents.map(async parent => {
      const parentVersion = await getVersionObj(parent);
      if (parentVersion) {
        await addParentsRecursively(parentVersion, snaps, isLocal);
      } else {
        const err = new (_exceptions().ParentNotFound)(modelComponent.id(), version.hash().toString(), parent.toString());
        if (throws) throw err;
        error = err;
      }
    }));
  };
  const localVersion = await repo.load(localHead);
  if (!localVersion) {
    const err = new Error(`fatal: a component "${modelComponent.id()}" is missing the local head object (${localHead}) in the filesystem.
run the following command to fix it:
bit import ${modelComponent.id()} --objects`);
    if (throws) throw err;
    return new (_divergeData().DivergeData)(snapsOnLocal, [], remoteHead, err);
  }
  await addParentsRecursively(localVersion, snapsOnLocal, true);
  if (remoteHeadExistsLocally && !hasMultipleParents) {
    return new (_divergeData().DivergeData)(snapsOnLocal, [], remoteHead, error);
  }
  const remoteVersion = await getVersionObj(remoteHead);
  if (!remoteVersion) {
    const err = new (_exceptions().VersionNotFoundOnFS)(remoteHead.toString(), modelComponent.id());
    if (throws) throw err;
    return new (_divergeData().DivergeData)([], [], undefined, err);
  }
  await addParentsRecursively(remoteVersion, snapsOnRemote, false);
  if (localHeadExistsRemotely) {
    return new (_divergeData().DivergeData)([], (0, _difference2().default)(snapsOnRemote, snapsOnLocal), localHead, error);
  }
  if (remoteHeadExistsLocally) {
    // happens when `hasMultipleParents` is true. now that remote was traversed as well, it's possible to find the diff
    return new (_divergeData().DivergeData)((0, _difference2().default)(snapsOnLocal, snapsOnRemote), [], remoteHead, error);
  }
  if (!commonSnapBeforeDiverge) {
    var _localVersion$unrelat;
    const unmergedData = repo.unmergedComponents.getEntry(modelComponent.name);
    const isUnrelatedFromUnmerged = (unmergedData === null || unmergedData === void 0 ? void 0 : unmergedData.unrelated) && unmergedData.head.isEqual(remoteHead);
    const isUnrelatedFromVersionObj = (_localVersion$unrelat = localVersion.unrelated) === null || _localVersion$unrelat === void 0 ? void 0 : _localVersion$unrelat.head.isEqual(remoteHead);
    if (isUnrelatedFromUnmerged || isUnrelatedFromVersionObj) {
      return new (_divergeData().DivergeData)(snapsOnLocal, snapsOnRemote, undefined);
    }
    const err = new (_noCommonSnap().NoCommonSnap)(modelComponent.id());
    if (throws) throw err;
    return new (_divergeData().DivergeData)(snapsOnLocal, snapsOnRemote, undefined, err);
  }
  return new (_divergeData().DivergeData)((0, _difference2().default)(snapsOnLocal, snapsOnRemote), (0, _difference2().default)(snapsOnRemote, snapsOnLocal), commonSnapBeforeDiverge, error);
}