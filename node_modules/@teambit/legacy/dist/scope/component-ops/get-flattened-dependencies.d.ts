import { Scope } from '..';
import Component from '../../consumer/component/consumer-component';
export declare class FlattenedDependenciesGetter {
    private scope;
    private components;
    private dependenciesGraph;
    private prodGraph;
    private versionDependencies;
    private cache;
    constructor(scope: Scope, components: Component[]);
    /**
     * to get the flattened dependencies of a component, we iterate over the direct dependencies and
     * figure out what should be the flattened of each one of the dependencies.
     * a dependency can be one of the two scenarios and should be handled accordingly.
     * 1. a dependency can be tagged/snapped along with the current component.
     * 2. a dependency can be a component that was already tagged before.
     * there is no option #3 of a component that exists on the workspace but wasn't tagged and is not
     * part of the current tag. In such case, we throw an error, see throwWhenDepNotIncluded below.
     *
     * the flattened dependencies process handles the two cases above differently.
     * 1. first, it builds a graph with all current components, this way it's easier to get the
     * flattened dependencies by graph algorithm. (without graph, it becomes difficult when there are
     * circular dependencies).
     * 2. for other components, it loads them from the model and gets the flattened from the objects.
     */
    populateFlattenedDependencies(): Promise<void>;
    private createGraphs;
    private importExternalDependenciesInBulk;
    private getFlattened;
    private getFlattenedFromCurrentComponents;
    private getFlattenedFromVersion;
}
