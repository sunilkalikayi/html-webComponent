"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlattenedDependenciesGetter = void 0;
function _tail2() {
  const data = _interopRequireDefault(require("ramda/src/tail"));
  _tail2 = function () {
    return data;
  };
  return data;
}
function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));
  _flatten2 = function () {
    return data;
  };
  return data;
}
function _uniq2() {
  const data = _interopRequireDefault(require("ramda/src/uniq"));
  _uniq2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _graphlib() {
  const data = _interopRequireDefault(require("graphlib"));
  _graphlib = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _componentsGraph() {
  const data = require("../graph/components-graph");
  _componentsGraph = function () {
    return data;
  };
  return data;
}
function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("./scope-components-importer"));
  _scopeComponentsImporter = function () {
    return data;
  };
  return data;
}
class FlattenedDependenciesGetter {
  constructor(scope, components) {
    this.scope = scope;
    this.components = components;
    (0, _defineProperty2().default)(this, "dependenciesGraph", void 0);
    (0, _defineProperty2().default)(this, "prodGraph", void 0);
    (0, _defineProperty2().default)(this, "versionDependencies", void 0);
    (0, _defineProperty2().default)(this, "cache", {});
  }

  /**
   * to get the flattened dependencies of a component, we iterate over the direct dependencies and
   * figure out what should be the flattened of each one of the dependencies.
   * a dependency can be one of the two scenarios and should be handled accordingly.
   * 1. a dependency can be tagged/snapped along with the current component.
   * 2. a dependency can be a component that was already tagged before.
   * there is no option #3 of a component that exists on the workspace but wasn't tagged and is not
   * part of the current tag. In such case, we throw an error, see throwWhenDepNotIncluded below.
   *
   * the flattened dependencies process handles the two cases above differently.
   * 1. first, it builds a graph with all current components, this way it's easier to get the
   * flattened dependencies by graph algorithm. (without graph, it becomes difficult when there are
   * circular dependencies).
   * 2. for other components, it loads them from the model and gets the flattened from the objects.
   */
  async populateFlattenedDependencies() {
    _logger().default.debug(`populateFlattenedDependencies starts with ${this.components.length} components`);
    this.createGraphs(this.components);
    await this.importExternalDependenciesInBulk();
    await (0, _pMapSeries().default)(this.components, async component => {
      component.flattenedDependencies = await this.getFlattened(component.id);
    });
  }
  createGraphs(components) {
    this.dependenciesGraph = (0, _componentsGraph().buildComponentsGraphCombined)(components);
    // uncomment to see the graph nicely. very helpful for debugging
    // console.log("this.dependenciesGraph", this.dependenciesGraph.toString())
    this.prodGraph = this.dependenciesGraph.getSubGraphByEdgeType('dependencies');
  }
  async importExternalDependenciesInBulk() {
    const allDependencies = this.components.map(component => {
      return getEdges(this.dependenciesGraph, component.id.toString());
    });
    const idsStr = (0, _uniq2().default)((0, _flatten2().default)(allDependencies));
    const bitIds = idsStr.filter(id => id).map(idStr => this.dependenciesGraph.node(idStr)).filter(bitId => bitId && bitId.hasScope()).filter(bitId => !this.components.find(c => c.id.isEqual(bitId)));
    const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(this.scope);
    this.versionDependencies = await scopeComponentsImporter.importMany({
      ids: _bitId().BitIds.fromArray(bitIds),
      cache: true,
      throwForDependencyNotFound: true
    });
  }
  async getFlattened(bitId) {
    const dependencies = this.getFlattenedFromCurrentComponents(bitId);
    dependencies.forEach(dep => throwWhenDepNotIncluded(bitId, dep));
    const dependenciesDeps = await (0, _pMapSeries().default)(dependencies, dep => this.getFlattenedFromVersion(dep, bitId));
    const dependenciesDepsFlattened = (0, _lodash().flatten)(dependenciesDeps);
    dependencies.push(...dependenciesDepsFlattened);
    return _bitId().BitIds.uniqFromArray(dependencies);
  }
  getFlattenedFromCurrentComponents(bitId) {
    const allDeps = getEdges(this.dependenciesGraph, bitId.toString()) || [];
    const dependencies = allDeps.map(idStr => this.dependenciesGraph.node(idStr));
    return dependencies;
  }
  async getFlattenedFromVersion(id, dependentId) {
    if (!this.cache[id.toString()]) {
      const versionDeps = this.versionDependencies.find(({
        component
      }) => component.toId().isEqual(id));
      if (versionDeps) {
        const dependencies = await versionDeps.component.flattenedDependencies(this.scope.objects);
        this.cache[id.toString()] = dependencies;
      } else {
        const existing = this.components.find(c => c.id.isEqual(id));
        if (existing) {
          this.cache[id.toString()] = new (_bitId().BitIds)();
        } else {
          if (!id.hasVersion()) {
            throw new Error(`error found while getting the dependencies of "${dependentId.toString()}". A dependency "${id.toString()}" doesn't have a version
if this is an external env/extension/aspect configured in workspace.jsonc, make sure it is set with a version`);
          }
          const fromModel = await this.scope.getVersionInstance(id);
          this.cache[id.toString()] = fromModel.flattenedDependencies;
        }
      }
    }
    return this.cache[id.toString()];
  }
}
exports.FlattenedDependenciesGetter = FlattenedDependenciesGetter;
function throwWhenDepNotIncluded(componentId, dependencyId) {
  if (!dependencyId.hasScope() && !dependencyId.hasVersion()) {
    throw new (_generalError().default)(`fatal: "${componentId.toString()}" has a dependency "${dependencyId.toString()}".
this dependency was not included in the tag command.`);
  }
}
function getEdges(graph, id) {
  if (!graph.hasNode(id)) return null;
  // @ts-ignore
  const edges = _graphlib().default.alg.preorder(graph, id);
  return (0, _tail2().default)(edges); // the first item is the component itself
}