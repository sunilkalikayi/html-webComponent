"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exportManyBareScope = exportManyBareScope;
exports.mergeObjects = mergeObjects;
exports.persistRemotes = persistRemotes;
exports.removePendingDirs = removePendingDirs;
exports.resumeExport = resumeExport;
exports.saveObjects = saveObjects;
exports.validateRemotes = validateRemotes;
function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));
  _flatten2 = function () {
    return data;
  };
  return data;
}
function _prop2() {
  const data = _interopRequireDefault(require("ramda/src/prop"));
  _prop2 = function () {
    return data;
  };
  return data;
}
function _sortBy2() {
  const data = _interopRequireDefault(require("ramda/src/sortBy"));
  _sortBy2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("../exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _componentNeedsUpdate() {
  const data = _interopRequireDefault(require("../exceptions/component-needs-update"));
  _componentNeedsUpdate = function () {
    return data;
  };
  return data;
}
function _scopeRemotes() {
  const data = require("../scope-remotes");
  _scopeRemotes = function () {
    return data;
  };
  return data;
}
function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("./scope-components-importer"));
  _scopeComponentsImporter = function () {
    return data;
  };
  return data;
}
function _actions() {
  const data = require("../actions");
  _actions = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("../../cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
function _persistFailed() {
  const data = require("../exceptions/persist-failed");
  _persistFailed = function () {
    return data;
  };
  return data;
}
function _objects() {
  const data = require("../objects");
  _objects = function () {
    return data;
  };
  return data;
}
/**
 * ** Legacy and "bit sign" Only **
 *
 * @TODO there is no real difference between bare scope and a working directory scope - let's adjust terminology to avoid confusions in the future
 * saves a component into the objects directory of the remote scope, then, resolves its
 * dependencies, saves them as well. Finally runs the build process if needed on an isolated
 * environment.
 */
async function exportManyBareScope(scope, objectList) {
  _logger().default.debugAndAddBreadCrumb('exportManyBareScope', `started with ${objectList.objects.length} objects`);
  const mergedIds = await saveObjects(scope, objectList);
  _logger().default.debugAndAddBreadCrumb('exportManyBareScope', 'will try to importMany in case there are missing dependencies');
  const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(scope);
  await scopeComponentsImporter.importManyFromOriginalScopes(mergedIds); // resolve dependencies
  _logger().default.debugAndAddBreadCrumb('exportManyBareScope', 'successfully ran importMany');
  return mergedIds;
}
/**
 * save objects into the scope.
 */
async function saveObjects(scope, objectList) {
  const bitObjectList = await objectList.toBitObjects();
  const objectsNotRequireMerge = bitObjectList.getObjectsNotRequireMerge();
  // components and lanes can't be just added, they need to be carefully merged.
  const {
    mergedIds,
    mergedComponentsResults,
    mergedLanes
  } = await mergeObjects(scope, objectList);
  const mergedComponents = mergedComponentsResults.map(_ => _.mergedComponent);
  const allObjects = [...mergedComponents, ...mergedLanes, ...objectsNotRequireMerge];
  scope.objects.validateObjects(true, allObjects);
  await scope.objects.writeObjectsToTheFS(allObjects);
  _logger().default.debugAndAddBreadCrumb('exportManyBareScope', 'objects were written successfully to the filesystem');
  return mergedIds;
}
/**
 * merge components into the scope.
 *
 * a component might have multiple versions that some where merged and some were not.
 * the BitIds returned here includes the versions that were merged. so it could contain multiple
 * ids of the same component with different versions
 */
async function mergeObjects(scope, objectList, throwForMissingDeps = false) {
  const bitObjectList = await objectList.toBitObjects();
  const components = bitObjectList.getComponents();
  const lanesObjects = bitObjectList.getLanes();
  const versions = bitObjectList.getVersions();
  _logger().default.debugAndAddBreadCrumb('export-scope-components.mergeObjects', `Going to merge ${components.length} components, ${lanesObjects.length} lanes`);
  const {
    mergeResults,
    errors
  } = lanesObjects.length ? {
    mergeResults: [],
    errors: []
  } // for lanes, no need to merge component objects, the lane is merged later.
  : await scope.sources.mergeComponents(components, versions);
  const mergeAllLanesResults = await (0, _pMapSeries().default)(lanesObjects, laneObject => scope.sources.mergeLane(laneObject, false, versions, components));
  const lanesErrors = mergeAllLanesResults.map(r => r.mergeErrors).flat();
  const componentsNeedUpdate = [...errors.filter(result => result instanceof _componentNeedsUpdate().default), ...lanesErrors];
  const componentsWithConflicts = errors.filter(result => result instanceof _exceptions().MergeConflict);
  if (componentsWithConflicts.length || componentsNeedUpdate.length) {
    const idsAndVersions = componentsWithConflicts.map(c => ({
      id: c.id,
      versions: c.versions
    }));
    const idsAndVersionsWithConflicts = (0, _sortBy2().default)((0, _prop2().default)('id'), idsAndVersions);
    const idsOfNeedUpdateComps = (0, _sortBy2().default)((0, _prop2().default)('id'), componentsNeedUpdate.map(c => ({
      id: c.id,
      lane: c.lane
    })));
    scope.objects.clearCache(); // just in case this error is caught. we don't want to persist anything by mistake.
    throw new (_exceptions().MergeConflictOnRemote)(idsAndVersionsWithConflicts, idsOfNeedUpdateComps);
  }
  if (throwForMissingDeps) await throwForMissingLocalDependencies(scope, versions, components, lanesObjects);
  const mergedComponents = mergeResults.filter(({
    mergedVersions
  }) => mergedVersions.length);
  const mergedLanesComponents = mergeAllLanesResults.map(r => r.mergeResults).flat().filter(({
    mergedVersions
  }) => mergedVersions.length);
  const mergedComponentsResults = [...mergedComponents, ...mergedLanesComponents];
  const getMergedIds = ({
    mergedComponent,
    mergedVersions
  }) => mergedVersions.map(version => mergedComponent.toBitId().changeVersion(version));
  const mergedIds = _bitId().BitIds.uniqFromArray(mergedComponentsResults.map(getMergedIds).flat());
  const mergedLanes = mergeAllLanesResults.map(r => r.mergeLane);
  return {
    mergedIds,
    mergedComponentsResults,
    mergedLanes
  };
}

/**
 * make sure that all local objects were actually transferred into the remote.
 * this gets called as part of the export-validate step. it doesn't check for dependencies from
 * other scopes, as they'll be retrieved later by the fetch-missing-deps step.
 * we can't wait for that step to validate local dependencies because it happens after persisting,
 * and we don't want to persist when local dependencies were not exported.
 */
async function throwForMissingLocalDependencies(scope, versions, components, lanes) {
  const compsWithHeads = lanes.length ? lanes.map(lane => lane.toBitIds()).flat() : components.map(c => c.toBitIdWithHead());
  await Promise.all(versions.map(async version => {
    const originComp = compsWithHeads.find(id => version.hash().toString() === id.version);
    if (!originComp) {
      // coz if an older version has a missing dep, then, it's fine. (it can easily happen when exporting lane, which
      // all old versions are exported)
      return;
    }
    const getOriginCompWithVer = () => {
      const compObj = components.find(c => c.toBitId().isEqualWithoutVersion(originComp));
      if (!compObj) return originComp;
      const tag = compObj.getTagOfRefIfExists(_objects().Ref.from(originComp.version));
      if (tag) return originComp.changeVersion(tag);
      return originComp;
    };
    const depsIds = version.getAllFlattenedDependencies();
    await Promise.all(depsIds.map(async depId => {
      if (depId.scope !== scope.name) return;
      const existingModelComponent = (await scope.getModelComponentIfExist(depId)) || components.find(c => c.toBitId().isEqualWithoutVersion(depId));
      if (!existingModelComponent) {
        scope.objects.clearCache(); // just in case this error is caught. we don't want to persist anything by mistake.
        throw new (_exceptions().ComponentNotFound)(depId.toString(), getOriginCompWithVer().toString());
      }
      const versionRef = existingModelComponent.getRef(depId.version);
      if (!versionRef) throw new Error(`unable to find Ref/Hash of ${depId.toString()}`);
      const objectExist = scope.objects.getCache(versionRef) || (await scope.objects.has(versionRef)) || versions.find(v => v.hash().isEqual(versionRef));
      if (!objectExist) {
        scope.objects.clearCache(); // just in case this error is caught. we don't want to persist anything by mistake.
        throw new (_exceptions().ComponentNotFound)(depId.toString(), getOriginCompWithVer().toString());
      }
    }));
  }));
}
async function validateRemotes(remotes, clientId, isResumingExport = true) {
  _loader().default.start('verifying that objects can be merged on the remotes...');
  try {
    await Promise.all(remotes.map(remote => remote.action(_actions().ExportValidate.name, {
      clientId,
      isResumingExport: true
    })));
  } catch (err) {
    _logger().default.errorAndAddBreadCrumb('validateRemotes', 'failed validating remotes', {}, err);
    if (!isResumingExport) {
      // when resuming export, we don't want to delete the pending-objects because some scopes
      // have them persisted and some not. we want to persist to all failing scopes.
      await removePendingDirs(remotes, clientId);
    }
    throw err;
  }
}
async function persistRemotes(manyObjectsPerRemote, clientId) {
  const persistedRemotes = [];
  await (0, _pMapSeries().default)(manyObjectsPerRemote, async objectsPerRemote => {
    const {
      remote
    } = objectsPerRemote;
    _loader().default.start(`persisting data on the remote "${remote.name}"...`);
    const maxRetries = 3;
    let succeed = false;
    let lastErrMsg = '';
    for (let i = 0; i < maxRetries; i += 1) {
      try {
        // eslint-disable-next-line no-await-in-loop
        const exportedIds = await remote.action(_actions().ExportPersist.name, {
          clientId
        });
        objectsPerRemote.exportedIds = exportedIds;
        succeed = true;
        break;
      } catch (err) {
        lastErrMsg = err.message;
        _logger().default.errorAndAddBreadCrumb('persistRemotes', `failed on remote ${remote.name}, attempt ${i + 1} out of ${maxRetries}`, {}, err);
      }
    }
    if (!succeed) {
      throw new (_persistFailed().PersistFailed)([remote.name], {
        [remote.name]: lastErrMsg
      });
    }
    _logger().default.debugAndAddBreadCrumb('persistRemotes', `successfully pushed all ids to the bare-scope ${remote.name}`);
    persistedRemotes.push(remote.name);
  });
}
async function resumeExport(scope, exportId, remotes) {
  const scopeRemotes = await (0, _scopeRemotes().getScopeRemotes)(scope);
  const remotesObj = await Promise.all(remotes.map(r => scopeRemotes.resolve(r, scope)));
  const remotesForPersist = remotesObj.map(remote => ({
    remote
  }));
  await validateRemotes(remotesObj, exportId);
  await persistRemotes(remotesForPersist, exportId);
  return (0, _flatten2().default)(remotesForPersist.map(r => r.exportedIds));
}
async function removePendingDirs(pushedRemotes, clientId) {
  await Promise.all(pushedRemotes.map(remote => remote.action(_actions().RemovePendingDir.name, {
    clientId
  })));
}