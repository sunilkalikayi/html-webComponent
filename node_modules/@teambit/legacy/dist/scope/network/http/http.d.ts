import { GraphQLClient } from 'graphql-request';
import fetch, { Response } from 'node-fetch';
import HttpAgent from 'agentkeepalive';
import { HttpsProxyAgent } from 'https-proxy-agent';
import { SocksProxyAgent } from 'socks-proxy-agent';
import { HttpProxyAgent } from 'http-proxy-agent';
import { AgentOptions } from '@teambit/toolbox.network.agent';
import { Network } from '../network';
import { BitId, BitIds } from '../../../bit-id';
import Component from '../../../consumer/component';
import { ListScopeResult } from '../../../consumer/component/components-list';
import DependencyGraph from '../../graph/scope-graph';
import { LaneData } from '../../lanes/lanes';
import { ComponentLog } from '../../models/model-component';
import { ScopeDescriptor } from '../../scope';
import { ObjectItemsStream, ObjectList } from '../../objects/object-list';
import { FETCH_OPTIONS } from '../../../api/scope/lib/fetch';
import { PushOptions } from '../../../api/scope/lib/put';
import RemovedObjects from '../../removed-components';
export declare enum Verb {
    WRITE = "write",
    READ = "read"
}
export declare type ProxyConfig = {
    httpProxy?: string;
    httpsProxy?: string;
    noProxy?: boolean | string;
};
export declare type NetworkConfig = {
    fetchRetries?: number;
    fetchRetryFactor?: number;
    fetchRetryMintimeout?: number;
    fetchRetryMaxtimeout?: number;
    fetchTimeout?: number;
    localAddress?: string;
    maxSockets?: number;
    networkConcurrency?: number;
    strictSSL?: boolean;
    ca?: string | string[];
    cafile?: string;
    cert?: string | string[];
    key?: string;
};
declare type Agent = HttpsProxyAgent | HttpAgent | HttpAgent.HttpsAgent | HttpProxyAgent | SocksProxyAgent | undefined;
/**
 * fetched from HTTP Authorization header.
 * (see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization)
 */
export declare type AuthData = {
    type: string;
    credentials: string;
};
export declare const DEFAULT_AUTH_TYPE = "Bearer";
export declare class Http implements Network {
    private graphClient;
    private _token;
    private url;
    private scopeName;
    private proxyConfig?;
    private agent?;
    private localScopeName?;
    private networkConfig?;
    constructor(graphClient: GraphQLClient, _token: string | undefined | null, url: string, scopeName: string, proxyConfig?: ProxyConfig | undefined, agent?: Agent, localScopeName?: string | undefined, networkConfig?: NetworkConfig | undefined);
    static getToken(): string | null;
    static getProxyConfig(checkProxyUriDefined?: boolean): Promise<ProxyConfig>;
    static getNetworkConfig(): Promise<NetworkConfig>;
    static getAgent(uri: string, agentOpts: AgentOptions): Promise<Agent>;
    get token(): string | null | undefined;
    close(): void;
    describeScope(): Promise<ScopeDescriptor>;
    deleteMany(ids: string[], force: boolean, context: Record<string, any>, idsAreLanes: boolean): Promise<RemovedObjects>;
    pushMany(objectList: ObjectList, pushOptions: PushOptions): Promise<string[]>;
    pushToCentralHub(objectList: ObjectList, options?: Record<string, any>): Promise<{
        successIds: string[];
        failedScopes: string[];
        exportId: string;
        errors: {
            [scopeName: string]: string;
        };
    }>;
    action<Options, Result>(name: string, options: Options): Promise<Result>;
    fetch(ids: string[], fetchOptions: FETCH_OPTIONS): Promise<ObjectItemsStream>;
    private getJsonResponse;
    private throwForNonOkStatus;
    private graphClientRequest;
    private readPutCentralStream;
    list(namespacesUsingWildcards?: string | undefined): Promise<ListScopeResult[]>;
    show(bitId: BitId): Promise<Component | null | undefined>;
    log(id: BitId): Promise<ComponentLog[]>;
    latestVersions(bitIds: BitIds): Promise<string[]>;
    graph(bitId?: BitId): Promise<DependencyGraph>;
    listLanes(): Promise<LaneData[]>;
    private getHeaders;
    private getClientVersion;
    private addAgentIfExist;
    static connect(host: string, scopeName: string, localScopeName?: string): Promise<Http>;
}
export declare function getAuthHeader(token: string): {
    Authorization: string;
};
/**
 * Read the proxy config from the global config, and wrap fetch with fetch with proxy
 */
export declare function getFetcherWithAgent(uri: string): Promise<typeof fetch | ((url: any, opts: any) => Promise<Response>)>;
/**
 * return a fetch wrapper with the proxy agent inside
 * @param proxyAgent
 */
export declare function wrapFetcherWithAgent(agent: Agent): (url: any, opts: any) => Promise<Response>;
export declare function getProxyAgent(proxy: string): HttpsProxyAgent;
export declare function getAuthDataFromHeader(authorizationHeader: string | undefined): AuthData | undefined;
export {};
