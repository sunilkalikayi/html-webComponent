"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Verb = exports.Http = exports.DEFAULT_AUTH_TYPE = void 0;
exports.getAuthDataFromHeader = getAuthDataFromHeader;
exports.getAuthHeader = getAuthHeader;
exports.getFetcherWithAgent = getFetcherWithAgent;
exports.getProxyAgent = getProxyAgent;
exports.wrapFetcherWithAgent = wrapFetcherWithAgent;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _graphqlRequest() {
  const data = require("graphql-request");
  _graphqlRequest = function () {
    return data;
  };
  return data;
}
function _nodeFetch() {
  const data = _interopRequireDefault(require("node-fetch"));
  _nodeFetch = function () {
    return data;
  };
  return data;
}
function _readline() {
  const data = _interopRequireDefault(require("readline"));
  _readline = function () {
    return data;
  };
  return data;
}
function _httpsProxyAgent() {
  const data = require("https-proxy-agent");
  _httpsProxyAgent = function () {
    return data;
  };
  return data;
}
function _toolboxNetwork() {
  const data = require("@teambit/toolbox.network.agent");
  _toolboxNetwork = function () {
    return data;
  };
  return data;
}
function _bootstrap() {
  const data = require("../../../bootstrap");
  _bootstrap = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = _interopRequireDefault(require("../../../consumer/component"));
  _component = function () {
    return data;
  };
  return data;
}
function _scopeGraph() {
  const data = _interopRequireDefault(require("../../graph/scope-graph"));
  _scopeGraph = function () {
    return data;
  };
  return data;
}
function _globalFlags() {
  const data = _interopRequireDefault(require("../../../cli/global-flags"));
  _globalFlags = function () {
    return data;
  };
  return data;
}
function _globalConfig() {
  const data = require("../../../api/consumer/lib/global-config");
  _globalConfig = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _objectList() {
  const data = require("../../objects/object-list");
  _objectList = function () {
    return data;
  };
  return data;
}
function _remoteErrorHandler() {
  const data = require("../remote-error-handler");
  _remoteErrorHandler = function () {
    return data;
  };
  return data;
}
function _httpInvalidJsonResponse() {
  const data = require("../exceptions/http-invalid-json-response");
  _httpInvalidJsonResponse = function () {
    return data;
  };
  return data;
}
function _removedComponents() {
  const data = _interopRequireDefault(require("../../removed-components"));
  _removedComponents = function () {
    return data;
  };
  return data;
}
function _graphqlClientError() {
  const data = require("../exceptions/graphql-client-error");
  _graphqlClientError = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("../../../cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("../exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
let Verb;
exports.Verb = Verb;
(function (Verb) {
  Verb["WRITE"] = "write";
  Verb["READ"] = "read";
})(Verb || (exports.Verb = Verb = {}));
const DEFAULT_AUTH_TYPE = 'Bearer';
exports.DEFAULT_AUTH_TYPE = DEFAULT_AUTH_TYPE;
class Http {
  constructor(graphClient, _token, url, scopeName, proxyConfig, agent, localScopeName, networkConfig) {
    this.graphClient = graphClient;
    this._token = _token;
    this.url = url;
    this.scopeName = scopeName;
    this.proxyConfig = proxyConfig;
    this.agent = agent;
    this.localScopeName = localScopeName;
    this.networkConfig = networkConfig;
  }
  static getToken() {
    const processToken = _globalFlags().default.token;
    const token = processToken || (0, _globalConfig().getSync)(_constants().CFG_USER_TOKEN_KEY);
    if (!token) return null;
    return token;
  }
  static async getProxyConfig(checkProxyUriDefined = true) {
    var _obj$CFG_HTTPS_PROXY;
    const obj = await (0, _globalConfig().list)();
    const httpProxy = obj[_constants().CFG_PROXY];
    const httpsProxy = (_obj$CFG_HTTPS_PROXY = obj[_constants().CFG_HTTPS_PROXY]) !== null && _obj$CFG_HTTPS_PROXY !== void 0 ? _obj$CFG_HTTPS_PROXY : obj[_constants().CFG_PROXY];

    // If check is true, return the proxy config only case there is actual proxy server defined
    if (checkProxyUriDefined && !httpProxy && !httpsProxy) {
      return {};
    }
    return {
      httpProxy,
      httpsProxy,
      noProxy: obj[_constants().CFG_PROXY_NO_PROXY]
    };
  }
  static async getNetworkConfig() {
    var _ref, _obj$CFG_NETWORK_STRI, _obj$CFG_FETCH_RETRIE, _obj$CFG_FETCH_RETRY_, _obj$CFG_FETCH_RETRY_2, _obj$CFG_FETCH_RETRY_3, _obj$CFG_FETCH_TIMEOU, _obj$CFG_MAX_SOCKETS, _obj$CFG_NETWORK_CONC, _obj$CFG_NETWORK_CA, _obj$CFG_NETWORK_CA_F, _obj$CFG_NETWORK_CERT, _obj$CFG_NETWORK_KEY;
    const obj = await (0, _globalConfig().list)();

    // Reading strictSSL from both network.strict-ssl and network.strict_ssl for backward compatibility.
    const strictSSL = (_ref = (_obj$CFG_NETWORK_STRI = obj[_constants().CFG_NETWORK_STRICT_SSL]) !== null && _obj$CFG_NETWORK_STRI !== void 0 ? _obj$CFG_NETWORK_STRI : obj['network.strict_ssl']) !== null && _ref !== void 0 ? _ref : obj[_constants().CFG_PROXY_STRICT_SSL];
    const networkConfig = {
      fetchRetries: (_obj$CFG_FETCH_RETRIE = obj[_constants().CFG_FETCH_RETRIES]) !== null && _obj$CFG_FETCH_RETRIE !== void 0 ? _obj$CFG_FETCH_RETRIE : 2,
      fetchRetryFactor: (_obj$CFG_FETCH_RETRY_ = obj[_constants().CFG_FETCH_RETRY_FACTOR]) !== null && _obj$CFG_FETCH_RETRY_ !== void 0 ? _obj$CFG_FETCH_RETRY_ : 10,
      fetchRetryMintimeout: (_obj$CFG_FETCH_RETRY_2 = obj[_constants().CFG_FETCH_RETRY_MINTIMEOUT]) !== null && _obj$CFG_FETCH_RETRY_2 !== void 0 ? _obj$CFG_FETCH_RETRY_2 : 10000,
      fetchRetryMaxtimeout: (_obj$CFG_FETCH_RETRY_3 = obj[_constants().CFG_FETCH_RETRY_MAXTIMEOUT]) !== null && _obj$CFG_FETCH_RETRY_3 !== void 0 ? _obj$CFG_FETCH_RETRY_3 : 60000,
      fetchTimeout: (_obj$CFG_FETCH_TIMEOU = obj[_constants().CFG_FETCH_TIMEOUT]) !== null && _obj$CFG_FETCH_TIMEOU !== void 0 ? _obj$CFG_FETCH_TIMEOU : 60000,
      localAddress: obj[_constants().CFG_LOCAL_ADDRESS],
      maxSockets: (_obj$CFG_MAX_SOCKETS = obj[_constants().CFG_MAX_SOCKETS]) !== null && _obj$CFG_MAX_SOCKETS !== void 0 ? _obj$CFG_MAX_SOCKETS : 15,
      networkConcurrency: (_obj$CFG_NETWORK_CONC = obj[_constants().CFG_NETWORK_CONCURRENCY]) !== null && _obj$CFG_NETWORK_CONC !== void 0 ? _obj$CFG_NETWORK_CONC : 16,
      strictSSL: typeof strictSSL === 'string' ? strictSSL === 'true' : strictSSL,
      ca: (_obj$CFG_NETWORK_CA = obj[_constants().CFG_NETWORK_CA]) !== null && _obj$CFG_NETWORK_CA !== void 0 ? _obj$CFG_NETWORK_CA : obj[_constants().CFG_PROXY_CA],
      cafile: (_obj$CFG_NETWORK_CA_F = obj[_constants().CFG_NETWORK_CA_FILE]) !== null && _obj$CFG_NETWORK_CA_F !== void 0 ? _obj$CFG_NETWORK_CA_F : obj[_constants().CFG_PROXY_CA_FILE],
      cert: (_obj$CFG_NETWORK_CERT = obj[_constants().CFG_NETWORK_CERT]) !== null && _obj$CFG_NETWORK_CERT !== void 0 ? _obj$CFG_NETWORK_CERT : obj[_constants().CFG_PROXY_CERT],
      key: (_obj$CFG_NETWORK_KEY = obj[_constants().CFG_NETWORK_KEY]) !== null && _obj$CFG_NETWORK_KEY !== void 0 ? _obj$CFG_NETWORK_KEY : obj[_constants().CFG_PROXY_KEY]
    };
    _logger().default.debug(`the next network configuration is used in network.http: ${_objectSpread(_objectSpread({}, networkConfig), {}, {
      key: networkConfig.key ? 'set' : 'not set' // this is sensitive information, we should not log it
    })}`);
    return networkConfig;
  }
  static async getAgent(uri, agentOpts) {
    const agent = await (0, _toolboxNetwork().getAgent)(uri, agentOpts);
    return agent;
  }
  get token() {
    if (this._token === undefined) return this._token;
    return Http.getToken();
  }
  close() {}
  async describeScope() {
    const SCOPE_QUERY = (0, _graphqlRequest().gql)`
      {
        scope {
          name
        }
      }
    `;
    const data = await this.graphClientRequest(SCOPE_QUERY, Verb.READ);
    return {
      name: data.scope.name
    };
  }
  async deleteMany(ids, force, context, idsAreLanes) {
    const route = 'api/scope/delete';
    _logger().default.debug(`Http.delete, url: ${this.url}/${route}`);
    const body = JSON.stringify({
      ids,
      force,
      lanes: idsAreLanes
    });
    const headers = this.getHeaders({
      'Content-Type': 'application/json',
      'x-verb': 'write'
    });
    const opts = this.addAgentIfExist({
      method: 'post',
      body,
      headers
    });
    const res = await (0, _nodeFetch().default)(`${this.url}/${route}`, opts);
    await this.throwForNonOkStatus(res);
    const results = await this.getJsonResponse(res);
    return _removedComponents().default.fromObjects(results);
  }
  async pushMany(objectList, pushOptions) {
    const route = 'api/scope/put';
    _logger().default.debug(`Http.pushMany, url: ${this.url}/${route}  total objects ${objectList.count()}`);
    const body = objectList.toTar();
    const headers = this.getHeaders({
      'push-options': JSON.stringify(pushOptions),
      'x-verb': Verb.WRITE
    });
    const opts = this.addAgentIfExist({
      method: 'post',
      body,
      headers
    });
    const res = await (0, _nodeFetch().default)(`${this.url}/${route}`, opts);
    await this.throwForNonOkStatus(res);
    const ids = await this.getJsonResponse(res);
    return ids;
  }
  async pushToCentralHub(objectList, options = {}) {
    const route = 'api/put';
    _logger().default.debug(`Http.pushToCentralHub, started. url: ${this.url}/${route}. total objects ${objectList.count()}`);
    const pack = objectList.toTar();
    const opts = this.addAgentIfExist({
      method: 'post',
      body: pack,
      headers: this.getHeaders({
        'push-options': JSON.stringify(options),
        'x-verb': Verb.WRITE
      })
    });
    const res = await (0, _nodeFetch().default)(`${this.url}/${route}`, opts);
    _logger().default.debug(`Http.pushToCentralHub, completed. url: ${this.url}/${route}, status ${res.status} statusText ${res.statusText}`);
    const results = await this.readPutCentralStream(res.body);
    if (!results.data) throw new Error(`HTTP results are missing "data" property`);
    if (results.data.isError) {
      throw new (_exceptions().UnexpectedNetworkError)(results.message);
    }
    await this.throwForNonOkStatus(res);
    return results.data;
  }
  async action(name, options) {
    const route = 'api/scope/action';
    _logger().default.debug(`Http.action, url: ${this.url}/${route}`);
    const body = JSON.stringify({
      name,
      options
    });
    const headers = this.getHeaders({
      'Content-Type': 'application/json',
      'x-verb': Verb.WRITE
    });
    const opts = this.addAgentIfExist({
      method: 'post',
      body,
      headers
    });
    const res = await (0, _nodeFetch().default)(`${this.url}/${route}`, opts);
    await this.throwForNonOkStatus(res);
    const results = await this.getJsonResponse(res);
    return results;
  }
  async fetch(ids, fetchOptions) {
    const route = 'api/scope/fetch';
    const scopeData = `scopeName: ${this.scopeName}, url: ${this.url}/${route}`;
    _logger().default.debug(`Http.fetch, ${scopeData}`);
    const body = JSON.stringify({
      ids,
      fetchOptions
    });
    const headers = this.getHeaders({
      'Content-Type': 'application/json',
      'x-verb': Verb.READ
    });
    const opts = this.addAgentIfExist({
      method: 'post',
      body,
      headers
    });
    const res = await (0, _nodeFetch().default)(`${this.url}/${route}`, opts);
    _logger().default.debug(`Http.fetch got a response, ${scopeData}, status ${res.status}, statusText ${res.statusText}`);
    await this.throwForNonOkStatus(res);
    const objectListReadable = _objectList().ObjectList.fromTarToObjectStream(res.body);
    return objectListReadable;
  }
  async getJsonResponse(res) {
    try {
      return await res.json();
    } catch (err) {
      _logger().default.error('failed response', res);
      throw new (_httpInvalidJsonResponse().HttpInvalidJsonResponse)(res.url);
    }
  }
  async throwForNonOkStatus(res) {
    var _jsonResponse, _jsonResponse$error, _jsonResponse2;
    if (res.ok) return;
    let jsonResponse;
    try {
      jsonResponse = await res.json();
    } catch (e) {
      // the response is not json, ignore the body.
    }
    _logger().default.error(`parsed error from HTTP, url: ${res.url}`, jsonResponse);
    const error = (_jsonResponse = jsonResponse) !== null && _jsonResponse !== void 0 && (_jsonResponse$error = _jsonResponse.error) !== null && _jsonResponse$error !== void 0 && _jsonResponse$error.code ? (_jsonResponse2 = jsonResponse) === null || _jsonResponse2 === void 0 ? void 0 : _jsonResponse2.error : jsonResponse;
    if (error && !error.message && jsonResponse.message) error.message = jsonResponse.message;
    const err = (0, _remoteErrorHandler().remoteErrorHandler)(error === null || error === void 0 ? void 0 : error.code, error, res.url, `url: ${res.url}. status: ${res.status}. text: ${res.statusText}`);
    throw err;
  }
  async graphClientRequest(query, verb = Verb.READ, variables) {
    _logger().default.debug(`http.graphClientRequest, scope "${this.scopeName}", url "${this.url}", query ${query}`);
    try {
      this.graphClient.setHeader('x-verb', verb);
      return await this.graphClient.request(query, variables);
    } catch (err) {
      if (err instanceof _graphqlRequest().ClientError) {
        throw new (_graphqlClientError().GraphQLClientError)(err, this.url, this.scopeName);
      }
      // should not be here. it's just in case
      throw err;
    }
  }
  async readPutCentralStream(body) {
    const readline = _readline().default.createInterface({
      input: body,
      crlfDelay: Infinity
    });
    let results = {};
    readline.on('line', line => {
      const json = JSON.parse(line);
      if (json.end) results = json;
      _loader().default.start(json.message);
      // this logger is super important for debugging if the export fails. it shows at what step the failure occurred
      _logger().default.debug(`http, msg from central-hub: ${json.message}`);
    });
    return new Promise((resolve, reject) => {
      readline.on('close', () => {
        resolve(results);
      });
      readline.on('error', err => {
        _logger().default.error('readLine failed with error', err);
        reject(new Error(`readline failed with error, ${err === null || err === void 0 ? void 0 : err.message}`));
      });
    });
  }
  async list(namespacesUsingWildcards) {
    const LIST_HARMONY = (0, _graphqlRequest().gql)`
      query list($namespaces: [String!]) {
        scope {
          components(namespaces: $namespaces) {
            id {
              scope
              version
              name
            }
            deprecation {
              isDeprecate
            }
          }
        }
      }
    `;
    const LIST_LEGACY = (0, _graphqlRequest().gql)`
      query list($namespaces: String) {
        scope {
          _legacyList(namespaces: $namespaces) {
            id
            deprecated
          }
        }
      }
    `;
    try {
      const data = await this.graphClientRequest(LIST_HARMONY, Verb.READ, {
        namespaces: namespacesUsingWildcards ? [namespacesUsingWildcards] : undefined
      });
      data.scope.components.forEach(comp => {
        comp.id = _bitId().BitId.parse(comp.id);
        comp.deprecated = comp.deprecation.isDeprecate;
      });
      return data.scope.components;
    } catch (e) {
      const data = await this.graphClientRequest(LIST_LEGACY, Verb.READ, {
        namespaces: namespacesUsingWildcards
      });
      data.scope._legacyList.forEach(comp => {
        comp.id = _bitId().BitId.parse(comp.id);
      });
      return data.scope._legacyList;
    }
  }
  async show(bitId) {
    const SHOW_COMPONENT = (0, _graphqlRequest().gql)`
      query showLegacy($id: String!) {
        scope {
          _getLegacy(id: $id)
        }
      }
    `;
    const data = await this.graphClientRequest(SHOW_COMPONENT, Verb.READ, {
      id: bitId.toString()
    });
    return _component().default.fromString(data.scope._getLegacy);
  }
  async log(id) {
    const GET_LOG_QUERY = (0, _graphqlRequest().gql)`
      query getLogs($id: String!) {
        scope {
          getLogs(id: $id) {
            message
            username
            email
            date
            hash
            tag
          }
        }
      }
    `;
    const data = await this.graphClientRequest(GET_LOG_QUERY, Verb.READ, {
      id: id.toString()
    });
    return data.scope.getLogs;
  }
  async latestVersions(bitIds) {
    const GET_LATEST_VERSIONS = (0, _graphqlRequest().gql)`
      query getLatestVersions($ids: [String]!) {
        scope {
          _legacyLatestVersions(ids: $ids)
        }
      }
    `;
    const data = await this.graphClientRequest(GET_LATEST_VERSIONS, Verb.READ, {
      ids: bitIds.map(id => id.toString())
    });
    return data.scope._legacyLatestVersions;
  }
  async graph(bitId) {
    const GRAPH_QUERY = (0, _graphqlRequest().gql)`
      query graph($ids: [String], $filter: String) {
        graph(ids: $ids, filter: $filter) {
          nodes {
            id
            component {
              id {
                name
                version
                scope
              }
            }
          }
          edges {
            sourceId
            targetId
            dependencyLifecycleType
          }
        }
      }
    `;
    const {
      graph
    } = await this.graphClientRequest(GRAPH_QUERY, Verb.READ, {
      ids: bitId ? [bitId.toString()] : []
    });
    const nodes = graph.nodes.map(node => ({
      idStr: node.id,
      bitId: new (_bitId().BitId)(node.component.id)
    }));
    const edges = graph.edges.map(edge => ({
      src: edge.sourceId,
      target: edge.targetId,
      depType: edge.dependencyLifecycleType === 'DEV' ? 'devDependencies' : 'dependencies'
    }));
    const oldGraph = _scopeGraph().default.buildFromNodesAndEdges(nodes, edges);
    return new (_scopeGraph().default)(oldGraph);
  }
  async listLanes() {
    const LIST_LANES = (0, _graphqlRequest().gql)`
      query Lanes {
        lanes {
          list {
            id {
              name
              scope
            }
            components {
              id {
                name
                scope
                version
              }
            }
          }
        }
      }
    `;
    const res = await this.graphClientRequest(LIST_LANES, Verb.READ);
    return res.lanes.list;
  }
  getHeaders(headers = {}) {
    const authHeader = this.token ? getAuthHeader(this.token) : {};
    const localScope = this.localScopeName ? {
      'x-request-scope': this.localScopeName
    } : {};
    return Object.assign(headers, authHeader, localScope, {
      connection: 'keep-alive'
    }, {
      'x-client-version': this.getClientVersion()
    });
  }
  getClientVersion() {
    return (0, _bootstrap().getHarmonyVersion)(true);
  }
  addAgentIfExist(opts = {}) {
    const optsWithAgent = this.agent ? Object.assign({}, opts, {
      agent: this.agent
    }) : opts;
    return optsWithAgent;
  }
  static async connect(host, scopeName, localScopeName) {
    const token = Http.getToken();
    const headers = token ? getAuthHeader(token) : {};
    const proxyConfig = await Http.getProxyConfig();
    const networkConfig = await Http.getNetworkConfig();
    const agent = await Http.getAgent(host, _objectSpread(_objectSpread({}, proxyConfig), networkConfig));
    const graphQlUrl = `${host}/graphql`;
    const graphQlFetcher = await getFetcherWithAgent(graphQlUrl);
    const graphClient = new (_graphqlRequest().GraphQLClient)(graphQlUrl, {
      headers,
      fetch: graphQlFetcher
    });
    return new Http(graphClient, token, host, scopeName, proxyConfig, agent, localScopeName, networkConfig);
  }
}
exports.Http = Http;
function getAuthHeader(token) {
  return {
    Authorization: `${DEFAULT_AUTH_TYPE} ${token}`
  };
}

/**
 * Read the proxy config from the global config, and wrap fetch with fetch with proxy
 */
async function getFetcherWithAgent(uri) {
  const proxyConfig = await Http.getProxyConfig();
  const networkConfig = await Http.getNetworkConfig();
  const agent = await Http.getAgent(uri, _objectSpread(_objectSpread({}, proxyConfig), networkConfig));
  const fetcher = agent ? wrapFetcherWithAgent(agent) : _nodeFetch().default;
  return fetcher;
}

/**
 * return a fetch wrapper with the proxy agent inside
 * @param proxyAgent
 */
function wrapFetcherWithAgent(agent) {
  return (url, opts) => {
    const actualOpts = Object.assign({}, opts, {
      agent
    });
    return (0, _nodeFetch().default)(url, actualOpts);
  };
}
function getProxyAgent(proxy) {
  const proxyAgent = new (_httpsProxyAgent().HttpsProxyAgent)(proxy);
  return proxyAgent;
}
function getAuthDataFromHeader(authorizationHeader) {
  if (!authorizationHeader) return undefined;
  const authorizationSplit = authorizationHeader.split(' ');
  if (authorizationSplit.length !== 2) {
    throw new Error(`fatal: HTTP Authorization header "${authorizationHeader}" is invalid. it should have exactly one space`);
  }
  return {
    type: authorizationSplit[0],
    credentials: authorizationSplit[1]
  };
}