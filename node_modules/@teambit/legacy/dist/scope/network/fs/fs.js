"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = require("../../../api/scope");
  _scope = function () {
    return data;
  };
  return data;
}
function _action() {
  const data = require("../../../api/scope/lib/action");
  _action = function () {
    return data;
  };
  return data;
}
function _componentsList() {
  const data = _interopRequireDefault(require("../../../consumer/component/components-list"));
  _componentsList = function () {
    return data;
  };
  return data;
}
function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("../../component-ops/scope-components-importer"));
  _scopeComponentsImporter = function () {
    return data;
  };
  return data;
}
function _scopeGraph() {
  const data = _interopRequireDefault(require("../../graph/scope-graph"));
  _scopeGraph = function () {
    return data;
  };
  return data;
}
function _scopeLoader() {
  const data = _interopRequireDefault(require("../../scope-loader"));
  _scopeLoader = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("../exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
class Fs {
  constructor(scopePath) {
    (0, _defineProperty2().default)(this, "scopePath", void 0);
    (0, _defineProperty2().default)(this, "scope", void 0);
    this.scopePath = scopePath;
  }
  close() {
    return this;
  }
  getScope() {
    if (!this.scope) throw new (_exceptions().FsScopeNotLoaded)();
    return this.scope;
  }
  describeScope() {
    return Promise.resolve(this.getScope().describe());
  }
  pushMany(objectList, pushOptions) {
    return (0, _scope().put)({
      path: this.scopePath,
      objectList
    }, pushOptions);
  }
  action(name, options) {
    return (0, _action().action)(this.scopePath, name, options);
  }
  deleteMany(ids, force, context, idsAreLanes) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return (0, _scope().remove)({
      path: this.scopePath,
      ids,
      force,
      lanes: idsAreLanes
    });
  }
  async fetch(ids, fetchOptions) {
    const objectsReadable = await (0, _scope().fetch)(this.scopePath, ids, fetchOptions);
    return objectsReadable;
  }
  latestVersions(componentIds) {
    return this.getScope().latestVersions(componentIds).then(componentsIds => componentsIds.map(componentId => componentId.toString()));
  }
  list(namespacesUsingWildcards) {
    return _componentsList().default.listLocalScope(this.getScope(), namespacesUsingWildcards);
  }
  show(bitId) {
    const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(this.getScope());
    return scopeComponentsImporter.loadComponent(bitId);
  }
  log(bitId) {
    return this.getScope().loadComponentLogs(bitId);
  }
  listLanes(name, mergeData) {
    return this.getScope().lanes.getLanesData(this.getScope(), name, mergeData);
  }
  async graph(bitId) {
    const scope = this.getScope();
    const dependencyGraph = await _scopeGraph().default.loadLatest(scope);
    // get as string to mimic the exact steps of using ssh
    const getGraphAsString = () => {
      if (!bitId) {
        return dependencyGraph.serialize();
      }
      const componentGraph = dependencyGraph.getSubGraphOfConnectedComponents(bitId);
      return dependencyGraph.serialize(componentGraph);
    };
    const graphStr = getGraphAsString();
    return _scopeGraph().default.loadFromString(graphStr);
  }
  async connect() {
    return (0, _scopeLoader().default)(this.scopePath).then(scope => {
      this.scope = scope;
      return this;
    });
  }
}
exports.default = Fs;