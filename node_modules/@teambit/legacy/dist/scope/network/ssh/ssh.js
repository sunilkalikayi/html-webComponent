"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DEFAULT_STRATEGIES = exports.DEFAULT_READ_STRATEGIES = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _once2() {
  const data = _interopRequireDefault(require("ramda/src/once"));
  _once2 = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = _interopRequireDefault(require("lodash.merge"));
  _lodash = function () {
    return data;
  };
  return data;
}
function os() {
  const data = _interopRequireWildcard(require("os"));
  os = function () {
    return data;
  };
  return data;
}
function _ssh() {
  const data = require("ssh2");
  _ssh = function () {
    return data;
  };
  return data;
}
function _analytics() {
  const data = require("../../../analytics/analytics");
  _analytics = function () {
    return data;
  };
  return data;
}
function globalConfig() {
  const data = _interopRequireWildcard(require("../../../api/consumer/lib/global-config"));
  globalConfig = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _globalFlags() {
  const data = _interopRequireDefault(require("../../../cli/global-flags"));
  _globalFlags = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = _interopRequireDefault(require("../../../consumer/component"));
  _component = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _prompts() {
  const data = require("../../../prompts");
  _prompts = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _scopeGraph() {
  const data = _interopRequireDefault(require("../../graph/scope-graph"));
  _scopeGraph = function () {
    return data;
  };
  return data;
}
function _removedComponents() {
  const data = _interopRequireDefault(require("../../removed-components"));
  _removedComponents = function () {
    return data;
  };
  return data;
}
function _checkVersionCompatibility() {
  const data = _interopRequireDefault(require("../check-version-compatibility"));
  _checkVersionCompatibility = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("../exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _keyGetter() {
  const data = _interopRequireDefault(require("./key-getter"));
  _keyGetter = function () {
    return data;
  };
  return data;
}
function _objectList() {
  const data = require("../../objects/object-list");
  _objectList = function () {
    return data;
  };
  return data;
}
function _compsAndLanesObjects() {
  const data = _interopRequireDefault(require("../../comps-and-lanes-objects"));
  _compsAndLanesObjects = function () {
    return data;
  };
  return data;
}
function _remoteErrorHandler() {
  const data = require("../remote-error-handler");
  _remoteErrorHandler = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const checkVersionCompatibility = (0, _once2().default)(_checkVersionCompatibility().default);
const AUTH_FAILED_MESSAGE = 'All configured authentication methods failed';
const PASSPHRASE_POSSIBLY_MISSING_MESSAGE = 'Cannot parse privateKey: Unsupported key format';
function absolutePath(path) {
  if (!path.startsWith('/')) return `~/${path}`;
  return path;
}
function clean(str) {
  return str.replace('\n', '');
}
class AuthenticationStrategyFailed extends Error {}
const DEFAULT_STRATEGIES = ['token', 'ssh-agent', 'ssh-key', 'user-password'];
exports.DEFAULT_STRATEGIES = DEFAULT_STRATEGIES;
const DEFAULT_READ_STRATEGIES = ['token', 'ssh-agent', 'ssh-key', 'anonymous', 'user-password'];
exports.DEFAULT_READ_STRATEGIES = DEFAULT_READ_STRATEGIES;
class SSH {
  // Username entered by the user on the prompt user/pass process

  constructor({
    path,
    username,
    port,
    host
  }) {
    (0, _defineProperty2().default)(this, "connection", void 0);
    (0, _defineProperty2().default)(this, "path", void 0);
    (0, _defineProperty2().default)(this, "username", void 0);
    (0, _defineProperty2().default)(this, "port", void 0);
    (0, _defineProperty2().default)(this, "host", void 0);
    (0, _defineProperty2().default)(this, "_sshUsername", void 0);
    this.path = path;
    this.username = username;
    this.port = port;
    this.host = host || '';
  }

  /**
   * Network strategies:
   * 1) token (generated by bit-login command)
   * 2) ssh-agent (public-key should be saved on bit.dev, user needs to enable ssh-agent in its os. the agent saves the passphrase, so no need to enter)
   * 3) ssh-key. (user can specify location by `bit config`, if not, the default one is used. doesn't support passphrase)
   * 4) anonymous. (for read operations only) - trying to do the action as anonymous user
   * 5) prompt of user/password
   */
  async connect(strategiesNames = DEFAULT_STRATEGIES) {
    const strategies = {
      token: this._tokenAuthentication,
      anonymous: this._anonymousAuthentication,
      'ssh-agent': this._sshAgentAuthentication,
      'ssh-key': this._sshKeyAuthentication,
      'user-password': this._userPassAuthentication
    };
    const strategiesFailures = [];
    for (const strategyName of strategiesNames) {
      _logger().default.debug(`ssh, trying to connect using ${strategyName}`);
      const strategyFunc = strategies[strategyName].bind(this);
      try {
        const strategyResult = await strategyFunc(); // eslint-disable-line
        if (strategyResult) return strategyResult;
      } catch (err) {
        _logger().default.debug(`ssh, failed to connect using ${strategyName}. ${err.message}`);
        if (err instanceof AuthenticationStrategyFailed) {
          strategiesFailures.push(err.message);
        } else {
          throw err;
        }
      }
    }
    _logger().default.errorAndAddBreadCrumb('ssh', 'all connection strategies have been failed!');
    strategiesFailures.unshift('The following strategies were failed');
    throw new (_exceptions().AuthenticationFailed)(strategiesFailures.join('\n[-] '));
  }
  async _tokenAuthentication() {
    const sshConfig = this._composeTokenAuthObject();
    if (!sshConfig) {
      throw new AuthenticationStrategyFailed('user token not defined in bit-config. please run `bit login` to authenticate.');
    }
    const authFailedMsg = 'failed to authenticate with user token. generate a new token by running `bit logout && bit login`.';
    return this._connectWithConfig(sshConfig, 'token', authFailedMsg);
  }
  async _anonymousAuthentication() {
    const sshConfig = this._composeAnonymousAuthObject();
    if (!sshConfig) {
      throw new AuthenticationStrategyFailed('could not create the anonymous ssh configuration.');
    }
    const authFailedMsg = 'collection might be private.';
    return this._connectWithConfig(sshConfig, 'anonymous', authFailedMsg);
  }
  async _sshAgentAuthentication() {
    if (!this._hasAgentSocket()) {
      throw new AuthenticationStrategyFailed('unable to get SSH keys from ssh-agent to. perhaps service is down or disabled.');
    }
    const sshConfig = (0, _lodash().default)(this._composeBaseObject(), {
      agent: process.env.SSH_AUTH_SOCK
    });
    const authFailedMsg = 'no matching private key found in ssh-agent to authenticate to remote server.';
    return this._connectWithConfig(sshConfig, 'ssh-agent', authFailedMsg);
  }
  async _sshKeyAuthentication() {
    const keyBuffer = await (0, _keyGetter().default)();
    if (!keyBuffer) {
      throw new AuthenticationStrategyFailed('SSH key not found in `~/.ssh/id_rsa` or `ssh_key_file` config in `bit config` either not configured or refers to wrong path.');
    }
    const sshConfig = (0, _lodash().default)(this._composeBaseObject(), {
      privateKey: keyBuffer
    });
    const authFailedMsg = 'failed connecting to remote server using `~/.ssh/id_rsa` or `ssh_key_file` in `bit config`.';
    return this._connectWithConfig(sshConfig, 'ssh-key', authFailedMsg);
  }
  async _userPassAuthentication() {
    const sshConfig = await this._composeUserPassObject();
    const authFailedMsg = 'unable to connect using provided username and password combination.';
    return this._connectWithConfig(sshConfig, 'user-password', authFailedMsg);
  }
  close() {
    this.connection.end();
    return this;
  }
  _composeBaseObject(passphrase) {
    return {
      username: this.username,
      host: this.host,
      port: this.port,
      passphrase,
      readyTimeout: _constants().DEFAULT_SSH_READY_TIMEOUT
    };
  }
  _composeTokenAuthObject() {
    const processToken = _globalFlags().default.token;
    const token = processToken || (0, globalConfig().getSync)(_constants().CFG_USER_TOKEN_KEY);
    if (token) {
      this._sshUsername = 'token';
      return (0, _lodash().default)(this._composeBaseObject(), {
        username: 'token',
        password: token
      });
    }
    return null;
  }
  _composeAnonymousAuthObject() {
    this._sshUsername = 'anonymous';
    return (0, _lodash().default)(this._composeBaseObject(), {
      username: 'anonymous',
      password: ''
    });
  }
  _composeUserPassObject() {
    // @ts-ignore
    return (0, _prompts().userpass)().then(({
      username,
      password
    }) => {
      _analytics().Analytics.setExtraData('authentication_method', 'user_password');
      this._sshUsername = username;
      return (0, _lodash().default)(this._composeBaseObject(), {
        username,
        password
      });
    });
  }
  _hasAgentSocket() {
    return !!process.env.SSH_AUTH_SOCK;
  }
  async _connectWithConfig(sshConfig, authenticationType, authFailedMsg) {
    const connectWithConfigP = () => {
      const conn = new (_ssh().Client)();
      return new Promise((resolve, reject) => {
        conn.on('error', err => {
          reject(err);
        }).on('ready', () => {
          resolve(conn);
        }).connect(sshConfig);
      });
    };
    try {
      this.connection = await connectWithConfigP();
      _analytics().Analytics.setExtraData('authentication_method', authenticationType);
      _logger().default.debug(`ssh, authenticated successfully using ${authenticationType}`);
      return this;
    } catch (err) {
      if (err.message === AUTH_FAILED_MESSAGE) {
        throw new AuthenticationStrategyFailed(authFailedMsg);
      }
      _logger().default.error('ssh', err);
      if (err.code === 'ENOTFOUND') {
        throw new (_generalError().default)(`unable to find the SSH server. host: ${err.host}, port: ${err.port}. Original error message: ${err.message}`);
      }
      if (err.message === PASSPHRASE_POSSIBLY_MISSING_MESSAGE) {
        const macMojaveOs = process.platform === 'darwin' && os().release() === '18.2.0';
        let passphrasePossiblyMissing = 'error connecting with private ssh key. in case passphrase is used, use ssh-agent.';
        if (macMojaveOs) {
          passphrasePossiblyMissing += ' for macOS Mojave users, use `-m PEM` for `ssh-keygen` command to generate a valid SSH key';
        }
        throw new AuthenticationStrategyFailed(passphrasePossiblyMissing);
      }
      throw new AuthenticationStrategyFailed(`${authFailedMsg} due to an error "${err.message}"`);
    }
  }
  buildCmd(commandName, path, payload, context) {
    const compress = globalConfig().getSync(_constants().CFG_SSH_NO_COMPRESS) !== 'true';
    return `bit ${commandName} ${(0, _utils().toBase64)(path)} ${(0, _utils().packCommand)((0, _utils().buildCommandMessage)(payload, context, compress), true, compress)}`;
  }
  exec(commandName, payload, context, dataToStream) {
    _logger().default.debug(`ssh: going to run a remote command ${commandName}, path: ${this.path}`);
    // Add the entered username to context
    if (this._sshUsername) {
      context = context || {};
      context.sshUsername = this._sshUsername;
    }
    // eslint-disable-next-line consistent-return
    return new Promise((resolve, reject) => {
      let res = '';
      let err;
      const cmd = this.buildCmd(commandName, absolutePath(this.path || ''), payload, context);
      if (!this.connection) {
        err = 'ssh connection is not defined';
        _logger().default.error('ssh', err);
        return reject(err);
      }
      // eslint-disable-next-line consistent-return
      this.connection.exec(cmd, (error, stream) => {
        if (error) {
          _logger().default.error('ssh, exec returns an error: ', error);
          return reject(error);
        }
        if (dataToStream) {
          stream.stdin.write(dataToStream);
          stream.stdin.end();
        }
        stream.on('data', response => {
          res += response.toString();
        }).on('exit', code => {
          _logger().default.debug(`ssh: exit. Exit code: ${code}`);
          const promiseExit = () => {
            return code && code !== 0 ? reject(this.errorHandler(code, err)) : resolve(clean(res));
          };
          // sometimes the connection 'exit' before 'close' and then it doesn't have the data (err) ready yet.
          // in that case, we prefer to wait until the onClose will terminate the promise.
          // sometimes though, the connection only 'exit' and never 'close' (happened when _put command sent back
          // more than 1MB of data), in that case, the following setTimeout will terminate the promise.
          setTimeout(promiseExit, 2000);
        }).on('close', (code, signal) => {
          // @todo: not sure why the next line was needed. if commenting it doesn't create any bug, please remove.
          // otherwise, replace payload with dataToStream
          // if (commandName === '_put') res = res.replace(payload, '');
          _logger().default.debug(`ssh: returned with code: ${code}, signal: ${signal}.`);
          // DO NOT CLOSE THE CONNECTION (using this.connection.end()), it causes bugs when there are several open
          // connections. Same bugs occur when running "this.connection.end()" on "end" or "exit" events.
          return code && code !== 0 ? reject(this.errorHandler(code, err)) : resolve(clean(res));
        }).stderr.on('data', response => {
          err = response.toString();
          _logger().default.error(`ssh: got an error, ${err}`);
        });
      });
    });
  }
  errorHandler(code, err) {
    let parsedError;
    let remoteIsLegacy = false;
    try {
      const {
        headers,
        payload
      } = this._unpack(err, false);
      checkVersionCompatibility(headers.version);
      parsedError = payload;
      remoteIsLegacy = headers.version === '14.8.8' && parsedError.message.includes('Please update your Bit client');
    } catch (e) {
      // be graceful when can't parse error message
      _logger().default.error(`ssh: failed parsing error as JSON, error: ${err}`);
    }
    if (remoteIsLegacy) {
      return new (_generalError().default)(`fatal: unable to connect to a remote legacy SSH server from Harmony client`);
    }
    return (0, _remoteErrorHandler().remoteErrorHandler)(code, parsedError, `${this.host}:${this.path}`, err);
  }
  _unpack(data, base64 = true) {
    try {
      const unpacked = (0, _utils().unpackCommand)(data, base64);
      return unpacked;
    } catch (err) {
      _logger().default.error(`unpackCommand found on error "${err}", while parsing the following string: ${data}`);
      throw new (_exceptions().SSHInvalidResponse)(data);
    }
  }
  async pushMany(objectList, pushOptions, context) {
    // This ComponentObjects.manyToString will handle all the base64 stuff so we won't send this payload
    // to the pack command (to prevent duplicate base64)
    const data = await this.exec('_put', pushOptions, context, objectList.toJsonString());
    const {
      payload,
      headers
    } = this._unpack(data);
    checkVersionCompatibility(headers.version);
    return payload.ids;
  }
  async action(name, options) {
    const args = {
      name,
      options
    };
    const result = await this.exec(`_action`, args);
    const {
      payload,
      headers
    } = this._unpack(result);
    checkVersionCompatibility(headers.version);
    return payload;
  }
  deleteMany(ids, force, context, idsAreLanes) {
    return this.exec('_delete', {
      bitIds: ids,
      force,
      lanes: idsAreLanes
    }, context).then(data => {
      const {
        payload
      } = this._unpack(data);
      return _removedComponents().default.fromObjects(payload);
    });
  }
  describeScope() {
    return this.exec('_scope').then(data => {
      const {
        payload,
        headers
      } = this._unpack(data);
      checkVersionCompatibility(headers.version);
      return payload;
    }).catch(() => {
      throw new (_exceptions().RemoteScopeNotFound)(this.path);
    });
  }
  async list(namespacesUsingWildcards) {
    return this.exec('_list', namespacesUsingWildcards).then(async str => {
      const {
        payload,
        headers
      } = this._unpack(str);
      checkVersionCompatibility(headers.version);
      payload.forEach(result => {
        result.id = new (_bitId().BitId)(result.id);
      });
      return payload;
    });
  }
  async listLanes(name, mergeData) {
    const options = mergeData ? '--merge-data' : '';
    const str = await this.exec(`_lanes ${options}`, name);
    const {
      payload,
      headers
    } = this._unpack(str);
    checkVersionCompatibility(headers.version);
    return payload.map(result => _objectSpread(_objectSpread({}, result), {}, {
      components: result.components.map(component => ({
        id: new (_bitId().BitId)(component.id),
        head: component.head
      }))
    }));
  }
  latestVersions(componentIds) {
    const componentIdsStr = componentIds.map(componentId => componentId.toString());
    return this.exec('_latest', componentIdsStr).then(str => {
      const {
        payload,
        headers
      } = this._unpack(str);
      checkVersionCompatibility(headers.version);
      return payload;
    });
  }
  search(query, reindex) {
    return this.exec('_search', {
      query,
      reindex: reindex.toString()
    }).then(data => {
      const {
        payload,
        headers
      } = this._unpack(data);
      checkVersionCompatibility(headers.version);
      return payload;
    });
  }
  show(id) {
    return this.exec('_show', id.toString()).then(str => {
      const {
        payload,
        headers
      } = this._unpack(str);
      checkVersionCompatibility(headers.version);
      return str ? _component().default.fromString(payload) : null;
    });
  }
  log(id) {
    return this.exec('_log', id.toString()).then(str => {
      const {
        payload,
        headers
      } = this._unpack(str);
      checkVersionCompatibility(headers.version);
      return str ? JSON.parse(payload) : null;
    });
  }
  graph(bitId) {
    const idStr = bitId ? bitId.toString() : '';
    return this.exec('_graph', idStr).then(str => {
      const {
        payload,
        headers
      } = this._unpack(str);
      checkVersionCompatibility(headers.version);
      return _scopeGraph().default.loadFromString(payload);
    });
  }
  async fetch(idsStr, fetchOptions, context) {
    let options = '';
    const {
      type,
      withoutDependencies,
      includeArtifacts
    } = fetchOptions;
    if (type !== 'component') options = ` --type ${type}`;
    if (withoutDependencies) options += ' --no-dependencies';
    if (includeArtifacts) options += ' --include-artifacts';
    const str = await this.exec(`_fetch ${options}`, idsStr, context);
    const parseResponse = () => {
      try {
        const results = JSON.parse(str);
        return results;
      } catch (err) {
        throw new (_exceptions().SSHInvalidResponse)(str);
      }
    };
    const {
      payload,
      headers
    } = parseResponse();
    checkVersionCompatibility(headers.version);
    const format = headers.format;
    if (!format) {
      // this is an old version that doesn't have the "format" header
      const componentObjects = _compsAndLanesObjects().default.fromString(payload);
      return componentObjects.toObjectList().toReadableStream();
    }
    if (format === _objectList().FETCH_FORMAT_OBJECT_LIST) {
      return _objectList().ObjectList.fromJsonString(payload).toReadableStream();
    }
    throw new Error(`ssh.fetch, format "${format}" is not supported`);
  }
}
exports.default = SSH;