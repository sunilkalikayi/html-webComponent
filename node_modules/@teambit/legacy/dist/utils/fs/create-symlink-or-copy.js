"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createSymlinkOrCopy;
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _fs() {
  const data = _interopRequireDefault(require("fs"));
  _fs = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));
  _showDoctorError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * @param srcPath the path where the symlink is pointing to
 * @param destPath the path where to write the symlink
 * @param componentId
 */
function createSymlinkOrCopy(srcPath, destPath,
// @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
componentId = '', avoidHardLink = false) {
  _logger().default.trace(`createSymlinkOrCopy, deleting ${destPath}`);
  _fsExtra().default.removeSync(destPath); // in case a symlink already generated or when linking a component, when a component has been moved
  _fsExtra().default.ensureDirSync(path().dirname(destPath));
  try {
    _logger().default.trace(`createSymlinkOrCopy, generating a symlink on ${destPath} pointing to ${srcPath}, avoidHardLink=${avoidHardLink}`);
    if (avoidHardLink) symlink();else link();
  } catch (err) {
    const winMsg = _constants().IS_WINDOWS ? ' (or maybe copy)' : '';
    const errorHeader = componentId ? `failed to link a component ${componentId}` : 'failed to generate a symlink';
    throw new (_showDoctorError().default)(`${errorHeader}.
Symlink${winMsg} from: ${srcPath}, to: ${destPath} was failed.
Please use "--log=trace" flag to get more info about the error.
Original error: ${err}`);
  }
  function symlink() {
    _constants().IS_WINDOWS ? symlinkOrHardLink() : _fsExtra().default.symlinkSync(srcPath, destPath);
  }

  /**
   * for Windows. try to symlink, if fails (probably not-admin user), try to link.
   */
  function symlinkOrHardLink() {
    try {
      _fsExtra().default.symlinkSync(srcPath, destPath);
      _logger().default.trace(`createSymlinkOrCopy, symlinkOrHardLink() successfully created the symlink`);
    } catch (err) {
      // it can be a file or directory, we don't know. just run link(), it will junction for dirs and hard-link for files.
      link();
    }
  }
  function link() {
    _logger().default.trace(`createSymlinkOrCopy, link()`);
    try {
      hardLinkOrJunctionByFsExtra(srcPath);
      _logger().default.trace(`createSymlinkOrCopy, link() successfully created the link`);
    } catch (err) {
      if (err.code === 'EXDEV') {
        _logger().default.trace(`createSymlinkOrCopy, link() found EXDEV error, trying fs native`);
        // this is docker, which for some weird reason, throw error: "EXDEV: cross-device link not permitted"
        // only when using fs-extra. it doesn't happen with "fs".
        hardLinkOrJunctionByFsNative(srcPath);
        return;
      }
      if (err.code !== 'ENOENT') {
        throw err;
      }
      if (path().isAbsolute(srcPath)) {
        throw err; // the file really doesn't exist :)
      }
      // the src is a relative-path of the dest, not of the cwd, that's why it got ENOENT
      if (_constants().IS_WINDOWS) {
        _logger().default.trace(`createSymlinkOrCopy, link() changing the path to be absolute on Windows`);
        const srcAbsolute = path().join(destPath, '..', srcPath);
        hardLinkOrJunctionByFsExtra(srcAbsolute);
        return;
      }
      // on linux, you can always create symlink, regardless the relative-path.
      _fsExtra().default.symlinkSync(srcPath, destPath);
    }
  }
  function hardLinkOrJunctionByFsExtra(src) {
    try {
      _fsExtra().default.linkSync(src, destPath);
    } catch (err) {
      if (err.code === 'EPERM') {
        _logger().default.trace(`createSymlinkOrCopy, hardLinkOrJunctionByFsExtra() using Junction option`);
        // it's a directory. use 'junction', it works on both Linux and Win
        _fsExtra().default.symlinkSync(srcPath, destPath, 'junction');
      } else {
        throw err;
      }
    }
  }
  function hardLinkOrJunctionByFsNative(src) {
    try {
      _fs().default.linkSync(src, destPath);
    } catch (err) {
      if (err.code === 'EPERM' || err.code === 'EXDEV') {
        _logger().default.trace(`createSymlinkOrCopy, hardLinkOrJunctionByFsNative() using Junction option`);
        // it's a directory. use 'junction', it works on both Linux and Win
        _fs().default.symlinkSync(srcPath, destPath, 'junction');
      } else {
        throw err;
      }
    }
  }
}