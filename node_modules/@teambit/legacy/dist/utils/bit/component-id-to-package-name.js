"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = componentIdToPackageName;
function _bitId() {
  const data = _interopRequireDefault(require("../../bit-id/bit-id"));
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _componentPlaceholders() {
  const data = require("./component-placeholders");
  _componentPlaceholders = function () {
    return data;
  };
  return data;
}
function _npmRegistryName() {
  const data = _interopRequireDefault(require("./npm-registry-name"));
  _npmRegistryName = function () {
    return data;
  };
  return data;
}
function _parseScope() {
  const data = require("./parse-scope");
  _parseScope = function () {
    return data;
  };
  return data;
}
/**
 * convert a component name to a valid npm package name
 * e.g. BitId { scope: util, name: is-string } => @bit/util.is-string
 */
function componentIdToPackageName({
  id,
  bindingPrefix,
  defaultScope,
  withPrefix = true,
  extensions,
  isDependency = false
}) {
  const fromExtensions = getNameFromExtensions(id, defaultScope, extensions, isDependency);
  if (fromExtensions) return fromExtensions;
  const allSlashes = new RegExp('/', 'g');
  const name = id.name.replace(allSlashes, _constants().NODE_PATH_COMPONENT_SEPARATOR);
  const scope = id.scope || defaultScope;
  const partsToJoin = scope ? [scope, name] : [name];
  let nameWithoutPrefix = partsToJoin.join(_constants().NODE_PATH_COMPONENT_SEPARATOR);
  if (!withPrefix) return nameWithoutPrefix;
  const registryPrefix = bindingPrefix || (0, _npmRegistryName().default)();
  // Make sure we don't have the prefix also as part of the scope name
  // since prefixes are now taken from the owner name, and the scope name has the owner name as well.
  const registryPrefixWithDotWithoutAt = `${registryPrefix}.`.replace('@', '');
  if (nameWithoutPrefix.startsWith(registryPrefixWithDotWithoutAt) && registryPrefix !== '@bit') {
    nameWithoutPrefix = nameWithoutPrefix.replace(registryPrefixWithDotWithoutAt, '');
  }
  return `${registryPrefix}/${nameWithoutPrefix}`;
}
function getNameFromExtensions(id, defaultScope, extensions, isDependency) {
  var _pkgExt$config, _pkgExt$config$packag;
  if (!extensions) return null;
  if (isDependency) {
    const dependencyResolverExt = extensions.findExtension(_constants().Extensions.dependencyResolver);
    if (!dependencyResolverExt || !dependencyResolverExt.data.dependencies) return null;
    const dep = dependencyResolverExt.data.dependencies.find(d => {
      if (d.__type !== 'component') {
        return false;
      }
      if (!d.componentId.isEqual) {
        if (typeof d.componentId === 'string') {
          d.componentId = _bitId().default.parse(d.componentId);
        } else {
          d.componentId = new (_bitId().default)(d.componentId);
        }
      }
      return d.componentId.isEqual(id);
    });
    return dep ? dep.packageName : null;
  }
  const pkgExt = extensions.findExtension(_constants().Extensions.pkg);
  if (!pkgExt) return null;
  const name = (_pkgExt$config = pkgExt.config) === null || _pkgExt$config === void 0 ? void 0 : (_pkgExt$config$packag = _pkgExt$config.packageJson) === null || _pkgExt$config$packag === void 0 ? void 0 : _pkgExt$config$packag.name;
  const scopeId = id.scope || defaultScope;
  const {
    scope,
    owner
  } = (0, _parseScope().parseScope)(scopeId);
  if (!name) return null;
  return (0, _componentPlaceholders().replacePlaceHolderForPackageValue)({
    name: id.name,
    scope,
    owner,
    scopeId
  }, name);
}