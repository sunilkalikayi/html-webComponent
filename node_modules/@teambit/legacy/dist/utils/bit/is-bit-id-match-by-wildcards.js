"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBitIdMatchByWildcards;
function _is2() {
  const data = _interopRequireDefault(require("ramda/src/is"));
  _is2 = function () {
    return data;
  };
  return data;
}
function isBitIdMatchByWildcards(bitId, idsWithWildcard) {
  if (!Array.isArray(idsWithWildcard)) idsWithWildcard = [idsWithWildcard];
  const regexPatterns = idsWithWildcard.map(id => getRegex(id));
  const isNameMatchByWildcard = name => {
    return regexPatterns.some(regex => regex.test(name));
  };
  return isNameMatchByWildcard(bitId.toStringWithoutVersion()) || isNameMatchByWildcard(bitId.toStringWithoutScopeAndVersion());
}
function getRegex(idWithWildcard) {
  if (!(0, _is2().default)(String, idWithWildcard)) {
    throw new TypeError(`filterComponentsByWildcard expects idWithWildcard to be string, got ${typeof idWithWildcard}`);
  }
  const rule = idWithWildcard.replace(/\*/g, '.*');
  return new RegExp(`^${rule}$`);
}