"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getLatestVersionNumber;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _semver() {
  const data = _interopRequireDefault(require("semver"));
  _semver = function () {
    return data;
  };
  return data;
}
/**
 * Retrieve bitId with the highest version from a list according to provided id
 * it returns the provided id if it has a version already
 * if the list contains id without version, it returns the provided id.
 */

function getLatestVersionNumber(bitIds, bitId) {
  if (!bitId.getVersion().latest) return bitId;

  // If the bitId provided doesn't contain version we want to ignore scope during search always
  // otherwise we will have problems finding the version from the bitmap after we export the component
  // because we tag with a name without scope but the bitmap contain it with the scope name since it was exported
  // without this, we will always just return the first component in the bitmap which is really bad
  const ignoreScope = !bitId.hasScope();
  const similarIds = ignoreScope ? bitIds.filterWithoutScopeAndVersion(bitId) : bitIds.filterWithoutVersion(bitId);
  const allVersionsForId = similarIds.filter(id => id.hasVersion() && !id.isVersionSnap()).map(id => id.version);

  // A case when the provided bitId doesn't exists in the array
  if ((0, _isEmpty2().default)(allVersionsForId)) {
    if (similarIds.length === 1) return similarIds[0];
    if (similarIds.length > 1) throw new Error(`found multiple snaps for ${bitId.toString()}, unable to figure which one is the latest`);
    return bitId;
  }
  const allVersionsWithoutNullForId = (0, _lodash().compact)(allVersionsForId);
  const maxVersion = _semver().default.maxSatisfying(allVersionsWithoutNullForId, '*', {
    includePrerelease: true
  });
  if (!maxVersion) {
    throw new Error(`semver was not able to find the highest version among the following: ${allVersionsWithoutNullForId.join(', ')}`);
  }
  const bitIdWithMaxVersion = bitId.changeVersion(maxVersion);
  const result = ignoreScope ? bitIds.searchWithoutScope(bitIdWithMaxVersion) : bitIds.search(bitIdWithMaxVersion);
  if (!result) {
    throw new Error(`getLatestVersionNumber failed to find the id ${bitIdWithMaxVersion.toString()} within bitIds`);
  }
  return result;
}