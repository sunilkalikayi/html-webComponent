"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLatestVersion = getLatestVersion;
exports.getValidVersionOrReleaseType = getValidVersionOrReleaseType;
exports.isReleaseTypeSupported = isReleaseTypeSupported;
exports.isStrReleaseType = isStrReleaseType;
exports.throwForUnsupportedReleaseType = throwForUnsupportedReleaseType;
exports.validateVersion = validateVersion;
function _semver() {
  const data = require("semver");
  _semver = function () {
    return data;
  };
  return data;
}
function _componentVersion() {
  const data = require("@teambit/component-version");
  _componentVersion = function () {
    return data;
  };
  return data;
}
function isStrReleaseType(str) {
  const releaseTypes = ['major', 'premajor', 'minor', 'preminor', 'patch', 'prepatch', 'prerelease'];
  return releaseTypes.includes(str);
}
function isReleaseTypeSupported(str) {
  const supportedReleaseTypes = ['patch', 'minor', 'major', 'prerelease'];
  return supportedReleaseTypes.includes(str);
}
function throwForUnsupportedReleaseType(str) {
  if (!isReleaseTypeSupported(str)) {
    throw new Error(`the release-type "${str}" is not supported`);
  }
}
function validateVersion(version) {
  if (version) {
    // it also changes to a valid string (e.g. from v1.0.0 to 1.0.0)
    const validVersion = (0, _semver().valid)(version);
    if (!validVersion) throw new (_componentVersion().InvalidVersion)(version);
    return validVersion;
  }
  return undefined;
}
function getValidVersionOrReleaseType(str) {
  if (isStrReleaseType(str)) {
    const releaseType = str;
    throwForUnsupportedReleaseType(releaseType);
    return {
      releaseType
    };
  }
  const exactVersion = validateVersion(str);
  return {
    exactVersion
  };
}
function getLatestVersion(versions) {
  const max = (0, _semver().maxSatisfying)(versions, '*', {
    includePrerelease: true
  });
  if (!max) throw new Error(`unable to find the latest version from ${versions.join(', ')}`);
  return max;
}