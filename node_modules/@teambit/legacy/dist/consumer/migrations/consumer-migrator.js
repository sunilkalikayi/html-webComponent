"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _forEach2() {
  const data = _interopRequireDefault(require("ramda/src/forEach"));
  _forEach2 = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _migrationHelper() {
  const data = _interopRequireDefault(require("../../migration/migration-helper"));
  _migrationHelper = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
let globalVerbose = false;

/**
 * Running migration process for consumer
 * (Currently support only bitmap migration, but might contain other stores in the future)
 * @param {string} bitmapVersion - The current bitmap version
 * @param {Object} migratonManifest - A manifest which define what migrations to run
 * @param {BitMap} bitMap - bit map object
 * @param {boolean} verbose - print logs
 */
var migrate = async function migrate(bitmapVersion, migratonManifest, bitMap, verbose = false) {
  globalVerbose = verbose;

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  const bitMapMigrations = (0, _migrationHelper().default)(_constants().BIT_VERSION, bitmapVersion, migratonManifest, verbose);
  const newBitMap = _runAllMigrationsForStore('bitmap', bitMap, bitMapMigrations);
  // Run more migration for other stores (like bit.json)

  const result = {
    bitMap: newBitMap
  };
  return result;
};
/**
 * Runs all the migrations for all the versions for store (bit map) file
 * @param {string} storeType - type of store (bitmap / bitjson etc)
 * @param {string} store - store data
 * @param {VersionMigrations[]} migrations
 */
exports.default = migrate;
const _runAllMigrationsForStore = (storeType, store, migrations) => {
  // Make sure we got a store
  if (!store) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return null;
  }
  _logger().default.debug(`start updating store ${storeType}`);
  (0, _forEach2().default)(_runAllVersionMigrationsForStore(storeType, store), migrations);
  return store;
};

/**
 * Runs all the the migration in specific version on store
 * @param {string} storeType - type of store (bitmap / bitjson etc)
 * @param {string} store - store data
 */
const _runAllVersionMigrationsForStore = (storeType, store) => migrations => {
  const versionNumber = Object.keys(migrations)[0];
  _logger().default.debug(`updating store ${storeType} to version ${versionNumber}`);
  const migrationForStoreType = migrations[versionNumber][storeType];
  // There is no migration for this type of object for this version
  if (!migrationForStoreType) return store;
  (0, _forEach2().default)(_runOneMigrationForStore(storeType, store), migrationForStoreType);
  return store;
};

/**
 * Run specific migration function on a store
 * @param {string} storeType - type of store (bitmap / bitjson etc)
 * @param {string} store - store data
 */
const _runOneMigrationForStore = (storeType, store) => migration => {
  _logger().default.debug(`running migration: ${migration.name} on ${storeType}`);
  if (globalVerbose) console.log(`running migration: ${migration.name} on ${storeType}`);
  try {
    const migratedStore = migration.migrate(store);
    return migratedStore;
  } catch (err) {
    _logger().default.error(`FAILED - running migration: ${migration.name} on ${storeType}`);
    throw err;
  }
};