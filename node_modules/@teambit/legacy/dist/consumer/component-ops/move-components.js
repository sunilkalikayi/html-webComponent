"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.moveExistingComponent = moveExistingComponent;
exports.movePaths = movePaths;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _bitIds() {
  const data = _interopRequireDefault(require("../../bit-id/bit-ids"));
  _bitIds = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _links() {
  const data = require("../../links");
  _links = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _moveSync() {
  const data = _interopRequireDefault(require("../../utils/fs/move-sync"));
  _moveSync = function () {
    return data;
  };
  return data;
}
function _removePath() {
  const data = _interopRequireDefault(require("../component/sources/remove-path"));
  _removePath = function () {
    return data;
  };
  return data;
}
async function movePaths(consumer, {
  from,
  to
}) {
  const fromExists = _fsExtra().default.existsSync(from);
  const toExists = _fsExtra().default.existsSync(to);
  if (fromExists && toExists) {
    throw new (_generalError().default)(`unable to move because both paths from (${from}) and to (${to}) already exist`);
  }
  if (!fromExists && !toExists) throw new (_generalError().default)(`both paths from (${from}) and to (${to}) do not exist`);
  if (!consumer.isLegacy && fromExists && !(0, _utils().isDir)(from)) {
    throw new (_bitError().BitError)(`bit move supports moving directories only, not files.
files withing a component dir are automatically tracked, no action is needed.
to change the main-file, use "bit add <component-dir> --main <new-main-file>"`);
  }
  const fromRelative = consumer.getPathRelativeToConsumer(from);
  const toRelative = consumer.getPathRelativeToConsumer(to);
  const fromAbsolute = consumer.toAbsolutePath(fromRelative);
  const toAbsolute = consumer.toAbsolutePath(toRelative);
  const existingPath = fromExists ? fromAbsolute : toAbsolute;
  const changes = consumer.bitMap.updatePathLocation(fromRelative, toRelative, existingPath);
  if (fromExists && !toExists) {
    // user would like to physically move the file. Otherwise (!fromExists and toExists), user would like to only update bit.map
    (0, _moveSync().default)(fromAbsolute, toAbsolute);
  }
  if (!(0, _isEmpty2().default)(changes)) {
    const componentsIds = changes.map(c => c.id);
    const {
      components
    } = await consumer.loadComponents(_bitIds().default.fromArray(componentsIds));
    const nodeModuleLinker = new (_links().NodeModuleLinker)(components, consumer, consumer.bitMap);
    await nodeModuleLinker.link();
  }
  return changes;
}
function moveExistingComponent(consumer, component, oldPath, newPath) {
  if (_fsExtra().default.existsSync(newPath)) {
    throw new (_generalError().default)(`could not move the component ${component.id.toString()} from ${oldPath} to ${newPath} as the destination path already exists`);
  }
  const componentMap = consumer.bitMap.getComponent(component.id);
  const oldPathRelative = consumer.getPathRelativeToConsumer(oldPath);
  const newPathRelative = consumer.getPathRelativeToConsumer(newPath);
  componentMap.updateDirLocation(oldPathRelative, newPathRelative);
  consumer.bitMap.markAsChanged();
  component.dataToPersist.files.forEach(file => {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const newRelative = file.relative.replace(oldPathRelative, newPathRelative);
    file.updatePaths({
      newRelative
    });
  });
  component.dataToPersist.removePath(new (_removePath().default)(oldPathRelative));
  component.writtenPath = newPathRelative;
}