import { BitId } from '../../../bit-id';
import { BitIdStr } from '../../../bit-id/bit-id';
import BitMap from '../../../consumer/bit-map';
import Consumer from '../../../consumer/consumer';
import { ModelComponent } from '../../../scope/models';
import { PathLinux, PathOsBased } from '../../../utils/path';
import ComponentMap, { ComponentMapFile, Config } from '../../bit-map/component-map';
export declare type AddResult = {
    id: BitId;
    files: ComponentMapFile[];
};
export declare type Warnings = {
    alreadyUsed: Record<string, any>;
    emptyDirectory: string[];
    existInScope: BitId[];
};
export declare type AddActionResults = {
    addedComponents: AddResult[];
    warnings: Warnings;
};
export declare type PathOrDSL = PathOsBased | string;
declare type PathsStats = {};
export declare type AddedComponent = {
    componentId: BitId;
    files: ComponentMapFile[];
    mainFile?: PathOsBased | null | undefined;
    trackDir?: PathOsBased;
    idFromPath: {
        name: string;
        namespace: string;
    } | null | undefined;
    immediateDir?: string;
};
export declare type AddProps = {
    componentPaths: PathOsBased[];
    id?: string;
    main?: PathOsBased;
    namespace?: string;
    override: boolean;
    trackDirFeature?: boolean;
    defaultScope?: string;
    config?: Config;
    shouldHandleOutOfSync?: boolean;
};
export declare type AddContext = {
    consumer: Consumer;
    alternateCwd?: string;
};
export default class AddComponents {
    consumer: Consumer;
    bitMap: BitMap;
    componentPaths: PathOsBased[];
    id: string | null | undefined;
    main: PathOsBased | null | undefined;
    namespace: string | null | undefined;
    override: boolean;
    trackDirFeature: boolean | null | undefined;
    warnings: Warnings;
    ignoreList: string[];
    gitIgnore: any;
    alternateCwd: string | null | undefined;
    addedComponents: AddResult[];
    defaultScope?: string;
    config?: Config;
    shouldHandleOutOfSync?: boolean;
    constructor(context: AddContext, addProps: AddProps);
    joinConsumerPathIfNeeded(paths: PathOrDSL[]): PathOrDSL[];
    /**
     * @param {string[]} files - array of file-paths from which it should search for the dsl patterns.
     * @param {*} filesWithPotentialDsl - array of file-path which may have DSL patterns
     *
     * @returns array of file-paths from 'files' parameter that match the patterns from 'filesWithPotentialDsl' parameter
     */
    getFilesAccordingToDsl(files: PathLinux[], filesWithPotentialDsl: PathOrDSL[]): Promise<PathLinux[]>;
    /**
     * unsupported files, such as, binary files, don't have link-file. instead, they have a symlink
     * inside the component dir, pointing to the dependency.
     * this methods check whether a file is auto generated for the unsupported files.
     */
    _isGeneratedForUnsupportedFiles(fileRelativePath: PathLinux, componentId: BitId, componentMap: ComponentMap): Promise<boolean>;
    /**
     * for imported component, the package.json in the root directory is a bit-generated file and as
     * such, it should be ignored
     */
    _isPackageJsonOnRootDir(pathRelativeToConsumerRoot: PathLinux, componentMap: ComponentMap): boolean;
    /**
     * imported components might have wrapDir, when they do, files should not be added outside of
     * that wrapDir
     */
    _isOutsideOfWrapDir(pathRelativeToConsumerRoot: PathLinux, componentMap: ComponentMap): boolean;
    /**
     * Add or update existing (imported and new) component according to bitmap
     * there are 3 options:
     * 1. a user is adding a new component. there is no record for this component in bit.map
     * 2. a user is updating an existing component. there is a record for this component in bit.map
     * 3. some or all the files of this component were previously added as another component-id.
     */
    addOrUpdateComponentInBitMap(component: AddedComponent): Promise<AddResult | null | undefined>;
    /**
     * current componentFiles are relative to the workspace. we want them relative to the rootDir.
     */
    _updateFilesAccordingToExistingRootDir(foundComponentFromBitMap: ComponentMap, componentFiles: ComponentMapFile[], component: AddedComponent): void;
    /**
     * the risk with merging the currently added files with the existing bitMap files is overriding
     * the `test` property. e.g. the component directory is re-added without adding the tests flag to
     * track new files in that directory. in this case, we want to preserve the `test` property.
     */
    _mergeFilesWithExistingComponentMapFiles(componentFiles: ComponentMapFile[], existingComponentMapFile: ComponentMapFile[]): any;
    /**
     * if an existing file is for example uppercase and the new file is lowercase it has different
     * behavior according to the OS. some OS are case sensitive, some are not.
     * it's safer to avoid saving both files and instead, replacing the old file with the new one.
     * in case a file has replaced and it is also a mainFile, replace the mainFile as well
     */
    _updateFilesWithCurrentLetterCases(currentComponentMap: ComponentMap, newFiles: ComponentMapFile[]): void;
    _getComponentFromScopeIfExist(id: BitId): Promise<ModelComponent | null | undefined>;
    /**
     * if the id is already saved in bitmap file, it might have more data (such as scope, version)
     * use that id instead.
     */
    _getIdAccordingToExistingComponent(currentId: BitIdStr): BitId;
    _getIdAccordingToTrackDir(dir: PathOsBased): BitId | null | undefined;
    /**
     * used for updating main file if exists or doesn't exists
     */
    _addMainFileToFiles(files: ComponentMapFile[]): PathOsBased | null | undefined;
    _findMainFileInFiles(mainFile: string, files: ComponentMapFile[]): ComponentMapFile | undefined;
    /**
     * given the component paths, prepare the id, mainFile and files to be added later on to bitmap
     * the id of the component is either entered by the user or, if not entered, concluded by the path.
     * e.g. bar/foo.js, the id would be bar/foo.
     * in case bitmap has already the same id, the complete id is taken from bitmap (see _getIdAccordingToExistingComponent)
     */
    addOneComponent(componentPathsStats: PathsStats): Promise<AddedComponent>;
    getIgnoreList(): string[];
    add(): Promise<AddActionResults>;
    linkComponents(ids: BitId[]): Promise<void>;
    addMultipleComponents(componentPathsStats: PathsStats): Promise<void>;
    /**
     * some uses of wildcards might add directories and their files at the same time, in such cases
     * only the files are needed and the directories can be ignored.
     * @see https://github.com/teambit/bit/issues/1406 for more details
     */
    _removeDirectoriesWhenTheirFilesAreAdded(componentPathsStats: PathsStats): void;
    _addMultipleToBitMap(added: AddedComponent[]): Promise<void>;
    _removeNamespaceIfNotNeeded(addedComponents: AddedComponent[]): void;
    _tryAddingMultiple(componentPathsStats: PathsStats): Promise<AddedComponent[]>;
    _throwForOutsideConsumer(relativeToConsumerPath: PathOsBased): void;
    private throwForExistingParentDir;
}
export declare function getFilesByDir(dir: string, consumerPath: string, gitIgnore: any): Promise<ComponentMapFile[]>;
export declare function getGitIgnoreHarmony(consumerPath: string): any;
export {};
