"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.getFilesByDir = getFilesByDir;
exports.getGitIgnoreHarmony = getGitIgnoreHarmony;
function _isNil2() {
  const data = _interopRequireDefault(require("ramda/src/isNil"));
  _isNil2 = function () {
    return data;
  };
  return data;
}
function _reject2() {
  const data = _interopRequireDefault(require("ramda/src/reject"));
  _reject2 = function () {
    return data;
  };
  return data;
}
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _head2() {
  const data = _interopRequireDefault(require("ramda/src/head"));
  _head2 = function () {
    return data;
  };
  return data;
}
function _last2() {
  const data = _interopRequireDefault(require("ramda/src/last"));
  _last2 = function () {
    return data;
  };
  return data;
}
function _prop2() {
  const data = _interopRequireDefault(require("ramda/src/prop"));
  _prop2 = function () {
    return data;
  };
  return data;
}
function _eqBy2() {
  const data = _interopRequireDefault(require("ramda/src/eqBy"));
  _eqBy2 = function () {
    return data;
  };
  return data;
}
function _unionWith2() {
  const data = _interopRequireDefault(require("ramda/src/unionWith"));
  _unionWith2 = function () {
    return data;
  };
  return data;
}
function _uniq2() {
  const data = _interopRequireDefault(require("ramda/src/uniq"));
  _uniq2 = function () {
    return data;
  };
  return data;
}
function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));
  _flatten2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _arrayDifference() {
  const data = _interopRequireDefault(require("array-difference"));
  _arrayDifference = function () {
    return data;
  };
  return data;
}
function _globby() {
  const data = _interopRequireDefault(require("globby"));
  _globby = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _ignore() {
  const data = _interopRequireDefault(require("ignore"));
  _ignore = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = _interopRequireDefault(require("lodash.assignwith"));
  _lodash = function () {
    return data;
  };
  return data;
}
function _lodash2() {
  const data = _interopRequireDefault(require("lodash.groupby"));
  _lodash2 = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _stringFormat() {
  const data = _interopRequireDefault(require("string-format"));
  _stringFormat = function () {
    return data;
  };
  return data;
}
function _analytics() {
  const data = require("../../../analytics/analytics");
  _analytics = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _showDoctorError() {
  const data = _interopRequireDefault(require("../../../error/show-doctor-error"));
  _showDoctorError = function () {
    return data;
  };
  return data;
}
function _links() {
  const data = require("../../../links");
  _links = function () {
    return data;
  };
  return data;
}
function _linkContent() {
  const data = require("../../../links/link-content");
  _linkContent = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _path2() {
  const data = require("../../../utils/path");
  _path2 = function () {
    return data;
  };
  return data;
}
function _componentMap() {
  const data = _interopRequireDefault(require("../../bit-map/component-map"));
  _componentMap = function () {
    return data;
  };
  return data;
}
function _missingMainFile() {
  const data = _interopRequireDefault(require("../../bit-map/exceptions/missing-main-file"));
  _missingMainFile = function () {
    return data;
  };
  return data;
}
function _componentNotFoundInPath() {
  const data = _interopRequireDefault(require("../../component/exceptions/component-not-found-in-path"));
  _componentNotFoundInPath = function () {
    return data;
  };
  return data;
}
function _determineMainFile() {
  const data = _interopRequireDefault(require("./determine-main-file"));
  _determineMainFile = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _addingIndividualFiles() {
  const data = require("./exceptions/adding-individual-files");
  _addingIndividualFiles = function () {
    return data;
  };
  return data;
}
function _ignoredDirectory() {
  const data = require("./exceptions/ignored-directory");
  _ignoredDirectory = function () {
    return data;
  };
  return data;
}
function _missingMainFileMultipleComponents() {
  const data = _interopRequireDefault(require("./exceptions/missing-main-file-multiple-components"));
  _missingMainFileMultipleComponents = function () {
    return data;
  };
  return data;
}
function _parentDirTracked() {
  const data = require("./exceptions/parent-dir-tracked");
  _parentDirTracked = function () {
    return data;
  };
  return data;
}
function _pathOutsideConsumer() {
  const data = _interopRequireDefault(require("./exceptions/path-outside-consumer"));
  _pathOutsideConsumer = function () {
    return data;
  };
  return data;
}
function _versionShouldBeRemoved() {
  const data = _interopRequireDefault(require("./exceptions/version-should-be-removed"));
  _versionShouldBeRemoved = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const REGEX_DSL_PATTERN = /{([^}]+)}/g;
class AddComponents {
  // id entered by the user

  // (default = false) replace the files array or only add files.

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  // helpful for out-of-sync

  // only bit-add (not bit-create/new) should handle out-of-sync scenario
  constructor(context, addProps) {
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "bitMap", void 0);
    (0, _defineProperty2().default)(this, "componentPaths", void 0);
    (0, _defineProperty2().default)(this, "id", void 0);
    (0, _defineProperty2().default)(this, "main", void 0);
    (0, _defineProperty2().default)(this, "namespace", void 0);
    (0, _defineProperty2().default)(this, "override", void 0);
    (0, _defineProperty2().default)(this, "trackDirFeature", void 0);
    (0, _defineProperty2().default)(this, "warnings", void 0);
    (0, _defineProperty2().default)(this, "ignoreList", void 0);
    (0, _defineProperty2().default)(this, "gitIgnore", void 0);
    (0, _defineProperty2().default)(this, "alternateCwd", void 0);
    (0, _defineProperty2().default)(this, "addedComponents", void 0);
    (0, _defineProperty2().default)(this, "defaultScope", void 0);
    (0, _defineProperty2().default)(this, "config", void 0);
    (0, _defineProperty2().default)(this, "shouldHandleOutOfSync", void 0);
    this.alternateCwd = context.alternateCwd;
    this.consumer = context.consumer;
    this.bitMap = this.consumer.bitMap;
    this.componentPaths = this.joinConsumerPathIfNeeded(addProps.componentPaths);
    this.id = addProps.id;
    this.main = addProps.main;
    this.namespace = addProps.namespace;
    this.override = addProps.override;
    this.trackDirFeature = addProps.trackDirFeature;
    this.warnings = {
      alreadyUsed: {},
      emptyDirectory: [],
      existInScope: []
    };
    this.addedComponents = [];
    this.defaultScope = addProps.defaultScope;
    this.config = addProps.config;
    this.shouldHandleOutOfSync = addProps.shouldHandleOutOfSync;
  }
  joinConsumerPathIfNeeded(paths) {
    if (paths.length > 0) {
      if (this.alternateCwd !== undefined && this.alternateCwd !== null) {
        const alternate = this.alternateCwd;
        return paths.map(file => path().join(alternate, file));
      }
      return paths;
    }
    return [];
  }

  /**
   * @param {string[]} files - array of file-paths from which it should search for the dsl patterns.
   * @param {*} filesWithPotentialDsl - array of file-path which may have DSL patterns
   *
   * @returns array of file-paths from 'files' parameter that match the patterns from 'filesWithPotentialDsl' parameter
   */
  async getFilesAccordingToDsl(files, filesWithPotentialDsl) {
    const filesListAllMatches = filesWithPotentialDsl.map(async dsl => {
      const filesListMatch = files.map(async file => {
        const fileInfo = (0, _utils().calculateFileInfo)(file);
        const generatedFile = (0, _stringFormat().default)(dsl, fileInfo);
        const matches = await (0, _utils().glob)(generatedFile);
        const matchesAfterGitIgnore = this.gitIgnore.filter(matches);
        return matchesAfterGitIgnore.filter(match => _fsExtra().default.existsSync(match));
      });
      return Promise.all(filesListMatch);
    });
    const filesListFlatten = (0, _flatten2().default)(await Promise.all(filesListAllMatches));
    const filesListUnique = (0, _uniq2().default)(filesListFlatten);
    return filesListUnique.map(file => {
      // when files array has the test file with different letter case, use the one from the file array
      const fileNormalized = (0, _utils().pathNormalizeToLinux)(file);
      const fileWithCorrectCase = files.find(f => f.toLowerCase() === fileNormalized.toLowerCase()) || fileNormalized;
      const relativeToConsumer = this.consumer.getPathRelativeToConsumer(fileWithCorrectCase);
      return (0, _utils().pathNormalizeToLinux)(relativeToConsumer);
    });
  }

  /**
   * unsupported files, such as, binary files, don't have link-file. instead, they have a symlink
   * inside the component dir, pointing to the dependency.
   * this methods check whether a file is auto generated for the unsupported files.
   */
  async _isGeneratedForUnsupportedFiles(fileRelativePath, componentId, componentMap) {
    if ((0, _linkContent().isSupportedExtension)(fileRelativePath)) return false;
    const componentFromModel = await this.consumer.loadComponentFromModelIfExist(componentId);
    if (!componentFromModel) {
      throw new (_showDoctorError().default)(`failed finding ${componentId.toString()} in the model although the component is imported, try running "bit import ${componentId.toString()} --objects" to get the component saved in the model`);
    }
    const dependencies = componentFromModel.getAllDependenciesCloned();
    const sourcePaths = dependencies.getSourcesPaths();
    const sourcePathsRelativeToConsumer = sourcePaths.map(sourcePath => (0, _utils().pathJoinLinux)(componentMap.rootDir, sourcePath));
    return sourcePathsRelativeToConsumer.includes(fileRelativePath);
  }

  /**
   * for imported component, the package.json in the root directory is a bit-generated file and as
   * such, it should be ignored
   */
  _isPackageJsonOnRootDir(pathRelativeToConsumerRoot, componentMap) {
    if (!componentMap.rootDir) {
      throw new Error('_isPackageJsonOnRootDir should not get called on non imported components');
    }
    return path().join(componentMap.rootDir, _constants().PACKAGE_JSON) === path().normalize(pathRelativeToConsumerRoot);
  }

  /**
   * imported components might have wrapDir, when they do, files should not be added outside of
   * that wrapDir
   */
  _isOutsideOfWrapDir(pathRelativeToConsumerRoot, componentMap) {
    if (!componentMap.rootDir) {
      throw new Error('_isOutsideOfWrapDir should not get called on non imported components');
    }
    if (!componentMap.wrapDir) return false;
    const wrapDirRelativeToConsumerRoot = path().join(componentMap.rootDir, componentMap.wrapDir);
    return !path().normalize(pathRelativeToConsumerRoot).startsWith(wrapDirRelativeToConsumerRoot);
  }

  /**
   * Add or update existing (imported and new) component according to bitmap
   * there are 3 options:
   * 1. a user is adding a new component. there is no record for this component in bit.map
   * 2. a user is updating an existing component. there is a record for this component in bit.map
   * 3. some or all the files of this component were previously added as another component-id.
   */
  async addOrUpdateComponentInBitMap(component) {
    const consumerPath = this.consumer.getPath();
    const parsedBitId = component.componentId;
    const componentFromScope = await this._getComponentFromScopeIfExist(parsedBitId);
    const files = component.files;
    const foundComponentFromBitMap = this.bitMap.getComponentIfExist(component.componentId, {
      ignoreScopeAndVersion: true
    });
    const componentFilesP = files.map(async file => {
      // $FlowFixMe null is removed later on
      const filePath = path().join(consumerPath, file.relativePath);
      const isAutoGenerated = await (0, _utils().isAutoGeneratedFile)(filePath);
      if (isAutoGenerated) {
        return null;
      }
      const caseSensitive = false;
      const existingIdOfFile = this.bitMap.getComponentIdByPath(file.relativePath, caseSensitive);
      const idOfFileIsDifferent = existingIdOfFile && !existingIdOfFile.isEqual(parsedBitId);
      if (idOfFileIsDifferent) {
        // not imported component file but exists in bitmap
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        if (this.warnings.alreadyUsed[existingIdOfFile]) {
          // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
          this.warnings.alreadyUsed[existingIdOfFile].push(file.relativePath);
        } else {
          // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
          this.warnings.alreadyUsed[existingIdOfFile] = [file.relativePath];
        }
        return null;
      }
      if (!foundComponentFromBitMap && componentFromScope && this.shouldHandleOutOfSync) {
        const newId = componentFromScope.toBitIdWithLatestVersion();
        if (!this.defaultScope || this.defaultScope === newId.scope) {
          // otherwise, if defaultScope !== newId.scope, they're different components,
          // and no need to change the id.
          // for more details about this scenario, see https://github.com/teambit/bit/issues/1543, last case.
          component.componentId = newId;
          this.warnings.existInScope.push(newId);
        }
      }
      return file;
    });
    // @ts-ignore it can't be null due to the filter function
    const componentFiles = (await Promise.all(componentFilesP)).filter(file => file);
    if (!componentFiles.length) return {
      id: component.componentId,
      files: []
    };
    if (foundComponentFromBitMap) {
      this._updateFilesAccordingToExistingRootDir(foundComponentFromBitMap, componentFiles, component);
    }
    if (this.trackDirFeature) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      if (this.bitMap._areFilesArraysEqual(foundComponentFromBitMap.files, componentFiles)) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        return foundComponentFromBitMap;
      }
    }
    if (!this.override && foundComponentFromBitMap) {
      this._updateFilesWithCurrentLetterCases(foundComponentFromBitMap, componentFiles);
      component.files = this._mergeFilesWithExistingComponentMapFiles(componentFiles, foundComponentFromBitMap.files);
    } else {
      component.files = componentFiles;
    }
    const {
      componentId,
      trackDir
    } = component;
    const mainFile = (0, _determineMainFile().default)(component, foundComponentFromBitMap);
    const getRootDir = () => {
      if (this.trackDirFeature) throw new Error('track dir should not calculate the rootDir');
      if (foundComponentFromBitMap) return foundComponentFromBitMap.rootDir;
      if (!trackDir) throw new Error(`addOrUpdateComponentInBitMap expect to have trackDir for non-legacy workspace`);
      const fileNotInsideTrackDir = componentFiles.find(file => !(0, _utils().pathNormalizeToLinux)(file.relativePath).startsWith(`${(0, _utils().pathNormalizeToLinux)(trackDir)}/`));
      if (fileNotInsideTrackDir) {
        // we check for this error before. however, it's possible that a user have one trackDir
        // and another dir for the tests.
        throw new (_addingIndividualFiles().AddingIndividualFiles)(fileNotInsideTrackDir.relativePath);
      }
      return (0, _utils().pathNormalizeToLinux)(trackDir);
    };
    const getComponentMap = () => {
      if (this.trackDirFeature) {
        return this.bitMap.addFilesToComponent({
          componentId,
          files: component.files
        });
      }
      const rootDir = getRootDir();
      const componentMap = this.bitMap.addComponent({
        componentId,
        files: component.files,
        defaultScope: this.defaultScope,
        config: this.config,
        mainFile,
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        override: this.override
      });
      if (rootDir) componentMap.changeRootDirAndUpdateFilesAccordingly(rootDir);
      return componentMap;
    };
    const componentMap = getComponentMap();
    return {
      id: componentId,
      files: componentMap.files
    };
  }

  /**
   * current componentFiles are relative to the workspace. we want them relative to the rootDir.
   */
  _updateFilesAccordingToExistingRootDir(foundComponentFromBitMap, componentFiles, component) {
    const existingRootDir = foundComponentFromBitMap.rootDir;
    if (!existingRootDir) return; // nothing to do.
    const areFilesInsideExistingRootDir = componentFiles.every(file => (0, _utils().pathNormalizeToLinux)(file.relativePath).startsWith(`${existingRootDir}/`));
    if (areFilesInsideExistingRootDir) {
      _componentMap().default.changeFilesPathAccordingToItsRootDir(existingRootDir, componentFiles);
      return;
    }
    // some (or all) added files are outside the existing rootDir, the rootDir needs to be changed
    // if a directory was added and it's a parent of the existing rootDir, change the rootDir to
    // the currently added rootDir.
    const currentlyAddedDir = (0, _utils().pathNormalizeToLinux)(component.trackDir);
    const currentlyAddedDirParentOfRootDir = currentlyAddedDir && existingRootDir.startsWith(`${currentlyAddedDir}/`);
    if (currentlyAddedDirParentOfRootDir) {
      foundComponentFromBitMap.changeRootDirAndUpdateFilesAccordingly(currentlyAddedDir);
      _componentMap().default.changeFilesPathAccordingToItsRootDir(currentlyAddedDir, componentFiles);
      return;
    }
    throw new (_generalError().default)(`unable to add individual files outside the root dir (${existingRootDir}) of ${component.componentId}.
you can add the directory these files are located at and it'll change the root dir of the component accordingly`);
    // we might want to change the behavior here to not throw an error and only change the rootDir to "."
    // foundComponentFromBitMap.changeRootDirAndUpdateFilesAccordingly('.');
  }

  /**
   * the risk with merging the currently added files with the existing bitMap files is overriding
   * the `test` property. e.g. the component directory is re-added without adding the tests flag to
   * track new files in that directory. in this case, we want to preserve the `test` property.
   */
  _mergeFilesWithExistingComponentMapFiles(componentFiles, existingComponentMapFile) {
    return (0, _unionWith2().default)((0, _eqBy2().default)((0, _prop2().default)('relativePath')), existingComponentMapFile, componentFiles);
  }

  /**
   * if an existing file is for example uppercase and the new file is lowercase it has different
   * behavior according to the OS. some OS are case sensitive, some are not.
   * it's safer to avoid saving both files and instead, replacing the old file with the new one.
   * in case a file has replaced and it is also a mainFile, replace the mainFile as well
   */
  _updateFilesWithCurrentLetterCases(currentComponentMap, newFiles) {
    const currentFiles = currentComponentMap.files;
    currentFiles.forEach(currentFile => {
      const sameFile = newFiles.find(newFile => newFile.relativePath.toLowerCase() === currentFile.relativePath.toLowerCase());
      if (sameFile && currentFile.relativePath !== sameFile.relativePath) {
        if (currentComponentMap.mainFile === currentFile.relativePath) {
          currentComponentMap.mainFile = sameFile.relativePath;
        }
        currentFile.relativePath = sameFile.relativePath;
      }
    });
  }
  async _getComponentFromScopeIfExist(id) {
    try {
      return await this.consumer.scope.getModelComponentIgnoreScope(id);
    } catch (err) {
      return null;
    }
  }

  /**
   * if the id is already saved in bitmap file, it might have more data (such as scope, version)
   * use that id instead.
   */
  _getIdAccordingToExistingComponent(currentId) {
    const existingComponentId = this.bitMap.getExistingBitId(currentId, false);
    if (currentId.includes(_constants().VERSION_DELIMITER)) {
      if (!existingComponentId ||
      // this id is new, it shouldn't have a version
      !existingComponentId.hasVersion() ||
      // this component is new, it shouldn't have a version
      // user shouldn't add files to a an existing component with different version
      // $FlowFixMe this function gets called only when this.id is set
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      existingComponentId.version !== _bitId().BitId.getVersionOnlyFromString(this.id)) {
        // $FlowFixMe this.id is defined here
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        throw new (_versionShouldBeRemoved().default)(this.id);
      }
    }
    return existingComponentId || _bitId().BitId.parse(currentId, false);
  }
  _getIdAccordingToTrackDir(dir) {
    const dirNormalizedToLinux = (0, _utils().pathNormalizeToLinux)(dir);
    const trackDirs = this.bitMap.getAllTrackDirs();
    if (!trackDirs) return null;
    return trackDirs[dirNormalizedToLinux];
  }

  /**
   * used for updating main file if exists or doesn't exists
   */
  _addMainFileToFiles(files) {
    let mainFile = this.main;
    if (mainFile && mainFile.match(REGEX_DSL_PATTERN)) {
      // it's a DSL
      files.forEach(file => {
        const fileInfo = (0, _utils().calculateFileInfo)(file.relativePath);
        const generatedFile = (0, _stringFormat().default)(mainFile, fileInfo);
        const foundFile = this._findMainFileInFiles(generatedFile, files);
        if (foundFile) {
          mainFile = foundFile.relativePath;
        }
        if (_fsExtra().default.existsSync(generatedFile) && !foundFile) {
          const shouldIgnore = this.gitIgnore.ignores(generatedFile);
          if (shouldIgnore) {
            // check if file is in exclude list
            throw new (_exceptions().ExcludedMainFile)(generatedFile);
          }
          files.push({
            relativePath: (0, _utils().pathNormalizeToLinux)(generatedFile),
            test: false,
            name: path().basename(generatedFile)
          });
          mainFile = generatedFile;
        }
      });
    }
    if (!mainFile) return undefined;
    if (this.alternateCwd) {
      mainFile = path().join(this.alternateCwd, mainFile);
    }
    const mainFileRelativeToConsumer = this.consumer.getPathRelativeToConsumer(mainFile);
    const mainPath = this.consumer.toAbsolutePath(mainFileRelativeToConsumer);
    if (_fsExtra().default.existsSync(mainPath)) {
      const shouldIgnore = this.gitIgnore.ignores(mainFileRelativeToConsumer);
      if (shouldIgnore) throw new (_exceptions().ExcludedMainFile)(mainFileRelativeToConsumer);
      if ((0, _utils().isDir)(mainPath)) {
        throw new (_exceptions().MainFileIsDir)(mainPath);
      }
      const foundFile = this._findMainFileInFiles(mainFileRelativeToConsumer, files);
      if (foundFile) {
        return foundFile.relativePath;
      }
      files.push({
        relativePath: (0, _utils().pathNormalizeToLinux)(mainFileRelativeToConsumer),
        test: false,
        name: path().basename(mainFileRelativeToConsumer)
      });
      return mainFileRelativeToConsumer;
    }
    return mainFile;
  }
  _findMainFileInFiles(mainFile, files) {
    const normalizedMainFile = (0, _utils().pathNormalizeToLinux)(mainFile).toLowerCase();
    return files.find(file => file.relativePath.toLowerCase() === normalizedMainFile);
  }

  /**
   * given the component paths, prepare the id, mainFile and files to be added later on to bitmap
   * the id of the component is either entered by the user or, if not entered, concluded by the path.
   * e.g. bar/foo.js, the id would be bar/foo.
   * in case bitmap has already the same id, the complete id is taken from bitmap (see _getIdAccordingToExistingComponent)
   */
  async addOneComponent(componentPathsStats) {
    let finalBitId; // final id to use for bitmap file
    let idFromPath;
    if (this.id) {
      finalBitId = this._getIdAccordingToExistingComponent(this.id);
    }
    const componentsWithFilesP = Object.keys(componentPathsStats).map(async componentPath => {
      if (componentPathsStats[componentPath].isDir) {
        const relativeComponentPath = this.consumer.getPathRelativeToConsumer(componentPath);
        this._throwForOutsideConsumer(relativeComponentPath);
        this.throwForExistingParentDir(relativeComponentPath);
        const matches = await (0, _utils().glob)(path().join(relativeComponentPath, '**'), {
          cwd: this.consumer.getPath(),
          nodir: true
        });
        if (!matches.length) throw new (_exceptions().EmptyDirectory)(componentPath);
        const filteredMatches = this.gitIgnore.filter(matches);
        if (!filteredMatches.length) {
          throw new (_exceptions().NoFiles)(matches);
        }
        const filteredMatchedFiles = filteredMatches.map(match => {
          return {
            relativePath: (0, _utils().pathNormalizeToLinux)(match),
            test: false,
            name: path().basename(match)
          };
        });
        const resolvedMainFile = this._addMainFileToFiles(filteredMatchedFiles);
        const absoluteComponentPath = path().resolve(componentPath);
        const splitPath = absoluteComponentPath.split(path().sep);
        const lastDir = splitPath[splitPath.length - 1];
        if (!finalBitId) {
          const idOfTrackDir = this._getIdAccordingToTrackDir(componentPath);
          if (idOfTrackDir) {
            finalBitId = idOfTrackDir;
          } else {
            const nameSpaceOrDir = this.namespace || splitPath[splitPath.length - 2];
            if (!this.namespace) {
              idFromPath = {
                namespace: _bitId().BitId.getValidIdChunk(nameSpaceOrDir),
                name: _bitId().BitId.getValidIdChunk(lastDir)
              };
            }
            finalBitId = _bitId().BitId.getValidBitId(nameSpaceOrDir, lastDir);
          }
        }
        const getTrackDir = () => {
          if (Object.keys(componentPathsStats).length === 1) {
            return relativeComponentPath;
          }
          return undefined;
        };
        const trackDir = getTrackDir();
        return {
          componentId: finalBitId,
          files: filteredMatchedFiles,
          mainFile: resolvedMainFile,
          trackDir,
          idFromPath,
          immediateDir: lastDir
        };
      }
      // is file
      const absolutePath = path().resolve(componentPath);
      const pathParsed = path().parse(absolutePath);
      const relativeFilePath = this.consumer.getPathRelativeToConsumer(componentPath);
      this._throwForOutsideConsumer(relativeFilePath);
      if (!finalBitId) {
        let dirName = pathParsed.dir;
        if (!dirName) {
          dirName = path().dirname(absolutePath);
        }
        const nameSpaceOrLastDir = this.namespace || (0, _last2().default)(dirName.split(path().sep));
        if (!this.namespace) {
          idFromPath = {
            namespace: _bitId().BitId.getValidIdChunk(nameSpaceOrLastDir),
            name: _bitId().BitId.getValidIdChunk(pathParsed.name)
          };
        }
        finalBitId = _bitId().BitId.getValidBitId(nameSpaceOrLastDir, pathParsed.name);
      }
      const files = [{
        relativePath: (0, _utils().pathNormalizeToLinux)(relativeFilePath),
        test: false,
        name: path().basename(relativeFilePath)
      }];
      const resolvedMainFile = this._addMainFileToFiles(files);
      return {
        componentId: finalBitId,
        files,
        mainFile: resolvedMainFile,
        idFromPath
      };
    });
    let componentsWithFiles = await Promise.all(componentsWithFilesP);

    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const componentId = finalBitId;
    componentsWithFiles = componentsWithFiles.filter(componentWithFiles => componentWithFiles.files.length);

    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (componentsWithFiles.length === 0) return {
      componentId,
      files: []
    };
    if (componentsWithFiles.length === 1) return componentsWithFiles[0];
    const files = componentsWithFiles.reduce((a, b) => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return a.concat(b.files);
    }, []);
    const groupedComponents = (0, _lodash2().default)(files, 'relativePath');
    const uniqComponents = Object.keys(groupedComponents).map(key => (0, _lodash().default)({}, ...groupedComponents[key], (val1, val2) => val1 || val2));
    return {
      componentId,
      files: uniqComponents,
      mainFile: (0, _head2().default)(componentsWithFiles).mainFile,
      trackDir: (0, _head2().default)(componentsWithFiles).trackDir,
      idFromPath
    };
  }
  getIgnoreList() {
    const consumerPath = this.consumer.getPath();
    return getIgnoreListHarmony(consumerPath);
  }
  async add() {
    this.ignoreList = this.getIgnoreList();
    this.gitIgnore = (0, _ignore().default)().add(this.ignoreList); // add ignore list

    let componentPathsStats = {};
    const resolvedComponentPathsWithoutGitIgnore = (0, _flatten2().default)(await Promise.all(this.componentPaths.map(componentPath => (0, _utils().glob)(componentPath))));
    this.gitIgnore = (0, _ignore().default)().add(this.ignoreList); // add ignore list

    const resolvedComponentPathsWithGitIgnore = this.gitIgnore.filter(resolvedComponentPathsWithoutGitIgnore);
    // Run diff on both arrays to see what was filtered out because of the gitignore file
    const diff = (0, _arrayDifference().default)(resolvedComponentPathsWithGitIgnore, resolvedComponentPathsWithoutGitIgnore);
    if ((0, _isEmpty2().default)(resolvedComponentPathsWithoutGitIgnore)) {
      throw new (_exceptions().PathsNotExist)(this.componentPaths);
    }
    if (!(0, _isEmpty2().default)(resolvedComponentPathsWithGitIgnore)) {
      componentPathsStats = validatePaths(resolvedComponentPathsWithGitIgnore);
    } else {
      throw new (_exceptions().NoFiles)(diff);
    }
    Object.keys(componentPathsStats).forEach(compPath => {
      if (!componentPathsStats[compPath].isDir) {
        throw new (_addingIndividualFiles().AddingIndividualFiles)(compPath);
      }
    });
    // if a user entered multiple paths and entered an id, he wants all these paths to be one component
    // conversely, if a user entered multiple paths without id, he wants each dir as an individual component
    const isMultipleComponents = Object.keys(componentPathsStats).length > 1 && !this.id;
    if (isMultipleComponents) {
      await this.addMultipleComponents(componentPathsStats);
    } else {
      _logger().default.debugAndAddBreadCrumb('add-components', 'adding one component');
      // when a user enters more than one directory, he would like to keep the directories names
      // so then when a component is imported, it will write the files into the original directories
      const addedOne = await this.addOneComponent(componentPathsStats);
      this._removeNamespaceIfNotNeeded([addedOne]);
      if (!(0, _isEmpty2().default)(addedOne.files)) {
        const addedResult = await this.addOrUpdateComponentInBitMap(addedOne);
        if (addedResult) this.addedComponents.push(addedResult);
      }
    }
    await this.linkComponents(this.addedComponents.map(item => item.id));
    _analytics().Analytics.setExtraData('num_components', this.addedComponents.length);
    return {
      addedComponents: this.addedComponents,
      warnings: this.warnings
    };
  }
  async linkComponents(ids) {
    if (this.trackDirFeature) {
      // if trackDirFeature is set, it happens during the component-load and because we load the
      // components in the next line, it gets into an infinite loop.
      return;
    }
    const {
      components
    } = await this.consumer.loadComponents(_bitId().BitIds.fromArray(ids));
    const nodeModuleLinker = new (_links().NodeModuleLinker)(components, this.consumer, this.consumer.bitMap);
    await nodeModuleLinker.link();
  }
  async addMultipleComponents(componentPathsStats) {
    _logger().default.debugAndAddBreadCrumb('add-components', 'adding multiple components');
    this._removeDirectoriesWhenTheirFilesAreAdded(componentPathsStats);
    const added = await this._tryAddingMultiple(componentPathsStats);
    validateNoDuplicateIds(added);
    this._removeNamespaceIfNotNeeded(added);
    await this._addMultipleToBitMap(added);
  }

  /**
   * some uses of wildcards might add directories and their files at the same time, in such cases
   * only the files are needed and the directories can be ignored.
   * @see https://github.com/teambit/bit/issues/1406 for more details
   */
  _removeDirectoriesWhenTheirFilesAreAdded(componentPathsStats) {
    const allPaths = Object.keys(componentPathsStats);
    allPaths.forEach(componentPath => {
      const foundDir = allPaths.find(p => p === path().dirname(componentPath));
      if (foundDir && componentPathsStats[foundDir]) {
        _logger().default.debug(`add-components._removeDirectoriesWhenTheirFilesAreAdded, ignoring ${foundDir}`);
        delete componentPathsStats[foundDir];
      }
    });
  }
  async _addMultipleToBitMap(added) {
    const missingMainFiles = [];
    await Promise.all(added.map(async component => {
      if (!(0, _isEmpty2().default)(component.files)) {
        try {
          const addedComponent = await this.addOrUpdateComponentInBitMap(component);
          if (addedComponent && addedComponent.files.length) this.addedComponents.push(addedComponent);
        } catch (err) {
          if (!(err instanceof _missingMainFile().default)) throw err;
          // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
          missingMainFiles.push(err);
        }
      }
    }));
    if (missingMainFiles.length) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      throw new (_missingMainFileMultipleComponents().default)(missingMainFiles.map(err => err.componentId).sort());
    }
  }
  _removeNamespaceIfNotNeeded(addedComponents) {
    const allIds = this.bitMap.getAllBitIdsFromAllLanes();
    addedComponents.forEach(addedComponent => {
      if (!addedComponent.idFromPath) return; // when the id was not generated from the path do nothing.
      const componentsWithSameName = addedComponents // $FlowFixMe
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      .filter(a => a.idFromPath && a.idFromPath.name === addedComponent.idFromPath.name);
      const bitIdFromNameOnly = new (_bitId().BitId)({
        name: addedComponent.idFromPath.name
      });
      const existingComponentWithSameName = allIds.searchWithoutScopeAndVersion(bitIdFromNameOnly);
      if (componentsWithSameName.length === 1 && !existingComponentWithSameName) {
        addedComponent.componentId = bitIdFromNameOnly;
      }
    });
  }
  async _tryAddingMultiple(componentPathsStats) {
    const addedP = Object.keys(componentPathsStats).map(async onePath => {
      const oneComponentPathStat = {
        [onePath]: componentPathsStats[onePath]
      };
      try {
        const addedComponent = await this.addOneComponent(oneComponentPathStat);
        return addedComponent;
      } catch (err) {
        if (!(err instanceof _exceptions().EmptyDirectory)) throw err;
        this.warnings.emptyDirectory.push(onePath);
        return null;
      }
    });
    const added = await Promise.all(addedP);
    return (0, _reject2().default)(_isNil2().default, added);
  }
  _throwForOutsideConsumer(relativeToConsumerPath) {
    if (relativeToConsumerPath.startsWith('..')) {
      throw new (_pathOutsideConsumer().default)(relativeToConsumerPath);
    }
  }
  throwForExistingParentDir(relativeToConsumerPath) {
    const isParentDir = parent => {
      const relative = path().relative(parent, relativeToConsumerPath);
      return relative && !relative.startsWith('..') && !path().isAbsolute(relative);
    };
    this.bitMap.components.forEach(componentMap => {
      if (!componentMap.rootDir) return;
      if (isParentDir(componentMap.rootDir)) {
        throw new (_parentDirTracked().ParentDirTracked)(componentMap.rootDir, componentMap.id.toStringWithoutVersion(), relativeToConsumerPath);
      }
    });
  }
}

/**
 * validatePaths - validate if paths entered by user exist and if not throw an error
 *
 * @param {string[]} fileArray - array of paths
 * @returns {PathsStats} componentPathsStats
 */
exports.default = AddComponents;
function validatePaths(fileArray) {
  const componentPathsStats = {};
  fileArray.forEach(componentPath => {
    if (!_fsExtra().default.existsSync(componentPath)) {
      throw new (_exceptions().PathsNotExist)([componentPath]);
    }
    componentPathsStats[componentPath] = {
      isDir: (0, _utils().isDir)(componentPath)
    };
  });
  return componentPathsStats;
}

/**
 * validate that no two files where added with the same id in the same bit add command
 */
function validateNoDuplicateIds(addComponents) {
  const duplicateIds = {};
  const newGroupedComponents = (0, _lodash2().default)(addComponents, 'componentId');
  Object.keys(newGroupedComponents).forEach(key => {
    if (newGroupedComponents[key].length > 1) duplicateIds[key] = newGroupedComponents[key];
  });
  if (!(0, _isEmpty2().default)(duplicateIds) && !(0, _isNil2().default)(duplicateIds)) throw new (_exceptions().DuplicateIds)(duplicateIds);
}
async function getFilesByDir(dir, consumerPath, gitIgnore) {
  const matches = await (0, _globby().default)(dir, {
    cwd: consumerPath,
    onlyFiles: true
  });
  if (!matches.length) throw new (_componentNotFoundInPath().default)(dir);
  const filteredMatches = gitIgnore.filter(matches);
  if (!filteredMatches.length) throw new (_ignoredDirectory().IgnoredDirectory)(dir);
  return filteredMatches.map(match => {
    const normalizedPath = (0, _utils().pathNormalizeToLinux)(match);
    // the path is relative to consumer. remove the rootDir.
    const relativePath = normalizedPath.replace(`${dir}/`, '');
    return {
      relativePath,
      test: false,
      name: path().basename(match)
    };
  });
}
function getGitIgnoreHarmony(consumerPath) {
  const ignoreList = getIgnoreListHarmony(consumerPath);
  return (0, _ignore().default)().add(ignoreList);
}
function getIgnoreListHarmony(consumerPath) {
  const ignoreList = (0, _utils().retrieveIgnoreList)(consumerPath);
  // the ability to track package.json is deprecated since Harmony
  ignoreList.push(_constants().PACKAGE_JSON);
  return ignoreList;
}