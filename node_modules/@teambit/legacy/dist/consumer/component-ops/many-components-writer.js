"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _composeComponentPath() {
  const data = require("../../utils/bit/compose-component-path");
  _composeComponentPath = function () {
    return data;
  };
  return data;
}
function _path2() {
  const data = require("../../utils/path");
  _path2 = function () {
    return data;
  };
  return data;
}
function _dataToPersist() {
  const data = _interopRequireDefault(require("../component/sources/data-to-persist"));
  _dataToPersist = function () {
    return data;
  };
  return data;
}
function _componentWriter() {
  const data = _interopRequireDefault(require("./component-writer"));
  _componentWriter = function () {
    return data;
  };
  return data;
}
function _moveComponents() {
  const data = require("./move-components");
  _moveComponents = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * write the components into '/components' dir (or according to the bit.map) and its dependencies in the
 * '/components/.dependencies' dir. Both directories are configurable in bit.json
 * For example: global/a has a dependency my-scope/global/b@1. The directories will be:
 * project/root/components/global/a/impl.js
 * project/root/components/.dependencies/global/b/my-scope/1/impl.js
 *
 * In case there are some same dependencies shared between the components, it makes sure to
 * write them only once.
 */
class ManyComponentsWriter {
  // prints npm results

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  constructor(params) {
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "componentsWithDependencies", void 0);
    (0, _defineProperty2().default)(this, "writeToPath", void 0);
    (0, _defineProperty2().default)(this, "override", void 0);
    (0, _defineProperty2().default)(this, "writeConfig", void 0);
    (0, _defineProperty2().default)(this, "installNpmPackages", void 0);
    (0, _defineProperty2().default)(this, "verbose", void 0);
    (0, _defineProperty2().default)(this, "dependenciesIdsCache", void 0);
    (0, _defineProperty2().default)(this, "writtenComponents", void 0);
    (0, _defineProperty2().default)(this, "writtenDependencies", void 0);
    (0, _defineProperty2().default)(this, "basePath", void 0);
    (0, _defineProperty2().default)(this, "resetConfig", void 0);
    this.consumer = params.consumer;
    this.componentsWithDependencies = params.componentsWithDependencies;
    this.writeToPath = params.writeToPath;
    this.override = this._setBooleanDefault(params.override, true);
    this.writeConfig = this._setBooleanDefault(params.writeConfig, false);
    this.installNpmPackages = this._setBooleanDefault(params.installNpmPackages, true);
    this.verbose = this._setBooleanDefault(params.verbose, false);
    this.dependenciesIdsCache = {};
    this.resetConfig = params.resetConfig;
    this.basePath = this.consumer.getPath();
  }
  static registerExternalInstaller(installer) {
    this.externalInstaller = installer;
  }
  _setBooleanDefault(field, defaultValue) {
    return typeof field === 'undefined' ? defaultValue : Boolean(field);
  }
  async writeAll() {
    await this._writeComponentsAndDependencies();
    await this._installPackages();
    _logger().default.debug('ManyComponentsWriter, Done!');
  }
  async _writeComponentsAndDependencies() {
    _logger().default.debug('ManyComponentsWriter, _writeComponentsAndDependencies');
    await this._populateComponentsFilesToWrite();
    this._moveComponentsIfNeeded();
    await this._persistComponentsData();
  }
  async _installPackages() {
    var _ManyComponentsWriter2;
    _logger().default.debug('ManyComponentsWriter, _installPackages');
    if (!this.installNpmPackages) {
      return;
    }
    try {
      var _ManyComponentsWriter;
      await ((_ManyComponentsWriter = ManyComponentsWriter.externalInstaller) === null || _ManyComponentsWriter === void 0 ? void 0 : _ManyComponentsWriter.install());
    } catch (err) {
      _logger().default.error('_installPackagesIfNeeded, external package-installer found an error', err);
      throw new (_bitError().BitError)(`failed installing the packages, consider running the command with "--skip-dependency-installation" flag.
error from the package-manager: ${err.message}.
please use the '--log=error' flag for the full error.`);
    }
    // this compiles all components on the workspace, not only the imported ones.
    // reason being is that the installed above deletes all dists dir of components that are somehow part of the
    // dependency graph. not only the imported components.
    await ((_ManyComponentsWriter2 = ManyComponentsWriter.externalCompiler) === null || _ManyComponentsWriter2 === void 0 ? void 0 : _ManyComponentsWriter2.call(ManyComponentsWriter));
  }
  async _persistComponentsData() {
    var _this$consumer, _this$consumer$config;
    const dataToPersist = new (_dataToPersist().default)();
    this.componentsWithDependencies.forEach(componentWithDeps => {
      const allComponents = [componentWithDeps.component, ...componentWithDeps.allDependencies];
      allComponents.forEach(component => dataToPersist.merge(component.dataToPersist));
    });
    const componentsConfig = (_this$consumer = this.consumer) === null || _this$consumer === void 0 ? void 0 : (_this$consumer$config = _this$consumer.config) === null || _this$consumer$config === void 0 ? void 0 : _this$consumer$config.componentsConfig;
    if (componentsConfig !== null && componentsConfig !== void 0 && componentsConfig.hasChanged) {
      var _this$consumer2;
      const jsonFiles = await ((_this$consumer2 = this.consumer) === null || _this$consumer2 === void 0 ? void 0 : _this$consumer2.config.toVinyl(this.consumer.getPath()));
      if (jsonFiles) {
        dataToPersist.addManyFiles(jsonFiles);
      }
    }
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    dataToPersist.addBasePath(this.basePath);
    await dataToPersist.persistAllToFS();
  }
  async _populateComponentsFilesToWrite() {
    const writeComponentsParams = this._getWriteComponentsParams();
    const componentWriterInstances = writeComponentsParams.map(writeParams => new (_componentWriter().default)(writeParams));
    this.fixDirsIfNested(componentWriterInstances);
    // add componentMap entries into .bitmap before starting the process because steps like writing package-json
    // rely on .bitmap to determine whether a dependency exists and what's its origin
    componentWriterInstances.forEach(componentWriter => {
      componentWriter.existingComponentMap = componentWriter.existingComponentMap || componentWriter.addComponentToBitMap(componentWriter.writeToPath);
    });
    if (this.resetConfig) {
      componentWriterInstances.forEach(componentWriter => {
        var _componentWriter$exis;
        (_componentWriter$exis = componentWriter.existingComponentMap) === null || _componentWriter$exis === void 0 ? true : delete _componentWriter$exis.config;
      });
    }
    this.writtenComponents = await (0, _pMapSeries().default)(componentWriterInstances, componentWriter => componentWriter.populateComponentsFilesToWrite());
  }

  /**
   * e.g. [bar, bar/foo] => [bar_1, bar/foo]
   * otherwise, the bar/foo component will be saved inside "bar" component.
   * in case bar_1 is taken, increment to bar_2 until the name is available.
   */
  fixDirsIfNested(componentWriterInstances) {
    const allDirs = componentWriterInstances.map(c => c.writeToPath);

    // get all components that their root-dir is a parent of other components root-dir.
    const parentsOfOthersComps = componentWriterInstances.filter(({
      writeToPath
    }) => allDirs.find(d => d.startsWith(`${writeToPath}/`)));
    if (!parentsOfOthersComps.length) {
      return;
    }
    const parentsOfOthersCompsDirs = parentsOfOthersComps.map(c => c.writeToPath);
    const incrementPath = (p, number) => `${p}_${number}`;
    const existingRootDirs = Object.keys(this.consumer.bitMap.getAllTrackDirs());
    const allPaths = [...existingRootDirs, ...parentsOfOthersCompsDirs];
    const incrementRecursively = p => {
      let num = 1;
      let newPath = incrementPath(p, num);
      while (allPaths.includes(newPath)) {
        newPath = incrementPath(p, num += 1);
      }
      return newPath;
    };

    // change the paths of all these parents root-dir to not collide with the children root-dir
    parentsOfOthersComps.forEach(componentWriter => {
      if (existingRootDirs.includes(componentWriter.writeToPath)) return; // component already exists.
      const newPath = incrementRecursively(componentWriter.writeToPath);
      componentWriter.writeToPath = newPath;
    });
  }
  _getWriteComponentsParams() {
    return this.componentsWithDependencies.map(componentWithDeps => this._getWriteParamsOfOneComponent(componentWithDeps));
  }
  _getWriteParamsOfOneComponent(componentWithDeps) {
    // for isolated components, the component files should be on the root. see #1758
    const componentRootDir = this._getComponentRootDir(componentWithDeps.component.id);
    const getParams = () => {
      if (!this.consumer) {
        return {};
      }
      // AUTHORED and IMPORTED components can't be saved with multiple versions, so we can ignore the version to
      // find the component in bit.map
      const componentMap = this.consumer.bitMap.getComponentIfExist(componentWithDeps.component.id, {
        ignoreVersion: true
      });
      // $FlowFixMe consumer is set here
      this._throwErrorWhenDirectoryNotEmpty(this.consumer.toAbsolutePath(componentRootDir), componentMap);
      return {
        existingComponentMap: componentMap
      };
    };
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return _objectSpread(_objectSpread({}, this._getDefaultWriteParams()), {}, {
      component: componentWithDeps.component,
      writeToPath: componentRootDir,
      writeConfig: this.writeConfig
    }, getParams());
  }
  _getDefaultWriteParams() {
    return {
      consumer: this.consumer,
      bitMap: this.consumer.bitMap
    };
  }
  _moveComponentsIfNeeded() {
    if (this.writeToPath && this.consumer) {
      this.componentsWithDependencies.forEach(componentWithDeps => {
        // @ts-ignore componentWithDeps.component.componentMap is set
        const componentMap = componentWithDeps.component.componentMap;
        if (!componentMap.rootDir) {
          throw new (_generalError().default)(`unable to use "--path" flag.
to move individual files, use bit move.
to move all component files to a different directory, run bit remove and then bit import --path`);
        }
        const relativeWrittenPath = componentWithDeps.component.writtenPath;
        // @ts-ignore relativeWrittenPath is set at this point
        const absoluteWrittenPath = this.consumer.toAbsolutePath(relativeWrittenPath);
        // @ts-ignore this.writeToPath is set at this point
        const absoluteWriteToPath = path().resolve(this.writeToPath); // don't use consumer.toAbsolutePath, it might be an inner dir
        if (relativeWrittenPath && absoluteWrittenPath !== absoluteWriteToPath) {
          const component = componentWithDeps.component;
          // @ts-ignore consumer is set here
          (0, _moveComponents().moveExistingComponent)(this.consumer, component, absoluteWrittenPath, absoluteWriteToPath);
        }
      });
    }
  }
  _getComponentRootDir(bitId) {
    if (this.consumer) {
      return this.writeToPath ? (0, _path2().pathNormalizeToLinux)(this.consumer.getPathRelativeToConsumer(path().resolve(this.writeToPath))) : this.consumer.composeRelativeComponentPath(bitId);
    }
    return (0, _composeComponentPath().composeComponentPath)(bitId);
  }
  _getDependencyRootDir(bitId) {
    return this.consumer.composeRelativeDependencyPath(bitId);
  }
  _throwErrorWhenDirectoryNotEmpty(componentDir, componentMap) {
    // if not writeToPath specified, it goes to the default directory. When componentMap exists, the
    // component is not new, and it's ok to override the existing directory.
    if (!this.writeToPath && componentMap) return;
    // if writeToPath specified and that directory is already used for that component, it's ok to override
    if (this.writeToPath && componentMap && componentMap.rootDir && componentMap.rootDir === this.writeToPath) return;
    if (_fsExtra().default.pathExistsSync(componentDir)) {
      if (!(0, _utils().isDir)(componentDir)) {
        throw new (_generalError().default)(`unable to import to ${componentDir} because it's a file`);
      }
      if (!(0, _utils().isDirEmptySync)(componentDir) && !this.override) {
        throw new (_generalError().default)(`unable to import to ${componentDir}, the directory is not empty. use --override flag to delete the directory and then import`);
      }
    }
  }
}
exports.default = ManyComponentsWriter;
(0, _defineProperty2().default)(ManyComponentsWriter, "externalInstaller", void 0);
(0, _defineProperty2().default)(ManyComponentsWriter, "externalCompiler", void 0);