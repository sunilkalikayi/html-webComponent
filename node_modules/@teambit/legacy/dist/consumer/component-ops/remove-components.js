"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeComponents;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _groupArray() {
  const data = _interopRequireDefault(require("group-array"));
  _groupArray = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = _interopRequireDefault(require("lodash.partition"));
  _lodash = function () {
    return data;
  };
  return data;
}
function _bitIds() {
  const data = _interopRequireDefault(require("../../bit-id/bit-ids"));
  _bitIds = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _enrichContextFromGlobal() {
  const data = _interopRequireDefault(require("../../hooks/utils/enrich-context-from-global"));
  _enrichContextFromGlobal = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _remotes() {
  const data = require("../../remotes");
  _remotes = function () {
    return data;
  };
  return data;
}
function _removedLocalObjects() {
  const data = _interopRequireDefault(require("../../scope/removed-local-objects"));
  _removedLocalObjects = function () {
    return data;
  };
  return data;
}
function _scopeRemotes() {
  const data = require("../../scope/scope-remotes");
  _scopeRemotes = function () {
    return data;
  };
  return data;
}
function _deleteComponentFiles() {
  const data = _interopRequireDefault(require("../component-ops/delete-component-files"));
  _deleteComponentFiles = function () {
    return data;
  };
  return data;
}
function _componentsList() {
  const data = _interopRequireDefault(require("../component/components-list"));
  _componentsList = function () {
    return data;
  };
  return data;
}
function _consumerComponent() {
  const data = _interopRequireDefault(require("../component/consumer-component"));
  _consumerComponent = function () {
    return data;
  };
  return data;
}
function packageJsonUtils() {
  const data = _interopRequireWildcard(require("../component/package-json-utils"));
  packageJsonUtils = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Remove components local and remote
 * splits array of ids into local and remote and removes according to flags
 * @param {string[]} ids - list of remote component ids to delete
 * @param {boolean} force - delete component that are used by other components.
 * @param {boolean} remote - delete component from a remote scope
 * @param {boolean} track - keep tracking local staged components in bitmap.
 * @param {boolean} deleteFiles - delete local added files from fs.
 */
async function removeComponents({
  consumer,
  ids,
  force,
  remote,
  track,
  deleteFiles,
  fromLane
}) {
  _logger().default.debugAndAddBreadCrumb('removeComponents', `{ids}. force: ${force.toString()}`, {
    ids: ids.toString()
  });
  // added this to remove support for remove only one version from a component
  const bitIdsLatest = _bitIds().default.fromArray(ids.map(id => {
    return id.changeVersion(_constants().LATEST_BIT_VERSION);
  }));
  const [localIds, remoteIds] = (0, _lodash().default)(bitIdsLatest, id => id.isLocal());
  if (remote && localIds.length) {
    throw new (_generalError().default)(`unable to remove the remote components: ${localIds.join(',')} as they don't contain a scope-name`);
  }
  const remoteResult = remote && !(0, _isEmpty2().default)(remoteIds) ? await removeRemote(consumer, remoteIds, force) : [];
  const localResult = !remote ? await removeLocal(consumer, bitIdsLatest, force, track, deleteFiles, fromLane) : new (_removedLocalObjects().default)();
  return {
    localResult,
    remoteResult
  };
}

/**
 * Remove remote component from ssh server
 * this method groups remote components by remote name and deletes remote components together
 * @param {BitIds} bitIds - list of remote component ids to delete
 * @param {boolean} force - delete component that are used by other components.
 */
async function removeRemote(consumer, bitIds, force) {
  const groupedBitsByScope = (0, _groupArray().default)(bitIds, 'scope');
  const remotes = consumer ? await (0, _scopeRemotes().getScopeRemotes)(consumer.scope) : await _remotes().Remotes.getGlobalRemotes();
  const context = {};
  (0, _enrichContextFromGlobal().default)(context);
  const removeP = Object.keys(groupedBitsByScope).map(async key => {
    const resolvedRemote = await remotes.resolve(key, consumer === null || consumer === void 0 ? void 0 : consumer.scope);
    const idsStr = groupedBitsByScope[key].map(id => id.toStringWithoutVersion());
    return resolvedRemote.deleteMany(idsStr, force, context);
  });
  return Promise.all(removeP);
}

/**
 * removeLocal - remove local (imported, new staged components) from modules and bitmap according to flags
 * @param {BitIds} bitIds - list of component ids to delete
 * @param {boolean} force - delete component that are used by other components.
 * @param {boolean} deleteFiles - delete component that are used by other components.
 */
async function removeLocal(consumer, bitIds, force, track, deleteFiles, fromLane) {
  // local remove in case user wants to delete tagged components
  const modifiedComponents = new (_bitIds().default)();
  const nonModifiedComponents = new (_bitIds().default)(); // $FlowFixMe
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  if ((0, _isEmpty2().default)(bitIds)) return new (_removedLocalObjects().default)();
  if (!force) {
    await Promise.all(bitIds.map(async id => {
      try {
        const componentStatus = await consumer.getComponentStatusById(id);
        if (componentStatus.modified) modifiedComponents.push(id);else nonModifiedComponents.push(id);
      } catch (err) {
        // if a component has an error, such as, missing main file, we do want to allow removing that component
        if (_consumerComponent().default.isComponentInvalidByErrorType(err)) {
          nonModifiedComponents.push(id);
        } else {
          throw err;
        }
      }
    }));
  }
  const idsToRemove = force ? bitIds : nonModifiedComponents;
  const componentsList = new (_componentsList().default)(consumer);
  const newComponents = await componentsList.listNewComponents(false);
  const idsToRemoveFromScope = _bitIds().default.fromArray(idsToRemove.filter(id => !newComponents.hasWithoutScopeAndVersion(id)));
  const idsToCleanFromWorkspace = _bitIds().default.fromArray(idsToRemove.filter(id => newComponents.hasWithoutScopeAndVersion(id)));
  const {
    components: componentsToRemove,
    invalidComponents
  } = await consumer.loadComponents(idsToRemove, false);
  const {
    removedComponentIds,
    missingComponents,
    dependentBits,
    removedFromLane
  } = await consumer.scope.removeMany(idsToRemoveFromScope, force, consumer, fromLane);
  // otherwise, components should still be in .bitmap file
  idsToCleanFromWorkspace.push(...removedComponentIds);
  if (idsToCleanFromWorkspace.length) {
    if (deleteFiles) await (0, _deleteComponentFiles().default)(consumer, idsToCleanFromWorkspace);
    if (!track) {
      const invalidComponentsIds = invalidComponents.map(i => i.id);
      const removedComponents = componentsToRemove.filter(c => idsToCleanFromWorkspace.hasWithoutVersion(c.id));
      await packageJsonUtils().removeComponentsFromWorkspacesAndDependencies(consumer, removedComponents, invalidComponentsIds);
      await consumer.cleanFromBitMap(idsToCleanFromWorkspace);
    }
  }
  if (removedFromLane.length) {
    await consumer.cleanOrRevertFromBitMapWhenOnLane(removedFromLane);
  }
  return new (_removedLocalObjects().default)(_bitIds().default.uniqFromArray([...idsToCleanFromWorkspace, ...removedComponentIds]), missingComponents, modifiedComponents, dependentBits, removedFromLane);
}