"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.changeCodeFromRelativeToModulePaths = changeCodeFromRelativeToModulePaths;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _componentIssues() {
  const data = require("@teambit/component-issues");
  _componentIssues = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("../../utils/bit/component-id-to-package-name"));
  _componentIdToPackageName = function () {
    return data;
  };
  return data;
}
function _replacePackageName() {
  const data = _interopRequireDefault(require("../../utils/string/replace-package-name"));
  _replacePackageName = function () {
    return data;
  };
  return data;
}
function _dataToPersist() {
  const data = _interopRequireDefault(require("../component/sources/data-to-persist"));
  _dataToPersist = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
async function changeCodeFromRelativeToModulePaths(consumer, bitIds) {
  const components = await loadComponents(consumer, bitIds);
  const componentsWithRelativeIssues = components.filter(c => c.issues && c.issues.getIssue(_componentIssues().IssuesClasses.RelativeComponentsAuthored));
  const dataToPersist = new (_dataToPersist().default)();
  const codemodResults = await Promise.all(componentsWithRelativeIssues.map(async component => {
    const {
      files,
      warnings
    } = await codemodComponent(consumer, component);
    dataToPersist.addManyFiles(files);
    return {
      id: component.id,
      changedFiles: files.map(f => f.relative),
      warnings
    };
  }));
  await dataToPersist.persistAllToFS();
  const idsToReload = codemodResults.filter(c => !c.warnings || c.warnings.length === 0).map(c => c.id);
  await reloadComponents(consumer, idsToReload);
  return codemodResults.filter(c => c.changedFiles.length || c.warnings);
}
async function reloadComponents(consumer, bitIds) {
  consumer.clearCache();
  if (!bitIds.length) return;
  const components = await loadComponents(consumer, bitIds);
  const componentsWithRelativeIssues = components.filter(c => c.issues && c.issues.getIssue(_componentIssues().IssuesClasses.RelativeComponentsAuthored));
  if (componentsWithRelativeIssues.length) {
    const failedComps = componentsWithRelativeIssues.map(c => c.id.toString()).join(', ');
    throw new Error(`failed rewiring the following components: ${failedComps}`);
  }
}
async function loadComponents(consumer, bitIds) {
  const componentsIds = bitIds.length ? _bitId().BitIds.fromArray(bitIds) : consumer.bitmapIdsFromCurrentLane;
  const {
    components
  } = await consumer.loadComponents(componentsIds);
  return components;
}
async function codemodComponent(consumer, component) {
  const issues = component.issues;
  const files = [];
  if (!issues || !issues.getIssue(_componentIssues().IssuesClasses.RelativeComponentsAuthored)) return {
    files
  };
  const warnings = [];
  await Promise.all(component.files.map(async file => {
    var _issues$getIssue;
    const relativeInstances = (_issues$getIssue = issues.getIssue(_componentIssues().IssuesClasses.RelativeComponentsAuthored)) === null || _issues$getIssue === void 0 ? void 0 : _issues$getIssue.data[(0, _utils().pathNormalizeToLinux)(file.relative)];
    if (!relativeInstances) return;
    // @ts-ignore
    const fileBefore = file.contents.toString();
    let newFileString = fileBefore;
    await Promise.all(relativeInstances.map(async relativeEntry => {
      const id = relativeEntry.componentId;
      if (isLinkFileHasDifferentImportType(relativeEntry.relativePath.importSpecifiers)) {
        warnings.push(`"${file.relative}" requires "${id.toString()}" through a link-file ("${relativeEntry.importSource}") and not directly, which makes it difficult change the import, please change your code to require the component directly`);
        return;
      }
      const requiredComponent = await consumer.loadComponent(id);
      const packageName = (0, _componentIdToPackageName().default)(_objectSpread(_objectSpread({}, requiredComponent), {}, {
        id
      }));
      const cssFamily = ['.css', '.scss', '.less', '.sass'];
      const isCss = cssFamily.includes(file.extname);
      const packageNameSupportCss = isCss ? `~${packageName}` : packageName;
      const stringToReplace = getNameWithoutInternalPath(consumer, relativeEntry);
      // @todo: the "dist" should be replaced by the compiler dist-dir.
      // newFileString = replacePackageName(newFileString, stringToReplace, packageNameSupportCss, 'dist');
      newFileString = (0, _replacePackageName().default)(newFileString, stringToReplace, packageNameSupportCss);
    }));
    if (fileBefore !== newFileString) {
      // @ts-ignore
      file.contents = Buffer.from(newFileString);
      files.push(file);
    }
  }));
  return {
    files,
    warnings
  };
}

/**
 * e.g.
 * importSource: '../workspace/workspace.ui'
 * sourceRelativePath: 'extensions/workspace/workspace.ui.tsx'
 * rootDir in .bitmap: 'extensions/workspace'.
 *
 * expected to return "../workspace", as this is the path to the package root without the internal path.
 *
 * eventually, only this string is replaced by the new package-name and the internal-path part
 * remains intact. ('../workspace/workspace.ui' => '@bit/workspace/workspace.ui').
 */
function getNameWithoutInternalPath(consumer, relativeEntry) {
  const importSource = relativeEntry.importSource;
  const componentMap = consumer.bitMap.getComponentIfExist(relativeEntry.componentId);
  if (!componentMap) return importSource;
  const rootDir = componentMap.rootDir;
  if (!rootDir) return importSource;
  const mainFile = componentMap.trackDir ? componentMap.mainFile : (0, _utils().pathJoinLinux)(rootDir, componentMap.mainFile);
  const filePathRelativeToWorkspace = relativeEntry.relativePath.sourceRelativePath;
  if (filePathRelativeToWorkspace === mainFile) {
    return importSource;
  }
  // the importSource is not the main-file but an internal file, remove the internal part.
  const internalPath = (0, _utils().pathRelativeLinux)(rootDir, filePathRelativeToWorkspace);
  const removeLastOccurrence = (str, toRemove) => str.replace(new RegExp(`/${toRemove}$`), '');
  if (importSource.endsWith(internalPath)) {
    return removeLastOccurrence(importSource, internalPath);
  }
  const internalPathNoExt = internalPath.replace(_path().default.extname(internalPath), '');
  if (importSource.endsWith(internalPathNoExt)) {
    return removeLastOccurrence(importSource, internalPathNoExt);
  }
  const internalPathNoIndex = removeLastOccurrence(internalPathNoExt, 'index');
  if (importSource.endsWith(internalPathNoIndex)) {
    return removeLastOccurrence(importSource, internalPathNoIndex);
  }

  // unable to find anything useful. just return the importSource.
  return importSource;
}

/**
 * if this is a link-file (a file that only import and export other files), bit doesn't require
 * the user to track it and it knows to skip it. If however, the link file uses default import and
 * the real file uses non-default, or vice versa, the codemod will result in an incorrect import
 * statement, and won't work.
 */
function isLinkFileHasDifferentImportType(importSpecifiers) {
  if (!importSpecifiers) return false;
  return importSpecifiers.some(importSpecifier => {
    if (!importSpecifier.linkFile) return false;
    return importSpecifier.linkFile.isDefault !== importSpecifier.mainFile.isDefault;
  });
}