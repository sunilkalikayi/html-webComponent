"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _defaultErrorHandler() {
  const data = _interopRequireDefault(require("../../cli/default-error-handler"));
  _defaultErrorHandler = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _installPackages() {
  const data = require("../../npm-client/install-packages");
  _installPackages = function () {
    return data;
  };
  return data;
}
function _scopeGraph() {
  const data = _interopRequireDefault(require("../../scope/graph/scope-graph"));
  _scopeGraph = function () {
    return data;
  };
  return data;
}
function _scopeRemotes() {
  const data = require("../../scope/scope-remotes");
  _scopeRemotes = function () {
    return data;
  };
  return data;
}
function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("../../utils/bit/component-id-to-package-name"));
  _componentIdToPackageName = function () {
    return data;
  };
  return data;
}
function _packageJsonFile() {
  const data = _interopRequireDefault(require("../component/package-json-file"));
  _packageJsonFile = function () {
    return data;
  };
  return data;
}
function packageJsonUtils() {
  const data = _interopRequireWildcard(require("../component/package-json-utils"));
  packageJsonUtils = function () {
    return data;
  };
  return data;
}
function _deleteComponentFiles() {
  const data = _interopRequireDefault(require("./delete-component-files"));
  _deleteComponentFiles = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class EjectComponents {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // for rollback in case of errors
  constructor(consumer, componentsIds, force) {
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "componentsIds", void 0);
    (0, _defineProperty2().default)(this, "force", void 0);
    (0, _defineProperty2().default)(this, "idsToEject", void 0);
    (0, _defineProperty2().default)(this, "componentsToEject", []);
    (0, _defineProperty2().default)(this, "notEjectedDependents", void 0);
    (0, _defineProperty2().default)(this, "failedComponents", void 0);
    (0, _defineProperty2().default)(this, "packageJsonFilesBeforeChanges", void 0);
    this.consumer = consumer;
    this.componentsIds = componentsIds;
    this.force = force || false;
    this.idsToEject = new (_bitId().BitIds)();
    this.failedComponents = {
      modifiedComponents: new (_bitId().BitIds)(),
      stagedComponents: new (_bitId().BitIds)(),
      notExportedComponents: new (_bitId().BitIds)(),
      selfHostedExportedComponents: new (_bitId().BitIds)()
    };
  }
  async eject() {
    await this.decideWhichComponentsToEject();
    _logger().default.debugAndAddBreadCrumb('eject-components.eject', `${this.idsToEject.length} to eject`);
    await this.loadComponentsToEject();
    if (this.idsToEject.length) {
      this._validateIdsHaveScopesAndVersions();
      await this.findNonEjectedDependents();
      await this.loadPackageJsonFilesForPotentialRollBack();
      await this.removeComponentsFromPackageJsonAndNodeModules();
      await this.addComponentsAsPackagesToPackageJsonFiles();
      await this.installPackagesUsingNPMClient();
      await this.removeComponents();
    }
    _logger().default.debug('eject: completed successfully');
    return {
      ejectedComponents: this.idsToEject,
      failedComponents: this.failedComponents
    };
  }

  /**
   * needed for update their package.json later with the dependencies version (instead of the
   * relative paths)
   */
  async findNonEjectedDependents() {
    // this also loads all non-nested components into the memory, so retrieving them later is at no cost
    const graph = await _scopeGraph().default.buildGraphFromCurrentlyUsedComponents(this.consumer);
    const scopeGraph = new (_scopeGraph().default)(graph);
    const notEjectedData = [];
    this.idsToEject.forEach(componentId => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const dependents = scopeGraph.getImmediateDependentsPerId(componentId, true);
      const notEjectedDependents = dependents.filter(d => !this.idsToEject.hasWithoutScopeAndVersion(d));
      notEjectedDependents.forEach(dependentId => {
        const foundInNotEjectedData = notEjectedData.find(d => d.id.isEqual(dependentId));
        if (foundInNotEjectedData) foundInNotEjectedData.dependencies.push(componentId);else notEjectedData.push({
          id: dependentId,
          dependencies: [componentId]
        });
      });
    });
    const notEjectedComponentsDataP = notEjectedData.map(async notEjectedItem => {
      const dependent = await this.consumer.loadComponent(notEjectedItem.id);
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const {
        components: ejectedDependencies
      } = await this.consumer.loadComponents(notEjectedItem.dependencies);
      return {
        dependent,
        ejectedDependencies
      };
    });
    const notEjectedComponentsData = await Promise.all(notEjectedComponentsDataP);
    this.notEjectedDependents = notEjectedComponentsData.filter(d => d.dependent.packageJsonFile);
  }
  async loadPackageJsonFilesForPotentialRollBack() {
    const rootPackageJson = await _packageJsonFile().default.load(this.consumer.getPath());
    this.packageJsonFilesBeforeChanges = [rootPackageJson];
    this.notEjectedDependents.forEach(({
      dependent
    }) => {
      // $FlowFixMe notEjectedDependents has only dependents with packageJsonFile
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      this.packageJsonFilesBeforeChanges.push(dependent.packageJsonFile.clone());
    });
  }
  async decideWhichComponentsToEject() {
    _logger().default.debug('eject: getting the components status');
    if ((0, _isEmpty2().default)(this.componentsIds)) return;
    const remotes = await (0, _scopeRemotes().getScopeRemotes)(this.consumer.scope);
    const hubExportedComponents = new (_bitId().BitIds)();
    this.componentsIds.forEach(bitId => {
      if (!bitId.hasScope()) this.failedComponents.notExportedComponents.push(bitId);else if (remotes.isHub(bitId.scope)) hubExportedComponents.push(bitId);else this.failedComponents.selfHostedExportedComponents.push(bitId);
    });
    if (this.force) {
      this.idsToEject = hubExportedComponents;
    } else {
      await Promise.all(hubExportedComponents.map(async id => {
        try {
          const componentStatus = await this.consumer.getComponentStatusById(id);
          if (componentStatus.modified) this.failedComponents.modifiedComponents.push(id);else if (componentStatus.staged) this.failedComponents.stagedComponents.push(id);else this.idsToEject.push(id);
        } catch (err) {
          this.throwEjectError(`eject operation failed getting the status of ${id.toString()}, no action has been done.
            please fix the issue to continue.`, err);
        }
      }));
    }
  }
  async loadComponentsToEject() {
    const {
      components
    } = await this.consumer.loadComponents(this.idsToEject);
    this.componentsToEject = components;
  }
  async removeComponentsFromPackageJsonAndNodeModules() {
    const action = 'removing the existing components from package.json and node_modules';
    try {
      _logger().default.debugAndAddBreadCrumb('eject', action);
      await packageJsonUtils().removeComponentsFromWorkspacesAndDependencies(this.consumer, this.componentsToEject);
    } catch (err) {
      _logger().default.warn(`eject: failed ${action}, restoring package.json`);
      await this.rollBack(action);
      this.throwEjectError(this._buildExceptionMessageWithRollbackData(action), err);
    }
  }
  async addComponentsAsPackagesToPackageJsonFiles() {
    const action = 'adding the components as packages into package.json';
    try {
      _logger().default.debugAndAddBreadCrumb('eject', action);
      await packageJsonUtils().addComponentsWithVersionToRoot(this.consumer, this.componentsToEject);
      this.notEjectedDependents.forEach(({
        dependent,
        ejectedDependencies
      }) => {
        const dependenciesToReplace = ejectedDependencies.reduce((acc, dependency) => {
          const packageName = (0, _componentIdToPackageName().default)(dependency);
          acc[packageName] = dependency.version;
          return acc;
        }, {});
        // $FlowFixMe notEjectedDependents has only dependents with packageJsonFile
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        dependent.packageJsonFile.replaceDependencies(dependenciesToReplace);
      });
      // $FlowFixMe notEjectedDependents has only dependents with packageJsonFile
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      await Promise.all(this.notEjectedDependents.map(({
        dependent
      }) => dependent.packageJsonFile.write()));
    } catch (err) {
      _logger().default.error(`eject: failed ${action}, restoring package.json`, err);
      await this.rollBack(action);
      this.throwEjectError(this._buildExceptionMessageWithRollbackData(action), err);
    }
  }
  async installPackagesUsingNPMClient() {
    const action = 'installing the components using the NPM client';
    try {
      _logger().default.debugAndAddBreadCrumb('eject', action);
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const dirs = this.notEjectedDependents // $FlowFixMe componentMap must be set for authored and imported
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      .map(({
        dependent
      }) => dependent.componentMap.rootDir).filter(x => x);
      await (0, _installPackages().installPackages)(this.consumer, dirs, true, true);
    } catch (err) {
      await this.rollBack(action);
      this.throwEjectError(this._buildExceptionMessageWithRollbackData(action), err);
    }
  }
  async rollBack(action) {
    await Promise.all(this.packageJsonFilesBeforeChanges.map(async packageJsonFile => {
      if (packageJsonFile.fileExist) {
        _logger().default.warn(`eject: failed ${action}, restoring package.json at ${packageJsonFile.filePath}`);
        await packageJsonFile.write();
      } else {
        _logger().default.warn(`eject: failed ${action}, no package.json to restore at ${packageJsonFile.filePath}`);
      }
    }));
  }
  _buildExceptionMessageWithRollbackData(action) {
    return `eject failed ${action}.
your package.json (if existed) has been restored, however, some bit generated data may have been deleted, please run "bit link" to restore them.`;
  }
  async removeComponents() {
    try {
      _logger().default.debug('eject: removing the components files from the filesystem');
      await this.removeLocalComponents();
    } catch (err) {
      this.throwEjectError(`eject operation has installed your components successfully using the NPM client.
however, it failed removing the old components from the filesystem.
please use bit remove command to remove them.`, err);
    }
  }

  /**
   * as part of the 'eject' operation, a component is removed locally. as opposed to the remove
   * command, in this case, no need to remove the objects from the scope, only remove from the
   * filesystem, which means, delete the component files, untrack from .bitmap and clean
   * package.json and bit.json traces.
   */
  async removeLocalComponents() {
    // @todo: what about the dependencies? if they are getting deleted we have to make sure they
    // not used anywhere else. Because this is part of the eject operation, the user probably
    // gets the dependencies as npm packages so we don't need to worry much about have extra
    // dependencies on the filesystem
    await (0, _deleteComponentFiles().default)(this.consumer, this.idsToEject);
    await this.consumer.cleanFromBitMap(this.idsToEject);
  }
  throwEjectError(message, originalError) {
    const {
      message: originalErrorMessage
    } = (0, _defaultErrorHandler().default)(originalError);
    _logger().default.error(`eject has stopped due to an error ${originalErrorMessage}`, originalError);
    throw new Error(`${message}

got the following error: ${originalErrorMessage}`);
  }
  _validateIdsHaveScopesAndVersions() {
    this.idsToEject.forEach(id => {
      if (!id.hasScope() || !id.hasVersion()) {
        throw new TypeError(`EjectComponents expects ids with scope and version, got ${id.toString()}`);
      }
    });
  }
}
exports.default = EjectComponents;