"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));
  _showDoctorError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _componentNodeModulesPath() {
  const data = _interopRequireDefault(require("../../utils/bit/component-node-modules-path"));
  _componentNodeModulesPath = function () {
    return data;
  };
  return data;
}
function _path2() {
  const data = require("../../utils/path");
  _path2 = function () {
    return data;
  };
  return data;
}
function _dataToPersist() {
  const data = _interopRequireDefault(require("../component/sources/data-to-persist"));
  _dataToPersist = function () {
    return data;
  };
  return data;
}
function _removePath() {
  const data = _interopRequireDefault(require("../component/sources/remove-path"));
  _removePath = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class ComponentWriter {
  // default to true

  // when using capsule, the consumer is not defined

  constructor({
    component,
    writeToPath,
    writeConfig = false,
    writePackageJson = true,
    override = true,
    isolated = false,
    consumer,
    scope = consumer === null || consumer === void 0 ? void 0 : consumer.scope,
    bitMap,
    ignoreBitDependencies = true,
    deleteBitDirContent,
    existingComponentMap
  }) {
    (0, _defineProperty2().default)(this, "component", void 0);
    (0, _defineProperty2().default)(this, "writeToPath", void 0);
    (0, _defineProperty2().default)(this, "writeConfig", void 0);
    (0, _defineProperty2().default)(this, "writePackageJson", void 0);
    (0, _defineProperty2().default)(this, "override", void 0);
    (0, _defineProperty2().default)(this, "isolated", void 0);
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "bitMap", void 0);
    (0, _defineProperty2().default)(this, "ignoreBitDependencies", void 0);
    (0, _defineProperty2().default)(this, "deleteBitDirContent", void 0);
    (0, _defineProperty2().default)(this, "existingComponentMap", void 0);
    this.component = component;
    this.writeToPath = writeToPath;
    this.writeConfig = writeConfig;
    this.writePackageJson = writePackageJson;
    this.override = override;
    this.isolated = isolated;
    this.consumer = consumer;
    this.scope = scope;
    this.bitMap = bitMap;
    this.ignoreBitDependencies = ignoreBitDependencies;
    this.deleteBitDirContent = deleteBitDirContent;
    this.existingComponentMap = existingComponentMap;
  }

  /**
   * write the component to the filesystem and update .bitmap with the details.
   *
   * bitMap gets updated before writing the files to the filesystem, because as part of writing the
   * package-json file, the componentMap is needed to be stored with the updated version.
   *
   * when a component is not new, write the files according to the paths in .bitmap.
   */
  async write() {
    if (!this.consumer) throw new Error('ComponentWriter.write expect to have a consumer');
    await this.populateComponentsFilesToWrite();
    this.component.dataToPersist.addBasePath(this.consumer.getPath());
    await this.component.dataToPersist.persistAllToFS();
    return this.component;
  }
  async populateComponentsFilesToWrite() {
    if (this.isolated) throw new Error('for isolation, please use this.populateComponentsFilesToWriteForCapsule()');
    if (!this.component.files || !this.component.files.length) {
      throw new (_showDoctorError().default)(`Component ${this.component.id.toString()} is invalid as it has no files`);
    }
    this.throwForImportingLegacyIntoHarmony();
    this.component.dataToPersist = new (_dataToPersist().default)();
    this._updateFilesBasePaths();
    this.component.componentMap = this.existingComponentMap || this.addComponentToBitMap(this.writeToPath);
    this.deleteBitDirContent = false;
    this._updateComponentRootPathAccordingToBitMap();
    this.component.componentMap = this.addComponentToBitMap(this.component.componentMap.rootDir);
    this.writePackageJson = false;
    await this.populateFilesToWriteToComponentDir();
    return this.component;
  }
  throwForImportingLegacyIntoHarmony() {
    if (this.component.isLegacy && this.consumer) {
      throw new Error(`unable to write component "${this.component.id.toString()}", it is a legacy component and this workspace is Harmony`);
    }
  }
  async populateFilesToWriteToComponentDir() {
    if (this.deleteBitDirContent) {
      this.component.dataToPersist.removePath(new (_removePath().default)(this.writeToPath));
    }
    this.component.files.forEach(file => file.override = this.override);
    this.component.files.map(file => this.component.dataToPersist.addFile(file));

    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (this.component.license && this.component.license.contents) {
      this.component.license.updatePaths({
        newBase: this.writeToPath
      });
      // $FlowFixMe this.component.license is set
      this.component.license.override = this.override;
      // $FlowFixMe this.component.license is set
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      this.component.dataToPersist.addFile(this.component.license);
    }
  }
  addComponentToBitMap(rootDir) {
    if (rootDir === '.') {
      throw new Error('addComponentToBitMap: rootDir cannot be "."');
    }
    const filesForBitMap = this.component.files.map(file => {
      return {
        name: file.basename,
        relativePath: (0, _path2().pathNormalizeToLinux)(file.relative),
        test: file.test
      };
    });
    return this.bitMap.addComponent({
      componentId: this.component.id,
      files: filesForBitMap,
      mainFile: (0, _path2().pathNormalizeToLinux)(this.component.mainFile),
      rootDir
    });
  }
  _updateComponentRootPathAccordingToBitMap() {
    // @ts-ignore this.component.componentMap is set
    this.writeToPath = this.component.componentMap.getRootDir();
    this.component.writtenPath = this.writeToPath;
    this._updateFilesBasePaths();
  }
  _updateFilesBasePaths() {
    const newBase = this.writeToPath || '.';
    this.component.files.forEach(file => file.updatePaths({
      newBase
    }));
  }
  async _cleanOldNestedComponent() {
    if (!this.consumer) throw new Error('ComponentWriter._cleanOldNestedComponent expect to have a consumer');
    // @ts-ignore this function gets called when it was previously NESTED, so the rootDir is set
    const oldLocation = path().join(this.consumer.getPath(), this.component.componentMap.rootDir);
    _logger().default.debugAndAddBreadCrumb('component-writer._cleanOldNestedComponent', 'deleting the old directory of a component at {oldLocation}', {
      oldLocation
    });
    await _fsExtra().default.remove(oldLocation);
    await this._removeNodeModulesLinksFromDependents();
    this.bitMap.removeComponent(this.component.id);
  }
  async _removeNodeModulesLinksFromDependents() {
    if (!this.consumer) {
      throw new Error('ComponentWriter._removeNodeModulesLinksFromDependents expect to have a consumer');
    }
    const directDependentIds = await this.consumer.getAuthoredAndImportedDependentsIdsOf([this.component]);
    await Promise.all(directDependentIds.map(dependentId => {
      const dependentComponentMap = this.consumer ? this.consumer.bitMap.getComponent(dependentId) : null;
      const relativeLinkPath = this.consumer ? (0, _componentNodeModulesPath().default)(this.component) : null;
      const nodeModulesLinkAbs = this.consumer && dependentComponentMap && relativeLinkPath ? this.consumer.toAbsolutePath(path().join(dependentComponentMap.getRootDir(), relativeLinkPath)) : null;
      if (nodeModulesLinkAbs) {
        _logger().default.debug(`deleting an obsolete link to node_modules at ${nodeModulesLinkAbs}`);
      }
      return nodeModulesLinkAbs ? _fsExtra().default.remove(nodeModulesLinkAbs) : Promise.resolve();
    }));
  }
}
exports.default = ComponentWriter;