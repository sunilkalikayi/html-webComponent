"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ComponentStatusLoader = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));
  _showDoctorError = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("../bit-map/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _componentsPendingImport() {
  const data = _interopRequireDefault(require("../component-ops/exceptions/components-pending-import"));
  _componentsPendingImport = function () {
    return data;
  };
  return data;
}
function _componentNotFoundInPath() {
  const data = _interopRequireDefault(require("../component/exceptions/component-not-found-in-path"));
  _componentNotFoundInPath = function () {
    return data;
  };
  return data;
}
function _missingFilesFromComponent() {
  const data = _interopRequireDefault(require("../component/exceptions/missing-files-from-component"));
  _missingFilesFromComponent = function () {
    return data;
  };
  return data;
}
function _componentOutOfSync() {
  const data = _interopRequireDefault(require("../exceptions/component-out-of-sync"));
  _componentOutOfSync = function () {
    return data;
  };
  return data;
}
class ComponentStatusLoader {
  // cache loaded components
  constructor(consumer) {
    this.consumer = consumer;
    (0, _defineProperty2().default)(this, "_componentsStatusCache", {});
  }
  async getManyComponentsStatuses(ids) {
    const results = [];
    await (0, _pMapSeries().default)(ids, async id => {
      const status = await this.getComponentStatusById(id);
      results.push({
        id,
        status
      });
    });
    return results;
  }

  /**
   * Get a component status by ID. Return a ComponentStatus object.
   * Keep in mind that a result can be a partial object of ComponentStatus, e.g. { notExist: true }.
   * Each one of the ComponentStatus properties can be undefined, true or false.
   * As a result, in order to check whether a component is not modified use (status.modified === false).
   * Don't use (!status.modified) because a component may not exist and the status.modified will be undefined.
   *
   * The status may have 'true' for several properties. For example, a component can be staged and modified at the
   * same time.
   *
   * The result is cached per ID and can be called several times with no penalties.
   */
  async getComponentStatusById(id) {
    if (!this._componentsStatusCache[id.toString()]) {
      this._componentsStatusCache[id.toString()] = await this.getStatus(id);
    }
    return this._componentsStatusCache[id.toString()];
  }
  async getStatus(id) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const status = {};
    const componentFromModel = await this.consumer.scope.getModelComponentIfExist(id);
    let componentFromFileSystem;
    try {
      // change to 'latest' before loading from FS. don't change to null, otherwise, it'll cause
      // loadOne to not find model component as it assumes there is no version
      // also, don't leave the id as is, otherwise, it'll cause issues with import --merge, when
      // imported version is bigger than .bitmap, it won't find it and will consider as deleted
      componentFromFileSystem = await this.consumer.loadComponent(id.changeVersion(_constants().LATEST));
    } catch (err) {
      if (err instanceof _missingFilesFromComponent().default || err instanceof _componentNotFoundInPath().default || err instanceof _exceptions().MissingBitMapComponent) {
        // the file/s have been deleted or the component doesn't exist in bit.map file
        if (componentFromModel) status.deleted = true;else status.notExist = true;
        return status;
      }
      if (err instanceof _componentsPendingImport().default) {
        status.missingFromScope;
        return status;
      }
      throw err;
    }
    if (!componentFromModel) {
      status.newlyCreated = true;
      return status;
    }
    const lane = await this.consumer.getCurrentLaneObject();
    await componentFromModel.setDivergeData(this.consumer.scope.objects);
    status.staged = await componentFromModel.isLocallyChanged(this.consumer.scope.objects, lane);
    const versionFromFs = componentFromFileSystem.id.version;
    const idStr = id.toString();
    if (!componentFromFileSystem.id.hasVersion()) {
      throw new (_componentOutOfSync().default)(idStr);
    }
    // TODO: instead of doing that like this we should use:
    // const versionFromModel = await componentFromModel.loadVersion(versionFromFs, this.consumer.scope.objects);
    // it looks like it's exactly the same code but it's not working from some reason
    const versionRef = componentFromModel.getRef(versionFromFs);
    if (!versionRef) throw new (_showDoctorError().default)(`version ${versionFromFs} was not found in ${idStr}`);
    const versionFromModel = await this.consumer.scope.getObject(versionRef.hash);
    if (!versionFromModel) {
      throw new (_showDoctorError().default)(`failed loading version ${versionFromFs} of ${idStr} from the scope`);
    }
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    status.modified = await this.consumer.isComponentModified(versionFromModel, componentFromFileSystem);
    return status;
  }
}
exports.ComponentStatusLoader = ComponentStatusLoader;