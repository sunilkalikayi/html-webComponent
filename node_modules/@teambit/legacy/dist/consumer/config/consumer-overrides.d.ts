import BitId from '../../bit-id/bit-id';
import Component from '../component/consumer-component';
import { ComponentOverridesData } from './component-overrides';
export declare type ConsumerOverridesOfComponent = ComponentOverridesData & {
    extensions?: Record<string, any>;
    env?: Record<string, any>;
    propagate?: boolean;
    defaultScope?: string;
    defaultOwner?: string;
};
export declare type ConsumerOverridesConfig = {
    [key: string]: ConsumerOverridesOfComponent;
};
export declare const overridesForbiddenFields: string[];
export declare const overridesBitInternalFields: string[];
export declare const nonPackageJsonFields: string[];
export default class ConsumerOverrides {
    overrides: ConsumerOverridesConfig;
    hasChanged: boolean;
    constructor(overrides: ConsumerOverridesConfig);
    static load(overrides?: Record<string, any>): ConsumerOverrides;
    getOverrideComponentData(bitId: BitId): ConsumerOverridesOfComponent | undefined;
    _updateSpecificOverridesWithGeneralOverrides(generalOverrides: Record<string, any>, specificOverrides: Record<string, any>): void;
    _getAllRulesMatchedById(bitId: BitId): string[];
    _isMatchByWildcard(bitId: BitId, idWithPossibleWildcard: string): boolean;
    _isExcluded(overridesValues: Record<string, any>, bitId: BitId): any;
    /**
     * sort from the more specific (more namespaces) to the more generic (less namespaces)
     * e.g.
     * src/utils/javascript/*
     * src/utils/javascript/*
     * src/utils/*
     * src/*
     *
     * more namespaces (slashes) === more specific
     * more wildcards === less specific
     *
     * if both have the same number of namespaces (slashes), the one with less wildcards is first.
     * if both have the same number of wildcards, the one with more namespaces is first.
     *
     * a reminder about compare function:
     * If the result is negative a is sorted before b.
     * If the result is positive b is sorted before a.
     * If the result is 0 no changes is done with the sort order of the two values.
     */
    static sortWildcards(a: string, b: string): number;
    updateOverridesIfChanged(component: Component, areEnvsChanged: boolean): boolean;
    areOverridesObjectsEqual(overridesA: ConsumerOverridesOfComponent | null | undefined, overridesB: ConsumerOverridesOfComponent): boolean;
    findExactMatch(bitId: BitId): string | null | undefined;
    removeExactMatch(bitId: BitId): boolean;
    static validate(overrides: Record<string, any>): void;
}
