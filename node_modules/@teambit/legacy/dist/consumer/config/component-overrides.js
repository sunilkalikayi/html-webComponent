"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.componentOverridesForbiddenFields = void 0;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _mergeDeepLeft2() {
  const data = _interopRequireDefault(require("ramda/src/mergeDeepLeft"));
  _mergeDeepLeft2 = function () {
    return data;
  };
  return data;
}
function _filter2() {
  const data = _interopRequireDefault(require("ramda/src/filter"));
  _filter2 = function () {
    return data;
  };
  return data;
}
function _keys2() {
  const data = _interopRequireDefault(require("ramda/src/keys"));
  _keys2 = function () {
    return data;
  };
  return data;
}
function _path2() {
  const data = _interopRequireDefault(require("ramda/src/path"));
  _path2 = function () {
    return data;
  };
  return data;
}
function _pickBy2() {
  const data = _interopRequireDefault(require("ramda/src/pickBy"));
  _pickBy2 = function () {
    return data;
  };
  return data;
}
function _clone2() {
  const data = _interopRequireDefault(require("ramda/src/clone"));
  _clone2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _consumerOverrides() {
  const data = require("./consumer-overrides");
  _consumerOverrides = function () {
    return data;
  };
  return data;
}
// consumer internal fields should not be used in component overrides, otherwise, they might conflict upon import
const componentOverridesForbiddenFields = [..._consumerOverrides().overridesForbiddenFields, ..._consumerOverrides().overridesBitInternalFields];
exports.componentOverridesForbiddenFields = componentOverridesForbiddenFields;
class ComponentOverrides {
  constructor(overrides) {
    (0, _defineProperty2().default)(this, "overrides", void 0);
    this.overrides = overrides || {};
  }
  static registerOnComponentOverridesLoading(extId, func) {
    this.componentOverridesLoadingRegistry[extId] = func;
  }

  /**
   * overrides of component can be determined by three different sources.
   * 1. component-config. (bit.json/package.json of the component itself).
   *    authored normally don't have it, most imported have it, unless they choose not to write package.json/bit.json.
   * 2. consumer-config. (bit.json/package.json of the consumer when it has overrides of the component).
   * 3. model. (when the component is tagged, the overrides data is saved into the model).
   *
   * the strategy of loading them is as follows:
   * a) find the component config. (if exists)
   * b) find the overrides of workspace config matching this component. (if exists)
   * c) merge between the two. in case of conflict, the component config wins.
   *
   * the following steps are needed to find the component config
   * a) if the component config is written to the filesystem, use it
   * b) if the component config is not written, it can be for two reasons:
   * 1) it's imported and the user chose not to write package.json nor bit.json. in this case, use
   * component from the model.
   * 2) it's author. by default, the config is written into consumer-config (if not exist) on import.
   * which, in this case, use only consumer-config.
   * an exception is when an author runs `eject-conf` command to explicitly write the config, then,
   * use the component-config.
   */
  static async loadFromConsumer(componentId, workspaceConfig, overridesFromModel, componentConfig, isLegacy) {
    // overrides from consumer-config is not relevant and should not affect imported
    let legacyOverridesFromConsumer = workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.getComponentConfig(componentId);
    const plainLegacy = workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig._legacyPlainObject();
    if (plainLegacy && plainLegacy.env) {
      legacyOverridesFromConsumer = legacyOverridesFromConsumer || {};
    }
    const getFromComponent = () => {
      if (componentConfig && componentConfig.componentHasWrittenConfig) {
        return componentConfig.overrides;
      }
      // @todo: we might consider using overridesFromModel here.
      // return isAuthor ? null : overridesFromModel;
      return null;
    };
    let extensionsAddedOverrides = {};
    // Do not run the hook for legacy projects since it will use the default env in that case for takeing dependencies and will change the main file
    if (!isLegacy) {
      extensionsAddedOverrides = await runOnLoadOverridesEvent(this.componentOverridesLoadingRegistry, componentConfig.parseExtensions());
    }
    const mergedLegacyConsumerOverridesWithExtensions = mergeOverrides(legacyOverridesFromConsumer || {}, extensionsAddedOverrides);
    const fromComponent = getFromComponent();
    if (!fromComponent) {
      return new ComponentOverrides(mergedLegacyConsumerOverridesWithExtensions);
    }
    const mergedOverrides = mergedLegacyConsumerOverridesWithExtensions ? mergeOverrides(fromComponent, mergedLegacyConsumerOverridesWithExtensions) : fromComponent;
    return new ComponentOverrides(mergedOverrides);
  }
  static loadFromScope(overridesFromModel = {}) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return new ComponentOverrides((0, _clone2().default)(overridesFromModel), {});
  }
  get componentOverridesData() {
    const isNotSystemField = (val, field) => !_consumerOverrides().overridesBitInternalFields.includes(field);
    return (0, _pickBy2().default)(isNotSystemField, this.overrides);
  }
  get componentOverridesPackageJsonData() {
    const isPackageJsonField = (val, field) => !_consumerOverrides().nonPackageJsonFields.includes(field);
    return (0, _pickBy2().default)(isPackageJsonField, this.overrides);
  }
  getEnvByType(envType) {
    return (0, _path2().default)(['env', envType], this.overrides);
  }
  getComponentDependenciesWithVersion() {
    const allDeps = Object.assign({}, this.overrides.dependencies, this.overrides.devDependencies, this.overrides.peerDependencies);
    return this._filterForComponentWithValidVersion(allDeps);
  }
  get defaultScope() {
    return this.overrides.defaultScope;
  }
  _filterForComponentWithValidVersion(deps) {
    return Object.keys(deps).reduce((acc, current) => {
      if (this._isValidVersion(deps[current]) && current.startsWith(_constants().OVERRIDE_COMPONENT_PREFIX)) {
        const component = current.replace(_constants().OVERRIDE_COMPONENT_PREFIX, '');
        acc[component] = deps[current];
      }
      return acc;
    }, {});
  }
  _isValidVersion(ver) {
    return ver !== _constants().MANUALLY_ADD_DEPENDENCY && ver !== _constants().MANUALLY_REMOVE_DEPENDENCY;
  }
  getIgnored(field) {
    return (0, _keys2().default)((0, _filter2().default)(dep => dep === _constants().MANUALLY_REMOVE_DEPENDENCY, this.overrides[field] || {}));
  }
  getIgnoredFiles(field) {
    const ignoredRules = this.getIgnored(field);
    return ignoredRules.filter(rule => rule.startsWith(_constants().OVERRIDE_FILE_PREFIX)).map(rule => rule.replace(_constants().OVERRIDE_FILE_PREFIX, ''));
  }
  getIgnoredPackages(field) {
    const ignoredRules = this.getIgnored(field);
    return ignoredRules.filter(rule => !rule.startsWith(_constants().OVERRIDE_FILE_PREFIX));
  }
  static getAllFilesPaths(overrides) {
    if (!overrides) return [];
    const allDeps = Object.assign({}, overrides.dependencies, overrides.devDependencies, overrides.peerDependencies);
    return Object.keys(allDeps).filter(rule => rule.startsWith(_constants().OVERRIDE_FILE_PREFIX)).map(rule => rule.replace(_constants().OVERRIDE_FILE_PREFIX, ''));
  }
  clone() {
    return new ComponentOverrides((0, _clone2().default)(this.overrides));
  }
}
exports.default = ComponentOverrides;
(0, _defineProperty2().default)(ComponentOverrides, "componentOverridesLoadingRegistry", {});
function mergeOverrides(overrides1, overrides2) {
  // Make sure to not mutate the original object
  const result = (0, _clone2().default)(overrides1);
  const isObjectAndNotArray = val => typeof val === 'object' && !Array.isArray(val);
  Object.keys(overrides2 || {}).forEach(field => {
    // Do not merge internal fields
    if (_consumerOverrides().overridesBitInternalFields.includes(field)) {
      return; // do nothing
    }

    if (isObjectAndNotArray(overrides1[field]) && isObjectAndNotArray(overrides2[field])) {
      result[field] = Object.assign({}, overrides2[field], overrides1[field]);
    } else if (!result[field]) {
      result[field] = overrides2[field];
    }
    // when overrides1[field] is set and not an object, do not override it by overrides2
  });

  return result;
}

/**
 * Merge added overrides from many extensions
 *
 * @param {any[]} configs
 * @returns A merge results of all config
 */
function mergeExtensionsOverrides(configs) {
  return configs.reduce((prev, curr) => {
    return (0, _mergeDeepLeft2().default)(prev, curr);
  }, {});
}

/**
 * Runs all the functions from the registry and merged their results
 *
 * @param {OverridesLoadRegistry} configsRegistry
 * @returns {Promise<ComponentOverridesData>} A merge results of the added overrides by all the extensions
 */
async function runOnLoadOverridesEvent(configsRegistry, extensions) {
  const extensionsAddedOverridesP = Object.keys(configsRegistry).map(extId => {
    // TODO: only running func for relevant extensions
    const func = configsRegistry[extId];
    return func(extensions);
  });
  const extensionsAddedOverrides = await Promise.all(extensionsAddedOverridesP);
  let extensionsConfigModificationsObject = mergeExtensionsOverrides(extensionsAddedOverrides);
  const filterFunc = val => !(0, _isEmpty2().default)(val);
  extensionsConfigModificationsObject = (0, _utils().filterObject)(extensionsConfigModificationsObject, filterFunc);
  return extensionsConfigModificationsObject;
}