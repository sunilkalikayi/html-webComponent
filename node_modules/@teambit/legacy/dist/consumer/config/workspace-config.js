"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _filterObject() {
  const data = _interopRequireDefault(require("../../utils/filter-object"));
  _filterObject = function () {
    return data;
  };
  return data;
}
function _abstractConfig() {
  const data = _interopRequireDefault(require("./abstract-config"));
  _abstractConfig = function () {
    return data;
  };
  return data;
}
function _consumerOverrides() {
  const data = _interopRequireDefault(require("./consumer-overrides"));
  _consumerOverrides = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _invalidConfigPropPath() {
  const data = _interopRequireDefault(require("./exceptions/invalid-config-prop-path"));
  _invalidConfigPropPath = function () {
    return data;
  };
  return data;
}
function _invalidPackageManager() {
  const data = _interopRequireDefault(require("./exceptions/invalid-package-manager"));
  _invalidPackageManager = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const DEFAULT_USE_WORKSPACES = false;
const DEFAULT_MANAGE_WORKSPACES = true;
class WorkspaceConfig extends _abstractConfig().default {
  // save hub dependencies as bit components rather than npm packages

  // package manager client to use
  // package manager process options
  // Enables integration with Yarn Workspaces
  // manage workspaces with yarn

  // workspace package.json if exists (parsed)
  // default remote scope to export to

  static registerOnWorkspaceConfigIsExist(func) {
    this.workspaceConfigIsExistRegistry = func;
  }
  static registerOnWorkspaceConfigLoading(func) {
    this.workspaceConfigLoadingRegistry = func;
  }
  static registerOnWorkspaceConfigEnsuring(func) {
    this.workspaceConfigEnsuringRegistry = func;
  }
  static registerOnWorkspaceConfigReset(func) {
    this.workspaceConfigResetRegistry = func;
  }
  constructor({
    saveDependenciesAsComponents = _constants().DEFAULT_SAVE_DEPENDENCIES_AS_COMPONENTS,
    lang,
    componentsDefaultDirectory = _constants().DEFAULT_COMPONENTS_DIR_PATH,
    dependenciesDirectory = _constants().DEFAULT_DEPENDENCIES_DIR_PATH,
    bindingPrefix,
    extensions,
    packageManager = _constants().DEFAULT_PACKAGE_MANAGER,
    packageManagerArgs,
    packageManagerProcessOptions,
    useWorkspaces = DEFAULT_USE_WORKSPACES,
    manageWorkspaces = DEFAULT_MANAGE_WORKSPACES,
    resolveModules,
    defaultScope,
    overrides = _consumerOverrides().default.load()
  }) {
    super({
      lang,
      bindingPrefix,
      extensions
    });
    (0, _defineProperty2().default)(this, "componentsDefaultDirectory", void 0);
    (0, _defineProperty2().default)(this, "dependenciesDirectory", void 0);
    (0, _defineProperty2().default)(this, "saveDependenciesAsComponents", void 0);
    (0, _defineProperty2().default)(this, "packageManager", void 0);
    (0, _defineProperty2().default)(this, "packageManagerArgs", void 0);
    (0, _defineProperty2().default)(this, "packageManagerProcessOptions", void 0);
    (0, _defineProperty2().default)(this, "useWorkspaces", void 0);
    (0, _defineProperty2().default)(this, "manageWorkspaces", void 0);
    (0, _defineProperty2().default)(this, "resolveModules", void 0);
    (0, _defineProperty2().default)(this, "overrides", void 0);
    (0, _defineProperty2().default)(this, "packageJsonObject", void 0);
    (0, _defineProperty2().default)(this, "defaultScope", void 0);
    if (packageManager !== 'npm' && packageManager !== 'yarn') {
      throw new (_invalidPackageManager().default)(packageManager);
    }
    this.componentsDefaultDirectory = componentsDefaultDirectory;
    // Make sure we have the component name in the path. otherwise components will be imported to the same dir.
    if (!componentsDefaultDirectory.includes('{name}')) {
      this.componentsDefaultDirectory = `${this.componentsDefaultDirectory}/{name}`;
    }
    this.dependenciesDirectory = dependenciesDirectory;
    this.saveDependenciesAsComponents = saveDependenciesAsComponents;
    this.packageManager = packageManager;
    this.packageManagerArgs = packageManagerArgs;
    this.packageManagerProcessOptions = packageManagerProcessOptions;
    this.useWorkspaces = useWorkspaces;
    this.manageWorkspaces = manageWorkspaces;
    this.resolveModules = resolveModules;
    this.defaultScope = defaultScope;
    this.overrides = overrides;
  }
  toPlainObject() {
    const superObject = super.toPlainObject();
    const consumerObject = _objectSpread(_objectSpread({}, superObject), {}, {
      componentsDefaultDirectory: this.componentsDefaultDirectory,
      dependenciesDirectory: this.dependenciesDirectory,
      saveDependenciesAsComponents: this.saveDependenciesAsComponents,
      packageManager: this.packageManager,
      packageManagerArgs: this.packageManagerArgs,
      packageManagerProcessOptions: this.packageManagerProcessOptions,
      useWorkspaces: this.useWorkspaces,
      manageWorkspaces: this.manageWorkspaces,
      resolveModules: this.resolveModules,
      defaultScope: this.defaultScope,
      overrides: this.overrides.overrides
    });
    const isPropDefault = (val, key) => {
      if (key === 'dependenciesDirectory') return val !== _constants().DEFAULT_DEPENDENCIES_DIR_PATH;
      if (key === 'useWorkspaces') return val !== DEFAULT_USE_WORKSPACES;
      if (key === 'manageWorkspaces') return val !== DEFAULT_MANAGE_WORKSPACES;
      if (key === 'saveDependenciesAsComponents') return val !== _constants().DEFAULT_SAVE_DEPENDENCIES_AS_COMPONENTS;
      if (key === 'resolveModules') return !(0, _isEmpty2().default)(val);
      if (key === 'defaultScope') return Boolean(val);
      if (key === 'overrides') return !(0, _isEmpty2().default)(val);
      return true;
    };
    return (0, _filterObject().default)(consumerObject, isPropDefault);
  }
  static create(workspaceConfigProps) {
    return new WorkspaceConfig(workspaceConfigProps);
  }
  static async ensure(dirPath, standAlone = false, workspaceConfigProps = {}) {
    const ensureFunc = this.workspaceConfigEnsuringRegistry;
    return ensureFunc(dirPath, standAlone, workspaceConfigProps);
  }
  static async _ensure(workspacePath, standAlone, workspaceConfigProps = {}) {
    try {
      const workspaceConfig = await this.load(workspacePath);
      return workspaceConfig;
    } catch (err) {
      if (err instanceof _exceptions().BitConfigNotFound || err instanceof _exceptions().InvalidBitJson) {
        const consumerBitJson = this.create(workspaceConfigProps);
        const packageJsonExists = await _abstractConfig().default.pathHasPackageJson(workspacePath);
        if (packageJsonExists && !standAlone) {
          consumerBitJson.writeToPackageJson = true;
        } else {
          consumerBitJson.writeToBitJson = true;
        }
        return consumerBitJson;
      }
      throw err;
    }
  }
  static async reset(dirPath, resetHard) {
    const deleteBitJsonFile = async () => {
      const bitJsonPath = _abstractConfig().default.composeBitJsonPath(dirPath);
      _logger().default.info(`deleting the workspace configuration file at ${bitJsonPath}`);
      await _fsExtra().default.remove(bitJsonPath);
    };
    if (resetHard) {
      await deleteBitJsonFile();
    }
    const resetFunc = this.workspaceConfigResetRegistry;
    await resetFunc(dirPath, resetHard);
    await WorkspaceConfig.ensure(dirPath);
  }
  static fromPlainObject(object) {
    this.validate(object);
    const {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      lang,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      componentsDefaultDirectory,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      dependenciesDirectory,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      bindingPrefix,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      extensions,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      saveDependenciesAsComponents,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageManager,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageManagerArgs,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageManagerProcessOptions,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      useWorkspaces,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      manageWorkspaces,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      resolveModules,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      defaultScope,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      overrides
    } = object;
    return new WorkspaceConfig({
      lang,
      bindingPrefix,
      extensions,
      saveDependenciesAsComponents,
      componentsDefaultDirectory,
      dependenciesDirectory,
      packageManager,
      packageManagerArgs,
      packageManagerProcessOptions,
      useWorkspaces,
      manageWorkspaces,
      resolveModules,
      defaultScope,
      overrides: _consumerOverrides().default.load(overrides)
    });
  }
  static async load(dirPath) {
    const res = await this._loadIfExist(dirPath);
    if (!res) {
      throw new (_exceptions().BitConfigNotFound)();
    }
    return res;
  }
  static async loadIfExist(dirPath) {
    const loadFunc = this.workspaceConfigLoadingRegistry;
    if (loadFunc && typeof loadFunc === 'function') {
      return loadFunc(dirPath);
    }
    return undefined;
  }
  static async isExist(dirPath) {
    const isExistFunc = this.workspaceConfigIsExistRegistry;
    if (isExistFunc && typeof isExistFunc === 'function') {
      return isExistFunc(dirPath);
    }
    return undefined;
  }
  static async _isExist(dirPath) {
    const bitJsonPath = _abstractConfig().default.composeBitJsonPath(dirPath);
    const packageJsonPath = _abstractConfig().default.composePackageJsonPath(dirPath);
    const bitJsonExist = await _fsExtra().default.pathExists(bitJsonPath);
    if (bitJsonExist) {
      return true;
    }
    const packageJson = await this.loadPackageJson(packageJsonPath);
    if (packageJson && packageJson.bit) {
      return true;
    }
    return false;
  }
  static async _loadIfExist(dirPath) {
    const bitJsonPath = _abstractConfig().default.composeBitJsonPath(dirPath);
    const packageJsonPath = _abstractConfig().default.composePackageJsonPath(dirPath);
    const [bitJsonFile, packageJsonFile] = await Promise.all([this.loadBitJson(bitJsonPath),
    // $FlowFixMe
    this.loadPackageJson(packageJsonPath)]);
    const bitJsonConfig = bitJsonFile || {};
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const packageJsonHasConfig = packageJsonFile && packageJsonFile.bit;
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const packageJsonConfig = packageJsonHasConfig ? packageJsonFile.bit : {};
    if ((0, _isEmpty2().default)(bitJsonConfig) && (0, _isEmpty2().default)(packageJsonConfig)) return undefined;
    // in case of conflicts, bit.json wins package.json
    const config = Object.assign(packageJsonConfig, bitJsonConfig);
    const workspaceConfig = this.fromPlainObject(config);
    workspaceConfig.path = bitJsonPath;
    workspaceConfig.writeToBitJson = Boolean(bitJsonFile);
    workspaceConfig.writeToPackageJson = packageJsonHasConfig;
    workspaceConfig.packageJsonObject = packageJsonFile;
    return workspaceConfig;
  }
  static async loadBitJson(bitJsonPath) {
    try {
      const file = await _abstractConfig().default.loadJsonFileIfExist(bitJsonPath);
      return file;
    } catch (e) {
      throw new (_exceptions().InvalidBitJson)(bitJsonPath);
    }
  }
  static async loadPackageJson(packageJsonPath) {
    try {
      const file = await _abstractConfig().default.loadJsonFileIfExist(packageJsonPath);
      return file;
    } catch (e) {
      throw new (_exceptions().InvalidPackageJson)(packageJsonPath);
    }
  }
  static validate(object) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const {
      componentsDefaultDirectory,
      dependenciesDirectory
    } = object;
    const pathsToValidate = {
      componentsDefaultDirectory,
      dependenciesDirectory
    };
    Object.keys(pathsToValidate).forEach(field => throwForInvalidPath(field, pathsToValidate[field]));
    function throwForInvalidPath(fieldName, pathToValidate) {
      if (pathToValidate && !(0, _utils().isValidPath)(pathToValidate)) {
        throw new (_invalidConfigPropPath().default)(fieldName, pathToValidate);
      }
    }
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    _consumerOverrides().default.validate(object.overrides);
  }
}
exports.default = WorkspaceConfig;
(0, _defineProperty2().default)(WorkspaceConfig, "workspaceConfigIsExistRegistry", void 0);
(0, _defineProperty2().default)(WorkspaceConfig, "workspaceConfigLoadingRegistry", void 0);
(0, _defineProperty2().default)(WorkspaceConfig, "workspaceConfigEnsuringRegistry", void 0);
(0, _defineProperty2().default)(WorkspaceConfig, "workspaceConfigResetRegistry", void 0);