import { BitId } from '../../bit-id';
import ComponentConfig from './component-config';
import { ConsumerOverridesOfComponent } from './consumer-overrides';
import { ILegacyWorkspaceConfig } from './legacy-workspace-config-interface';
export declare const componentOverridesForbiddenFields: string[];
export declare type DependenciesOverridesData = {
    dependencies?: Record<string, string>;
    devDependencies?: Record<string, string>;
    peerDependencies?: Record<string, string>;
};
export declare type ComponentOverridesData = DependenciesOverridesData & {
    [key: string]: any;
};
declare type OverridesLoadRegistry = {
    [extId: string]: Function;
};
export default class ComponentOverrides {
    overrides: ConsumerOverridesOfComponent;
    constructor(overrides: ConsumerOverridesOfComponent | null | undefined);
    static componentOverridesLoadingRegistry: OverridesLoadRegistry;
    static registerOnComponentOverridesLoading(extId: any, func: (id: any, config: any) => any): void;
    /**
     * overrides of component can be determined by three different sources.
     * 1. component-config. (bit.json/package.json of the component itself).
     *    authored normally don't have it, most imported have it, unless they choose not to write package.json/bit.json.
     * 2. consumer-config. (bit.json/package.json of the consumer when it has overrides of the component).
     * 3. model. (when the component is tagged, the overrides data is saved into the model).
     *
     * the strategy of loading them is as follows:
     * a) find the component config. (if exists)
     * b) find the overrides of workspace config matching this component. (if exists)
     * c) merge between the two. in case of conflict, the component config wins.
     *
     * the following steps are needed to find the component config
     * a) if the component config is written to the filesystem, use it
     * b) if the component config is not written, it can be for two reasons:
     * 1) it's imported and the user chose not to write package.json nor bit.json. in this case, use
     * component from the model.
     * 2) it's author. by default, the config is written into consumer-config (if not exist) on import.
     * which, in this case, use only consumer-config.
     * an exception is when an author runs `eject-conf` command to explicitly write the config, then,
     * use the component-config.
     */
    static loadFromConsumer(componentId: BitId, workspaceConfig: ILegacyWorkspaceConfig, overridesFromModel: ComponentOverridesData | undefined, componentConfig: ComponentConfig, isLegacy: boolean): Promise<ComponentOverrides>;
    static loadFromScope(overridesFromModel?: ComponentOverridesData | null | undefined): ComponentOverrides;
    get componentOverridesData(): any;
    get componentOverridesPackageJsonData(): any;
    getEnvByType(envType: any): string | Record<string, any> | undefined;
    getComponentDependenciesWithVersion(): Record<string, any>;
    get defaultScope(): string | undefined;
    _filterForComponentWithValidVersion(deps: Record<string, any>): Record<string, any>;
    _isValidVersion(ver: string): boolean;
    getIgnored(field: string): string[];
    getIgnoredFiles(field: string): string[];
    getIgnoredPackages(field: string): string[];
    static getAllFilesPaths(overrides: Record<string, any>): string[];
    clone(): ComponentOverrides;
}
export {};
