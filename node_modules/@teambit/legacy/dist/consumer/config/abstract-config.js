"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _equals2() {
  const data = _interopRequireDefault(require("ramda/src/equals"));
  _equals2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _packageJsonFile() {
  const data = _interopRequireDefault(require("../component/package-json-file"));
  _packageJsonFile = function () {
    return data;
  };
  return data;
}
function _dataToPersist() {
  const data = _interopRequireDefault(require("../component/sources/data-to-persist"));
  _dataToPersist = function () {
    return data;
  };
  return data;
}
function _jsonFile() {
  const data = _interopRequireDefault(require("../component/sources/json-file"));
  _jsonFile = function () {
    return data;
  };
  return data;
}
function _extensionData() {
  const data = require("./extension-data");
  _extensionData = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * There are two Bit Config: WorkspaceConfig and ComponentConfig, both inherit this class.
 * The config data can be written in package.json inside "bit" property. And, can be written in
 * bit.json file. Also, it might be written in both, in which case, if there is any conflict, the
 * bit.json wins.
 */
class AbstractConfig {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  constructor(props) {
    (0, _defineProperty2().default)(this, "path", void 0);
    (0, _defineProperty2().default)(this, "dependencies", void 0);
    (0, _defineProperty2().default)(this, "devDependencies", void 0);
    (0, _defineProperty2().default)(this, "lang", void 0);
    (0, _defineProperty2().default)(this, "bindingPrefix", void 0);
    (0, _defineProperty2().default)(this, "extensions", void 0);
    (0, _defineProperty2().default)(this, "writeToPackageJson", false);
    (0, _defineProperty2().default)(this, "writeToBitJson", false);
    this.lang = props.lang || _constants().DEFAULT_LANGUAGE;
    this.bindingPrefix = props.bindingPrefix || _constants().DEFAULT_BINDINGS_PREFIX;
    this.extensions = props.extensions || new (_extensionData().ExtensionDataList)();
  }
  getDependencies() {
    return _bitId().BitIds.fromObject(this.dependencies);
  }
  toPlainObject() {
    var _this$extensions;
    const isPropDefaultOrNull = (val, key) => {
      if (!val) return false;
      if (key === 'lang') return val !== _constants().DEFAULT_LANGUAGE;
      if (key === 'bindingPrefix') return val !== _constants().DEFAULT_BINDINGS_PREFIX;
      if (key === 'extensions') return !(0, _equals2().default)(val, _constants().DEFAULT_EXTENSIONS);
      return true;
    };
    return (0, _utils().filterObject)({
      lang: this.lang,
      bindingPrefix: this.bindingPrefix,
      dependencies: this.dependencies,
      extensions: (_this$extensions = this.extensions) === null || _this$extensions === void 0 ? void 0 : _this$extensions.toConfigObject()
    }, isPropDefaultOrNull);
  }
  async write({
    workspaceDir,
    componentDir
  }) {
    const jsonFiles = await this.prepareToWrite({
      workspaceDir,
      componentDir
    });
    const dataToPersist = new (_dataToPersist().default)();
    dataToPersist.addManyFiles(jsonFiles);
    dataToPersist.addBasePath(workspaceDir);
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return dataToPersist.persistAllToFS();
  }
  async prepareToWrite({
    workspaceDir,
    componentDir = '.'
  }) {
    const files = await this.toVinyl({
      workspaceDir,
      componentDir
    });
    return files;
  }
  async toVinyl({
    workspaceDir,
    componentDir = '.'
  }) {
    const plainObject = this.toPlainObject();
    const jsonFiles = [];
    if (this.writeToPackageJson) {
      const packageJsonFile = await _packageJsonFile().default.load(workspaceDir, componentDir);
      packageJsonFile.addOrUpdateProperty('bit', plainObject);
      jsonFiles.push(packageJsonFile.toVinylFile());
    }
    if (this.writeToBitJson) {
      const bitJsonPath = AbstractConfig.composeBitJsonPath(componentDir);
      const params = {
        base: componentDir,
        override: true,
        path: bitJsonPath,
        content: plainObject
      };
      const bitJsonFile = _jsonFile().default.load(params);
      jsonFiles.push(bitJsonFile);
    }
    return jsonFiles;
  }
  static composeBitJsonPath(bitPath) {
    return path().join(bitPath, _constants().BIT_JSON);
  }
  static composePackageJsonPath(bitPath) {
    return path().join(bitPath, _constants().PACKAGE_JSON);
  }
  static async pathHasBitJson(bitPath) {
    return _fsExtra().default.pathExists(this.composeBitJsonPath(bitPath));
  }
  static async pathHasPackageJson(bitPath) {
    return _fsExtra().default.pathExists(this.composePackageJsonPath(bitPath));
  }
  static async loadJsonFileIfExist(jsonFilePath) {
    try {
      const file = await _fsExtra().default.readJson(jsonFilePath);
      return file;
    } catch (e) {
      if (e.code === 'ENOENT') return null;
      throw e;
    }
  }
  static async removeIfExist(bitPath) {
    const dirToRemove = this.composeBitJsonPath(bitPath);
    const exists = await _fsExtra().default.pathExists(dirToRemove);
    if (exists) {
      _logger().default.info(`abstract-config, deleting ${dirToRemove}`);
      await _fsExtra().default.remove(dirToRemove);
      return true;
    }
    return false;
  }
}
exports.default = AbstractConfig;