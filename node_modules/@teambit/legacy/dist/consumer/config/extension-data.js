"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.REMOVE_EXTENSION_SPECIAL_SIGN = exports.INTERNAL_CONFIG_FIELDS = exports.ExtensionDataList = exports.ExtensionDataEntry = void 0;
exports.configEntryToDataEntry = configEntryToDataEntry;
exports.removeInternalConfigFields = removeInternalConfigFields;
exports.removeInternalConfigFieldsWithMutation = removeInternalConfigFieldsWithMutation;
function _prop2() {
  const data = _interopRequireDefault(require("ramda/src/prop"));
  _prop2 = function () {
    return data;
  };
  return data;
}
function _sortBy2() {
  const data = _interopRequireDefault(require("ramda/src/sortBy"));
  _sortBy2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _clone2() {
  const data = _interopRequireDefault(require("ramda/src/clone"));
  _clone2 = function () {
    return data;
  };
  return data;
}
function _unionWith2() {
  const data = _interopRequireDefault(require("ramda/src/unionWith"));
  _unionWith2 = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _artifactFiles() {
  const data = require("../component/sources/artifact-files");
  _artifactFiles = function () {
    return data;
  };
  return data;
}
const mergeReducer = (accumulator, currentValue) => (0, _unionWith2().default)(ignoreVersionPredicate, accumulator, currentValue);
const REMOVE_EXTENSION_SPECIAL_SIGN = '-';
exports.REMOVE_EXTENSION_SPECIAL_SIGN = REMOVE_EXTENSION_SPECIAL_SIGN;
const INTERNAL_CONFIG_FIELDS = ['__specific'];
exports.INTERNAL_CONFIG_FIELDS = INTERNAL_CONFIG_FIELDS;
class ExtensionDataEntry {
  constructor(legacyId, extensionId, name, rawConfig = {}, data = {}, newExtensionId = undefined) {
    this.legacyId = legacyId;
    this.extensionId = extensionId;
    this.name = name;
    this.rawConfig = rawConfig;
    this.data = data;
    this.newExtensionId = newExtensionId;
  }
  get id() {
    if (this.extensionId) return this.extensionId;
    if (this.name) return this.name;
    if (this.legacyId) return this.legacyId;
    return '';
  }
  get stringId() {
    var _this$extensionId;
    if (this.extensionId) return (_this$extensionId = this.extensionId) === null || _this$extensionId === void 0 ? void 0 : _this$extensionId.toString();
    if (this.name) return this.name;
    if (this.legacyId) return this.legacyId;
    return '';
  }
  get config() {
    if (this.rawConfig === REMOVE_EXTENSION_SPECIAL_SIGN) return {};
    return this.rawConfig;
  }
  set config(val) {
    this.rawConfig = val;
  }
  get isLegacy() {
    var _this$config;
    if ((_this$config = this.config) !== null && _this$config !== void 0 && _this$config.__legacy) return true;
    return false;
  }
  get isRemoved() {
    return this.rawConfig === REMOVE_EXTENSION_SPECIAL_SIGN;
  }
  toModelObject() {
    const extensionId = this.extensionId && this.extensionId.serialize ? this.extensionId.serialize() : this.extensionId;
    return {
      extensionId,
      // Do not use raw config here
      config: this.config,
      data: this.data,
      legacyId: this.legacyId,
      name: this.name,
      newExtensionId: this.newExtensionId
    };
  }
  toComponentObject() {
    const extensionId = this.extensionId ? this.extensionId.toString() : this.extensionId;
    return {
      extensionId,
      // Do not use raw config here
      config: this.config,
      data: this.data,
      legacyId: this.legacyId,
      name: this.name,
      newExtensionId: this.newExtensionId
    };
  }
  clone() {
    var _this$extensionId2;
    return new ExtensionDataEntry(this.legacyId, (_this$extensionId2 = this.extensionId) === null || _this$extensionId2 === void 0 ? void 0 : _this$extensionId2.clone(), this.name, (0, _clone2().default)(this.rawConfig), (0, _clone2().default)(this.data));
  }
}
exports.ExtensionDataEntry = ExtensionDataEntry;
class ExtensionDataList extends Array {
  static registerCoreExtensionName(name) {
    ExtensionDataList.coreExtensionsNames.set(name, '');
  }
  static registerManyCoreExtensionNames(names) {
    names.forEach(name => {
      ExtensionDataList.coreExtensionsNames.set(name, '');
    });
  }
  get ids() {
    const list = this.map(entry => entry.stringId);
    return list;
  }

  /**
   * returns only new 3rd party extension ids, not core, nor legacy.
   */
  get extensionsBitIds() {
    const bitIds = this.filter(entry => entry.extensionId).map(entry => entry.extensionId);
    return _bitId().BitIds.fromArray(bitIds);
  }
  toModelObjects() {
    const extensionsClone = this.clone();
    extensionsClone.forEach(ext => {
      if (ext.extensionId) {
        // TODO: fix the types of extensions. after this it should be an object not an object id
        // @ts-ignore
        ext.extensionId = ext.extensionId.serialize();
      }
    });
    (0, _artifactFiles().convertBuildArtifactsToModelObject)(extensionsClone);
    return extensionsClone.map(ext => ext.toModelObject());
  }
  static fromModelObject(entries) {
    const extensionDataList = ExtensionDataList.fromArray(entries);
    (0, _artifactFiles().convertBuildArtifactsFromModelObject)(extensionDataList);
    return extensionDataList;
  }
  findExtension(extensionId, ignoreVersion = false, ignoreScope = false) {
    if (ExtensionDataList.coreExtensionsNames.has(extensionId)) {
      return this.findCoreExtension(extensionId);
    }
    return this.find(extEntry => {
      if (ignoreVersion && ignoreScope) {
        var _extEntry$extensionId;
        return ((_extEntry$extensionId = extEntry.extensionId) === null || _extEntry$extensionId === void 0 ? void 0 : _extEntry$extensionId.toStringWithoutScopeAndVersion()) === extensionId;
      }
      if (ignoreVersion) {
        var _extEntry$extensionId2;
        return ((_extEntry$extensionId2 = extEntry.extensionId) === null || _extEntry$extensionId2 === void 0 ? void 0 : _extEntry$extensionId2.toStringWithoutVersion()) === extensionId;
      }
      if (ignoreScope) {
        var _extEntry$extensionId3;
        return ((_extEntry$extensionId3 = extEntry.extensionId) === null || _extEntry$extensionId3 === void 0 ? void 0 : _extEntry$extensionId3.toStringWithoutScope()) === extensionId;
      }
      return extEntry.stringId === extensionId;
    });
  }
  findCoreExtension(extensionId) {
    return this.find(extEntry => extEntry.name === extensionId);
  }
  remove(id) {
    return ExtensionDataList.fromArray(this.filter(entry => {
      return entry.stringId !== id.toString() && entry.stringId !== id.toStringWithoutVersion();
    }));
  }

  /**
   * Filter extension marked to be removed with the special remove sign REMOVE_EXTENSION_SPECIAL_SIGN ("-")
   */
  filterRemovedExtensions() {
    const filtered = this.filter(entry => {
      return !entry.isRemoved;
    });
    return ExtensionDataList.fromArray(filtered);
  }
  toConfigObject() {
    const res = {};
    this.forEach(entry => {
      if (entry.rawConfig && !(0, _lodash().isEmpty)(entry.rawConfig)) {
        res[entry.stringId] = removeInternalConfigFields(entry.rawConfig);
        if ((0, _lodash().isEmpty)(res[entry.stringId])) delete res[entry.stringId];
      }
    });
    return res;
  }
  toConfigArray() {
    const arr = this.map(entry => {
      // Remove extensions without config
      const clonedEntry = entry.clone();
      if (clonedEntry.rawConfig && !(0, _lodash().isEmpty)(clonedEntry.rawConfig)) {
        removeInternalConfigFieldsWithMutation(clonedEntry.rawConfig);
        if ((0, _lodash().isEmpty)(clonedEntry.rawConfig)) return undefined;
        return {
          id: clonedEntry.stringId,
          config: clonedEntry.config
        };
      }
      return undefined;
    });
    return (0, _lodash().compact)(arr);
  }
  clone() {
    const extensionDataEntries = this.map(extensionData => extensionData.clone());
    const extensionDataList = new ExtensionDataList(...extensionDataEntries);
    (0, _artifactFiles().reStructureBuildArtifacts)(extensionDataList);
    return extensionDataList;
  }
  _filterLegacy() {
    return ExtensionDataList.fromArray(this.filter(ext => !ext.isLegacy));
  }
  sortById() {
    const arr = (0, _sortBy2().default)((0, _prop2().default)('stringId'), this);
    // Also sort the config
    arr.forEach(entry => {
      entry.config = (0, _utils().sortObject)(entry.config);
    });
    return ExtensionDataList.fromArray(arr);
  }
  static fromConfigObject(obj = {}) {
    const arr = Object.keys(obj).map(extensionId => configEntryToDataEntry(extensionId, obj[extensionId]));
    return this.fromArray(arr);
  }
  static fromArray(entries) {
    if (!entries || !entries.length) {
      return new ExtensionDataList();
    }
    return new ExtensionDataList(...entries);
  }

  /**
   * Merge a list of ExtensionDataList into one ExtensionDataList
   * In case of entry with the same id appear in more than one list
   * the former in the list will be taken
   * see unit tests for examples
   *
   * Make sure you extension ids are resolved before call this, otherwise you might get unexpected results
   * for example:
   * you might have 2 entries like: default-scope/my-extension and my-extension on the same time
   *
   * @static
   * @param {ExtensionDataList[]} list
   * @returns {ExtensionDataList}
   * @memberof ExtensionDataList
   */
  static mergeConfigs(list) {
    if (list.length === 1) {
      return list[0];
    }
    const merged = list.reduce(mergeReducer, new ExtensionDataList());
    return ExtensionDataList.fromArray(merged);
  }
}
exports.ExtensionDataList = ExtensionDataList;
(0, _defineProperty2().default)(ExtensionDataList, "coreExtensionsNames", new Map());
function ignoreVersionPredicate(extensionEntry1, extensionEntry2) {
  if (extensionEntry1.extensionId && extensionEntry2.extensionId) {
    return extensionEntry1.extensionId.isEqualWithoutVersion(extensionEntry2.extensionId);
  }
  if (extensionEntry1.name && extensionEntry2.name) {
    return extensionEntry1.name === extensionEntry2.name;
  }
  return false;
}
function configEntryToDataEntry(extensionId, config) {
  const isCore = ExtensionDataList.coreExtensionsNames.has(extensionId);
  if (!isCore) {
    const parsedId = _bitId().BitId.parse(extensionId, true);
    return new ExtensionDataEntry(undefined, parsedId, undefined, config, undefined);
  }
  return new ExtensionDataEntry(undefined, undefined, extensionId, config, undefined);
}
function removeInternalConfigFields(config) {
  if (!config || config === REMOVE_EXTENSION_SPECIAL_SIGN) return config;
  const clonedConfig = (0, _lodash().cloneDeep)(config);
  INTERNAL_CONFIG_FIELDS.forEach(field => delete clonedConfig[field]);
  return clonedConfig;
}
function removeInternalConfigFieldsWithMutation(config) {
  if (!config || config === REMOVE_EXTENSION_SPECIAL_SIGN) return;
  INTERNAL_CONFIG_FIELDS.forEach(field => delete config[field]);
}