"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.getBindingPrefixByDefaultScope = getBindingPrefixByDefaultScope;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));
  _showDoctorError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _filterObject() {
  const data = _interopRequireDefault(require("../../utils/filter-object"));
  _filterObject = function () {
    return data;
  };
  return data;
}
function _abstractConfig() {
  const data = _interopRequireDefault(require("./abstract-config"));
  _abstractConfig = function () {
    return data;
  };
  return data;
}
function _extensionData() {
  const data = require("./extension-data");
  _extensionData = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
// TODO: take for some other place like config
// TODO: unify this and the same in src/components/utils/load-extensions/load-resolved-extensions.ts
const ignoreLoadingExtensionsErrors = false;
class ComponentConfig extends _abstractConfig().default {
  // whether a component has bit.json written to FS or package.json written with 'bit' property

  static registerOnComponentConfigLoading(extId, func) {
    this.componentConfigLoadingRegistry[extId] = func;
  }
  static registerOnComponentConfigLegacyLoading(extId, func) {
    this.componentConfigLegacyLoadingRegistry[extId] = func;
  }
  constructor({
    lang,
    bindingPrefix,
    extensions,
    defaultScope,
    overrides
  }) {
    super({
      lang,
      bindingPrefix,
      extensions
    });
    (0, _defineProperty2().default)(this, "overrides", void 0);
    (0, _defineProperty2().default)(this, "defaultScope", void 0);
    (0, _defineProperty2().default)(this, "componentHasWrittenConfig", false);
    (0, _defineProperty2().default)(this, "packageJsonFile", void 0);
    this.defaultScope = defaultScope;
    this.overrides = overrides;
    this.writeToBitJson = true; // will be changed later to work similar to workspace-config
  }

  toPlainObject() {
    const superObject = super.toPlainObject();
    const componentObject = _objectSpread(_objectSpread({}, superObject), {}, {
      overrides: this.overrides
    });
    const isPropDefaultOrEmpty = (val, key) => {
      if (key === 'overrides') return !(0, _isEmpty2().default)(val);
      return true;
    };
    return (0, _filterObject().default)(componentObject, isPropDefaultOrEmpty);
  }
  validate(bitJsonPath) {
    if (this.extensions && typeof this.extensions !== 'object') {
      throw new (_showDoctorError().default)(`bit.json at "${bitJsonPath}" is invalid, re-import the component with "--conf" flag to recreate it`);
    }
  }

  /**
   * Return the extensions as ExtensionDataList
   *
   * @returns {ExtensionDataList}
   * @memberof ComponentConfig
   */
  parseExtensions() {
    return _extensionData().ExtensionDataList.fromArray(this.extensions);
  }
  mergeWithComponentData(component) {
    this.bindingPrefix = this.bindingPrefix || component.bindingPrefix;
    this.lang = this.lang || component.lang;
  }
  static async load({
    componentId
  }) {
    const onLoadResults = await this.runOnLoadEvent(this.componentConfigLoadingRegistry, componentId);
    const wsComponentConfig = onLoadResults[0];
    const defaultScope = wsComponentConfig.defaultScope;
    const bindingPrefix = getBindingPrefixByDefaultScope(defaultScope);
    const componentConfig = new ComponentConfig({
      extensions: wsComponentConfig.extensions,
      defaultScope,
      bindingPrefix
    });
    return componentConfig;
  }

  /**
   * Run all subscribers to the component config load event
   *
   * @static
   * @param {ConfigLoadRegistry} subscribers
   * @param {BitId} id
   * @memberof ComponentConfig
   */
  static async runOnLoadEvent(subscribers, id) {
    _logger().default.debugAndAddBreadCrumb('componentConfigLoad', `running on load even for component ${id.toString()}`);
    try {
      const res = await (0, _pMapSeries().default)(Object.keys(subscribers), async extId => {
        const func = subscribers[extId];
        return func(id);
      });
      return res;
    } catch (err) {
      if (!ignoreLoadingExtensionsErrors) {
        throw err;
      }
      // TODO: improve texts
      _logger().default.console(`\nfailed loading an extension for component ${id.toString()}, error is:`, 'warn', 'yellow');
      // TODO: this show an ugly error, we should somehow show a proper errors
      _logger().default.console(err, 'warn', 'yellow');
      _logger().default.console('the error has been ignored', 'warn', 'yellow');
      _logger().default.warn('extension on load event throw an error', err);
    }
    return [];
  }
}
exports.default = ComponentConfig;
(0, _defineProperty2().default)(ComponentConfig, "componentConfigLoadingRegistry", {});
(0, _defineProperty2().default)(ComponentConfig, "componentConfigLegacyLoadingRegistry", {});
function getBindingPrefixByDefaultScope(defaultScope) {
  const splittedScope = defaultScope.split('.');
  const defaultOwner = splittedScope.length === 1 ? defaultScope : splittedScope[0];
  let bindingPrefix = _constants().DEFAULT_REGISTRY_DOMAIN_PREFIX;
  if (defaultOwner && defaultOwner !== _constants().DEFAULT_REGISTRY_DOMAIN_PREFIX) {
    bindingPrefix = defaultOwner.startsWith('@') ? defaultOwner : `@${defaultOwner}`;
  }
  return bindingPrefix;
}