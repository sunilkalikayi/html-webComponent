"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyVersionReport = exports.MergeOptions = exports.FileStatus = void 0;
exports.conflictSummaryReport = conflictSummaryReport;
exports.getMergeStrategy = getMergeStrategy;
exports.getMergeStrategyInteractive = getMergeStrategyInteractive;
exports.mergeOptionsCli = void 0;
exports.mergeVersion = mergeVersion;
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _prompts() {
  const data = require("../../../prompts");
  _prompts = function () {
    return data;
  };
  return data;
}
function _repositories() {
  const data = require("../../../scope/repositories");
  _repositories = function () {
    return data;
  };
  return data;
}
function _path2() {
  const data = require("../../../utils/path");
  _path2 = function () {
    return data;
  };
  return data;
}
function _componentWriter() {
  const data = _interopRequireDefault(require("../../component-ops/component-writer"));
  _componentWriter = function () {
    return data;
  };
  return data;
}
function _twoWayMerge() {
  const data = _interopRequireDefault(require("./two-way-merge"));
  _twoWayMerge = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const mergeOptionsCli = {
  o: 'ours',
  t: 'theirs',
  m: 'manual'
};
exports.mergeOptionsCli = mergeOptionsCli;
const MergeOptions = {
  ours: 'ours',
  theirs: 'theirs',
  manual: 'manual'
};
// @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
exports.MergeOptions = MergeOptions;
const FileStatus = {
  merged: _chalk().default.green('auto-merged'),
  manual: _chalk().default.red('CONFLICT'),
  binaryConflict: _chalk().default.red('unchanged-BINARY-CONFLICT'),
  updated: _chalk().default.green('updated'),
  added: _chalk().default.green('added'),
  removed: _chalk().default.green('removed'),
  overridden: _chalk().default.yellow('overridden'),
  unchanged: _chalk().default.green('unchanged'),
  remainDeleted: _chalk().default.green('remain-deleted')
};
// fileName is PathLinux. TS doesn't let anything else in the keys other than string and number
exports.FileStatus = FileStatus;
async function mergeVersion(consumer, version, ids, mergeStrategy) {
  const {
    components
  } = await consumer.loadComponents(_bitId().BitIds.fromArray(ids));
  const allComponentsStatus = await getAllComponentsStatus();
  const componentWithConflict = allComponentsStatus.find(component => component.mergeResults.hasConflicts);
  if (componentWithConflict && !mergeStrategy) {
    mergeStrategy = await getMergeStrategyInteractive();
  }

  // don't use Promise.all to not call importMany multiple times in parallel.
  const mergedComponents = await (0, _pMapSeries().default)(allComponentsStatus, ({
    id,
    componentFromFS,
    mergeResults
  }) => {
    return applyVersion(consumer, id, componentFromFS, mergeResults, mergeStrategy);
  });
  return {
    components: mergedComponents,
    version
  };
  async function getAllComponentsStatus() {
    const tmp = new (_repositories().Tmp)(consumer.scope);
    try {
      const componentsStatus = await Promise.all(components.map(component => getComponentStatus(consumer, component, version)));
      await tmp.clear();
      return componentsStatus;
    } catch (err) {
      await tmp.clear();
      throw err;
    }
  }
}
async function getComponentStatus(consumer, component, version) {
  const componentModel = await consumer.scope.getModelComponentIfExist(component.id);
  if (!componentModel) {
    throw new (_generalError().default)(`component ${component.id.toString()} doesn't have any version yet`);
  }
  const hasVersion = await componentModel.hasVersion(version, consumer.scope.objects);
  if (!hasVersion) {
    throw new (_generalError().default)(`component ${component.id.toStringWithoutVersion()} doesn't have version ${version}`);
  }
  const existingBitMapId = consumer.bitMap.getBitId(component.id, {
    ignoreVersion: true
  });
  const currentlyUsedVersion = existingBitMapId.version;
  if (currentlyUsedVersion === version) {
    throw new (_generalError().default)(`component ${component.id.toStringWithoutVersion()} is already at version ${version}`);
  }
  const unmerged = consumer.scope.objects.unmergedComponents.getEntry(component.name);
  if (unmerged) {
    throw new (_generalError().default)(`component ${component.id.toStringWithoutVersion()} is in during-merge state, please snap/tag it first (or use bit merge --resolve/--abort)`);
  }
  const otherComponent = await consumer.loadComponentFromModel(component.id.changeVersion(version));
  const mergeResults = await (0, _twoWayMerge().default)({
    consumer,
    otherComponent,
    otherVersion: version,
    currentComponent: component,
    // $FlowFixMe
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    currentVersion: currentlyUsedVersion
  });
  return {
    componentFromFS: component,
    id: component.id,
    mergeResults
  };
}

/**
 * it doesn't matter whether the component is modified. the idea is to merge the
 * specified version with the current version.
 *
 * 1) when there are conflicts and the strategy is "ours", don't do any change to the component.
 *
 * 2) when there are conflicts and the strategy is "theirs", add all files from the specified
 * version and write the component.
 *
 * 3) when there is no conflict or there are conflicts and the strategy is manual, update
 * component.files.
 *
 * it's going to be 2-way merge:
 * current-file: is the current file.
 * base-file: empty.
 * other-file: the specified version.
 */
async function applyVersion(consumer, id, componentFromFS, mergeResults, mergeStrategy) {
  const filesStatus = {};
  if (mergeResults.hasConflicts && mergeStrategy === MergeOptions.ours) {
    componentFromFS.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      filesStatus[(0, _path2().pathNormalizeToLinux)(file.relative)] = FileStatus.unchanged;
    });
    return {
      id,
      filesStatus
    };
  }
  const component = componentFromFS.componentFromModel;
  if (!component) throw new (_generalError().default)('failed finding the component in the model');
  const componentMap = componentFromFS.componentMap;
  if (!componentMap) throw new (_generalError().default)('applyVersion: componentMap was not found');
  const files = componentFromFS.files;
  component.files = files;
  files.forEach(file => {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    filesStatus[(0, _path2().pathNormalizeToLinux)(file.relative)] = FileStatus.unchanged;
  });

  // update files according to the merge results
  const modifiedStatus = applyModifiedVersion(consumer, files, mergeResults, mergeStrategy);
  const componentWriter = new (_componentWriter().default)({
    component,
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    writeToPath: (0, _path2().pathNormalizeToLinux)(component.files[0].base),
    // find the current path from the files. (we use the first one but it's the same for all)
    writeConfig: false,
    // never override the existing bit.json
    writePackageJson: false,
    deleteBitDirContent: false,
    consumer,
    bitMap: consumer.bitMap,
    existingComponentMap: componentMap
  });
  await componentWriter.write();
  consumer.bitMap.removeComponent(component.id);
  componentWriter.addComponentToBitMap(componentMap.rootDir);
  return {
    id,
    filesStatus: Object.assign(filesStatus, modifiedStatus)
  };
}
function applyModifiedVersion(consumer, componentFiles, mergeResults, mergeStrategy) {
  const filesStatus = {};
  mergeResults.modifiedFiles.forEach(file => {
    const filePath = path().normalize(file.filePath);
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const foundFile = componentFiles.find(componentFile => componentFile.relative === filePath);
    if (!foundFile) throw new (_generalError().default)(`file ${filePath} not found`);
    if (mergeResults.hasConflicts && mergeStrategy === MergeOptions.theirs) {
      // write the version of otherFile
      const otherFile = file.otherFile;
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      foundFile.contents = otherFile.contents;
      filesStatus[file.filePath] = FileStatus.updated;
    } else if (file.conflict) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      foundFile.contents = Buffer.from(file.conflict);
      filesStatus[file.filePath] = FileStatus.manual;
    } else if (typeof file.output === 'string') {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      foundFile.contents = Buffer.from(file.output);
      filesStatus[file.filePath] = FileStatus.merged;
    } else {
      throw new (_generalError().default)('file does not have output nor conflict');
    }
  });
  mergeResults.addFiles.forEach(file => {
    const otherFile = file.otherFile;
    componentFiles.push(otherFile);
    filesStatus[file.filePath] = FileStatus.added;
  });
  return filesStatus;
}
async function getMergeStrategyInteractive() {
  try {
    const result = await (0, _prompts().resolveConflictPrompt)();
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return mergeOptionsCli[result.mergeStrategy];
  } catch (err) {
    // probably user clicked ^C
    throw new (_generalError().default)('the action has been canceled');
  }
}
function getMergeStrategy(ours, theirs, manual) {
  if (ours && theirs || ours && manual || theirs && manual) {
    throw new (_generalError().default)('please choose only one of the following: ours, theirs or manual');
  }
  if (ours) return MergeOptions.ours;
  if (theirs) return MergeOptions.theirs;
  if (manual) return MergeOptions.manual;
  return null;
}
const applyVersionReport = (components, addName = true, showVersion = false) => {
  const tab = addName ? '\t' : '';
  return components.map(component => {
    const name = showVersion ? component.id.toString() : component.id.toStringWithoutVersion();
    const files = Object.keys(component.filesStatus).map(file => {
      const note = component.filesStatus[file] === FileStatus.manual ? _chalk().default.white('automatic merge failed. please fix conflicts manually and then run "bit install" and "bit compile"') : '';
      return `${tab}${component.filesStatus[file]} ${_chalk().default.bold(file)} ${note}`;
    }).join('\n');
    return `${addName ? name : ''}\n${_chalk().default.cyan(files)}`;
  }).join('\n\n');
};
exports.applyVersionReport = applyVersionReport;
function conflictSummaryReport(components) {
  const tab = '\t';
  return (0, _lodash().compact)(components.map(component => {
    const name = component.id.toStringWithoutVersion();
    const files = (0, _lodash().compact)(Object.keys(component.filesStatus).map(file => {
      if (component.filesStatus[file] === FileStatus.manual) {
        return `${tab}${component.filesStatus[file]} ${_chalk().default.bold(file)}`;
      }
      return null;
    }));
    if (!files.length) return null;
    return `${name}\n${_chalk().default.cyan(files.join('\n'))}`;
  })).join('\n');
}