"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _tmp() {
  const data = _interopRequireDefault(require("../../../scope/repositories/tmp"));
  _tmp = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _mergeFiles() {
  const data = _interopRequireDefault(require("../../../utils/merge-files"));
  _mergeFiles = function () {
    return data;
  };
  return data;
}
var twoWayMergeVersions = async function twoWayMergeVersions({
  consumer,
  otherComponent,
  otherVersion,
  currentComponent,
  currentVersion
}) {
  const otherFiles = otherComponent.files;
  const currentFiles = currentComponent.files;
  const results = {
    addFiles: [],
    modifiedFiles: [],
    unModifiedFiles: [],
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    overrideFiles: [],
    hasConflicts: false
  };
  const getFileResult = (otherFile, currentFile) => {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const filePath = (0, _utils().pathNormalizeToLinux)(otherFile.relative);
    if (!currentFile) {
      results.addFiles.push({
        filePath,
        otherFile
      });
      return;
    }
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const otherFileHash = (0, _utils().sha1)(otherFile.contents);
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const currentFileHash = (0, _utils().sha1)(currentFile.contents);
    if (otherFileHash === currentFileHash) {
      results.unModifiedFiles.push({
        filePath,
        currentFile
      });
      return;
    }
    // it was changed in both, there is a chance for conflict
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    currentFile.version = currentVersion;
    // $FlowFixMe it's a hack to pass the data, version is not a valid attribute.
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    otherFile.version = otherVersion;
    results.modifiedFiles.push({
      filePath,
      currentFile,
      otherFile,
      output: null,
      conflict: null
    });
  };
  otherFiles.forEach(otherFile => {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const currentFile = currentFiles.find(file => file.relative === otherFile.relative);
    getFileResult(otherFile, currentFile);
  });
  if ((0, _isEmpty2().default)(results.modifiedFiles)) return results;
  const conflictResults = await getMergeResults(consumer, results.modifiedFiles);
  conflictResults.forEach(conflictResult => {
    const modifiedFile = results.modifiedFiles.find(file => file.filePath === conflictResult.filePath);
    if (!modifiedFile) throw new (_generalError().default)(`unable to find ${conflictResult.filePath} in modified files array`);
    modifiedFile.output = conflictResult.output;
    modifiedFile.conflict = conflictResult.conflict;
    if (conflictResult.conflict) results.hasConflicts = true;
  });
  return results;
};
exports.default = twoWayMergeVersions;
async function getMergeResults(consumer,
// @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
modifiedFiles) {
  const tmp = new (_tmp().default)(consumer.scope);
  const conflictResultsP = modifiedFiles.map(async modifiedFile => {
    const currentFilePathP = tmp.save(modifiedFile.currentFile.contents);
    const writeFile = async file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return tmp.save(file.contents);
    };
    const baseFilePathP = tmp.save('');
    const otherFilePathP = writeFile(modifiedFile.otherFile);
    const [otherFilePath, baseFilePath, currentFilePath] = await Promise.all([otherFilePathP, baseFilePathP, currentFilePathP]);
    const mergeFilesParams = {
      filePath: modifiedFile.filePath,
      currentFile: {
        label: modifiedFile.currentFile.version,
        path: currentFilePath
      },
      baseFile: {
        path: baseFilePath
      },
      otherFile: {
        label: modifiedFile.otherFile.version,
        path: otherFilePath
      }
    };
    return (0, _mergeFiles().default)(mergeFilesParams);
  });
  return Promise.all(conflictResultsP);
}