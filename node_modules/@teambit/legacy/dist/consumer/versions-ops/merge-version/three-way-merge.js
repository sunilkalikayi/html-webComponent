"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = threeWayMergeVersions;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _repositories() {
  const data = require("../../../scope/repositories");
  _repositories = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _mergeFiles() {
  const data = _interopRequireDefault(require("../../../utils/merge-files"));
  _mergeFiles = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("../../../utils/path");
  _path = function () {
    return data;
  };
  return data;
}
function _sources() {
  const data = require("../../component/sources");
  _sources = function () {
    return data;
  };
  return data;
}
/**
 * to do the actual merge we use git, specifically `merge-file` command, so we try to use the same
 * terminology as git. From the command help:
 * `git merge-file <current-file> <base-file> <other-file>
 * git merge-file incorporates all changes that lead from the <base-file> to <other-file> into
 * <current-file>. The result ordinarily goes into <current-file>.`
 *
 * see checkout-version.getBaseVersion() for a case when a component is modified and then the base-file is not the
 * common file before other-file and current-file.
 * otherwise, Git terminology pretty much reflects what we do here. current-file is the one that is currently written
 * to the filesystem. other-file is the one the user wants to checkout to. base-file is the original file where both:
 * base-file and other-file were originated from.
 */
async function threeWayMergeVersions({
  consumer,
  otherComponent,
  otherLabel,
  currentComponent,
  currentLabel,
  baseComponent
}) {
  // baseFiles and currentFiles come from the model, therefore their paths include the
  // sharedOriginallyDir. fsFiles come from the Fs, therefore their paths don't include the
  // sharedOriginallyDir.
  // option 1) strip sharedOriginallyDir from baseFiles and currentFiles. the problem is that the
  // sharedDir can be different if the dependencies were changes for example, as a result, it won't
  // be possible to compare between the files as the paths are different.
  // in the previous it was implemented this way and caused a bug, which now has an e2e-test to
  // block it. see https://github.com/teambit/bit/pull/2070 PR.
  // option 2) add sharedOriginallyDir to the fsFiles. we must go with this option.
  // one thing we have to change is the end-of-line, it should be set as LF, same way we do before
  // saving the file as an object.
  const baseFiles = baseComponent.files;
  const otherFiles = otherComponent.files;
  const currentFiles = currentComponent.cloneFilesWithSharedDir();
  currentFiles.forEach(fsFile => {
    fsFile.contents = _utils().eol.lf(fsFile.contents);
  });
  const results = {
    addFiles: [],
    removeFiles: [],
    remainDeletedFiles: [],
    modifiedFiles: [],
    unModifiedFiles: [],
    overrideFiles: [],
    updatedFiles: [],
    hasConflicts: false
  };
  const getFileResult = async (fsFile, baseFile, otherFile) => {
    const filePath = (0, _path().pathNormalizeToLinux)(fsFile.relative);
    if (!otherFile) {
      // if !otherFile && !baseFile, the file was created after the last tag, no need to do any
      // calculation, the file should be added
      if (!baseFile) {
        results.addFiles.push({
          filePath,
          fsFile
        });
        return;
      }
      // if !otherFile && baseFile, the file was created as part of the last tag but not
      // available on the other, so it needs to be removed.
      results.removeFiles.push({
        filePath
      });
      return;
    }
    if (!baseFile) {
      // if otherFile && !baseFile, the file was deleted as part of the last tag
      results.overrideFiles.push({
        filePath,
        fsFile
      });
      return;
    }
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const fsFileHash = (0, _utils().sha1)(fsFile.contents);
    const baseFileHash = baseFile.file.hash;
    const otherFileHash = otherFile.file.hash;
    if (fsFileHash === otherFileHash) {
      // if fs === other, no need to take any action (regardless the base)
      results.unModifiedFiles.push({
        filePath,
        fsFile
      });
      return;
    }
    if (fsFileHash === baseFileHash) {
      // the file has no local modification.
      // the file currently in the fs, is not the same as the file we want to write (other).
      // but no need to check whether it has conflicts because we always want to write the other.
      const content = await otherFile.file.load(consumer.scope.objects);
      results.updatedFiles.push({
        filePath,
        otherFile,
        content: content.contents
      });
      return;
    }
    // it was changed in both, there is a chance for conflict
    fsFile.label = currentLabel;
    // @ts-ignore it's a hack to pass the data, version is not a valid attribute.
    otherFile.label = otherLabel;
    results.modifiedFiles.push({
      filePath,
      fsFile,
      baseFile,
      otherFile,
      output: null,
      conflict: null
    });
  };
  await Promise.all(currentFiles.map(async fsFile => {
    const relativePath = (0, _path().pathNormalizeToLinux)(fsFile.relative);
    const baseFile = baseFiles.find(file => file.relativePath === relativePath);
    const otherFile = otherFiles.find(file => file.relativePath === relativePath);
    await getFileResult(fsFile, baseFile, otherFile);
  }));
  const fsFilesPaths = currentFiles.map(fsFile => (0, _path().pathNormalizeToLinux)(fsFile.relative));
  const baseFilesPaths = baseFiles.map(baseFile => baseFile.relativePath);
  const deletedFromFs = otherFiles.filter(otherFile => !fsFilesPaths.includes(otherFile.relativePath) && baseFilesPaths.includes(otherFile.relativePath));
  const addedOnOther = otherFiles.filter(otherFile => !fsFilesPaths.includes(otherFile.relativePath) && !baseFilesPaths.includes(otherFile.relativePath));
  deletedFromFs.forEach(file => results.remainDeletedFiles.push({
    filePath: file.relativePath
  }));
  await Promise.all(addedOnOther.map(async file => {
    const fsFile = await _sources().SourceFile.loadFromSourceFileModel(file, consumer.scope.objects);
    results.addFiles.push({
      filePath: file.relativePath,
      fsFile
    });
  }));
  if ((0, _isEmpty2().default)(results.modifiedFiles)) return results;
  const conflictResults = await getMergeResults(consumer, results.modifiedFiles);
  conflictResults.forEach(conflictResult => {
    const modifiedFile = results.modifiedFiles.find(file => file.filePath === conflictResult.filePath);
    if (!modifiedFile) throw new (_generalError().default)(`unable to find ${conflictResult.filePath} in modified files array`);
    modifiedFile.output = conflictResult.output;
    modifiedFile.conflict = conflictResult.conflict;
    modifiedFile.isBinaryConflict = conflictResult.isBinaryConflict;
    if (conflictResult.conflict || conflictResult.isBinaryConflict) results.hasConflicts = true;
  });
  return results;
}
async function getMergeResults(consumer, modifiedFiles) {
  const tmp = new (_repositories().Tmp)(consumer.scope);
  const conflictResultsP = modifiedFiles.map(async modifiedFile => {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const fsFilePathP = tmp.save(modifiedFile.fsFile.contents);
    const writeFile = async file => {
      const content = await file.file.load(consumer.scope.objects);
      // @ts-ignore
      return tmp.save(content.contents.toString());
    };
    const baseFilePathP = writeFile(modifiedFile.baseFile);
    const otherFilePathP = writeFile(modifiedFile.otherFile);
    const [fsFilePath, baseFilePath, otherFilePath] = await Promise.all([fsFilePathP, baseFilePathP, otherFilePathP]);
    const mergeFilesParams = {
      filePath: modifiedFile.filePath,
      currentFile: {
        label: modifiedFile.fsFile.label,
        path: fsFilePath
      },
      baseFile: {
        path: baseFilePath
      },
      otherFile: {
        // @ts-ignore
        label: modifiedFile.otherFile.label,
        path: otherFilePath
      }
    };
    return (0, _mergeFiles().default)(mergeFilesParams);
  });
  return Promise.all(conflictResultsP);
}