import { Consumer } from '..';
import { BitId } from '../../bit-id';
import { ComponentWithDependencies } from '../../scope';
import Version from '../../scope/models/version';
import ConsumerComponent from '../component';
import { SourceFile } from '../component/sources';
import { ApplyVersionResult, MergeStrategy } from './merge-version';
import { MergeResultsThreeWay } from './merge-version/three-way-merge';
export declare type CheckoutProps = {
    version?: string;
    ids?: BitId[];
    latestVersion?: boolean;
    promptMergeOptions?: boolean;
    mergeStrategy?: MergeStrategy | null;
    verbose?: boolean;
    skipNpmInstall?: boolean;
    ignorePackageJson?: boolean;
    writeConfig?: boolean;
    reset?: boolean;
    all?: boolean;
    ignoreDist?: boolean;
    isLane?: boolean;
};
export declare type ComponentStatus = {
    componentFromFS?: ConsumerComponent;
    componentFromModel?: Version;
    id: BitId;
    failureMessage?: string;
    unchangedLegitimately?: boolean;
    mergeResults?: MergeResultsThreeWay | null | undefined;
};
declare type ApplyVersionWithComps = {
    applyVersionResult: ApplyVersionResult;
    component?: ComponentWithDependencies;
};
/**
 * 1) when the files are modified with conflicts and the strategy is "ours", leave the FS as is
 * and update only bitmap id version. (not the componentMap object).
 *
 * 2) when the files are modified with conflicts and the strategy is "theirs", write the component
 * according to id.version.
 *
 * 3) when files are modified with no conflict or files are modified with conflicts and the
 * strategy is manual, load the component according to id.version and update component.files.
 * applyModifiedVersion() docs explains what files are updated/added.
 *
 * 4) when --reset flag is used, write the component according to the bitmap version
 *
 * Side note:
 * Deleted file => if files are in used version but not in the modified one, no need to delete it. (similar to git).
 * Added file => if files are not in used version but in the modified one, they'll be under mergeResults.addFiles
 */
export declare function applyVersion(consumer: Consumer, id: BitId, componentFromFS: ConsumerComponent | null | undefined, // it can be null only when isLanes is true
mergeResults: MergeResultsThreeWay | null | undefined, checkoutProps: CheckoutProps): Promise<ApplyVersionWithComps>;
/**
 * relevant only when
 * 1) there is no conflict => add files from mergeResults: addFiles, overrideFiles and modifiedFiles.output.
 * 2) there is conflict and mergeStrategy is manual => add files from mergeResults: addFiles, overrideFiles and modifiedFiles.conflict.
 *
 * this function only updates the files content, it doesn't write the files
 */
export declare function applyModifiedVersion(componentFiles: SourceFile[], mergeResults: MergeResultsThreeWay, mergeStrategy: MergeStrategy | null | undefined): {
    filesStatus: Record<string, any>;
    modifiedFiles: SourceFile[];
};
/**
 * when files exist on the filesystem but not on the checked out versions, they need to be deleted.
 * this function only mark them as such. later `deleteFilesIfNeeded()` will delete them
 */
export declare function markFilesToBeRemovedIfNeeded(succeededComponents: ComponentStatus[], componentsResults: ApplyVersionWithComps[]): void;
/**
 * it's needed in case the checked out version removed files that exist on the current version.
 * without this function, these files would be left on the filesystem.
 */
export declare function deleteFilesIfNeeded(componentsResults: ApplyVersionWithComps[], consumer: Consumer): Promise<void>;
export {};
