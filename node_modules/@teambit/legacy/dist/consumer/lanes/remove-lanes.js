"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeLanes;
function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));
  _flatten2 = function () {
    return data;
  };
  return data;
}
function _groupArray() {
  const data = _interopRequireDefault(require("group-array"));
  _groupArray = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _enrichContextFromGlobal() {
  const data = _interopRequireDefault(require("../../hooks/utils/enrich-context-from-global"));
  _enrichContextFromGlobal = function () {
    return data;
  };
  return data;
}
function _remotes() {
  const data = require("../../remotes");
  _remotes = function () {
    return data;
  };
  return data;
}
function _scopeRemotes() {
  const data = require("../../scope/scope-remotes");
  _scopeRemotes = function () {
    return data;
  };
  return data;
}
async function removeLanes(consumer, lanes, remote, force) {
  if (remote) {
    const remoteLaneIds = lanes.map(lane => _laneId().LaneId.parse(lane));
    const results = await removeRemoteLanes(consumer, remoteLaneIds, force);
    const laneResults = (0, _flatten2().default)(results.map(r => r.removedLanes));
    return {
      laneResults
    };
  }
  if (!consumer) throw new Error('consumer must exist for local removal');
  await consumer.scope.lanes.removeLanes(consumer.scope, lanes, force, consumer.getCurrentLaneId().name);
  return {
    laneResults: lanes
  };
}
async function removeRemoteLanes(consumer, lanes, force) {
  const groupedLanesByScope = (0, _groupArray().default)(lanes, 'scope');
  const remotes = consumer ? await (0, _scopeRemotes().getScopeRemotes)(consumer.scope) : await _remotes().Remotes.getGlobalRemotes();
  const context = {};
  (0, _enrichContextFromGlobal().default)(context);
  const removeP = Object.keys(groupedLanesByScope).map(async key => {
    const resolvedRemote = await remotes.resolve(key, consumer === null || consumer === void 0 ? void 0 : consumer.scope);
    const idsStr = groupedLanesByScope[key].map(id => id.name);
    return resolvedRemote.deleteMany(idsStr, force, context, true);
  });
  return Promise.all(removeP);
}