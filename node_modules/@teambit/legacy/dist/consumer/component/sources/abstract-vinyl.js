"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._verboseMsg = _verboseMsg;
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _vinyl() {
  const data = _interopRequireDefault(require("vinyl"));
  _vinyl = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _source() {
  const data = _interopRequireDefault(require("../../../scope/models/source"));
  _source = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class AbstractVinyl extends _vinyl().default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2().default)(this, "override", true);
    (0, _defineProperty2().default)(this, "verbose", false);
  }
  static fromVinyl(vinyl) {
    if (vinyl instanceof AbstractVinyl) return vinyl;
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return new AbstractVinyl(vinyl);
  }
  get relativeDir() {
    return path().dirname(this.relative);
  }

  // Update the base path and keep the relative value to be the same
  updatePaths({
    newBase,
    newRelative,
    newCwd
  }) {
    const relative = newRelative || this.relative;
    const base = newBase || this.base;
    if (newCwd) this.cwd = newCwd;
    this.base = base;
    this.path = path().join(this.base, relative);
  }
  async write(writePath,
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  override = this.override, verbose = this.verbose) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const filePath = writePath || this.path;
    const msg = _verboseMsg(filePath, override);
    if (verbose) {
      console.log(msg); // eslint-disable-line no-console
    }

    _logger().default.debug(msg);
    if (!override && _fsExtra().default.existsSync(filePath)) return null;
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    await _fsExtra().default.outputFile(filePath, _utils().eol.auto(this.contents));
    return filePath;
  }
  toReadableString() {
    return {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      relativePath: this.relative,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      content: this.contents.toString()
    };
  }
  static loadFromParsedStringBase(parsedString) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const contents = Buffer.isBuffer(parsedString._contents) ? parsedString._contents : Buffer.from(parsedString._contents);
    return {
      cwd: parsedString._cwd,
      path: parsedString.history[parsedString.history.length - 1],
      base: parsedString._base,
      contents
    };
  }

  /**
   * before saving component files in the model, their EOL should be converted to Linux format so
   * then when working on the same components in Windows and Linux they won't appear as modified
   */
  toSourceAsLinuxEOL() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return _source().default.from(_utils().eol.lf(this.contents));
  }
  async _getStatIfFileExists() {
    try {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return await _fsExtra().default.lstat(this.path);
    } catch (err) {
      return null; // probably file does not exist
    }
  }
}

/**
 * Generate message for the logs and for output in case of verbose
 * this function is exported for testing purposes
 */
exports.default = AbstractVinyl;
function _verboseMsg(filePath, force) {
  const msg = `writing a file to the file-system at ${filePath}, force: ${force.toString()}`;
  return msg;
}