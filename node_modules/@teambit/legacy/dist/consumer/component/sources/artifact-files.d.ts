import { BitId } from '../../../bit-id';
import { Scope } from '../../../scope';
import { Source } from '../../../scope/models';
import { Ref } from '../../../scope/objects';
import { ExtensionDataList } from '../../config';
import Component from '../consumer-component';
import { ArtifactVinyl } from './artifact';
export declare type ArtifactRef = {
    relativePath: string;
    ref: Ref;
    url?: string;
};
export declare type ArtifactModel = {
    relativePath: string;
    file: string;
    url?: string;
};
export declare type ArtifactSource = {
    relativePath: string;
    source: Source;
    url?: string;
};
export declare type ArtifactObject = {
    name: string;
    description?: string;
    generatedBy: string;
    storage: string;
    task: {
        id: string;
        name?: string;
    };
    files: ArtifactFiles;
};
declare type ArtifactFilesObject = {
    paths?: string[];
    vinyls?: ArtifactVinyl[];
    refs?: ArtifactRef[];
};
/**
 * Artifacts utilize lazy loading mechanism. As such, when loading them from the objects, they are
 * not converted to ArtifactVinyl[]. Instead, they are loaded as ArtifactRef[].
 * Later, when they're needed, the `getVinylsAndImportIfMissing` method is used to load them and if
 * needed, to import them from a remote.
 *
 * the workflow of an artifact during the tag is as follows:
 * 1. First, it got created on a capsule and saved to the ConsumerComponent as ArtifactVinyl.
 * 2. On tag, it is transformed to ArtifactSource in order to save the Sources (BitObjects) in the objects.
 * 3. Finally, once the Version object is saved, it needs to save only the hash of the artifacts, hence ArtifactModel.
 */
export declare class ArtifactFiles {
    paths: string[];
    vinyls: ArtifactVinyl[];
    refs: ArtifactRef[];
    constructor(paths?: string[], vinyls?: ArtifactVinyl[], refs?: ArtifactRef[]);
    clone(): ArtifactFiles;
    populateRefsFromSources(sources: ArtifactSource[]): void;
    populateVinylsFromPaths(rootDir: string): void;
    getExistingVinyls(): ArtifactVinyl[];
    isEmpty(): boolean;
    static fromModel(artifactModels?: ArtifactModel[]): ArtifactFiles;
    static fromObject(obj: ArtifactFilesObject): ArtifactFiles;
    static fromVinylsToSources(vinyls: ArtifactVinyl[]): ArtifactSource[];
    getVinylsAndImportIfMissing(id: BitId, scope: Scope): Promise<ArtifactVinyl[]>;
}
export declare function importMultipleDistsArtifacts(scope: Scope, components: Component[]): Promise<void>;
export declare function refsToModelObjects(refs: ArtifactRef[]): ArtifactModel[];
export declare function getRefsFromExtensions(extensions: ExtensionDataList): Ref[];
export declare function getArtifactFilesByExtension(extensions: ExtensionDataList, extensionName: string): ArtifactFiles[];
export declare function convertBuildArtifactsToModelObject(extensions: ExtensionDataList): void;
export declare function convertBuildArtifactsFromModelObject(extensions: ExtensionDataList): void;
export declare function getArtifactsFiles(extensions: ExtensionDataList): ArtifactFiles[];
export declare function reStructureBuildArtifacts(extensions: ExtensionDataList): void;
export declare function deserializeArtifactFiles(obj: {
    paths: string[];
    vinyls: ArtifactVinyl[];
    refs: ArtifactRef[];
}): ArtifactFiles;
export {};
