"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArtifactFiles = void 0;
exports.convertBuildArtifactsFromModelObject = convertBuildArtifactsFromModelObject;
exports.convertBuildArtifactsToModelObject = convertBuildArtifactsToModelObject;
exports.deserializeArtifactFiles = deserializeArtifactFiles;
exports.getArtifactFilesByExtension = getArtifactFilesByExtension;
exports.getArtifactsFiles = getArtifactsFiles;
exports.getRefsFromExtensions = getRefsFromExtensions;
exports.importMultipleDistsArtifacts = importMultipleDistsArtifacts;
exports.reStructureBuildArtifacts = reStructureBuildArtifacts;
exports.refsToModelObjects = refsToModelObjects;
function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));
  _flatten2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _showDoctorError() {
  const data = _interopRequireDefault(require("../../../error/show-doctor-error"));
  _showDoctorError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("../../../scope/component-ops/scope-components-importer"));
  _scopeComponentsImporter = function () {
    return data;
  };
  return data;
}
function _objects() {
  const data = require("../../../scope/objects");
  _objects = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _artifact() {
  const data = require("./artifact");
  _artifact = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * Artifacts utilize lazy loading mechanism. As such, when loading them from the objects, they are
 * not converted to ArtifactVinyl[]. Instead, they are loaded as ArtifactRef[].
 * Later, when they're needed, the `getVinylsAndImportIfMissing` method is used to load them and if
 * needed, to import them from a remote.
 *
 * the workflow of an artifact during the tag is as follows:
 * 1. First, it got created on a capsule and saved to the ConsumerComponent as ArtifactVinyl.
 * 2. On tag, it is transformed to ArtifactSource in order to save the Sources (BitObjects) in the objects.
 * 3. Finally, once the Version object is saved, it needs to save only the hash of the artifacts, hence ArtifactModel.
 */
class ArtifactFiles {
  constructor(paths = [], vinyls = [], refs = []) {
    this.paths = paths;
    this.vinyls = vinyls;
    this.refs = refs;
  }
  clone() {
    const vinyls = this.vinyls.map(vinyl => vinyl.clone());
    const refs = this.refs.map(ref => _objectSpread({}, ref));
    return new ArtifactFiles(_objectSpread({}, this.paths), vinyls, refs);
  }
  populateRefsFromSources(sources) {
    this.refs = sources.map(source => ({
      relativePath: source.relativePath,
      ref: source.source.hash(),
      url: source.url
    }));
  }
  populateVinylsFromPaths(rootDir) {
    this.vinyls = this.paths.map(file => new (_artifact().ArtifactVinyl)({
      path: file,
      contents: _fsExtra().default.readFileSync(_path().default.join(rootDir, file))
    }));
  }
  getExistingVinyls() {
    return this.vinyls;
  }
  isEmpty() {
    return !this.vinyls.length && !this.refs.length && !this.paths.length;
  }
  static fromModel(artifactModels = []) {
    const refs = artifactModels.map(artifactModel => ({
      relativePath: artifactModel.relativePath,
      ref: _objects().Ref.from(artifactModel.file),
      url: artifactModel.url
    }));
    return new ArtifactFiles([], [], refs);
  }
  static fromObject(obj) {
    var _obj$refs;
    const refs = (_obj$refs = obj.refs) === null || _obj$refs === void 0 ? void 0 : _obj$refs.map(ref => {
      const artifactRef = {
        relativePath: ref.relativePath,
        url: ref.url,
        ref: new (_objects().Ref)(ref.ref.hash)
      };
      return artifactRef;
    });
    return new ArtifactFiles(obj.paths, obj.vinyls, refs);
  }
  static fromVinylsToSources(vinyls) {
    return vinyls.map(artifact => {
      return {
        relativePath: (0, _utils().pathNormalizeToLinux)(artifact.relative),
        source: artifact.toSourceAsLinuxEOL(),
        url: artifact.url
      };
    });
  }
  async getVinylsAndImportIfMissing(id, scope) {
    if (this.isEmpty()) return [];
    if (this.vinyls.length) return this.vinyls;
    const allHashes = this.refs.map(artifact => artifact.ref.hash);
    const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(scope);
    const lane = await scope.getCurrentLaneObject();
    const unmergedEntry = scope.objects.unmergedComponents.getEntry(id.name);
    let errorFromUnmergedLaneScope;
    if (unmergedEntry !== null && unmergedEntry !== void 0 && unmergedEntry.laneId) {
      try {
        _logger().default.debug(`getVinylsAndImportIfMissing, trying to get artifacts for ${id.toString()} from unmerged-lane-id: ${unmergedEntry.laneId.toString()}`);
        await scopeComponentsImporter.importManyObjects({
          [unmergedEntry.laneId.scope]: allHashes
        });
      } catch (err) {
        _logger().default.debug(`getVinylsAndImportIfMissing, unable to get artifacts for ${id.toString()} from ${unmergedEntry.laneId.toString()}`);
        errorFromUnmergedLaneScope = err;
      }
    }
    const isIdOnLane = await scope.isIdOnLane(id, lane);
    const scopeName = isIdOnLane ? lane === null || lane === void 0 ? void 0 : lane.scope : id.scope;
    try {
      await scopeComponentsImporter.importManyObjects({
        [scopeName]: allHashes
      });
    } catch (err) {
      if (!unmergedEntry || errorFromUnmergedLaneScope) {
        _logger().default.error('failed fetching the following hashes', {
          id,
          isIdOnLane,
          scopeName,
          allHashes
        });
        throw err;
      }
      // unmergedEntry is set, and it was able to fetch from the unmerged-lane-id scope. all is good.
    }

    const getOneArtifact = async artifact => {
      const content = await artifact.ref.load(scope.objects);
      if (!content) throw new (_showDoctorError().default)(`failed loading file ${artifact.relativePath} from the model`);
      return new (_artifact().ArtifactVinyl)({
        base: '.',
        path: artifact.relativePath,
        contents: content.contents,
        url: artifact.url
      });
    };
    this.vinyls = await Promise.all(this.refs.map(artifact => getOneArtifact(artifact)));
    return this.vinyls;
  }
}
exports.ArtifactFiles = ArtifactFiles;
async function importMultipleDistsArtifacts(scope, components) {
  _logger().default.debug(`importMultipleDistsArtifacts: ${components.length} components: ${components.map(c => c.id.toString()).join(', ')}`);
  const extensionsNamesForDistArtifacts = 'teambit.compilation/compiler';
  const lane = await scope.getCurrentLaneObject();
  const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(scope);
  if (lane) {
    // when on lane, locally, it's possible that not all components have their entire history (e.g. during "bit sign").
    // as a result, the following "scope.isIdOnLane" fails to traverse the history.
    // in terms of performance it's not ideal. once we have the lane-history, it'll be faster to get this data.
    const compsIds = _bitId().BitIds.fromArray(components.map(c => c.id));
    const compsToImport = _bitId().BitIds.uniqFromArray(lane.toBitIds().filter(id => compsIds.hasWithoutVersion(id)));
    await scopeComponentsImporter.importManyDeltaWithoutDeps(compsToImport, true, lane, true);
    // fetch also the components from main, otherwise, in some cases, you'll get an error: "error: version "some-snap" of component some-comp was not found on the filesystem."
    await scopeComponentsImporter.importManyDeltaWithoutDeps(compsToImport.toVersionLatest(), true, undefined, true);
  }
  const groupedHashes = {};
  const debugHashesOrigin = {};
  await Promise.all(components.map(async component => {
    const artifactsFiles = getArtifactFilesByExtension(component.extensions, extensionsNamesForDistArtifacts);
    const isIdOnLane = await scope.isIdOnLane(component.id, lane);
    const scopeName = isIdOnLane ? lane === null || lane === void 0 ? void 0 : lane.scope : component.scope;
    artifactsFiles.forEach(artifactFiles => {
      if (!artifactFiles) return;
      if (!(artifactFiles instanceof ArtifactFiles)) {
        artifactFiles = deserializeArtifactFiles(artifactFiles);
      }
      if (artifactFiles.isEmpty()) return;
      if (artifactFiles.vinyls.length) return;
      const allHashes = artifactFiles.refs.map(artifact => artifact.ref.hash);
      (groupedHashes[scopeName] || (groupedHashes[scopeName] = [])).push(...allHashes);
      allHashes.forEach(hash => debugHashesOrigin[hash] = `id: ${component.id.toString()}. isIdOnLane: ${isIdOnLane}`);
    });
  }));
  try {
    await scopeComponentsImporter.importManyObjects(groupedHashes);
  } catch (err) {
    _logger().default.error('failed fetching the following hashes', {
      groupedHashes,
      debugHashesOrigin
    });
    throw err;
  }
  _logger().default.debug(`importMultipleDistsArtifacts: ${components.length} components. completed successfully`);
}
function refsToModelObjects(refs) {
  return refs.map(artifact => {
    return {
      relativePath: artifact.relativePath,
      file: artifact.ref.hash,
      url: artifact.url
    };
  });
}
function getRefsFromExtensions(extensions) {
  const artifactsFiles = getArtifactsFiles(extensions);
  const refs = artifactsFiles.map(artifactFiles => artifactFiles.refs.map(r => r.ref));
  return (0, _flatten2().default)(refs).filter(ref => ref);
}
function getArtifactFilesByExtension(extensions, extensionName) {
  const buildArtifacts = getBuildArtifacts(extensions);
  return buildArtifacts.filter(artifact => artifact.task.id === extensionName).map(artifact => artifact.files);
}
function convertBuildArtifactsToModelObject(extensions) {
  const buildArtifacts = getBuildArtifacts(extensions);
  buildArtifacts.forEach(artifact => {
    // @ts-ignore
    artifact.files = refsToModelObjects(artifact.files.refs);
  });
}
function convertBuildArtifactsFromModelObject(extensions) {
  const artifactObjects = getBuildArtifacts(extensions);
  artifactObjects.forEach(artifactObject => {
    // @ts-ignore
    artifactObject.files = ArtifactFiles.fromModel(artifactObject.files);
  });
}
function getArtifactsFiles(extensions) {
  const buildArtifacts = getBuildArtifacts(extensions);
  return buildArtifacts.map(artifacts => artifacts.files);
}
function reStructureBuildArtifacts(extensions) {
  const buildArtifacts = getBuildArtifacts(extensions);
  buildArtifacts.forEach(artifacts => {
    artifacts.files = deserializeArtifactFiles(artifacts.files);
  });
}
function deserializeArtifactFiles(obj) {
  const refs = obj.refs.map(ref => ({
    relativePath: ref.relativePath,
    ref: new (_objects().Ref)(ref.ref.hash),
    url: ref.url
  }));
  return new ArtifactFiles(obj.paths, obj.vinyls, refs);
}
function getBuildArtifacts(extensions) {
  var _extensions$findExten, _extensions$findExten2;
  return ((_extensions$findExten = extensions.findExtension('teambit.pipelines/builder')) === null || _extensions$findExten === void 0 ? void 0 : (_extensions$findExten2 = _extensions$findExten.data) === null || _extensions$findExten2 === void 0 ? void 0 : _extensions$findExten2.artifacts) || [];
}