"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _bluebird() {
  const data = _interopRequireDefault(require("bluebird"));
  _bluebird = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _concurrency() {
  const data = require("../../../utils/concurrency");
  _concurrency = function () {
    return data;
  };
  return data;
}
function _removeFilesAndEmptyDirsRecursively() {
  const data = _interopRequireDefault(require("../../../utils/fs/remove-files-and-empty-dirs-recursively"));
  _removeFilesAndEmptyDirsRecursively = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class DataToPersist {
  constructor() {
    (0, _defineProperty2().default)(this, "files", void 0);
    (0, _defineProperty2().default)(this, "symlinks", void 0);
    (0, _defineProperty2().default)(this, "remove", void 0);
    this.files = [];
    this.symlinks = [];
    this.remove = [];
  }
  addFile(file) {
    if (!file) throw new Error('failed adding an empty file into DataToPersist');
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (!file.path) {
      throw new Error('failed adding a file into DataToPersist as it does not have a path property');
    }
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const existingFileIndex = this.files.findIndex(existingFile => existingFile.path === file.path);
    if (existingFileIndex !== -1) {
      if (file.override) {
        // delete existing file
        this.files.splice(existingFileIndex, 1);
      } else {
        // don't push this one. keep the existing file
        return;
      }
    }
    this._throwForDirectoryCollision(file);
    this.files.push(file);
  }
  addManyFiles(files = []) {
    files.forEach(file => this.addFile(file));
  }
  removePath(pathToRemove) {
    if (!pathToRemove) throw new Error('failed adding a path to remove into DataToPersist');
    if (!this.remove.includes(pathToRemove)) {
      this.remove.push(pathToRemove);
    }
  }
  removeManyPaths(pathsToRemove = []) {
    pathsToRemove.forEach(pathToRemove => this.removePath(pathToRemove));
  }
  addSymlink(symlink) {
    if (!symlink.src) throw new Error('failed adding a symlink into DataToPersist, src is empty');
    if (!symlink.dest) throw new Error('failed adding a symlink into DataToPersist, dest is empty');
    this.symlinks.push(symlink);
  }
  addManySymlinks(symlinks = []) {
    symlinks.forEach(symlink => this.addSymlink(symlink));
  }
  merge(dataToPersist) {
    if (!dataToPersist) return;
    this.addManyFiles(dataToPersist.files);
    this.removeManyPaths(dataToPersist.remove);
    this.addManySymlinks(dataToPersist.symlinks);
  }
  async persistAllToFS() {
    this._log();
    this._validateAbsolute();
    // the order is super important. first remove, then create and finally symlink
    await this._deletePathsFromFS();
    await this._persistFilesToFS();
    await this._persistSymlinksToFS();
  }
  async persistAllToCapsule(capsule, opts = {
    keepExistingCapsule: false
  }) {
    this._log();
    this._validateRelative();
    if (!opts.keepExistingCapsule) {
      await Promise.all(this.remove.map(pathToRemove => capsule.removePath(pathToRemove.path)));
    }
    await Promise.all(this.files.map(file => this._writeFileToCapsule(capsule, file, {
      overwriteExistingFile: !!opts.keepExistingCapsule
    })));
    await Promise.all(this.symlinks.map(symlink => this.atomicSymlink(capsule, symlink)));
  }
  async _writeFileToCapsule(capsule, file, opts = {
    overwriteExistingFile: false
  }) {
    // overwriteExistingFile: if a file with the same name exists in the capsule, overwrite it
    if (opts.overwriteExistingFile) {
      await capsule.removePath(file.path);
      return capsule.outputFile(file.path, file.contents, {});
    }
    if (file.override === false) {
      // @todo, capsule hack. use capsule.fs once you get it as a component.
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const capsulePath = capsule.container.getPath();
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const absPath = path().join(capsulePath, file.path);
      try {
        await _fsExtra().default.lstat(absPath); // if no errors have been thrown, the file exists
        _logger().default.debug(`skip file ${absPath}, it already exists`);
        return null;
      } catch (err) {
        if (err.code !== 'ENOENT') {
          throw err;
        }
      }
    }
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return capsule.outputFile(file.path, file.contents);
  }
  async atomicSymlink(capsule, symlink) {
    try {
      await capsule.symlink(symlink.src, symlink.dest);
    } catch (e) {
      // On windows when the link already created by npm we got EPERM error
      // TODO: We should handle this better and avoid creating the symlink if it's already exists
      if (e.code !== 'EEXIST' && e.code !== 'EPERM') {
        throw e;
      } else {
        _logger().default.debug(`ignoring ${e.code} error on atomicSymlink creation`);
      }
    }
  }
  addBasePath(basePath) {
    this.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      this._assertRelative(file.base);
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      file.updatePaths({
        newBase: path().join(basePath, file.base)
      });
    });
    this.symlinks.forEach(symlink => {
      this._assertRelative(symlink.src);
      this._assertRelative(symlink.dest);
      symlink.src = path().join(basePath, symlink.src);
      symlink.dest = path().join(basePath, symlink.dest);
    });
    this.remove.forEach(removePath => {
      this._assertRelative(removePath.path);
      removePath.path = path().join(basePath, removePath.path);
    });
  }
  /**
   * helps for debugging
   */
  toConsole() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    console.log(`\nfiles: ${this.files.map(f => f.path).join('\n')}`); // eslint-disable-line no-console
    console.log(`\nsymlinks: ${this.symlinks.map(s => `src: ${s.src}, dest: ${s.dest}`).join('\n')}`); // eslint-disable-line no-console
    console.log(`remove: ${this.remove.map(r => r.path).join('\n')}`); // eslint-disable-line no-console
  }

  filterByPath(filterFunc) {
    const dataToPersist = new DataToPersist();
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    dataToPersist.addManyFiles(this.files.filter(f => filterFunc(f.path)));
    dataToPersist.removeManyPaths(this.remove.filter(r => filterFunc(r.path)));
    dataToPersist.addManySymlinks(this.symlinks.filter(s => filterFunc(s.dest)));
    return dataToPersist;
  }
  async _persistFilesToFS() {
    const concurrency = (0, _concurrency().concurrentIOLimit)();
    return _bluebird().default.map(this.files, file => file.write(), {
      concurrency
    });
  }
  async _persistSymlinksToFS() {
    const concurrency = (0, _concurrency().concurrentIOLimit)();
    return _bluebird().default.map(this.symlinks, symlink => symlink.write(), {
      concurrency
    });
  }
  async _deletePathsFromFS() {
    const pathWithRemoveItsDirIfEmptyEnabled = this.remove.filter(p => p.removeItsDirIfEmpty).map(p => p.path);
    const restPaths = this.remove.filter(p => !p.removeItsDirIfEmpty);
    if (pathWithRemoveItsDirIfEmptyEnabled.length) {
      await (0, _removeFilesAndEmptyDirsRecursively().default)(pathWithRemoveItsDirIfEmptyEnabled);
    }
    const concurrency = (0, _concurrency().concurrentIOLimit)();
    return _bluebird().default.map(restPaths, removePath => removePath.persistToFS(), {
      concurrency
    });
  }
  _validateAbsolute() {
    // it's important to make sure that all paths are absolute before writing them to the
    // filesystem. relative paths won't work when running bit commands from an inner dir
    const validateAbsolutePath = pathToValidate => {
      if (!path().isAbsolute(pathToValidate)) {
        throw new Error(`DataToPersist expects ${pathToValidate} to be absolute, got relative`);
      }
    };
    this.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      validateAbsolutePath(file.path);
    });
    this.remove.forEach(removePath => {
      validateAbsolutePath(removePath.path);
    });
    this.symlinks.forEach(symlink => {
      validateAbsolutePath(symlink.src);
      validateAbsolutePath(symlink.dest);
    });
  }
  _validateRelative() {
    // it's important to make sure that all paths are relative before writing them to the capsule
    const validateRelativePath = pathToValidate => {
      if (path().isAbsolute(pathToValidate)) {
        throw new Error(`DataToPersist expects ${pathToValidate} to be relative, got absolute`);
      }
    };
    this.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      validateRelativePath(file.path);
    });
    this.remove.forEach(removePath => {
      validateRelativePath(removePath.path);
    });
    this.symlinks.forEach(symlink => {
      validateRelativePath(symlink.src);
      validateRelativePath(symlink.dest);
    });
  }
  _log() {
    if (this.remove.length) {
      const pathToDeleteStr = this.remove.map(r => r.path).join('\n');
      _logger().default.debug(`DataToPersist, paths-to-delete:\n${pathToDeleteStr}`);
    }
    if (this.files.length) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const filesToWriteStr = this.files.map(f => f.path).join('\n');
      _logger().default.debug(`DataToPersist, paths-to-write:\n${filesToWriteStr}`);
    }
    if (this.symlinks.length) {
      const symlinksStr = this.symlinks.map(symlink => `src (existing): ${symlink.src}\ndest (new): ${symlink.dest}`).join('\n');
      _logger().default.debug(`DataToPersist, symlinks:\n${symlinksStr}`);
    }
  }
  _assertRelative(pathToCheck) {
    if (path().isAbsolute(pathToCheck)) {
      throw new Error(`DataToPersist expects ${pathToCheck} to be relative, but found it absolute`);
    }
  }
  /**
   * prevent adding a file which later on will cause an error "EEXIST: file already exists, mkdir {dirname}".
   * this happens one a file is a directory name of the other file.
   * e.g. adding these two files, will cause the error above: "bar/foo" and "bar"
   *
   * to check for this possibility, we need to consider two scenarios:
   * 1) "bar/foo" is there and now adding "bar" => check whether one of the files starts with "bar/"
   * 2) "bar" is there and now adding "bar/foo" => check whether this file "bar/foo" starts with one of the files with '/'
   * practically, it runs `("bar/foo".startsWith("bar/"))` for both cases above.
   */
  _throwForDirectoryCollision(file) {
    const directoryCollision = this.files.find(
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    f => f.path.startsWith(`${file.path}${path().sep}`) || `${file.path}`.startsWith(`${f.path}${path().sep}`));
    if (directoryCollision) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      throw new Error(`unable to add the file "${file.path}", because another file "${directoryCollision.path}" is going to be written.
one of them is a directory of the other one, and is not possible to have them both`);
    }
  }
}
exports.default = DataToPersist;