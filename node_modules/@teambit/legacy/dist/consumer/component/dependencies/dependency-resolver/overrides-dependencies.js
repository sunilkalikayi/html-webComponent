"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _minimatch() {
  const data = _interopRequireDefault(require("minimatch"));
  _minimatch = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = _interopRequireDefault(require("lodash"));
  _lodash = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _packages() {
  const data = require("../../../../utils/packages");
  _packages = function () {
    return data;
  };
  return data;
}
class OverridesDependencies {
  constructor(component, consumer) {
    (0, _defineProperty2().default)(this, "component", void 0);
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "componentMap", void 0);
    (0, _defineProperty2().default)(this, "componentFromModel", void 0);
    (0, _defineProperty2().default)(this, "manuallyRemovedDependencies", void 0);
    (0, _defineProperty2().default)(this, "manuallyAddedDependencies", void 0);
    (0, _defineProperty2().default)(this, "missingPackageDependencies", void 0);
    this.component = component;
    this.consumer = consumer;
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    this.componentMap = this.component.componentMap;
    this.componentFromModel = this.component.componentFromModel;
    this.manuallyRemovedDependencies = {};
    this.manuallyAddedDependencies = {};
    this.missingPackageDependencies = [];
  }
  shouldIgnoreFile(file, fileType) {
    const shouldIgnoreByGlobMatch = patterns => {
      return patterns.some(pattern => (0, _minimatch().default)(file, pattern));
    };
    const field = fileType.isTestFile ? 'devDependencies' : 'dependencies';
    const ignoreField = this.component.overrides.getIgnoredFiles(field);
    const ignore = shouldIgnoreByGlobMatch(ignoreField);
    if (ignore) {
      this._addManuallyRemovedDep(field, file);
    }
    return ignore;
  }
  shouldIgnorePackage(packageName, fileType) {
    const field = fileType.isTestFile ? 'devDependencies' : 'dependencies';
    return this.shouldIgnorePackageByType(packageName, field);
  }
  shouldIgnorePackageByType(packageName, field) {
    const shouldIgnorePackage = packages => {
      return packages.some(pkg => pkg === packageName);
    };
    const ignoreField = this.component.overrides.getIgnoredPackages(field);
    const ignore = shouldIgnorePackage(ignoreField);
    if (ignore) {
      this._addManuallyRemovedDep(field, packageName);
    }
    return ignore;
  }
  shouldIgnorePeerPackage(packageName) {
    const shouldIgnorePackage = packages => {
      return packages.some(pkg => pkg === packageName);
    };
    const field = 'peerDependencies';
    const ignorePeer = this.component.overrides.getIgnoredPackages(field);
    const ignore = shouldIgnorePackage(ignorePeer);
    if (ignore) {
      this._addManuallyRemovedDep(field, packageName);
    }
    return ignore;
  }
  shouldIgnoreComponent(componentId, fileType) {
    const componentIdStr = componentId.toStringWithoutVersion();
    const shouldIgnore = ids => {
      return ids.some(id => {
        return componentId.isEqualWithoutVersion(id) || componentId.isEqualWithoutScopeAndVersion(id);
      });
    };
    const field = fileType.isTestFile ? 'devDependencies' : 'dependencies';
    const ignoredComponents = this._getIgnoredComponentsByField(field);
    const ignore = shouldIgnore(ignoredComponents);
    if (ignore) {
      this._addManuallyRemovedDep(field, componentIdStr);
    }
    return ignore;
  }
  getDependenciesToAddManually(packageJson, existingDependencies) {
    const overrides = this.component.overrides.componentOverridesData;
    if (!overrides) return null;
    const components = {};
    const packages = {};
    _constants().DEPENDENCIES_FIELDS.forEach(depField => {
      if (!overrides[depField]) return;
      Object.keys(overrides[depField]).forEach(dependency => {
        const dependencyValue = overrides[depField][dependency];
        if (dependencyValue === _constants().MANUALLY_REMOVE_DEPENDENCY) return;
        const componentData = this._getComponentIdToAdd(depField, dependency);
        if (componentData && componentData.componentId) {
          const dependencyExist = existingDependencies[depField].find(d => d.id.isEqualWithoutScopeAndVersion(componentData.componentId));
          if (!dependencyExist) {
            this._addManuallyAddedDep(depField, componentData.componentId.toString());
            components[depField] ? components[depField].push(componentData) : components[depField] = [componentData];
          }
          return;
        }
        const addedPkg = this._manuallyAddPackage(depField, dependency, dependencyValue, packageJson);
        if (addedPkg) {
          packages[depField] = Object.assign(packages[depField] || {}, addedPkg);
        }
      });
    });
    return {
      components,
      packages
    };
  }
  _getIgnoredComponentsByField(field) {
    const ignoredPackages = this.component.overrides.getIgnoredPackages(field);
    const ignoredComponents = ignoredPackages.map(packageName => this._getComponentIdFromPackage(packageName));
    return _lodash().default.compact(ignoredComponents);
  }
  _getComponentIdToAdd(field, dependency) {
    if (field === 'peerDependencies') return undefined;
    const packageData = this._resolvePackageData(dependency);
    return {
      componentId: packageData === null || packageData === void 0 ? void 0 : packageData.componentId,
      packageName: packageData === null || packageData === void 0 ? void 0 : packageData.name
    };
  }
  _getComponentIdFromPackage(packageName) {
    const packageData = this._resolvePackageData(packageName);
    return packageData === null || packageData === void 0 ? void 0 : packageData.componentId;
  }
  _manuallyAddPackage(field, dependency, dependencyValue, packageJson) {
    const packageVersionToAdd = () => {
      if (dependencyValue !== _constants().MANUALLY_ADD_DEPENDENCY) {
        return dependencyValue;
      }
      if (!packageJson) return null;
      for (const depField of _constants().DEPENDENCIES_FIELDS) {
        if (packageJson[depField]) {
          const found = Object.keys(packageJson[depField]).find(pkg => pkg === dependency);
          if (found) return packageJson[depField][dependency];
        }
      }
      return null;
    };
    const versionToAdd = packageVersionToAdd();
    if (!versionToAdd) {
      _logger().default.debug(`unable to manually add the dependency "${dependency}" into "${this.component.id.toString()}".
it's not an existing component, nor existing package (in a package.json)`);
      this.missingPackageDependencies.push(dependency);
      return undefined;
    }
    const packageStr = `${dependency}@${versionToAdd}`;
    this._addManuallyAddedDep(field, packageStr);
    return {
      [dependency]: versionToAdd
    };
  }
  _addManuallyRemovedDep(field, value) {
    this.manuallyRemovedDependencies[field] ? this.manuallyRemovedDependencies[field].push(value) : this.manuallyRemovedDependencies[field] = [value];
  }
  _addManuallyAddedDep(field, value) {
    this.manuallyAddedDependencies[field] ? this.manuallyAddedDependencies[field].push(value) : this.manuallyAddedDependencies[field] = [value];
  }

  // TODO: maybe cache those results??
  _resolvePackageData(packageName) {
    const rootDir = this.componentMap.rootDir;
    const consumerPath = this.consumer.getPath();
    const basePath = rootDir ? _path().default.join(consumerPath, rootDir) : consumerPath;
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const modulePath = (0, _packages().resolvePackagePath)(packageName, basePath, consumerPath);
    if (!modulePath) return undefined; // e.g. it's author and wasn't exported yet, so there's no node_modules of that component
    const packageObject = (0, _packages().resolvePackageData)(basePath, modulePath);
    return packageObject;
  }
}
exports.default = OverridesDependencies;