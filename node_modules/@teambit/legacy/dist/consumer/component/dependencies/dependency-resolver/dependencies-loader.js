"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DependenciesLoader = void 0;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _componentIssues() {
  const data = require("@teambit/component-issues");
  _componentIssues = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _lastModified() {
  const data = require("../../../../utils/fs/last-modified");
  _lastModified = function () {
    return data;
  };
  return data;
}
function _config() {
  const data = require("../../../config");
  _config = function () {
    return data;
  };
  return data;
}
function _dependenciesData() {
  const data = require("./dependencies-data");
  _dependenciesData = function () {
    return data;
  };
  return data;
}
function _dependenciesResolver() {
  const data = _interopRequireDefault(require("./dependencies-resolver"));
  _dependenciesResolver = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _componentIssuesTemplate() {
  const data = require("../../../../cli/templates/component-issues-template");
  _componentIssuesTemplate = function () {
    return data;
  };
  return data;
}
class DependenciesLoader {
  constructor(component, consumer, opts) {
    this.component = component;
    this.consumer = consumer;
    this.opts = opts;
    (0, _defineProperty2().default)(this, "idStr", void 0);
    this.idStr = this.component.id.toString();
  }
  async load() {
    const dependenciesData = await this.getDependenciesData();
    this.setDependenciesDataOnComponent(dependenciesData);
  }
  async getDependenciesData() {
    const depsDataFromCache = await this.getDependenciesDataFromCacheIfPossible();
    if (depsDataFromCache) {
      return depsDataFromCache;
    }
    const dependencyResolver = new (_dependenciesResolver().default)(this.component, this.consumer);
    const dependenciesData = await dependencyResolver.getDependenciesData(this.opts.cacheResolvedDependencies, this.opts.cacheProjectAst);
    if (this.shouldSaveInCache(dependenciesData)) {
      await this.consumer.componentFsCache.saveDependenciesDataInCache(this.idStr, dependenciesData.serialize());
    }
    return dependenciesData;
  }
  async getDependenciesDataFromCacheIfPossible() {
    var _this$component$compo;
    if (!this.opts.useDependenciesCache) {
      return null;
    }
    const cacheData = await this.consumer.componentFsCache.getDependenciesDataFromCache(this.idStr);
    if (!cacheData) {
      return null; // probably the first time, so it wasn't entered to the cache yet.
    }

    const rootDir = (_this$component$compo = this.component.componentMap) === null || _this$component$compo === void 0 ? void 0 : _this$component$compo.getComponentDir();
    if (!rootDir) {
      // could happen on legacy only and when there is no trackDir, in which case, we can't
      // determine whether or not a component file has been deleted, as a result, we are unable
      // to invalidate the cache in such a case.
      return null;
    }
    const filesPaths = this.component.files.map(f => f.path);
    const componentConfigPath = _path().default.join(this.consumer.getPath(), rootDir, _constants().COMPONENT_CONFIG_FILE_NAME);
    filesPaths.push(componentConfigPath);
    const lastModifiedComponent = await (0, _lastModified().getLastModifiedComponentTimestampMs)(rootDir, filesPaths);
    const wasModifiedAfterCache = lastModifiedComponent > cacheData.timestamp;
    if (wasModifiedAfterCache) {
      return null; // cache is invalid.
    }

    _logger().default.debug(`dependencies-loader, getting the dependencies data for ${this.idStr} from the cache`);
    return _dependenciesData().DependenciesData.deserialize(cacheData.data);
  }
  shouldSaveInCache(dependenciesData) {
    if (!dependenciesData.issues) return true;
    return !dependenciesData.issues.shouldBlockSavingInCache();
  }
  setDependenciesDataOnComponent(dependenciesData) {
    var _dependenciesData$all, _dependenciesData$all2, _dependenciesData$all3;
    this.component.setDependencies(dependenciesData.allDependencies.dependencies);
    this.component.setDevDependencies(dependenciesData.allDependencies.devDependencies);
    this.component.packageDependencies = (_dependenciesData$all = dependenciesData.allPackagesDependencies.packageDependencies) !== null && _dependenciesData$all !== void 0 ? _dependenciesData$all : {};
    this.component.devPackageDependencies = (_dependenciesData$all2 = dependenciesData.allPackagesDependencies.devPackageDependencies) !== null && _dependenciesData$all2 !== void 0 ? _dependenciesData$all2 : {};
    this.component.peerPackageDependencies = (_dependenciesData$all3 = dependenciesData.allPackagesDependencies.peerPackageDependencies) !== null && _dependenciesData$all3 !== void 0 ? _dependenciesData$all3 : {};
    const missingFromOverrides = dependenciesData.overridesDependencies.missingPackageDependencies;
    if (!(0, _isEmpty2().default)(missingFromOverrides)) {
      dependenciesData.issues.getOrCreate(_componentIssues().IssuesClasses.MissingPackagesDependenciesOnFs).data[_componentIssuesTemplate().MISSING_PACKAGES_FROM_OVERRIDES_LABEL] = missingFromOverrides;
    }
    if (!dependenciesData.issues.isEmpty()) this.component.issues = dependenciesData.issues;
    this.component.manuallyRemovedDependencies = dependenciesData.overridesDependencies.manuallyRemovedDependencies;
    this.component.manuallyAddedDependencies = dependenciesData.overridesDependencies.manuallyAddedDependencies;
    if (dependenciesData.coreAspects.length) {
      this.pushToDependencyResolverExtension('coreAspects', dependenciesData.coreAspects, 'set');
    }
  }
  pushToDependencyResolverExtension(dataField, data, operation = 'add') {
    const depResolverAspectName = _dependenciesResolver().default.getDepResolverAspectName();
    if (!depResolverAspectName) return;
    let extExistOnComponent = true;
    let ext = this.component.extensions.findCoreExtension(depResolverAspectName);
    if (!ext) {
      extExistOnComponent = false;
      // Create new deps resolver extension entry to add to the component with data only
      ext = new (_config().ExtensionDataEntry)(undefined, undefined, depResolverAspectName, undefined, {});
    }
    if (!ext.data[dataField]) ext.data[dataField] = [];
    if (operation === 'add') {
      const existing = ext.data[dataField].find(c => c.packageName === data.packageName);
      if (existing) {
        existing.componentId = data.componentId;
      } else {
        ext.data[dataField].push(data);
      }
    }
    if (operation === 'set') {
      ext.data[dataField] = data;
    }
    if (!extExistOnComponent) {
      this.component.extensions.push(ext);
    }
  }
}
exports.DependenciesLoader = DependenciesLoader;