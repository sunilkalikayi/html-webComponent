"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = updateDependenciesVersions;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function updateDependenciesVersions(consumer, component, debugDependencies) {
  updateDependencies(component.dependencies);
  updateDependencies(component.devDependencies);
  updateExtensions(component.extensions);
  function resolveVersion(id) {
    // @ts-ignore component.componentFromModel is set
    const idFromModel = getIdFromModelDeps(component.componentFromModel, id);
    const idFromBitMap = getIdFromBitMap(id);
    const idFromComponentConfig = getIdFromComponentConfig(id);
    const getFromComponentConfig = () => idFromComponentConfig;
    const getFromBitMap = () => idFromBitMap || null;
    const getFromModel = () => idFromModel || null;
    const debugDep = debugDependencies === null || debugDependencies === void 0 ? void 0 : debugDependencies.find(dep => dep.id.isEqualWithoutVersion(id));

    // @todo: change this once vendors feature is in.
    const getCurrentVersion = () => id.hasVersion() ? id : null;
    const strategies = [getFromComponentConfig, getCurrentVersion, getFromBitMap, getFromModel];
    for (const strategy of strategies) {
      const strategyId = strategy();
      if (strategyId) {
        _logger().default.debug(`found dependency version ${strategyId.version} for ${id.toString()} in strategy ${strategy.name}`);
        if (debugDep) {
          debugDep.versionResolvedFrom = strategy.name === 'getCurrentVersion' ? debugDep.versionResolvedFrom : strategy.name.replace('getFrom', '');
          debugDep.version = strategyId.version;
        }
        return strategyId.version;
      }
    }
    return undefined;
  }
  function updateDependency(dependency) {
    const resolvedVersion = resolveVersion(dependency.id);
    if (resolvedVersion) {
      dependency.id = dependency.id.changeVersion(resolvedVersion);
    }
  }
  function updateDependencies(dependencies) {
    dependencies.get().forEach(updateDependency);
  }
  function updateExtension(extension) {
    if (extension.extensionId) {
      const resolvedVersion = resolveVersion(extension.extensionId);
      if (resolvedVersion) {
        extension.extensionId = extension.extensionId.changeVersion(resolvedVersion);
      }
    }
  }
  function updateExtensions(extensions) {
    extensions.forEach(updateExtension);
  }

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  function getIdFromModelDeps(componentFromModel, componentId) {
    if (!componentFromModel) return null;
    const dependency = componentFromModel.getAllDependenciesIds().searchWithoutVersion(componentId);
    if (!dependency) return null;
    return dependency;
  }
  function getIdFromBitMap(componentId) {
    return consumer.bitMap.getBitIdIfExist(componentId, {
      ignoreVersion: true
    });
  }
  function getIdFromComponentConfig(componentId) {
    const dependencies = component.overrides.getComponentDependenciesWithVersion();
    if ((0, _isEmpty2().default)(dependencies)) return undefined;
    const dependency = Object.keys(dependencies).find(idStr => componentId.toStringWithoutVersion() === idStr || componentId.toStringWithoutScopeAndVersion() === idStr);
    if (!dependency) return undefined;
    return componentId.changeVersion(dependencies[dependency]);
  }
}