import { IssuesList } from '@teambit/component-issues';
import { Dependency } from '..';
import { BitId } from '../../../../bit-id';
import Consumer from '../../../../consumer/consumer';
import { PathLinux, PathLinuxRelative, PathOsBased } from '../../../../utils/path';
import ComponentMap from '../../../bit-map/component-map';
import Component from '../../../component/consumer-component';
import { RelativePath } from '../dependency';
import { FileObject, ImportSpecifier, DependenciesTree } from '../files-dependency-builder/types/dependency-tree-type';
import OverridesDependencies from './overrides-dependencies';
import { ResolvedPackageData } from '../../../../utils/packages';
import { DependenciesData } from './dependencies-data';
import { ExtensionDataList } from '../../../config';
export declare type AllDependencies = {
    dependencies: Dependency[];
    devDependencies: Dependency[];
};
export declare type AllPackagesDependencies = {
    packageDependencies: Record<string, string> | null | undefined;
    devPackageDependencies: Record<string, string> | null | undefined;
    peerPackageDependencies: Record<string, string> | null | undefined;
};
export declare type FileType = {
    isTestFile: boolean;
};
export declare type DebugDependencies = {
    components: DebugComponentsDependency[];
    unidentifiedPackages?: string[];
};
export declare type DebugComponentsDependency = {
    id: BitId;
    importSource?: string;
    dependencyPackageJsonPath?: string;
    dependentPackageJsonPath?: string;
    versionResolvedFrom?: 'DependencyPkgJson' | 'DependentPkgJson' | 'BitMap' | 'Model' | string;
    version?: string;
    componentIdResolvedFrom?: 'DependencyPkgJson' | 'DependencyPath';
    packageName?: string;
};
declare type WorkspacePolicyGetter = () => {
    dependencies?: Record<string, string>;
    peerDependencies?: Record<string, string>;
};
declare type HarmonyEnvPeersPolicyForComponentGetter = (configuredExtensions: ExtensionDataList) => Promise<{
    [name: string]: string;
}>;
declare type HarmonyEnvPeersPolicyForEnvItselfGetter = (componentId: BitId) => Promise<{
    [name: string]: string;
} | undefined>;
export default class DependencyResolver {
    component: Component;
    consumer: Consumer;
    componentId: BitId;
    componentMap: ComponentMap;
    componentFromModel: Component;
    consumerPath: PathOsBased;
    tree: DependenciesTree;
    allDependencies: AllDependencies;
    allPackagesDependencies: AllPackagesDependencies;
    issues: IssuesList;
    coreAspects: string[];
    processedFiles: string[];
    overridesDependencies: OverridesDependencies;
    debugDependenciesData: DebugDependencies;
    static getWorkspacePolicy: WorkspacePolicyGetter;
    static registerWorkspacePolicyGetter(func: WorkspacePolicyGetter): void;
    /**
     * This will get the peers policy provided by the env of the component
     */
    static getHarmonyEnvPeersPolicyForComponent: HarmonyEnvPeersPolicyForComponentGetter;
    static registerHarmonyEnvPeersPolicyForComponentGetter(func: HarmonyEnvPeersPolicyForComponentGetter): void;
    /**
     * This will get the peers policy provided by the env of the component
     */
    static getHarmonyEnvPeersPolicyForEnvItself: HarmonyEnvPeersPolicyForEnvItselfGetter;
    static registerHarmonyEnvPeersPolicyForEnvItselfGetter(func: HarmonyEnvPeersPolicyForEnvItselfGetter): void;
    static getDepResolverAspectName: () => string;
    static getCoreAspectsPackagesAndIds: () => Record<string, string>;
    static getDevFiles: (component: Component) => Promise<string[]>;
    constructor(component: Component, consumer: Consumer);
    setTree(tree: DependenciesTree): void;
    /**
     * Resolve components and packages dependencies for a component.
     * This method should NOT have any side-effect on the component. the DependenciesLoader class is
     * responsible for saving this data on the component object.
     *
     * The process is as follows:
     * 1) Use the language driver to parse the component files and find for each file its dependencies.
     * 2) The results we get from the driver per file tells us what are the files and packages that depend on our file.
     * and also whether there are missing packages and files.
     * 3) Using the information from the driver, we go over each one of the dependencies files and find its counterpart
     * component. The way how we find it, is by using the bit.map file which has a mapping between the component name and
     * the file paths.
     * 4) If we find a component to the file dependency, we add it to component.dependencies. Otherwise, it's added to
     * component.issues.untrackedDependencies
     * 5) Similarly, when we find the packages dependencies, they are added to component.packageDependencies. Otherwise,
     * they're added to component.issues.missingPackagesDependenciesOnFs
     * 6) In case the driver found a file dependency that is not on the file-system, we add that file to
     * component.issues.missingDependenciesOnFs
     */
    getDependenciesData(cacheResolvedDependencies: Record<string, any>, cacheProjectAst: Record<string, any> | undefined): Promise<DependenciesData>;
    /**
     * Given the tree of file dependencies from the driver, find the components of these files.
     * Each dependency file has a path, use bit.map to search for the component name by that path.
     * If the component is found, add it to "this.allDependencies.dependencies". Otherwise, add it to "this.issues.untrackedDependencies".
     *
     * For the found components, add their sourceRelativePath and destinationRelativePath, they are being used for
     * generating links upon import:
     * sourceRelativePath - location of the link file.
     * destinationRelativePath - destination written inside the link file.
     *
     * When a dependency is found in a regular (implementation) file, it goes to `dependencies`. If
     * it found on a test file, it goes to `devDependencies`.
     * Similarly, when a package is found in a regular file, it goes to `packageDependencies`. When
     * if found in a test file, it goes to `devPackageDependencies`.
     * An exception for the above is when a package is required in a regular or test file but is also
     * mentioned in the `package.json` file as a peerDependency, in that case, the package is added
     * to `peerPackageDependencies` and removed from other places. Unless this package is overridden
     * and marked as ignored in the consumer or component config file.
     */
    populateDependencies(files: string[], testsFiles: string[]): Promise<void>;
    addCustomResolvedIssues(): void;
    removeIgnoredPackagesByOverrides(): void;
    throwForNonExistFile(file: string): void;
    manuallyAddDependencies(): void;
    traverseTreeForComponentId(depFile: PathLinux): BitId | undefined;
    getComponentIdByResolvedPackageData(bit: ResolvedPackageData): BitId;
    /**
     * this happens when using relative paths between components, which is allowed on Legacy only.
     * on Harmony, during the execution of this function, it recognizes the use of relative-paths, enter
     * it to the "issues", then, later, it shows a warning on bit-status and block tagging.
     */
    getComponentIdByDepFile(depFile: PathLinux): {
        componentId: BitId | null | undefined;
        depFileRelative: PathLinux;
        destination: string | null | undefined;
    };
    /**
     * this is a workaround for cases where an alias points to a package with dist.
     * normally, aliases are created for local directories.
     * they can be however useful when a source code can't be touched and `require` to one package
     * needs to be replaced with a `require` to a component. in that case, our options are:
     * 1) point the alias to the package name.
     * 2) point the alias to the relative directory of the imported component
     * the ideal solution is #1, however, it requires changes in the Tree structure, which should
     * allow "components" to have more data, such as importSource.
     * here, we go option #2, the alias is a relative path to the component. however, when there is
     * dist directory, the resolved path contains the "dist", which doesn't exist in the ComponentMap,
     * the solution we take is to identify such cases, strip the dist, then try to find them again.
     */
    _getComponentIdFromCustomResolveToPackageWithDist(depFile: string): BitId | null | undefined;
    getDependencyPathsFromModel(componentId: BitId, depFile: PathLinux, rootDir: PathLinux): {
        componentId: BitId;
        destination: string;
        depFileRelative: string;
    };
    processDepFiles(originFile: PathLinuxRelative, fileType: FileType, nested?: boolean): void;
    processOneDepFile(originFile: PathLinuxRelative, depFile: string, importSpecifiers: ImportSpecifier[] | undefined, linkFile: string | undefined, fileType: FileType, depFileObject: FileObject, nested?: boolean): boolean;
    processLinkFile(originFile: PathLinuxRelative, linkFile: FileObject, fileType: FileType): void;
    /**
     * process require/import of Bit components where the require statement is not a relative path
     * but a module path, such as `require('@bit/bit.envs/compiler/babel');`
     */
    processComponents(originFile: PathLinuxRelative, fileType: FileType): void;
    private isPkgInWorkspacePolicies;
    private isPkgInVariants;
    private addImportNonMainIssueIfNeeded;
    private getValidVersion;
    processPackages(originFile: PathLinuxRelative, fileType: FileType): void;
    processMissing(originFile: PathLinuxRelative, fileType: FileType): void;
    throwForMissingComponentsOnHarmony(missingComponents: string[]): void;
    processErrors(originFile: PathLinuxRelative): void;
    /**
     * when a user uses core-extensions these core-extensions should not be dependencies.
     * here, we filter them out from all places they could entered as dependencies.
     * an exception is when running this method on bit-core-extensions themselves (dogfooding), in
     * which case we recognizes that the current originFile is a core-extension and avoid filtering.
     */
    processCoreAspects(originFile: PathLinuxRelative): void;
    /**
     * currently the only unidentified packages being process are the ones coming from custom-modules-resolution.
     * assuming the author used custom-resolution, which enable using non-relative import syntax,
     * for example, requiring the file 'src/utils/is-string' from anywhere as require('utils/is-string');
     * now, when the component is imported, the driver recognizes 'utils/is-string' as a package,
     * because it's not relative.
     * the goal here is to use the 'package' the driver found and match it with one of the
     * dependencies from the model. In the example above, we might find in the model, a dependency
     * is-string with importSource of 'utils/is-string'.
     * Once a match is found, copy the relativePaths from the model.
     *
     * keep in mind that this custom-modules-resolution supported on legacy components only.
     * as such, no need to find the packageName to pass to _pushToDependenciesIfNotExist method.
     */
    processUnidentifiedPackages(originFile: PathLinuxRelative, fileType: FileType): void;
    private _pushToDependenciesIfNotExist;
    pushToDependenciesArray(currentComponentsDeps: Dependency, fileType: FileType, depDebug: DebugComponentsDependency): void;
    /**
     * Remove the dependencies which appear both in dev and regular deps from the dev
     * Because if a dependency is both dev dependency and regular dependency it should be treated as regular one
     * Apply for both packages and components dependencies
     */
    removeDevAndEnvDepsIfTheyAlsoRegulars(): void;
    /**
     * given missing packages name, find whether they were dependencies with custom-resolve before.
     */
    findOriginallyCustomModuleResolvedDependencies(packages: string[]): Record<string, any> | null | undefined;
    getExistingDependency(dependencies: Dependency[], id: BitId): Dependency | null | undefined;
    getExistingDepRelativePaths(dependency: Dependency, relativePath: RelativePath): RelativePath | null | undefined;
    getDiffSpecifiers(originSpecifiers: ImportSpecifier[], targetSpecifiers: ImportSpecifier[]): any;
    applyPeersFromComponentModel(): void;
    applyPackageJson(): void;
    applyWorkspacePolicy(): void;
    applyAutoDetectedPeersFromEnvOnComponent(): Promise<void>;
    applyAutoDetectedPeersFromEnvOnEnvItSelf(): Promise<void>;
    /**
     * returns `package.json` of the component when it's imported, or `package.json` of the workspace
     * when it's authored.
     */
    _getPackageJson(): Record<string, any> | undefined;
    _getPackageJsonFromComponentModel(): Record<string, any> | undefined;
    private setLegacyInsideHarmonyIssue;
    /**
     * when requiring packages in typescript, sometimes there are the types packages with the same
     * name, which the user probably wants as well. for example, requiring `foo` package, will also
     * add `@types/foo` to the devDependencies if it has been found in the user `package.json` file.
     *
     * ideally this should be in bit-javascript. however, the decision where to put these `@types`
     * packages (dependencies/devDependencies) is done here according to the user `package.json`
     * and can't be done there because the `Tree` we get from bit-javascript doesn't have this
     * distinction.
     */
    _addTypesPackagesForTypeScript(packages: Record<string, any>, originFile: PathLinuxRelative): void;
    _pkgFieldMapping(field: string): "packageDependencies" | "devPackageDependencies" | "peerPackageDependencies";
    _pushToUntrackDependenciesIssues(originFile: PathLinuxRelative, depFileRelative: any, nested?: boolean): void;
    _pushToRelativeComponentsIssues(originFile: any, componentId: BitId): void;
    _pushToRelativeComponentsAuthoredIssues(originFile: any, componentId: any, importSource: string, relativePath: RelativePath): void;
    _pushToMissingDependenciesOnFs(originFile: PathLinuxRelative, missingFiles: string[]): void;
    _pushToMissingPackagesDependenciesIssues(originFile: PathLinuxRelative, missingPackages: string[]): void;
    _pushToMissingComponentsIssues(originFile: PathLinuxRelative, componentId: BitId): void;
}
export {};
