"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MissingHandler = void 0;
function _groupBy2() {
  const data = _interopRequireDefault(require("ramda/src/groupBy"));
  _groupBy2 = function () {
    return data;
  };
  return data;
}
function _packages() {
  const data = require("../../../../utils/packages");
  _packages = function () {
    return data;
  };
  return data;
}
function _generateTreeMadge() {
  const data = require("./generate-tree-madge");
  _generateTreeMadge = function () {
    return data;
  };
  return data;
}
class MissingHandler {
  constructor(missing, componentDir, workspacePath, bindingPrefix) {
    this.missing = missing;
    this.componentDir = componentDir;
    this.workspacePath = workspacePath;
    this.bindingPrefix = bindingPrefix;
  }

  /**
   * Run over each entry in the missing array and transform the missing from list of paths
   * to object with missing types
   */
  groupAndFindMissing() {
    const missingGroups = this.groupMissingByType();
    missingGroups.forEach(group => {
      if (group.packages) group.packages = group.packages.map(_packages().resolvePackageNameByPath);
      if (group.components) group.components = group.components.map(_packages().resolvePackageNameByPath);
    });
    // This is a hack to solve problems that madge has with packages for type script files
    // It see them as missing even if they are exists
    const foundPackages = {
      packages: {},
      components: []
    };
    missingGroups.forEach(group => this.processMissingGroup(group, foundPackages));
    return {
      missingGroups,
      foundPackages
    };
  }
  processMissingGroup(group, foundPackages) {
    if (!group.packages) return;
    const missingPackages = [];
    group.packages.forEach(packageName => {
      // Don't try to resolve the same package twice
      if (missingPackages.includes(packageName)) return;
      const resolvedPath = (0, _packages().resolvePackagePath)(packageName, this.componentDir, this.workspacePath);
      if (!resolvedPath) {
        missingPackages.push(packageName);
        return;
      }
      const resolvedPackageData = (0, _packages().resolvePackageData)(this.componentDir, resolvedPath);
      if (!resolvedPackageData) {
        missingPackages.push(packageName);
        return;
      }
      // if the package is actually a component add it to the components list
      if (resolvedPackageData.componentId) {
        foundPackages.components.push(resolvedPackageData);
      } else {
        const version = resolvedPackageData.versionUsedByDependent || resolvedPackageData.concreteVersion;
        if (!version) throw new Error(`unable to find the version for a package ${packageName}`);
        const packageWithVersion = {
          [resolvedPackageData.name]: version
        };
        Object.assign(foundPackages.packages, packageWithVersion);
      }
    });
  }

  /**
   * Group missing dependencies by types (files, components, packages)
   * @param {Array} missing list of missing paths to group
   * @returns {Function} function which group the dependencies
   */
  groupMissingByType() {
    const byPathType = (0, _groupBy2().default)(item => {
      return item.startsWith('.') ? 'files' : 'packages';
    });
    return Object.keys(this.missing).map(key => Object.assign({
      originFile: (0, _generateTreeMadge().processPath)(key, {}, this.componentDir)
    }, byPathType(this.missing[key])));
  }
}
exports.MissingHandler = MissingHandler;