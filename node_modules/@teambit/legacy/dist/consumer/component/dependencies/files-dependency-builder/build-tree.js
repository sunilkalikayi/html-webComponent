"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDependencyTree = getDependencyTree;
function _clone2() {
  const data = _interopRequireDefault(require("ramda/src/clone"));
  _clone2 = function () {
    return data;
  };
  return data;
}
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _packages() {
  const data = require("../../../../utils/packages");
  _packages = function () {
    return data;
  };
  return data;
}
function _generateTreeMadge() {
  const data = _interopRequireDefault(require("./generate-tree-madge"));
  _generateTreeMadge = function () {
    return data;
  };
  return data;
}
function _missingHandler() {
  const data = require("./missing-handler");
  _missingHandler = function () {
    return data;
  };
  return data;
}
function _pathMap() {
  const data = require("./path-map");
  _pathMap = function () {
    return data;
  };
  return data;
}
function _dependencyTreeType() {
  const data = require("./types/dependency-tree-type");
  _dependencyTreeType = function () {
    return data;
  };
  return data;
}
/**
 * Gets a list of dependencies and group them by types (files, components, packages)
 * It's also transform the node package dependencies from array of paths to object in this format:
 * {dependencyName: version} (like in package.json)
 *
 * componentDir is the root of working directory (used for node packages version calculation)
 */
function groupDependencyList(dependenciesPaths, componentDir, bindingPrefix) {
  const resultGroups = new (_dependencyTreeType().DependenciesTreeItem)();
  const isPackage = str => str.includes('node_modules/');
  const isBitLegacyInsideHarmony = str => str.includes(`node_modules/${bindingPrefix}`) || str.includes(`node_modules/${_constants().DEFAULT_BINDINGS_PREFIX}`);
  dependenciesPaths.forEach(dependencyPath => {
    if (!isPackage(dependencyPath)) {
      resultGroups.files.push({
        file: dependencyPath
      });
      return;
    }
    const resolvedPackage = (0, _packages().resolvePackageData)(componentDir, _path().default.join(componentDir, dependencyPath));
    if (!resolvedPackage) {
      // package doesn't have package.json, probably it's a custom-resolve-module dep file
      resultGroups.unidentifiedPackages.push(dependencyPath);
      return;
    }

    // If the package is a component add it to the components list
    // @todo: currently, for author, the package.json doesn't have any version.
    // we might change this decision later. see https://github.com/teambit/bit/pull/2924
    if (resolvedPackage.componentId) {
      resultGroups.components.push(resolvedPackage);
      return;
    }
    if (isBitLegacyInsideHarmony(dependencyPath)) {
      var _resolvedPackage$pack;
      const pkgRootDir = (_resolvedPackage$pack = resolvedPackage.packageJsonContent) === null || _resolvedPackage$pack === void 0 ? void 0 : _resolvedPackage$pack.componentRootFolder;
      const hasLegacyBitFiles = pkgRootDir && _fsExtra().default.existsSync(_path().default.join(pkgRootDir, '.bit_env_has_installed'));
      if (hasLegacyBitFiles) {
        throw new Error(`error: legacy dependency "${resolvedPackage.name}" was imported to one of the files in "${componentDir}".
this workspace is Harmony and therefore legacy components/packages are unsupported.
remove the import statement to fix this error`);
      }
    }
    const version = resolvedPackage.versionUsedByDependent || resolvedPackage.concreteVersion;
    const packageWithVersion = {
      [resolvedPackage.name]: version
    };
    Object.assign(resultGroups.packages, packageWithVersion);
  });
  return resultGroups;
}

/**
 * Run over each entry in the tree and transform the dependencies from list of paths
 * to object with dependencies types
 *
 * @returns new tree with grouped dependencies
 */
function MadgeTreeToDependenciesTree(tree, componentDir, bindingPrefix) {
  const result = {};
  Object.keys(tree).forEach(filePath => {
    if (tree[filePath] && !(0, _isEmpty2().default)(tree[filePath])) {
      result[filePath] = groupDependencyList(tree[filePath], componentDir, bindingPrefix);
    } else {
      result[filePath] = new (_dependencyTreeType().DependenciesTreeItem)();
    }
  });
  return result;
}

/**
 * add extra data such as custom-resolve and link-files from pathMap
 */
function updateTreeWithPathMap(tree, pathMapAbsolute, baseDir) {
  if (!pathMapAbsolute.length) return;
  const pathMapRelative = (0, _pathMap().convertPathMapToRelativePaths)(pathMapAbsolute, baseDir);
  const pathMap = (0, _pathMap().getPathMapWithLinkFilesData)(pathMapRelative);
  Object.keys(tree).forEach(filePath => {
    const treeFiles = tree[filePath].files;
    if (!treeFiles.length) return; // file has no dependency
    const mainFilePathMap = pathMap.find(file => file.file === filePath);
    if (!mainFilePathMap) throw new Error(`updateTreeWithPathMap: PathMap is missing for ${filePath}`);
    // a file might have a cycle dependency with itself, remove it from the dependencies.
    tree[filePath].files = treeFiles.filter(dependency => dependency.file !== filePath);
    tree[filePath].files.forEach(fileObject => {
      const dependencyPathMap = mainFilePathMap.dependencies.find(file => file.resolvedDep === fileObject.file);
      if (!dependencyPathMap) {
        throw new Error(`updateTreeWithPathMap: dependencyPathMap is missing for ${fileObject.file}`);
      }
      fileObject.importSource = dependencyPathMap.importSource;
      fileObject.isCustomResolveUsed = dependencyPathMap.isCustomResolveUsed;
      if (dependencyPathMap.linkFile) {
        fileObject.isLink = true;
        fileObject.linkDependencies = dependencyPathMap.realDependencies;
        return fileObject;
      }
      if (dependencyPathMap.importSpecifiers && dependencyPathMap.importSpecifiers.length) {
        const depImportSpecifiers = dependencyPathMap.importSpecifiers.map(importSpecifier => {
          return {
            mainFile: importSpecifier
          };
        });
        fileObject.importSpecifiers = depImportSpecifiers;
      }
      return fileObject;
    });
  });
}

/**
 * config aliases are passed later on to webpack-enhancer and it expects them to have the full path
 */
function getResolveConfigAbsolute(workspacePath, resolveConfig) {
  if (!resolveConfig) return resolveConfig;
  const resolveConfigAbsolute = (0, _clone2().default)(resolveConfig);
  if (resolveConfig.modulesDirectories) {
    resolveConfigAbsolute.modulesDirectories = resolveConfig.modulesDirectories.map(moduleDirectory => {
      return _path().default.isAbsolute(moduleDirectory) ? moduleDirectory : _path().default.join(workspacePath, moduleDirectory);
    });
  }
  if (resolveConfigAbsolute.aliases) {
    Object.keys(resolveConfigAbsolute.aliases).forEach(alias => {
      if (!_path().default.isAbsolute(resolveConfigAbsolute.aliases[alias])) {
        resolveConfigAbsolute.aliases[alias] = _path().default.join(workspacePath, resolveConfigAbsolute.aliases[alias]);
      }
    });
  }
  return resolveConfigAbsolute;
}
function mergeManuallyFoundPackagesToTree(foundPackages, missingGroups, tree) {
  if ((0, _isEmpty2().default)(foundPackages.components) && (0, _isEmpty2().default)(foundPackages.packages)) return;
  // Merge manually found packages (by groupMissing()) with the packages found by Madge (generate-tree-madge)
  Object.keys(foundPackages.packages).forEach(pkg => {
    // locate package in groups(contains missing)
    missingGroups.forEach(fileDep => {
      if (fileDep.packages && fileDep.packages.includes(pkg)) {
        fileDep.packages = fileDep.packages.filter(packageName => packageName !== pkg);
        (0, _lodash().set)(tree[fileDep.originFile], ['packages', pkg], foundPackages.packages[pkg]);
      }
    });
  });
  foundPackages.components.forEach(component => {
    missingGroups.forEach(fileDep => {
      if (fileDep.components && (component.fullPath && fileDep.components.includes(component.fullPath) || fileDep.components.includes(component.name))) {
        var _fileDep$originFile;
        fileDep.components = fileDep.components.filter(existComponent => {
          return existComponent !== component.fullPath && existComponent !== component.name;
        });
        (tree[_fileDep$originFile = fileDep.originFile] || (tree[_fileDep$originFile] = new (_dependencyTreeType().DependenciesTreeItem)())).components.push(component);
      }
      if (fileDep.packages && fileDep.packages.includes(component.name)) {
        var _fileDep$originFile2;
        fileDep.packages = fileDep.packages.filter(packageName => packageName !== component.name);
        (tree[_fileDep$originFile2 = fileDep.originFile] || (tree[_fileDep$originFile2] = new (_dependencyTreeType().DependenciesTreeItem)())).components.push(component);
      }
    });
  });
}
function mergeMissingToTree(missingGroups, tree) {
  if ((0, _isEmpty2().default)(missingGroups)) return;
  missingGroups.forEach(missing => {
    var _missing$originFile;
    const missingCloned = (0, _clone2().default)(missing);
    delete missingCloned.originFile;
    (tree[_missing$originFile = missing.originFile] || (tree[_missing$originFile] = new (_dependencyTreeType().DependenciesTreeItem)())).missing = missingCloned;
  });
}
function mergeErrorsToTree(errors, tree) {
  if ((0, _isEmpty2().default)(errors)) return;
  Object.keys(errors).forEach(file => {
    (tree[file] || (tree[file] = new (_dependencyTreeType().DependenciesTreeItem)())).error = errors[file];
  });
}

/**
 * Function for fetching dependency tree of file or dir
 * @param baseDir working directory
 * @param workspacePath
 * @param filePaths path of the file to calculate the dependencies
 * @param bindingPrefix
 */
async function getDependencyTree({
  componentDir,
  // component rootDir, for legacy-authored it's the same as workspacePath
  workspacePath,
  filePaths,
  bindingPrefix,
  resolveModulesConfig,
  visited = {},
  cacheProjectAst
}) {
  const resolveConfigAbsolute = getResolveConfigAbsolute(workspacePath, resolveModulesConfig);
  const config = {
    baseDir: componentDir,
    includeNpm: true,
    requireConfig: null,
    webpackConfig: null,
    visited,
    nonExistent: [],
    resolveConfig: resolveConfigAbsolute,
    cacheProjectAst
  };
  // This is important because without this, madge won't know to resolve files if we run the
  // CMD not from the root dir
  const fullPaths = filePaths.map(filePath => {
    if (filePath.startsWith(componentDir)) {
      return filePath;
    }
    return _path().default.resolve(componentDir, filePath);
  });
  const {
    madgeTree,
    skipped,
    pathMap,
    errors
  } = (0, _generateTreeMadge().default)(fullPaths, config);
  const tree = MadgeTreeToDependenciesTree(madgeTree, componentDir, bindingPrefix);
  const {
    missingGroups,
    foundPackages
  } = new (_missingHandler().MissingHandler)(skipped, componentDir, workspacePath, bindingPrefix).groupAndFindMissing();
  if (foundPackages) mergeManuallyFoundPackagesToTree(foundPackages, missingGroups, tree);
  if (errors) mergeErrorsToTree(errors, tree);
  if (missingGroups) mergeMissingToTree(missingGroups, tree);
  if (pathMap) updateTreeWithPathMap(tree, pathMap, componentDir);
  return {
    tree
  };
}