import { BitId, BitIds } from '../../../bit-id';
import { BitIdStr } from '../../../bit-id/bit-id';
import Scope from '../../../scope/scope';
import Dependency from './dependency';
export declare const DEPENDENCIES_TYPES: string[];
export declare const DEPENDENCIES_TYPES_UI_MAP: {
    dependencies: string;
    devDependencies: string;
};
export declare type DependenciesFilterFunction = (dependency: Dependency) => boolean;
export default class Dependencies {
    readonly dependencies: Dependency[];
    constructor(dependencies?: Dependency[]);
    serialize(): Record<string, any>[];
    get(): Dependency[];
    filter(fn: DependenciesFilterFunction): Dependencies;
    sort(): void;
    getClone(): Dependency[];
    add(dependency: Dependency): void;
    toStringOfIds(): string[];
    isEmpty(): boolean;
    cloneAsString(): Record<string, any>[];
    cloneAsObject(): Record<string, any>[];
    /**
     * needed for calculating the originallySharedDir. when isCustomResolveUsed, don't take into
     * account the dependencies as they don't have relative paths
     */
    getSourcesPaths(): string[];
    getById(id: BitId): Dependency | null | undefined;
    getByIdStr(id: BitIdStr): Dependency | null | undefined;
    getBySourcePath(sourcePath: string): Dependency | null | undefined;
    getAllIds(): BitIds;
    getIdsMap(): Record<string, BitId>;
    addRemoteAndLocalVersions(scope: Scope, modelDependencies: Dependencies): Promise<void>;
    getCustomResolvedData(): {
        [importSource: string]: BitId;
    };
    isCustomResolvedUsed(): boolean;
    validate(bitId?: BitId): void;
}
