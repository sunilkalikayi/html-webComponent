"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _uniqBy2() {
  const data = _interopRequireDefault(require("ramda/src/uniqBy"));
  _uniqBy2 = function () {
    return data;
  };
  return data;
}
function _is2() {
  const data = _interopRequireDefault(require("ramda/src/is"));
  _is2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _noIdMatchWildcard() {
  const data = _interopRequireDefault(require("../../api/consumer/lib/exceptions/no-id-match-wildcard"));
  _noIdMatchWildcard = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _getDivergeData() {
  const data = require("../../scope/component-ops/get-diverge-data");
  _getDivergeData = function () {
    return data;
  };
  return data;
}
function _modelComponent() {
  const data = _interopRequireDefault(require("../../scope/models/model-component"));
  _modelComponent = function () {
    return data;
  };
  return data;
}
function _scopeRemotes() {
  const data = require("../../scope/scope-remotes");
  _scopeRemotes = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _isBitIdMatchByWildcards() {
  const data = _interopRequireDefault(require("../../utils/bit/is-bit-id-match-by-wildcards"));
  _isBitIdMatchByWildcards = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = _interopRequireDefault(require("../component"));
  _component = function () {
    return data;
  };
  return data;
}
class ComponentsList {
  // @ts-ignore

  constructor(consumer) {
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "bitMap", void 0);
    (0, _defineProperty2().default)(this, "_fromFileSystem", {});
    (0, _defineProperty2().default)(this, "_fromObjectsIds", void 0);
    (0, _defineProperty2().default)(this, "_modelComponents", void 0);
    (0, _defineProperty2().default)(this, "_invalidComponents", void 0);
    (0, _defineProperty2().default)(this, "_modifiedComponents", void 0);
    (0, _defineProperty2().default)(this, "_removedComponents", void 0);
    (0, _defineProperty2().default)(this, "_mergePendingComponents", void 0);
    this.consumer = consumer;
    this.scope = consumer.scope;
    this.bitMap = consumer.bitMap;
  }
  async getModelComponents() {
    if (!this._modelComponents) {
      this._modelComponents = await this.scope.listIncludeRemoteHead(this.consumer.getCurrentLaneId());
    }
    return this._modelComponents;
  }

  /**
   * List all bit ids stored in the model
   */
  async getFromObjects() {
    if (!this._fromObjectsIds) {
      const modelComponents = await this.getModelComponents();
      this._fromObjectsIds = modelComponents.map(componentObjects => {
        return new (_bitId().BitId)({
          scope: componentObjects.scope,
          name: componentObjects.name,
          version: componentObjects.scope ? componentObjects.latest() : undefined
        });
      });
    }
    return this._fromObjectsIds;
  }
  async getComponentsFromFS(loadOpts) {
    return this.getFromFileSystem(loadOpts);
  }

  /**
   * Components that are in the model (either, tagged from a local scope or imported), and were
   * changed in the file system
   *
   * @param {boolean} [load=false] - Whether to load the component (false will return only the id)
   */
  async listModifiedComponents(load = false, loadOpts) {
    if (!this._modifiedComponents) {
      const fileSystemComponents = await this.getComponentsFromFS(loadOpts);
      const unmergedComponents = this.listDuringMergeStateComponents();
      const componentStatuses = await this.consumer.getManyComponentsStatuses(fileSystemComponents.map(f => f.id));
      this._modifiedComponents = fileSystemComponents.filter(component => {
        const status = componentStatuses.find(s => s.id.isEqual(component.id));
        if (!status) throw new Error(`listModifiedComponents unable to find status for ${component.id.toString()}`);
        return status.status.modified;
      }).filter(component => !unmergedComponents.hasWithoutScopeAndVersion(component.id));
    }
    if (load) return this._modifiedComponents;
    return this._modifiedComponents.map(component => component.id);
  }
  async listOutdatedComponents(loadOpts) {
    const fileSystemComponents = await this.getComponentsFromFS(loadOpts);
    const componentsFromModel = await this.getModelComponents();
    const unmergedComponents = this.listDuringMergeStateComponents();
    const mergePendingComponents = await this.listMergePendingComponents();
    const mergePendingComponentsIds = _bitId().BitIds.fromArray(mergePendingComponents.map(c => c.id));
    await Promise.all(fileSystemComponents.map(async component => {
      const modelComponent = componentsFromModel.find(c => c.toBitId().isEqualWithoutVersion(component.id));
      if (!modelComponent || !component.id.hasVersion() || unmergedComponents.hasWithoutScopeAndVersion(component.id)) return;
      if (mergePendingComponentsIds.hasWithoutVersion(component.id)) {
        // by default, outdated include merge-pending since the remote-head and local-head are
        // different, however we want them both to be separated as they need different treatment
        return;
      }
      const latestVersionLocally = modelComponent.latest();
      const latestIncludeRemoteHead = await modelComponent.latestIncludeRemote(this.scope.objects);
      const isOutdated = () => {
        if (latestIncludeRemoteHead !== latestVersionLocally) return true;
        return modelComponent.isLatestGreaterThan(component.id.version);
      };
      if (isOutdated()) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        component.latestVersion = latestIncludeRemoteHead;
      }
    }));
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return fileSystemComponents.filter(f => f.latestVersion);
  }

  /**
   * list components that their head is a snap, not a tag.
   * this is relevant only when the lane is the default (main), otherwise, the head is always a snap.
   * components that are during-merge are filtered out, we don't want them during tag and don't want
   * to show them in the "snapped" section in bit-status.
   */
  async listSnappedComponentsOnMain() {
    if (!this.consumer.isOnMain()) {
      return [];
    }
    const componentsFromModel = await this.getModelComponents();
    const authoredAndImportedIds = this.bitMap.getAllBitIds();
    const compsDuringMerge = this.listDuringMergeStateComponents();
    return componentsFromModel.filter(c => authoredAndImportedIds.hasWithoutVersion(c.toBitId())).filter(c => !compsDuringMerge.hasWithoutVersion(c.toBitId())).filter(c => c.isHeadSnap());
  }

  /**
   * list components on a lane that their main got updates.
   */
  async listUpdatesFromMainPending() {
    if (this.consumer.isOnMain()) {
      return [];
    }
    const authoredAndImportedIds = this.bitMap.getAllBitIds();
    const duringMergeIds = this.listDuringMergeStateComponents();
    const componentsFromModel = await this.getModelComponents();
    const compFromModelOnWorkspace = componentsFromModel.filter(c => authoredAndImportedIds.hasWithoutVersion(c.toBitId()))
    // if a component is merge-pending, it needs to be resolved first before getting more updates from main
    .filter(c => !duringMergeIds.hasWithoutVersion(c.toBitId()));
    const results = await Promise.all(compFromModelOnWorkspace.map(async modelComponent => {
      const headOnMain = modelComponent.head;
      const headOnLane = modelComponent.laneHeadLocal;
      if (!headOnMain || !headOnLane) return undefined;
      const divergeData = await (0, _getDivergeData().getDivergeData)({
        repo: this.scope.objects,
        modelComponent,
        remoteHead: headOnMain,
        checkedOutLocalHead: headOnLane,
        throws: false
      });
      if (!divergeData.snapsOnRemoteOnly.length && !divergeData.err) return undefined;
      return {
        id: modelComponent.toBitId(),
        divergeData
      };
    }));
    return (0, _lodash().compact)(results);
  }

  /**
   * if the local lane was forked from another lane, this gets the differences between the two
   */
  async listUpdatesFromForked() {
    if (this.consumer.isOnMain()) {
      return [];
    }
    const lane = await this.consumer.getCurrentLaneObject();
    const forkedFromLaneId = lane === null || lane === void 0 ? void 0 : lane.forkedFrom;
    if (!forkedFromLaneId) {
      return [];
    }
    const forkedFromLane = await this.scope.loadLane(forkedFromLaneId);
    if (!forkedFromLane) return []; // should we fetch it here?

    const authoredAndImportedIds = this.bitMap.getAllBitIds();
    const duringMergeIds = this.listDuringMergeStateComponents();
    const componentsFromModel = await this.getModelComponents();
    const compFromModelOnWorkspace = componentsFromModel.filter(c => authoredAndImportedIds.hasWithoutVersion(c.toBitId()))
    // if a component is merge-pending, it needs to be resolved first before getting more updates from main
    .filter(c => !duringMergeIds.hasWithoutVersion(c.toBitId()));
    const remoteForkedLane = await this.scope.objects.remoteLanes.getRemoteLane(forkedFromLaneId);
    if (!remoteForkedLane.length) return [];
    const results = await Promise.all(compFromModelOnWorkspace.map(async modelComponent => {
      const headOnForked = remoteForkedLane.find(c => c.id.isEqualWithoutVersion(modelComponent.toBitId()));
      const headOnLane = modelComponent.laneHeadLocal;
      if (!headOnForked || !headOnLane) return undefined;
      const divergeData = await (0, _getDivergeData().getDivergeData)({
        repo: this.scope.objects,
        modelComponent,
        remoteHead: headOnForked.head,
        checkedOutLocalHead: headOnLane,
        throws: false
      });
      if (!divergeData.snapsOnRemoteOnly.length && !divergeData.err) return undefined;
      return {
        id: modelComponent.toBitId(),
        divergeData
      };
    }));
    return (0, _lodash().compact)(results);
  }
  async listMergePendingComponents(loadOpts) {
    if (!this._mergePendingComponents) {
      const componentsFromFs = await this.getComponentsFromFS(loadOpts);
      const componentsFromModel = await this.getModelComponents();
      const duringMergeComps = this.listDuringMergeStateComponents();
      const updatesFromMain = await this.listUpdatesFromMainPending();
      this._mergePendingComponents = (await Promise.all(componentsFromFs.map(async component => {
        const modelComponent = componentsFromModel.find(c => c.toBitId().isEqualWithoutVersion(component.id));
        if (!modelComponent || duringMergeComps.hasWithoutScopeAndVersion(component.id)) return null;
        if (updatesFromMain.find(item => item.id.isEqualWithoutVersion(component.id))) return null;
        await modelComponent.setDivergeData(this.scope.objects);
        const divergedData = modelComponent.getDivergeData();
        if (!modelComponent.getDivergeData().isDiverged()) return null;
        return {
          id: modelComponent.toBitId(),
          diverge: divergedData
        };
      }))).filter(x => x);
    }
    return this._mergePendingComponents;
  }
  listDuringMergeStateComponents() {
    const unmergedComponents = this.scope.objects.unmergedComponents.getComponents();
    return _bitId().BitIds.fromArray(unmergedComponents.map(u => new (_bitId().BitId)(u.id)));
  }
  listSoftTaggedComponents() {
    return this.bitMap.components.filter(c => c.nextVersion).map(c => c.id);
  }
  async newModifiedAndAutoTaggedComponents() {
    const [newComponents, modifiedComponents] = await Promise.all([this.listNewComponents(true), this.listModifiedComponents(true)]);
    const autoTagPending = await this.listAutoTagPendingComponents();

    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const components = [...newComponents, ...modifiedComponents, ...autoTagPending];
    return Promise.all(components);
  }
  async idsFromObjects() {
    const fromObjects = await this.getFromObjects();
    return new (_bitId().BitIds)(...fromObjects);
  }

  /**
   * Components that are registered in bit.map but have never been tagged
   *
   * @param {boolean} [load=false] - Whether to load the component (false will return only the id)
   * @memberof ComponentsList
   */
  async listNewComponents(load = false, loadOpts) {
    const idsFromBitMap = this.idsFromBitMap();
    const idsFromObjects = await this.idsFromObjects();
    const newComponents = [];
    idsFromBitMap.forEach(id => {
      if (!idsFromObjects.searchWithoutVersion(id)) {
        newComponents.push(id);
      }
    });
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const newComponentsIds = new (_bitId().BitIds)(...newComponents);
    if (!load || !newComponents.length) return newComponentsIds;
    const {
      components
    } = await this.consumer.loadComponents(newComponentsIds, false, loadOpts);
    return components;
  }

  /**
   * list all components that can be tagged.
   */
  async listPotentialTagAllWorkspace() {
    return this.idsFromBitMap();
  }

  /**
   * New and modified components are tag pending
   *
   * @return {Promise<string[]>}
   */
  async listTagPendingComponents() {
    const newComponents = await this.listNewComponents();
    const modifiedComponents = await this.listModifiedComponents();
    const removedComponents = await this.listLocallySoftRemoved();
    const duringMergeIds = this.listDuringMergeStateComponents();
    return _bitId().BitIds.fromArray([...newComponents, ...modifiedComponents, ...removedComponents, ...duringMergeIds]);
  }
  async listExportPendingComponentsIds(lane) {
    const fromBitMap = this.bitMap.getAllBitIds();
    const modelComponents = await this.getModelComponents();
    const pendingExportComponents = await (0, _utils().filterAsync)(modelComponents, async component => {
      if (!fromBitMap.searchWithoutVersion(component.toBitId())) {
        // it's not on the .bitmap only in the scope, as part of the out-of-sync feature, it should
        // be considered as staged and should be exported. same for soft-removed components, which are on scope only.
        // notice that we use `hasLocalChanges`
        // and not `isLocallyChanged` by purpose. otherwise, cached components that were not
        // updated from a remote will be calculated as remote-ahead in the setDivergeData and will
        // be exported unexpectedly.
        return component.isLocallyChangedRegardlessOfLanes();
      }
      await component.setDivergeData(this.scope.objects);
      return component.isLocallyChanged(this.scope.objects, lane);
    });
    const ids = _bitId().BitIds.fromArray(pendingExportComponents.map(c => c.toBitId()));
    return this.updateIdsFromModelIfTheyOutOfSync(ids);
  }
  async listNonNewComponentsIds(loadOpts) {
    const authoredAndImported = await this.getComponentsFromFS(loadOpts);
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const newComponents = await this.listNewComponents();
    const nonNewComponents = authoredAndImported.filter(component => !newComponents.has(component.id));
    return _bitId().BitIds.fromArray(nonNewComponents.map(c => c.id.changeVersion(undefined)));
  }
  async updateIdsFromModelIfTheyOutOfSync(ids, loadOpts) {
    const authoredAndImported = this.bitMap.getAllBitIds();
    const updatedIdsP = ids.map(async id => {
      const idFromBitMap = authoredAndImported.searchWithoutScopeAndVersion(id);
      if (idFromBitMap && !idFromBitMap.hasVersion()) {
        // component is out of sync, fix it by loading it from the consumer
        const component = await this.consumer.loadComponent(id.changeVersion(_constants().LATEST), loadOpts);
        return component.id;
      }
      return id;
    });
    const updatedIds = await Promise.all(updatedIdsP);
    return _bitId().BitIds.fromArray(updatedIds);
  }
  async listExportPendingComponents(laneObj) {
    const exportPendingComponentsIds = await this.listExportPendingComponentsIds(laneObj);
    return Promise.all(exportPendingComponentsIds.map(id => this.scope.getModelComponent(id)));
  }
  async listAutoTagPendingComponents() {
    const modifiedComponents = await this.listModifiedComponents();
    const newComponents = await this.listNewComponents();
    if (!modifiedComponents || !modifiedComponents.length) return [];
    const autoTagPending = await this.consumer.listComponentsForAutoTagging(_bitId().BitIds.fromArray(modifiedComponents));
    return autoTagPending.filter(autoTagComp => !newComponents.has(autoTagComp.id));
  }
  idsFromBitMap() {
    return this.bitMap.getAllIdsAvailableOnLane();
  }
  async listAllIdsFromWorkspaceAndScope() {
    const idsFromBitMap = this.idsFromBitMap();
    const idsFromObjects = await this.idsFromObjects();
    return _bitId().BitIds.uniqFromArray([...idsFromBitMap, ...idsFromObjects]);
  }

  /**
   * Finds all components that are saved in the file system.
   * Components might be stored in the default component directory and also might be outside
   * of that directory. The bit.map is used to find them all
   * If they are on bit.map but not on the file-system, populate them to _invalidComponents property
   */
  async getFromFileSystem(loadOpts) {
    const cacheKeyName = 'all';
    if (!this._fromFileSystem[cacheKeyName]) {
      const idsFromBitMap = this.consumer.bitmapIdsFromCurrentLaneIncludeRemoved;
      const {
        components,
        invalidComponents,
        removedComponents
      } = await this.consumer.loadComponents(idsFromBitMap, false, loadOpts);
      this._fromFileSystem[cacheKeyName] = components;
      if (!this._invalidComponents) {
        this._invalidComponents = invalidComponents;
      }
      if (!this._removedComponents) {
        this._removedComponents = removedComponents;
      }
    }
    return this._fromFileSystem[cacheKeyName];
  }

  /**
   * components that are on bit.map but not on the file-system
   */
  async listInvalidComponents() {
    if (!this._invalidComponents) {
      await this.getFromFileSystem();
    }
    return this._invalidComponents;
  }

  /**
   * components that were deleted by soft-remove (bit remove --soft) and were not tagged/snapped after this change.
   * practically, their bitmap record has the config or "removed: true" and the component has deleted from the filesystem
   * in bit-status, we suggest to snap+export.
   */
  async listLocallySoftRemoved() {
    if (!this._removedComponents) {
      await this.getFromFileSystem();
    }
    return this._removedComponents.map(c => c.id);
  }

  /**
   * components that were soft-removed previously (probably in another workspace), exported and re-introduced here.
   * practically, the current `Version` object has a config with "removed: true", and the component exists in the filesystem
   * in bit-status we suggest to "bit remove".
   */
  async listRemotelySoftRemoved() {
    const fromFs = await this.getFromFileSystem();
    return fromFs.filter(comp => {
      var _comp$componentFromMo;
      return (_comp$componentFromMo = comp.componentFromModel) === null || _comp$componentFromMo === void 0 ? void 0 : _comp$componentFromMo.removed;
    });
  }

  /**
   * valid on legacy only. Harmony requires components to have their own directories
   */
  async listComponentsWithIndividualFiles() {
    const workspaceComponents = await this.getFromFileSystem();
    return workspaceComponents.filter(component => {
      const componentMap = component.componentMap;
      if (!componentMap) throw new Error('listComponentsWithIndividualFiles componentMap is missing');
      return Boolean(!componentMap.rootDir);
    });
  }

  /**
   * get called when the Consumer is available, shows also components from remote scopes
   */
  async listAll(showRemoteVersion, listScope, namespacesUsingWildcards) {
    const modelComponents = await this.getModelComponents();
    const authoredAndImportedIds = this.bitMap.getAllBitIds();
    const authoredAndImportedIdsNoVer = authoredAndImportedIds.map(id => id.changeVersion(undefined));
    const modelComponentsIds = modelComponents.map(c => c.toBitId());
    const allIds = listScope ? modelComponentsIds : _bitId().BitIds.uniqFromArray([...authoredAndImportedIdsNoVer, ...modelComponentsIds]);
    const idsFilteredByWildcards = namespacesUsingWildcards ? ComponentsList.filterComponentsByWildcard(allIds, namespacesUsingWildcards) : allIds;
    const idsSorted = ComponentsList.sortComponentsByName(idsFilteredByWildcards);
    const listAllResults = await Promise.all(idsSorted.map(async id => {
      const component = modelComponents.find(c => c.toBitId().isEqualWithoutVersion(id));
      const laneReadmeOf = await (component === null || component === void 0 ? void 0 : component.isLaneReadmeOf(this.scope.objects));
      const deprecated = await (component === null || component === void 0 ? void 0 : component.isDeprecated(this.scope.objects));
      return {
        id: component ? component.toBitIdWithLatestVersion() : id,
        deprecated,
        laneReadmeOf
      };
    }));
    const componentsIds = listAllResults.map(result => result.id);
    if (showRemoteVersion) {
      const latestVersionsInfo = await (0, _scopeRemotes().fetchRemoteVersions)(this.scope, componentsIds);
      latestVersionsInfo.forEach(componentId => {
        const listResult = listAllResults.find(c => c.id.isEqualWithoutVersion(componentId));
        if (!listResult) throw new Error(`failed finding ${componentId.toString()} in componentsIds`);
        // $FlowFixMe version must be set as it came from a remote
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        listResult.remoteVersion = componentId.version;
      });
    }
    listAllResults.forEach(listResult => {
      const existingBitMapId = authoredAndImportedIds.searchWithoutVersion(listResult.id);
      if (existingBitMapId) {
        listResult.currentlyUsedVersion = existingBitMapId.hasVersion() ? existingBitMapId.version : undefined;
      }
    });
    if (listScope) {
      return listAllResults;
    }
    const currentLane = await this.consumer.getCurrentLaneObject();
    const isIdOnCurrentLane = componentMap => {
      if (componentMap.isRemoved()) return false;
      if (!componentMap.onLanesOnly) return true; // component is on main, always show it
      if (!currentLane) return false; // if !currentLane the user is on main, don't show it.
      return Boolean(currentLane.getComponent(componentMap.id));
    };
    return listAllResults.filter(listResult => {
      const componentMap = this.bitMap.getComponentIfExist(listResult.id, {
        ignoreVersion: true
      });
      return componentMap && isIdOnCurrentLane(componentMap);
    });
  }

  /**
   * get called from a bare-scope, shows only components of that scope
   */
  static async listLocalScope(scope, namespacesUsingWildcards, includeRemoved = false) {
    const components = await scope.listLocal();
    const componentsOnMain = components.filter(comp => comp.head);
    const componentsFilteredByWildcards = namespacesUsingWildcards ? ComponentsList.filterComponentsByWildcard(componentsOnMain, namespacesUsingWildcards) : componentsOnMain;
    const componentsSorted = ComponentsList.sortComponentsByName(componentsFilteredByWildcards);
    const results = await Promise.all(componentsSorted.map(async component => {
      return {
        id: component.toBitIdWithLatestVersion(),
        deprecated: await component.isDeprecated(scope.objects),
        removed: await component.isRemoved(scope.objects),
        laneReadmeOf: await component.isLaneReadmeOf(scope.objects)
      };
    }));
    if (includeRemoved) return results;
    return results.filter(result => !result.removed);
  }

  // components can be one of the following: Component[] | ModelComponent[] | string[] | BitId[]
  static sortComponentsByName(components) {
    const getName = component => {
      let name;
      if ((0, _is2().default)(_modelComponent().default, component)) name = component.id();else if ((0, _is2().default)(_component().default, component)) name = component.id.toString();else if ((0, _is2().default)(_bitId().BitId, component)) name = component.toString();else name = component;
      return name.toUpperCase(); // ignore upper and lowercase
    };
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return components.sort((a, b) => {
      const nameA = getName(a);
      const nameB = getName(b);
      if (nameA < nameB) {
        return -1;
      }
      if (nameA > nameB) {
        return 1;
      }

      // names must be equal
      return 0;
    });
  }
  static filterComponentsByWildcard(components, idsWithWildcard) {
    const getBitId = component => {
      if ((0, _is2().default)(_modelComponent().default, component)) return component.toBitId();
      if ((0, _is2().default)(_component().default, component)) return component.id;
      if ((0, _is2().default)(_bitId().BitId, component)) return component;
      throw new TypeError(`filterComponentsByWildcard got component with the wrong type: ${typeof component}`);
    };
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return components.filter(component => {
      const bitId = getBitId(component);
      return (0, _isBitIdMatchByWildcards().default)(bitId, idsWithWildcard);
    });
  }
  static getUniqueComponents(components) {
    return (0, _uniqBy2().default)(component => JSON.stringify(component.id), components);
  }
  listComponentsByIdsWithWildcard(idsWithWildcard) {
    const allIds = this.bitMap.getAllBitIds();
    const matchedIds = ComponentsList.filterComponentsByWildcard(allIds, idsWithWildcard);
    if (!matchedIds.length) throw new (_noIdMatchWildcard().default)(idsWithWildcard);
    // $FlowFixMe filterComponentsByWildcard got BitId so it returns BitId
    return matchedIds;
  }
}
exports.default = ComponentsList;