import { IssuesList } from '@teambit/component-issues';
import BitId from '../../bit-id/bit-id';
import BitIds from '../../bit-id/bit-ids';
import { BuildStatus } from '../../constants';
import { Doclet } from '../../jsdoc/types';
import ComponentWithDependencies from '../../scope/component-dependencies';
import { ScopeListItem } from '../../scope/models/model-component';
import Version, { Log } from '../../scope/models/version';
import { PathLinux, PathOsBased, PathOsBasedRelative } from '../../utils/path';
import ComponentMap from '../bit-map/component-map';
import { Dist, License, SourceFile } from '../component/sources';
import ComponentConfig from '../config';
import ComponentOverrides from '../config/component-overrides';
import { ExtensionDataList } from '../config/extension-data';
import Consumer from '../consumer';
import { Dependencies, Dependency } from './dependencies';
import { ManuallyChangedDependencies } from './dependencies/dependency-resolver/overrides-dependencies';
import PackageJsonFile from './package-json-file';
import DataToPersist from './sources/data-to-persist';
import { ModelComponent } from '../../scope/models';
export declare type CustomResolvedPath = {
    destinationPath: PathLinux;
    importSource: string;
};
export declare type InvalidComponent = {
    id: BitId;
    error: Error;
    component: Component | undefined;
};
export declare type ComponentProps = {
    name: string;
    version?: string;
    scope?: string | null;
    lang?: string;
    bindingPrefix?: string;
    mainFile: PathOsBased;
    bitJson?: ComponentConfig;
    dependencies?: Dependency[];
    devDependencies?: Dependency[];
    flattenedDependencies?: BitIds;
    packageDependencies?: Record<string, string>;
    devPackageDependencies?: Record<string, string>;
    peerPackageDependencies?: Record<string, string>;
    overrides: ComponentOverrides;
    defaultScope: string | null;
    packageJsonFile?: PackageJsonFile;
    packageJsonChangedProps?: {
        [key: string]: any;
    };
    files: SourceFile[];
    docs?: Doclet[];
    dists?: Dist[];
    mainDistFile?: PathLinux;
    license?: License;
    deprecated?: boolean;
    removed?: boolean;
    log?: Log;
    schema?: string;
    scopesList?: ScopeListItem[];
    extensions: ExtensionDataList;
    componentFromModel?: Component;
    modelComponent?: ModelComponent;
    buildStatus?: BuildStatus;
};
export default class Component {
    static registerOnComponentConfigLoading(extId: any, func: (id: any) => any): void;
    static registerOnComponentConfigLegacyLoading(extId: any, func: (id: any, config: any) => any): void;
    static registerOnComponentOverridesLoading(extId: any, func: (id: any, config: any) => any): void;
    name: string;
    version: string | undefined;
    previouslyUsedVersion: string | undefined;
    scope: string | null | undefined;
    lang: string;
    bindingPrefix: string;
    mainFile: PathOsBased;
    bitJson: ComponentConfig | undefined;
    dependencies: Dependencies;
    devDependencies: Dependencies;
    flattenedDependencies: BitIds;
    packageDependencies: Record<string, string>;
    devPackageDependencies: Record<string, string>;
    peerPackageDependencies: Record<string, string>;
    manuallyRemovedDependencies: ManuallyChangedDependencies;
    manuallyAddedDependencies: ManuallyChangedDependencies;
    overrides: ComponentOverrides;
    docs: Doclet[] | undefined;
    files: SourceFile[];
    license: License | undefined;
    log: Log | undefined;
    writtenPath?: PathOsBasedRelative;
    dependenciesSavedAsComponents: boolean | undefined;
    loadedFromFileSystem: boolean;
    schema?: string;
    componentMap: ComponentMap | undefined;
    componentFromModel: Component | undefined;
    modelComponent?: ModelComponent;
    issues: IssuesList;
    deprecated: boolean;
    removed?: boolean;
    defaultScope: string | null;
    _isModified: boolean;
    packageJsonFile: PackageJsonFile | undefined;
    packageJsonChangedProps: Record<string, any> | undefined;
    _currentlyUsedVersion: BitId;
    pendingVersion: Version;
    dataToPersist: DataToPersist;
    scopesList: ScopeListItem[] | undefined;
    extensions: ExtensionDataList;
    _capsuleDir?: string;
    buildStatus?: BuildStatus;
    get id(): BitId;
    constructor({ name, version, scope, files, lang, bindingPrefix, mainFile, bitJson, dependencies, devDependencies, flattenedDependencies, packageDependencies, devPackageDependencies, peerPackageDependencies, componentFromModel, modelComponent, overrides, schema, defaultScope, packageJsonFile, packageJsonChangedProps, docs, license, log, deprecated, removed, scopesList, extensions, buildStatus, }: ComponentProps);
    validateComponent(): void;
    /**
     * Warning: this method does not return a deep copy for all objects in this class, only for the
     * ones you see in the implementation below.
     * Implement deep copy of other properties if needed
     */
    clone(): Component;
    getTmpFolder(workspacePrefix?: PathOsBased): PathOsBased;
    setDependencies(dependencies?: Dependency[]): void;
    setDevDependencies(devDependencies?: Dependency[]): void;
    getFileExtension(): string;
    _getHomepage(): string | undefined;
    get extensionDependencies(): Dependencies;
    getAllDependencies(): Dependency[];
    getAllDependenciesCloned(): Dependencies;
    getAllPackageDependencies(): {
        [x: string]: string;
    };
    getAllNonEnvsDependencies(): Dependency[];
    getAllDependenciesIds(): BitIds;
    get depsIdsGroupedByType(): {
        dependencies: BitIds;
        devDependencies: BitIds;
        extensionDependencies: BitIds;
    };
    hasDependencies(): boolean;
    getAllFlattenedDependencies(): BitId[];
    /**
     * components added since v14.8.0 have "rootDir" in .bitmap, which is mostly the same as the
     * sharedDir. so, if rootDir is found, no need to strip/add the sharedDir as the files are
     * already relative to the sharedDir rather than the author workspace.
     */
    get ignoreSharedDir(): boolean;
    get isLegacy(): boolean;
    cloneFilesWithSharedDir(): SourceFile[];
    toObject(): Record<string, any>;
    toString(): string;
    static isComponentInvalidByErrorType(err: Error): boolean;
    toComponentWithDependencies(consumer: Consumer): Promise<ComponentWithDependencies>;
    copyAllDependenciesFromModel(): void;
    static fromObject(object: Record<string, any>): Component;
    static fromString(str: string): Promise<Component>;
    static loadFromFileSystem({ componentMap, id, consumer, }: {
        componentMap: ComponentMap;
        id: BitId;
        consumer: Consumer;
    }): Promise<Component>;
}
