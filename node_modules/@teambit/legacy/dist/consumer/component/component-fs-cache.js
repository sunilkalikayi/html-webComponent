"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ComponentFsCache = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cacache() {
  const data = _interopRequireDefault(require("cacache"));
  _cacache = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _featureToggle() {
  const data = require("../../api/consumer/lib/feature-toggle");
  _featureToggle = function () {
    return data;
  };
  return data;
}
const WORKSPACE_CACHE = 'cache';
const COMPONENTS_CACHE = 'components';
const LAST_TRACK = 'last-track';
const DOCS = 'docs';
const DEPS = 'deps';
const FILE_PATHS = 'file-paths';
class ComponentFsCache {
  constructor(scopePath) {
    this.scopePath = scopePath;
    (0, _defineProperty2().default)(this, "basePath", void 0);
    (0, _defineProperty2().default)(this, "isNoFsCacheFeatureEnabled", void 0);
    this.basePath = _path().default.join(this.scopePath, WORKSPACE_CACHE, COMPONENTS_CACHE);
    this.isNoFsCacheFeatureEnabled = (0, _featureToggle().isFeatureEnabled)(_featureToggle().NO_FS_CACHE_FEATURE);
  }
  async getLastTrackTimestamp(idStr) {
    const results = await this.getFromCacheIfExist(LAST_TRACK, idStr);
    return results ? parseInt(results.data.toString()) : 0;
  }
  async setLastTrackTimestamp(idStr, timestamp) {
    await this.saveDataInCache(idStr, LAST_TRACK, Buffer.from(timestamp.toString()));
  }

  /**
   * @deprecated
   * not in use anymore. it takes time to save and get them from the cache, and it's faster to get them from the filesystem directly.
   */
  async getFilePathsFromCache(idStr) {
    return this.getStringDataFromCache(idStr, FILE_PATHS);
  }

  /**
   * @deprecated
   * not in use anymore. it takes time to save and get them from the cache, and it's faster to get them from the filesystem directly.
   */
  async saveFilePathsInCache(idStr, filePaths) {
    await this.saveStringDataInCache(idStr, FILE_PATHS, filePaths);
  }
  async getDocsFromCache(filePath) {
    return this.getStringDataFromCache(filePath, DOCS);
  }
  async saveDocsInCache(filePath, docs) {
    await this.saveStringDataInCache(filePath, DOCS, docs);
  }
  async getDependenciesDataFromCache(idStr) {
    return this.getStringDataFromCache(idStr, DEPS);
  }
  async saveDependenciesDataInCache(idStr, dependenciesData) {
    const metadata = {
      timestamp: Date.now()
    };
    await this.saveDataInCache(idStr, DEPS, dependenciesData, metadata);
  }
  async deleteAllDependenciesDataCache() {
    await _cacache().default.rm.all(this.getCachePath(DEPS));
  }
  async listDependenciesDataCache() {
    return _cacache().default.ls(this.getCachePath(DEPS));
  }
  async saveStringDataInCache(key, cacheName, data) {
    const dataBuffer = Buffer.from(JSON.stringify(data));
    const metadata = {
      timestamp: Date.now()
    };
    await this.saveDataInCache(key, cacheName, dataBuffer, metadata);
  }
  async saveDataInCache(key, cacheName, data, metadata) {
    if (this.isNoFsCacheFeatureEnabled) return;
    const cachePath = this.getCachePath(cacheName);
    await _cacache().default.put(cachePath, key, data, {
      metadata
    });
  }
  async getStringDataFromCache(key, cacheName) {
    const results = await this.getFromCacheIfExist(cacheName, key);
    if (!results) return null;
    return {
      timestamp: results.metadata.timestamp,
      data: results.data.toString()
    };
  }
  async getFromCacheIfExist(cacheName, key) {
    if (this.isNoFsCacheFeatureEnabled) return null;
    const cachePath = this.getCachePath(cacheName);
    try {
      const results = await _cacache().default.get(cachePath, key);
      return results;
    } catch (err) {
      if (err.code === 'ENOENT') {
        return null; // cache doesn't exists
      }

      if (err.code === 'EINTEGRITY') {
        _fsExtra().default.removeSync(cachePath);
        return null;
      }
      throw err;
    }
  }
  getCachePath(cacheName) {
    return _path().default.join(this.basePath, cacheName);
  }
}
exports.ComponentFsCache = ComponentFsCache;