"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _clone2() {
  const data = _interopRequireDefault(require("ramda/src/clone"));
  _clone2 = function () {
    return data;
  };
  return data;
}
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _detectIndent() {
  const data = _interopRequireDefault(require("detect-indent"));
  _detectIndent = function () {
    return data;
  };
  return data;
}
function _detectNewline() {
  const data = _interopRequireDefault(require("detect-newline"));
  _detectNewline = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _stringifyPackage() {
  const data = _interopRequireDefault(require("stringify-package"));
  _stringifyPackage = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("../../utils/bit/component-id-to-package-name"));
  _componentIdToPackageName = function () {
    return data;
  };
  return data;
}
function _packageJsonVinyl() {
  const data = _interopRequireDefault(require("./package-json-vinyl"));
  _packageJsonVinyl = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * when a package.json file is loaded, we save the indentation and the type of newline it uses, so
 * then we could preserve it later on while writing the file. this is same process used by NPM when
 * writing the package.json file
 */
class PackageJsonFile {
  // default when writing (in stringifyPackage) is "  ". (two spaces).
  // whether "\n" or "\r\n", default when writing (in stringifyPackage) is "\n"
  constructor({
    filePath,
    packageJsonObject = {},
    fileExist,
    workspaceDir,
    indent,
    newline
  }) {
    (0, _defineProperty2().default)(this, "packageJsonObject", void 0);
    (0, _defineProperty2().default)(this, "fileExist", void 0);
    (0, _defineProperty2().default)(this, "filePath", void 0);
    (0, _defineProperty2().default)(this, "workspaceDir", void 0);
    (0, _defineProperty2().default)(this, "indent", void 0);
    (0, _defineProperty2().default)(this, "newline", void 0);
    this.filePath = filePath;
    this.packageJsonObject = packageJsonObject;
    this.fileExist = fileExist;
    this.workspaceDir = workspaceDir;
    this.indent = indent;
    this.newline = newline;
  }
  async write() {
    if (!this.workspaceDir) throw new Error('PackageJsonFile is unable to write, workspaceDir is not defined');
    const pathToWrite = path().join(this.workspaceDir, this.filePath);
    _logger().default.debug(`package-json-file.write, path ${pathToWrite}`);
    const packageJsonStr = (0, _stringifyPackage().default)(this.packageJsonObject, this.indent, this.newline);
    await _fsExtra().default.outputFile(pathToWrite, packageJsonStr);
    this.fileExist = true;
  }

  /**
   * load from the given dir, if not exist, don't throw an error, just set packageJsonObject as an
   * empty object
   */
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  static async load(workspaceDir, componentDir = '.') {
    const filePath = composePath(componentDir);
    const filePathAbsolute = path().join(workspaceDir, filePath);
    const packageJsonStr = await PackageJsonFile.getPackageJsonStrIfExist(filePathAbsolute);
    if (!packageJsonStr) {
      return new PackageJsonFile({
        filePath,
        fileExist: false,
        workspaceDir
      });
    }
    const packageJsonObject = PackageJsonFile.parsePackageJsonStr(packageJsonStr, componentDir);
    const indent = (0, _detectIndent().default)(packageJsonStr).indent;
    const newline = (0, _detectNewline().default)(packageJsonStr);
    return new PackageJsonFile({
      filePath,
      packageJsonObject,
      fileExist: true,
      workspaceDir,
      indent,
      newline
    });
  }
  static async reset(workspaceDir) {
    const pkgJsonFile = await PackageJsonFile.load(workspaceDir);
    if (pkgJsonFile.fileExist) {
      pkgJsonFile.removeProperty('bit');
      await pkgJsonFile.write();
    }
  }
  static loadSync(workspaceDir, componentDir = '.') {
    const filePath = composePath(componentDir);
    const filePathAbsolute = path().join(workspaceDir, filePath);
    const packageJsonStr = PackageJsonFile.getPackageJsonStrIfExistSync(filePathAbsolute);
    if (!packageJsonStr) {
      return new PackageJsonFile({
        filePath,
        fileExist: false,
        workspaceDir
      });
    }
    const packageJsonObject = PackageJsonFile.parsePackageJsonStr(packageJsonStr, componentDir);
    const indent = (0, _detectIndent().default)(packageJsonStr).indent;
    const newline = (0, _detectNewline().default)(packageJsonStr);
    return new PackageJsonFile({
      filePath,
      packageJsonObject,
      fileExist: true,
      workspaceDir,
      indent,
      newline
    });
  }
  static loadFromPathSync(workspaceDir, pathToLoad) {
    const filePath = composePath(pathToLoad);
    const filePathAbsolute = path().join(workspaceDir, filePath);
    const packageJsonStr = PackageJsonFile.getPackageJsonStrIfExistSync(filePathAbsolute);
    if (!packageJsonStr) {
      return new PackageJsonFile({
        filePath,
        fileExist: false,
        workspaceDir
      });
    }
    const packageJsonObject = PackageJsonFile.parsePackageJsonStr(packageJsonStr, pathToLoad);
    return new PackageJsonFile({
      filePath,
      packageJsonObject,
      fileExist: true,
      workspaceDir
    });
  }
  static loadFromCapsuleSync(capsuleRootDir) {
    const filePath = composePath('.');
    const filePathAbsolute = path().join(capsuleRootDir, filePath);
    const packageJsonStr = PackageJsonFile.getPackageJsonStrIfExistSync(filePathAbsolute);
    if (!packageJsonStr) {
      throw new Error(`capsule ${capsuleRootDir} is missing package.json`);
    }
    const packageJsonObject = PackageJsonFile.parsePackageJsonStr(packageJsonStr, filePath);
    return new PackageJsonFile({
      filePath,
      packageJsonObject,
      fileExist: true,
      workspaceDir: capsuleRootDir
    });
  }
  static createFromComponent(componentDir, component, addDefaultScopeToCompId = false,
  // for the capsule, we want the default-scope because it gets published
  addExportProperty = false) {
    const filePath = composePath(componentDir);
    const name = (0, _componentIdToPackageName().default)(_objectSpread(_objectSpread({
      withPrefix: true
    }, component), {}, {
      id: component.id
    }));
    const componentIdWithDefaultScope = component.id.hasScope() || !addDefaultScopeToCompId ? component.id : component.id.changeScope(component.defaultScope);
    const packageJsonObject = {
      name,
      version: component.version,
      homepage: component._getHomepage(),
      main: component.mainFile,
      // Used for determine that a package is a component
      // Used when resolve dependencies to identify that some package should be treated as component
      // TODO: replace by better way to identify that something is a component for sure
      // TODO: Maybe need to add the binding prefix here
      componentId: componentIdWithDefaultScope.serialize(),
      dependencies: _objectSpread({}, component.packageDependencies),
      devDependencies: _objectSpread({}, component.devPackageDependencies),
      peerDependencies: _objectSpread({}, component.peerPackageDependencies),
      license: `SEE LICENSE IN ${!(0, _isEmpty2().default)(component.license) ? 'LICENSE' : 'UNLICENSED'}`
    };
    // @ts-ignore
    if (addExportProperty) packageJsonObject.exported = component.id.hasScope();
    if (!packageJsonObject.homepage) delete packageJsonObject.homepage;
    return new PackageJsonFile({
      filePath,
      packageJsonObject,
      fileExist: false
    });
  }
  toVinylFile() {
    return _packageJsonVinyl().default.load({
      base: path().dirname(this.filePath),
      path: this.filePath,
      content: this.packageJsonObject,
      indent: this.indent,
      newline: this.newline
    });
  }
  addDependencies(dependencies) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    this.packageJsonObject.dependencies = Object.assign({}, this.packageJsonObject.dependencies, dependencies);
  }
  addDevDependencies(dependencies) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    this.packageJsonObject.devDependencies = Object.assign({}, this.packageJsonObject.devDependencies, dependencies);
  }
  removeDependency(dependency) {
    delete this.packageJsonObject.dependencies[dependency];
  }
  copyPeerDependenciesToDev() {
    const devDeps = this.packageJsonObject.devDependencies || {};
    const peerDeps = this.packageJsonObject.peerDependencies || {};
    this.packageJsonObject.devDependencies = _objectSpread(_objectSpread({}, devDeps), peerDeps);
  }
  replaceDependencies(dependencies) {
    Object.keys(dependencies).forEach(dependency => {
      _constants().DEPENDENCIES_FIELDS.forEach(dependencyField => {
        if (this.packageJsonObject[dependencyField] && this.packageJsonObject[dependencyField][dependency]) {
          this.packageJsonObject[dependencyField][dependency] = dependencies[dependency];
        }
      });
    });
  }
  addOrUpdateProperty(propertyName, propertyValue) {
    this.packageJsonObject[propertyName] = propertyValue;
  }
  removeProperty(propertyName) {
    delete this.packageJsonObject[propertyName];
  }
  getProperty(propertyName) {
    return this.packageJsonObject[propertyName];
  }
  setPackageManager(packageManager) {
    if (!packageManager) return;
    this.packageJsonObject.packageManager = packageManager;
  }
  mergePackageJsonObject(packageJsonObject) {
    if (!packageJsonObject || (0, _isEmpty2().default)(packageJsonObject)) return;
    this.packageJsonObject = Object.assign(this.packageJsonObject, packageJsonObject);
  }
  clone() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const clone = new PackageJsonFile(this);
    clone.packageJsonObject = (0, _clone2().default)(this.packageJsonObject);
    return clone;
  }
  static propsNonUserChangeable() {
    return ['name', 'version', 'main', 'dependencies', 'devDependencies', 'peerDependencies', 'license', 'bit'];
  }
  static parsePackageJsonStr(str, dir) {
    try {
      return JSON.parse(str);
    } catch (err) {
      throw new Error(`failed parsing package.json file at ${dir}. original error: ${err.message}`);
    }
  }
  static async getPackageJsonStrIfExist(filePath) {
    try {
      return await _fsExtra().default.readFile(filePath, 'utf-8');
    } catch (err) {
      if (err.code === 'ENOENT') {
        return null; // file not found
      }

      throw err;
    }
  }
  static getPackageJsonStrIfExistSync(filePath) {
    try {
      return _fsExtra().default.readFileSync(filePath, 'utf-8');
    } catch (err) {
      if (err.code === 'ENOENT') {
        return null; // file not found
      }

      throw err;
    }
  }
}
exports.default = PackageJsonFile;
function composePath(componentRootFolder) {
  return path().join(componentRootFolder, _constants().PACKAGE_JSON);
}