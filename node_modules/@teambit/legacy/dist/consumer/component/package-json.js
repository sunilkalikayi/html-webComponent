"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("../../utils/bit/component-id-to-package-name"));
  _componentIdToPackageName = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function composePath(componentRootFolder) {
  return _path().default.join(componentRootFolder, _constants().PACKAGE_JSON);
}
class PackageJson {
  // path where to write the package.json

  constructor(componentRootFolder, {
    name,
    version,
    homepage,
    main,
    dependencies,
    devDependencies,
    peerDependencies,
    license,
    scripts,
    workspaces,
    componentId,
    exported
  }) {
    (0, _defineProperty2().default)(this, "name", void 0);
    (0, _defineProperty2().default)(this, "version", void 0);
    (0, _defineProperty2().default)(this, "homepage", void 0);
    (0, _defineProperty2().default)(this, "main", void 0);
    (0, _defineProperty2().default)(this, "dependencies", void 0);
    (0, _defineProperty2().default)(this, "devDependencies", void 0);
    (0, _defineProperty2().default)(this, "peerDependencies", void 0);
    (0, _defineProperty2().default)(this, "componentRootFolder", void 0);
    (0, _defineProperty2().default)(this, "license", void 0);
    (0, _defineProperty2().default)(this, "scripts", void 0);
    (0, _defineProperty2().default)(this, "workspaces", void 0);
    (0, _defineProperty2().default)(this, "componentId", void 0);
    (0, _defineProperty2().default)(this, "exported", void 0);
    this.name = name;
    this.version = version;
    this.homepage = homepage;
    this.main = main;
    this.dependencies = dependencies;
    this.devDependencies = devDependencies;
    this.peerDependencies = peerDependencies;
    this.componentRootFolder = componentRootFolder;
    this.license = license;
    this.scripts = scripts;
    this.workspaces = workspaces;
    this.componentId = componentId;
    this.exported = exported;
  }
  static loadSync(componentRootFolder) {
    const composedPath = composePath(componentRootFolder);
    if (!PackageJson.hasExisting(componentRootFolder)) return null;
    try {
      const componentJsonObject = _fsExtra().default.readJsonSync(composedPath);
      return new PackageJson(componentRootFolder, componentJsonObject);
    } catch (err) {
      _logger().default.error(`failed parsing ${composedPath}, the file content is ${_fsExtra().default.readFileSync(composedPath)}`);
      throw err;
    }
  }
  static hasExisting(componentRootFolder) {
    const packageJsonPath = composePath(componentRootFolder);
    return _fsExtra().default.pathExistsSync(packageJsonPath);
  }

  /*
   * load package.json from path
   */
  static async getPackageJson(pathStr) {
    const getRawObject = () => _fsExtra().default.readJson(composePath(pathStr));
    const exist = PackageJson.hasExisting(pathStr);
    if (exist) return getRawObject();
    return null;
  }

  /*
   * save package.json in path
   */
  static saveRawObject(pathStr, obj) {
    return _fsExtra().default.outputJSON(composePath(pathStr), obj, {
      spaces: 2
    });
  }

  /*
   * remove workspaces dir from workspace in package.json with changing other fields in package.json
   */
  static async removeComponentsFromWorkspaces(rootDir, pathsTOoRemove) {
    const pkg = (await PackageJson.getPackageJson(rootDir)) || {};
    const workspaces = this.extractWorkspacesPackages(pkg);
    if (!workspaces) return;
    const updatedWorkspaces = workspaces.filter(folder => !pathsTOoRemove.includes(folder));
    this.updateWorkspacesPackages(pkg, updatedWorkspaces);
    await PackageJson.saveRawObject(rootDir, pkg);
  }

  /*
   * remove components from package.json dependencies
   */
  static async removeComponentsFromDependencies(rootDir, components) {
    const pkg = await PackageJson.getPackageJson(rootDir);
    if (pkg && pkg.dependencies) {
      components.forEach(c => {
        delete pkg.dependencies[(0, _componentIdToPackageName().default)(c)];
      });
      await PackageJson.saveRawObject(rootDir, pkg);
    }
  }
  static extractWorkspacesPackages(packageJson) {
    if (!packageJson.workspaces) return null;
    this.throwForInvalidWorkspacesConfig(packageJson);
    if (Array.isArray(packageJson.workspaces)) {
      return packageJson.workspaces;
    }
    if (Array.isArray(packageJson.workspaces.packages)) {
      return packageJson.workspaces.packages;
    }
    return null;
  }
  static updateWorkspacesPackages(packageJson, workspacesPackages) {
    if (!packageJson.workspaces) return;
    this.throwForInvalidWorkspacesConfig(packageJson);
    if (Array.isArray(packageJson.workspaces)) {
      packageJson.workspaces = workspacesPackages;
    }
    if (Array.isArray(packageJson.workspaces.packages)) {
      packageJson.workspaces.packages = workspacesPackages;
    }
  }

  /**
   * according to Yarn Git repo, the workspaces type configured as the following
   * `workspaces?: Array<string> | WorkspacesConfig`
   * and `WorkspacesConfig` is:
   * `export type WorkspacesConfig = { packages?: Array<string>, nohoist?: Array<string> };`
   * see https://github.com/yarnpkg/yarn/blob/master/src/types.js
   */
  static throwForInvalidWorkspacesConfig(packageJson) {
    if (!packageJson.workspaces) return;
    if (typeof packageJson.workspaces !== 'object' || !Array.isArray(packageJson.workspaces) && !Array.isArray(packageJson.workspaces.packages)) {
      throw new Error('workspaces property does not have the correct format, please refer to Yarn documentation');
    }
  }
}
exports.default = PackageJson;