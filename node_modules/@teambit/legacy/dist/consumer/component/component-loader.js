"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _cacheFactory() {
  const data = require("../../cache/cache-factory");
  _cacheFactory = function () {
    return data;
  };
  return data;
}
function _inMemoryCache() {
  const data = require("../../cache/in-memory-cache");
  _inMemoryCache = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("../../scope/component-ops/scope-components-importer"));
  _scopeComponentsImporter = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _lastModified() {
  const data = require("../../utils/fs/last-modified");
  _lastModified = function () {
    return data;
  };
  return data;
}
function _componentsPendingImport() {
  const data = _interopRequireDefault(require("../component-ops/exceptions/components-pending-import"));
  _componentsPendingImport = function () {
    return data;
  };
  return data;
}
function _consumerComponent() {
  const data = _interopRequireDefault(require("../component/consumer-component"));
  _consumerComponent = function () {
    return data;
  };
  return data;
}
function _componentFsCache() {
  const data = require("./component-fs-cache");
  _componentFsCache = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("./dependencies/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _dependenciesLoader() {
  const data = require("./dependencies/dependency-resolver/dependencies-loader");
  _dependenciesLoader = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class ComponentLoader {
  // cache loaded components

  // specific platforms may need to parse the entire project. (was used for Angular, currently not in use)

  constructor(consumer) {
    (0, _defineProperty2().default)(this, "componentsCache", void 0);
    (0, _defineProperty2().default)(this, "_shouldCheckForClearingDependenciesCache", true);
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "cacheResolvedDependencies", void 0);
    (0, _defineProperty2().default)(this, "cacheProjectAst", void 0);
    (0, _defineProperty2().default)(this, "componentFsCache", void 0);
    this.consumer = consumer;
    this.cacheResolvedDependencies = {};
    this.componentFsCache = new (_componentFsCache().ComponentFsCache)(consumer.scope.getPath());
    this.componentsCache = (0, _cacheFactory().createInMemoryCache)({
      maxSize: (0, _inMemoryCache().getMaxSizeForComponents)()
    });
  }
  static registerOnComponentLoadSubscriber(func) {
    this.onComponentLoadSubscribers.push(func);
  }
  static registerOnComponentIssuesCalcSubscriber(func) {
    this.onComponentIssuesCalcSubscribers.push(func);
  }
  clearComponentsCache() {
    this.componentsCache.deleteAll();
    this.cacheResolvedDependencies = {};
    this._shouldCheckForClearingDependenciesCache = true;
  }
  clearOneComponentCache(id) {
    const idStr = id.toString();
    this.componentsCache.delete(idStr);
    this.cacheResolvedDependencies = {};
  }
  async invalidateDependenciesCacheIfNeeded() {
    if (this._shouldCheckForClearingDependenciesCache) {
      const pathsToCheck = [path().join(this.consumer.getPath(), 'node_modules'), path().join(this.consumer.getPath(), 'package.json'), path().join(this.consumer.getPath(), _constants().BIT_MAP), this.consumer.config.path];
      const lastModified = await (0, _lastModified().getLastModifiedPathsTimestampMs)(pathsToCheck);
      const dependenciesCacheList = await this.componentFsCache.listDependenciesDataCache();
      const lastUpdateAllComps = Object.keys(dependenciesCacheList).map(key => dependenciesCacheList[key].time);
      const firstCacheEntered = Math.min(...lastUpdateAllComps);
      // if lastUpdateAllComps is empty, firstCacheEntered is Infinity so shouldInvalidate is
      // always false, which is good. no need to invalidate the cache if nothing there.
      const shouldInvalidate = lastModified > firstCacheEntered;
      if (shouldInvalidate) {
        // at least one component inserted to the cache before workspace-config/node-modules
        // modification, invalidate the entire deps-cache.
        _logger().default.debug('component-loader, invalidating dependencies cache because either node-modules or workspace config had been changed');
        await this.componentFsCache.deleteAllDependenciesDataCache();
      }
    }
    this._shouldCheckForClearingDependenciesCache = false;
  }
  async loadMany(ids, throwOnFailure = true, loadOpts) {
    _logger().default.debugAndAddBreadCrumb('ComponentLoader', 'loading consumer-components from the file-system, ids: {ids}', {
      ids: ids.toString()
    });
    const alreadyLoadedComponents = [];
    const idsToProcess = [];
    const invalidComponents = [];
    const removedComponents = [];
    ids.forEach(id => {
      if (id.constructor.name !== _bitId().BitId.name) {
        throw new TypeError(`consumer.loadComponents expects to get BitId instances, instead, got "${typeof id}"`);
      }
      const idWithVersion = (0, _utils().getLatestVersionNumber)(this.consumer.bitmapIdsFromCurrentLaneIncludeRemoved, id);
      const idStr = idWithVersion.toString();
      const fromCache = this.componentsCache.get(idStr);
      if (fromCache) {
        alreadyLoadedComponents.push(fromCache);
      } else {
        idsToProcess.push(idWithVersion);
      }
    });
    _logger().default.debugAndAddBreadCrumb('ComponentLoader', `the following ${alreadyLoadedComponents.length} components have been already loaded, get them from the cache. {idsStr}`, {
      idsStr: alreadyLoadedComponents.map(c => c.id.toString()).join(', ')
    });
    if (!idsToProcess.length) return {
      components: alreadyLoadedComponents,
      invalidComponents,
      removedComponents
    };
    const allComponents = [];
    await (0, _pMapSeries().default)(idsToProcess, async id => {
      const component = await this.loadOne(id, throwOnFailure, invalidComponents, removedComponents, loadOpts);
      if (component) {
        this.componentsCache.set(component.id.toString(), component);
        _logger().default.debugAndAddBreadCrumb('ComponentLoader', 'Finished loading the component "{id}"', {
          id: component.id.toString()
        });
        allComponents.push(component);
      }
    });
    return {
      components: allComponents.concat(alreadyLoadedComponents),
      invalidComponents,
      removedComponents
    };
  }
  async loadOne(id, throwOnFailure, invalidComponents, removedComponents, loadOpts) {
    let componentMap = this.consumer.bitMap.getComponent(id);
    if (componentMap.isRemoved()) {
      const fromModel = await this.consumer.scope.getConsumerComponentIfExist(id);
      if (!fromModel) {
        invalidComponents.push({
          id,
          error: new Error(`fatal: ${id.toString()} is marked as removed but its objects are missing from the local scope, try to import this component individually with --objects flag`),
          component: undefined
        });
        return null;
      }
      fromModel.removed = true;
      fromModel.componentMap = componentMap;
      removedComponents.push(fromModel);
      return null;
    }
    let component;
    const handleError = error => {
      if (throwOnFailure) throw error;
      _logger().default.errorAndAddBreadCrumb('component-loader.loadOne', 'failed loading {id} from the file-system', {
        id: id.toString()
      });
      if (_consumerComponent().default.isComponentInvalidByErrorType(error)) {
        invalidComponents.push({
          id,
          error,
          component
        });
        return null;
      }
      throw error;
    };
    const newId = await this._handleOutOfSyncScenarios(componentMap);
    if (newId) {
      componentMap = this.consumer.bitMap.getComponent(newId);
    }
    const updatedId = newId || id;
    try {
      component = await _consumerComponent().default.loadFromFileSystem({
        componentMap,
        id: updatedId,
        consumer: this.consumer
      });
    } catch (err) {
      return handleError(err);
    }
    component.loadedFromFileSystem = true;
    // reload component map as it may be changed after calling Component.loadFromFileSystem()
    component.componentMap = this.consumer.bitMap.getComponent(updatedId);
    await this._handleOutOfSyncWithDefaultScope(component);
    const loadDependencies = async () => {
      await this.invalidateDependenciesCacheIfNeeded();
      const dependenciesLoader = new (_dependenciesLoader().DependenciesLoader)(component, this.consumer, {
        cacheResolvedDependencies: this.cacheResolvedDependencies,
        cacheProjectAst: this.cacheProjectAst,
        useDependenciesCache: component.issues.isEmpty()
      });
      await dependenciesLoader.load();
      (0, _dependencyResolver().updateDependenciesVersions)(this.consumer, component);
    };
    const runOnComponentLoadEvent = async () => {
      return (0, _pMapSeries().default)(ComponentLoader.onComponentLoadSubscribers, async subscriber => {
        component = await subscriber(component, loadOpts);
      });
    };
    try {
      await loadDependencies();
      await runOnComponentLoadEvent();
    } catch (err) {
      return handleError(err);
    }
    return component;
  }
  async runOnComponentIssuesCalcEvent(component) {
    return (0, _pMapSeries().default)(ComponentLoader.onComponentIssuesCalcSubscribers, async subscriber => {
      const issues = await subscriber(component);
      issues.forEach(issue => {
        component.issues.add(issue);
      });
    });
  }
  async _handleOutOfSyncScenarios(componentMap) {
    const currentId = componentMap.id;
    const componentFromModel = await this.consumer.loadComponentFromModelIfExist(currentId);
    let newId;
    if (componentFromModel && !currentId.hasVersion()) {
      // component is in the scope but .bitmap doesn't have version, sync .bitmap with the scope data
      newId = currentId.changeVersion(componentFromModel.version);
      if (componentFromModel.scope) newId = newId.changeScope(componentFromModel.scope);
    }
    if (componentFromModel && componentFromModel.scope && currentId.hasVersion() && !currentId.hasScope()) {
      // component is not exported in .bitmap but exported in the scope, sync .bitmap with the scope data
      newId = currentId.changeScope(componentFromModel.scope);
    }
    if (!componentFromModel && currentId.hasVersion()) {
      // the version used in .bitmap doesn't exist in the scope
      const modelComponent = await this.consumer.scope.getModelComponentIfExist(currentId.changeVersion(undefined));
      if (modelComponent) {
        // the scope has this component but not the version used in .bitmap, sync .bitmap with
        // latest version from the scope
        await this._throwPendingImportIfNeeded(currentId);
        newId = currentId.changeVersion(modelComponent.latest());
      } else if (!currentId.hasScope()) {
        // the scope doesn't have this component and .bitmap doesn't have scope, assume it's new
        newId = currentId.changeVersion(undefined);
      }
    }
    if (newId) {
      this.consumer.bitMap.updateComponentId(newId);
    }
    return newId;
  }
  async _handleOutOfSyncWithDefaultScope(component) {
    const {
      componentFromModel,
      componentMap
    } = component;
    // @ts-ignore componentMap is set here
    const currentId = componentMap.id;
    if (!componentFromModel && !currentId.hasVersion()) {
      // for Harmony, we know ahead the defaultScope, so even then .bitmap shows it as new and
      // there is nothing in the scope, we can check if there is a component with the same
      // default-scope in the objects
      const modelComponent = await this.consumer.scope.getModelComponentIfExist(currentId.changeScope(component.defaultScope));
      if (modelComponent) {
        const newId = currentId.changeVersion(modelComponent.latest()).changeScope(modelComponent.scope);
        component.componentFromModel = await this.consumer.loadComponentFromModelIfExist(newId);
        component.version = newId.version;
        component.scope = newId.scope;
        this.consumer.bitMap.updateComponentId(newId);
        component.componentMap = this.consumer.bitMap.getComponent(newId);
      }
    }
  }
  async _throwPendingImportIfNeeded(currentId) {
    if (currentId.hasScope()) {
      const remoteComponent = await this._getRemoteComponent(currentId);
      // @todo-lanes: make it work with lanes. It needs to go through the objects one by one and check
      // whether one of the hashes exist.
      // @ts-ignore version is set here
      if (remoteComponent && remoteComponent.hasTag(currentId.version)) {
        throw new (_componentsPendingImport().default)();
      }
    }
  }
  async _getRemoteComponent(id) {
    const scopeComponentsImporter = new (_scopeComponentsImporter().default)(this.consumer.scope);
    const objectList = await scopeComponentsImporter.getRemoteComponent(id);
    if (!objectList) return null;
    const components = objectList.getComponents();
    if (!components.length) return null; // probably doesn't exist
    return components[0];
  }
  static getInstance(consumer) {
    return new ComponentLoader(consumer);
  }
}
exports.default = ComponentLoader;
(0, _defineProperty2().default)(ComponentLoader, "onComponentLoadSubscribers", []);
(0, _defineProperty2().default)(ComponentLoader, "onComponentIssuesCalcSubscribers", []);