import { BitId, BitIds } from '../../bit-id';
import { DivergeData } from '../../scope/component-ops/diverge-data';
import { Lane } from '../../scope/models';
import ModelComponent from '../../scope/models/model-component';
import Scope from '../../scope/scope';
import BitMap from '../bit-map/bit-map';
import Component from '../component';
import { InvalidComponent } from '../component/consumer-component';
import Consumer from '../consumer';
import { ComponentLoadOptions } from './component-loader';
export declare type DivergeDataPerId = {
    id: BitId;
    divergeData: DivergeData;
};
export declare type ListScopeResult = {
    id: BitId;
    currentlyUsedVersion?: string | null | undefined;
    remoteVersion?: string;
    deprecated?: boolean;
    removed?: boolean;
    laneReadmeOf?: string[];
};
export declare type DivergedComponent = {
    id: BitId;
    diverge: DivergeData;
};
export default class ComponentsList {
    consumer: Consumer;
    scope: Scope;
    bitMap: BitMap;
    _fromFileSystem: {
        [cacheKey: string]: Component[];
    };
    _fromObjectsIds: BitId[];
    _modelComponents: ModelComponent[];
    _invalidComponents: InvalidComponent[];
    _modifiedComponents: Component[];
    _removedComponents: Component[];
    private _mergePendingComponents;
    constructor(consumer: Consumer);
    getModelComponents(): Promise<ModelComponent[]>;
    /**
     * List all bit ids stored in the model
     */
    getFromObjects(): Promise<BitId[]>;
    getComponentsFromFS(loadOpts?: ComponentLoadOptions): Promise<Component[]>;
    /**
     * Components that are in the model (either, tagged from a local scope or imported), and were
     * changed in the file system
     *
     * @param {boolean} [load=false] - Whether to load the component (false will return only the id)
     */
    listModifiedComponents(load?: boolean, loadOpts?: ComponentLoadOptions): Promise<Array<BitId | Component>>;
    listOutdatedComponents(loadOpts?: ComponentLoadOptions): Promise<Component[]>;
    /**
     * list components that their head is a snap, not a tag.
     * this is relevant only when the lane is the default (main), otherwise, the head is always a snap.
     * components that are during-merge are filtered out, we don't want them during tag and don't want
     * to show them in the "snapped" section in bit-status.
     */
    listSnappedComponentsOnMain(): Promise<ModelComponent[]>;
    /**
     * list components on a lane that their main got updates.
     */
    listUpdatesFromMainPending(): Promise<DivergeDataPerId[]>;
    /**
     * if the local lane was forked from another lane, this gets the differences between the two
     */
    listUpdatesFromForked(): Promise<DivergeDataPerId[]>;
    listMergePendingComponents(loadOpts?: ComponentLoadOptions): Promise<DivergedComponent[]>;
    listDuringMergeStateComponents(): BitIds;
    listSoftTaggedComponents(): BitId[];
    newModifiedAndAutoTaggedComponents(): Promise<Component[]>;
    idsFromObjects(): Promise<BitIds>;
    /**
     * Components that are registered in bit.map but have never been tagged
     *
     * @param {boolean} [load=false] - Whether to load the component (false will return only the id)
     * @memberof ComponentsList
     */
    listNewComponents(load?: boolean, loadOpts?: ComponentLoadOptions): Promise<BitIds | Component[]>;
    /**
     * list all components that can be tagged.
     */
    listPotentialTagAllWorkspace(): Promise<BitId[]>;
    /**
     * New and modified components are tag pending
     *
     * @return {Promise<string[]>}
     */
    listTagPendingComponents(): Promise<BitIds>;
    listExportPendingComponentsIds(lane?: Lane | null): Promise<BitIds>;
    listNonNewComponentsIds(loadOpts?: ComponentLoadOptions): Promise<BitIds>;
    updateIdsFromModelIfTheyOutOfSync(ids: BitIds, loadOpts?: ComponentLoadOptions): Promise<BitIds>;
    listExportPendingComponents(laneObj: Lane | null): Promise<ModelComponent[]>;
    listAutoTagPendingComponents(): Promise<Component[]>;
    idsFromBitMap(): BitIds;
    listAllIdsFromWorkspaceAndScope(): Promise<BitIds>;
    /**
     * Finds all components that are saved in the file system.
     * Components might be stored in the default component directory and also might be outside
     * of that directory. The bit.map is used to find them all
     * If they are on bit.map but not on the file-system, populate them to _invalidComponents property
     */
    getFromFileSystem(loadOpts?: ComponentLoadOptions): Promise<Component[]>;
    /**
     * components that are on bit.map but not on the file-system
     */
    listInvalidComponents(): Promise<InvalidComponent[]>;
    /**
     * components that were deleted by soft-remove (bit remove --soft) and were not tagged/snapped after this change.
     * practically, their bitmap record has the config or "removed: true" and the component has deleted from the filesystem
     * in bit-status, we suggest to snap+export.
     */
    listLocallySoftRemoved(): Promise<BitId[]>;
    /**
     * components that were soft-removed previously (probably in another workspace), exported and re-introduced here.
     * practically, the current `Version` object has a config with "removed: true", and the component exists in the filesystem
     * in bit-status we suggest to "bit remove".
     */
    listRemotelySoftRemoved(): Promise<Component[]>;
    /**
     * valid on legacy only. Harmony requires components to have their own directories
     */
    listComponentsWithIndividualFiles(): Promise<Component[]>;
    /**
     * get called when the Consumer is available, shows also components from remote scopes
     */
    listAll(showRemoteVersion: boolean, listScope: boolean, namespacesUsingWildcards?: string): Promise<ListScopeResult[]>;
    /**
     * get called from a bare-scope, shows only components of that scope
     */
    static listLocalScope(scope: Scope, namespacesUsingWildcards?: string, includeRemoved?: boolean): Promise<ListScopeResult[]>;
    static sortComponentsByName<T>(components: T): T;
    static filterComponentsByWildcard<T>(components: T, idsWithWildcard: string[] | string): T;
    static getUniqueComponents(components: Component[]): Component[];
    listComponentsByIdsWithWildcard(idsWithWildcard: string[]): BitId[];
}
