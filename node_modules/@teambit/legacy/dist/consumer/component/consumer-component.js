"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));
  _flatten2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _componentIssues() {
  const data = require("@teambit/component-issues");
  _componentIssues = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = _interopRequireDefault(require("../../bit-id/bit-id"));
  _bitId = function () {
    return data;
  };
  return data;
}
function _bitIds() {
  const data = _interopRequireDefault(require("../../bit-id/bit-ids"));
  _bitIds = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _parser() {
  const data = _interopRequireDefault(require("../../jsdoc/parser"));
  _parser = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _componentDependencies() {
  const data = _interopRequireDefault(require("../../scope/component-dependencies"));
  _componentDependencies = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _ignoredDirectory() {
  const data = require("../component-ops/add-components/exceptions/ignored-directory");
  _ignoredDirectory = function () {
    return data;
  };
  return data;
}
function _componentsPendingImport() {
  const data = _interopRequireDefault(require("../component-ops/exceptions/components-pending-import"));
  _componentsPendingImport = function () {
    return data;
  };
  return data;
}
function _sources() {
  const data = require("../component/sources");
  _sources = function () {
    return data;
  };
  return data;
}
function _config() {
  const data = _interopRequireDefault(require("../config"));
  _config = function () {
    return data;
  };
  return data;
}
function _componentOverrides() {
  const data = _interopRequireDefault(require("../config/component-overrides"));
  _componentOverrides = function () {
    return data;
  };
  return data;
}
function _extensionData() {
  const data = require("../config/extension-data");
  _extensionData = function () {
    return data;
  };
  return data;
}
function _componentOutOfSync() {
  const data = _interopRequireDefault(require("../exceptions/component-out-of-sync"));
  _componentOutOfSync = function () {
    return data;
  };
  return data;
}
function _componentSchema() {
  const data = require("./component-schema");
  _componentSchema = function () {
    return data;
  };
  return data;
}
function _dependencies() {
  const data = require("./dependencies");
  _dependencies = function () {
    return data;
  };
  return data;
}
function _componentNotFoundInPath() {
  const data = _interopRequireDefault(require("./exceptions/component-not-found-in-path"));
  _componentNotFoundInPath = function () {
    return data;
  };
  return data;
}
function _mainFileRemoved() {
  const data = _interopRequireDefault(require("./exceptions/main-file-removed"));
  _mainFileRemoved = function () {
    return data;
  };
  return data;
}
function _missingFilesFromComponent() {
  const data = _interopRequireDefault(require("./exceptions/missing-files-from-component"));
  _missingFilesFromComponent = function () {
    return data;
  };
  return data;
}
function _noComponentDir() {
  const data = require("./exceptions/no-component-dir");
  _noComponentDir = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class Component {
  static registerOnComponentConfigLoading(extId, func) {
    _config().default.registerOnComponentConfigLoading(extId, func);
  }
  static registerOnComponentConfigLegacyLoading(extId, func) {
    _config().default.registerOnComponentConfigLegacyLoading(extId, func);
  }
  static registerOnComponentOverridesLoading(extId, func) {
    _componentOverrides().default.registerOnComponentOverridesLoading(extId, func);
  }
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  get id() {
    return new (_bitId().default)({
      scope: this.scope,
      name: this.name,
      version: this.version
    });
  }
  constructor({
    name,
    version,
    scope,
    files,
    lang,
    bindingPrefix,
    mainFile,
    bitJson,
    dependencies,
    devDependencies,
    flattenedDependencies,
    packageDependencies,
    devPackageDependencies,
    peerPackageDependencies,
    componentFromModel,
    modelComponent,
    overrides,
    schema,
    defaultScope,
    packageJsonFile,
    packageJsonChangedProps,
    docs,
    license,
    log,
    deprecated,
    removed,
    scopesList,
    extensions,
    buildStatus
  }) {
    (0, _defineProperty2().default)(this, "name", void 0);
    (0, _defineProperty2().default)(this, "version", void 0);
    (0, _defineProperty2().default)(this, "previouslyUsedVersion", void 0);
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "lang", void 0);
    (0, _defineProperty2().default)(this, "bindingPrefix", void 0);
    (0, _defineProperty2().default)(this, "mainFile", void 0);
    (0, _defineProperty2().default)(this, "bitJson", void 0);
    (0, _defineProperty2().default)(this, "dependencies", void 0);
    (0, _defineProperty2().default)(this, "devDependencies", void 0);
    (0, _defineProperty2().default)(this, "flattenedDependencies", void 0);
    (0, _defineProperty2().default)(this, "packageDependencies", void 0);
    (0, _defineProperty2().default)(this, "devPackageDependencies", void 0);
    (0, _defineProperty2().default)(this, "peerPackageDependencies", void 0);
    (0, _defineProperty2().default)(this, "manuallyRemovedDependencies", {});
    (0, _defineProperty2().default)(this, "manuallyAddedDependencies", {});
    (0, _defineProperty2().default)(this, "overrides", void 0);
    (0, _defineProperty2().default)(this, "docs", void 0);
    (0, _defineProperty2().default)(this, "files", void 0);
    (0, _defineProperty2().default)(this, "license", void 0);
    (0, _defineProperty2().default)(this, "log", void 0);
    (0, _defineProperty2().default)(this, "writtenPath", void 0);
    (0, _defineProperty2().default)(this, "dependenciesSavedAsComponents", true);
    (0, _defineProperty2().default)(this, "loadedFromFileSystem", false);
    (0, _defineProperty2().default)(this, "schema", void 0);
    (0, _defineProperty2().default)(this, "componentMap", void 0);
    (0, _defineProperty2().default)(this, "componentFromModel", void 0);
    (0, _defineProperty2().default)(this, "modelComponent", void 0);
    (0, _defineProperty2().default)(this, "issues", void 0);
    (0, _defineProperty2().default)(this, "deprecated", void 0);
    (0, _defineProperty2().default)(this, "removed", void 0);
    (0, _defineProperty2().default)(this, "defaultScope", void 0);
    (0, _defineProperty2().default)(this, "_isModified", void 0);
    (0, _defineProperty2().default)(this, "packageJsonFile", void 0);
    (0, _defineProperty2().default)(this, "packageJsonChangedProps", void 0);
    (0, _defineProperty2().default)(this, "_currentlyUsedVersion", void 0);
    (0, _defineProperty2().default)(this, "pendingVersion", void 0);
    (0, _defineProperty2().default)(this, "dataToPersist", void 0);
    (0, _defineProperty2().default)(this, "scopesList", void 0);
    (0, _defineProperty2().default)(this, "extensions", new (_extensionData().ExtensionDataList)());
    (0, _defineProperty2().default)(this, "_capsuleDir", void 0);
    (0, _defineProperty2().default)(this, "buildStatus", void 0);
    this.name = name;
    this.version = version;
    this.scope = scope;
    this.files = files;
    this.lang = lang || _constants().DEFAULT_LANGUAGE;
    this.bindingPrefix = bindingPrefix || _constants().DEFAULT_BINDINGS_PREFIX;
    this.mainFile = path().normalize(mainFile);
    this.bitJson = bitJson;
    this.setDependencies(dependencies);
    this.setDevDependencies(devDependencies);
    this.flattenedDependencies = flattenedDependencies || new (_bitIds().default)();
    this.packageDependencies = packageDependencies || {};
    this.devPackageDependencies = devPackageDependencies || {};
    this.peerPackageDependencies = peerPackageDependencies || {};
    this.overrides = overrides;
    this.defaultScope = defaultScope;
    this.packageJsonFile = packageJsonFile;
    this.packageJsonChangedProps = packageJsonChangedProps;
    this.docs = docs || [];
    this.license = license;
    this.log = log;
    this.deprecated = deprecated || false;
    this.removed = removed;
    this.scopesList = scopesList;
    this.extensions = extensions || [];
    this.componentFromModel = componentFromModel;
    this.modelComponent = modelComponent;
    this.schema = schema;
    this.buildStatus = buildStatus;
    this.issues = new (_componentIssues().IssuesList)();
  }
  validateComponent() {
    const nonEmptyFields = ['name', 'mainFile'];
    nonEmptyFields.forEach(field => {
      if (!this[field]) {
        throw new (_generalError().default)(`failed loading a component ${this.id}, the field "${field}" can't be empty`);
      }
    });
  }

  /**
   * Warning: this method does not return a deep copy for all objects in this class, only for the
   * ones you see in the implementation below.
   * Implement deep copy of other properties if needed
   */
  clone() {
    const newInstance = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
    newInstance.setDependencies(this.dependencies.getClone());
    newInstance.setDevDependencies(this.devDependencies.getClone());
    newInstance.overrides = this.overrides.clone();
    newInstance.files = this.files.map(file => file.clone());
    return newInstance;
  }
  getTmpFolder(workspacePrefix = '') {
    let folder = path().join(workspacePrefix, _constants().BIT_WORKSPACE_TMP_DIRNAME, this.id.name);
    if (this.componentMap) {
      const componentDir = this.componentMap.getComponentDir();
      if (componentDir) {
        folder = path().join(workspacePrefix, componentDir, _constants().BIT_WORKSPACE_TMP_DIRNAME);
      }
    }
    return folder;
  }
  setDependencies(dependencies) {
    this.dependencies = new (_dependencies().Dependencies)(dependencies);
  }
  setDevDependencies(devDependencies) {
    this.devDependencies = new (_dependencies().Dependencies)(devDependencies);
  }
  getFileExtension() {
    switch (this.lang) {
      case _constants().DEFAULT_LANGUAGE:
      default:
        return 'js';
    }
  }
  _getHomepage() {
    // TODO: Validate somehow that this scope is really on bitsrc (maybe check if it contains . ?)
    const homepage = this.scope ? `https://${_constants().BASE_WEB_DOMAIN}/${this.scope.replace('.', '/')}/${this.name}` : undefined;
    return homepage;
  }
  get extensionDependencies() {
    return new (_dependencies().Dependencies)(this.extensions.extensionsBitIds.map(id => new (_dependencies().Dependency)(id, [])));
  }
  getAllDependencies() {
    return [...this.dependencies.dependencies, ...this.devDependencies.dependencies, ...this.extensionDependencies.dependencies];
  }
  getAllDependenciesCloned() {
    const dependencies = [...this.dependencies.getClone(), ...this.devDependencies.getClone(), ...this.extensionDependencies.getClone()];
    return new (_dependencies().Dependencies)(dependencies);
  }
  getAllPackageDependencies() {
    return _objectSpread(_objectSpread({}, this.packageDependencies), this.devPackageDependencies);
  }
  getAllNonEnvsDependencies() {
    return [...this.dependencies.dependencies, ...this.devDependencies.dependencies];
  }
  getAllDependenciesIds() {
    const allDependencies = (0, _flatten2().default)(Object.values(this.depsIdsGroupedByType));
    return _bitIds().default.fromArray(allDependencies);
  }
  get depsIdsGroupedByType() {
    return {
      dependencies: this.dependencies.getAllIds(),
      devDependencies: this.devDependencies.getAllIds(),
      extensionDependencies: this.extensions.extensionsBitIds
    };
  }
  hasDependencies() {
    const allDependencies = this.getAllDependenciesIds();
    return Boolean(allDependencies.length);
  }
  getAllFlattenedDependencies() {
    return [...this.flattenedDependencies];
  }

  /**
   * components added since v14.8.0 have "rootDir" in .bitmap, which is mostly the same as the
   * sharedDir. so, if rootDir is found, no need to strip/add the sharedDir as the files are
   * already relative to the sharedDir rather than the author workspace.
   */
  get ignoreSharedDir() {
    return !(0, _componentSchema().isSchemaSupport)(_componentSchema().SchemaFeature.sharedDir, this.schema);
  }
  get isLegacy() {
    return !this.schema || this.schema === _componentSchema().SchemaName.Legacy;
  }
  cloneFilesWithSharedDir() {
    return this.files.map(file => {
      const newFile = file.clone();
      const newRelative = (0, _utils().pathNormalizeToLinux)(file.relative);
      newFile.updatePaths({
        newRelative
      });
      return newFile;
    });
  }
  toObject() {
    return {
      name: this.name,
      version: this.version,
      mainFile: this.mainFile,
      scope: this.scope,
      lang: this.lang,
      bindingPrefix: this.bindingPrefix,
      dependencies: this.dependencies.serialize(),
      devDependencies: this.devDependencies.serialize(),
      extensions: this.extensions.map(ext => {
        const res = Object.assign({}, ext.toComponentObject());
        return res;
      }),
      packageDependencies: this.packageDependencies,
      devPackageDependencies: this.devPackageDependencies,
      peerPackageDependencies: this.peerPackageDependencies,
      manuallyRemovedDependencies: this.manuallyRemovedDependencies,
      manuallyAddedDependencies: this.manuallyAddedDependencies,
      overrides: this.overrides.componentOverridesData,
      files: this.files,
      docs: this.docs,
      schema: this.schema,
      license: this.license ? this.license.serialize() : null,
      log: this.log,
      deprecated: this.deprecated
    };
  }
  toString() {
    return JSON.stringify(this.toObject());
  }
  static isComponentInvalidByErrorType(err) {
    const invalidComponentErrors = [_mainFileRemoved().default, _missingFilesFromComponent().default, _componentNotFoundInPath().default, _componentOutOfSync().default, _componentsPendingImport().default, _noComponentDir().NoComponentDir, _ignoredDirectory().IgnoredDirectory];
    return invalidComponentErrors.some(errorType => err instanceof errorType);
  }
  async toComponentWithDependencies(consumer) {
    const getFlatten = field => {
      // when loaded from filesystem, it doesn't have the flatten, fetch them from model.
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return this.loadedFromFileSystem ? this.componentFromModel[field] : this[field];
    };
    const getDependenciesComponents = ids => {
      return Promise.all(ids.map(dependencyId => {
        if (consumer.bitMap.isExistWithSameVersion(dependencyId)) {
          return consumer.loadComponent(dependencyId);
        }
        // when dependencies are imported as npm packages, they are not in bit.map
        this.dependenciesSavedAsComponents = false;
        return consumer.loadComponentFromModel(dependencyId);
      }));
    };
    const dependencies = await getDependenciesComponents(getFlatten('flattenedDependencies'));
    return new (_componentDependencies().default)({
      component: this,
      dependencies,
      devDependencies: [],
      extensionDependencies: []
    });
  }
  copyAllDependenciesFromModel() {
    const componentFromModel = this.componentFromModel;
    if (!componentFromModel) throw new Error('copyDependenciesFromModel: component is missing from the model');
    this.setDependencies(componentFromModel.dependencies.get());
    this.setDevDependencies(componentFromModel.devDependencies.get());
  }

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  static async fromObject(object) {
    const {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      name,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      box,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      version,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      scope,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      lang,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      bindingPrefix,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      dependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      devDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      devPackageDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      peerPackageDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      docs,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      mainFile,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      files,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      license,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      overrides,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      deprecated,
      schema
    } = object;
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return new Component({
      name: box ? `${box}/${name}` : name,
      version,
      scope,
      lang,
      bindingPrefix,
      dependencies,
      devDependencies,
      packageDependencies,
      devPackageDependencies,
      peerPackageDependencies,
      mainFile,
      files,
      docs,
      license: license ? _sources().License.deserialize(license) : undefined,
      overrides: new (_componentOverrides().default)(overrides),
      deprecated: deprecated || false,
      schema
    });
  }
  static async fromString(str) {
    const object = JSON.parse(str);
    object.files = _sources().SourceFile.loadFromParsedStringArray(object.files);

    // added if statement to support new and old version of remote ls
    // old version of bit returns from server array of dists  and new version return object
    if (object.dists && Array.isArray(object.dists)) {
      object.dists = _sources().Dist.loadFromParsedStringArray(object.dists);
    } else if (object.dists && object.dists.dists) {
      object.dists = _sources().Dist.loadFromParsedStringArray(object.dists.dists);
    }
    return this.fromObject(object);
  }
  static async loadFromFileSystem({
    componentMap,
    id,
    consumer
  }) {
    const workspaceConfig = consumer.config;
    const modelComponent = await consumer.scope.getModelComponentIfExist(id);
    const componentFromModel = await consumer.loadComponentFromModelIfExist(id);
    if (!componentFromModel && id.scope) {
      const inScopeWithAnyVersion = await consumer.scope.getModelComponentIfExist(id.changeVersion(undefined));
      // if it's in scope with another version, the component will be synced in _handleOutOfSyncScenarios()
      if (!inScopeWithAnyVersion) throw new (_componentsPendingImport().default)();
    }
    const deprecated = componentFromModel ? componentFromModel.deprecated : false;
    const compDirAbs = path().join(consumer.getPath(), componentMap.getComponentDir());
    if (!_fsExtra().default.existsSync(compDirAbs)) throw new (_componentNotFoundInPath().default)(compDirAbs);

    // Load the base entry from the root dir in map file in case it was imported using -path
    // Or created using bit create so we don't want all the path but only the relative one
    // Check that bitDir isn't the same as consumer path to make sure we are not loading global stuff into component
    // (like dependencies)
    _logger().default.trace(`consumer-component.loadFromFileSystem, start loading config ${id.toString()}`);
    const componentConfig = await _config().default.load({
      componentId: id
    });
    _logger().default.trace(`consumer-component.loadFromFileSystem, finish loading config ${id.toString()}`);
    // by default, imported components are not written with bit.json file.
    // use the component from the model to get their bit.json values
    if (componentFromModel) {
      componentConfig.mergeWithComponentData(componentFromModel);
    }
    const extensions = componentConfig.extensions;

    // TODO: change this once we want to support change export by changing the default scope
    // TODO: when we do this, we need to think how we distinct if this is the purpose of the user, or he just didn't changed it
    const bindingPrefix = (componentFromModel === null || componentFromModel === void 0 ? void 0 : componentFromModel.bindingPrefix) || componentConfig.bindingPrefix || _constants().DEFAULT_BINDINGS_PREFIX;
    const overridesFromModel = componentFromModel ? componentFromModel.overrides.componentOverridesData : undefined;
    const overrides = await _componentOverrides().default.loadFromConsumer(id, workspaceConfig, overridesFromModel, componentConfig, consumer.isLegacy);
    const packageJsonFile = componentConfig && componentConfig.packageJsonFile || undefined;
    const packageJsonChangedProps = componentFromModel ? componentFromModel.packageJsonChangedProps : undefined;
    const files = await getLoadedFiles(consumer, componentMap, id, compDirAbs);
    const docsP = _getDocsForFiles(files, consumer.componentFsCache);
    const docs = await Promise.all(docsP);
    const flattenedDocs = docs ? (0, _flatten2().default)(docs) : [];
    const defaultScope = componentConfig.defaultScope || null;
    const getSchema = () => {
      if (componentFromModel) return componentFromModel.schema;
      return consumer.isLegacy ? undefined : _componentSchema().CURRENT_SCHEMA;
    };
    return new Component({
      name: id.name,
      scope: id.scope,
      version: id.version,
      lang: componentConfig.lang,
      bindingPrefix,
      bitJson: componentConfig,
      mainFile: componentMap.mainFile,
      files,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      loadedFromFileSystem: true,
      componentFromModel,
      modelComponent,
      componentMap,
      docs: flattenedDocs,
      deprecated,
      overrides,
      schema: getSchema(),
      defaultScope,
      packageJsonFile,
      packageJsonChangedProps,
      extensions,
      buildStatus: componentFromModel ? componentFromModel.buildStatus : undefined
    });
  }
}
exports.default = Component;
async function getLoadedFiles(consumer, componentMap, id, bitDir) {
  if (componentMap.noFilesError) {
    throw componentMap.noFilesError;
  }
  await componentMap.trackDirectoryChangesHarmony(consumer, id);
  const sourceFiles = componentMap.files.map(file => {
    const filePath = path().join(bitDir, file.relativePath);
    const sourceFile = _sources().SourceFile.load(filePath, bitDir, consumer.getPath(), {
      test: file.test
    });
    return sourceFile;
  });
  const filePaths = componentMap.getAllFilesPaths();
  if (!filePaths.includes(componentMap.mainFile)) {
    throw new (_mainFileRemoved().default)(componentMap.mainFile, id.toString());
  }
  return sourceFiles;
}
function _getDocsForFiles(files, componentFsCache) {
  return files.map(file => file.test ? Promise.resolve([]) : (0, _parser().default)(file, componentFsCache));
}