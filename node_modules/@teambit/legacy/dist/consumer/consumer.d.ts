import { LaneId } from '@teambit/lane-id';
import { BitId, BitIds } from '../bit-id';
import { BitIdStr } from '../bit-id/bit-id';
import { ComponentWithDependencies, Scope } from '../scope';
import { Lane, Version } from '../scope/models';
import { PathAbsolute, PathLinuxRelative, PathOsBased, PathOsBasedAbsolute, PathOsBasedRelative, PathRelative } from '../utils/path';
import BitMap from './bit-map/bit-map';
import Component from './component';
import { ComponentStatus, ComponentStatusLoader, ComponentStatusResult } from './component-ops/component-status-loader';
import ComponentLoader, { ComponentLoadOptions, LoadManyResult } from './component/component-loader';
import { ILegacyWorkspaceConfig } from './config';
import { WorkspaceConfigProps } from './config/workspace-config';
import DirStructure from './dir-structure/dir-structure';
declare type ConsumerProps = {
    projectPath: string;
    config: ILegacyWorkspaceConfig;
    scope: Scope;
    created?: boolean;
    isolated?: boolean;
    addedGitHooks?: string[] | undefined;
    existingGitHooks: string[] | undefined;
};
/**
 * @todo: change the class name to Workspace
 */
export default class Consumer {
    projectPath: PathOsBased;
    created: boolean;
    config: ILegacyWorkspaceConfig;
    scope: Scope;
    bitMap: BitMap;
    isolated: boolean;
    addedGitHooks: string[] | undefined;
    existingGitHooks: string[] | undefined;
    _dirStructure: DirStructure;
    _componentsStatusCache: Record<string, any>;
    packageManagerArgs: string[];
    componentLoader: ComponentLoader;
    componentStatusLoader: ComponentStatusLoader;
    packageJson: any;
    onCacheClear: Array<() => void>;
    constructor({ projectPath, config, scope, created, isolated, addedGitHooks, existingGitHooks, }: ConsumerProps);
    setBitMap(): Promise<void>;
    get dirStructure(): DirStructure;
    get componentFsCache(): import("./component/component-fs-cache").ComponentFsCache;
    get bitmapIdsFromCurrentLane(): BitIds;
    get bitmapIdsFromCurrentLaneIncludeRemoved(): BitIds;
    get bitMapIdsFromAllLanes(): BitIds;
    clearCache(): void;
    getTmpFolder(fullPath?: boolean): PathOsBased;
    getCurrentLaneId(): LaneId;
    getDefaultLaneId(): LaneId;
    /**
     * the name can be a full lane-id or only the lane-name, which can be the alias (local-lane) or the remote-name.
     */
    getParsedLaneId(name: string): Promise<LaneId>;
    isOnLane(): boolean;
    isOnMain(): boolean;
    getCurrentLaneObject(): Promise<Lane | null>;
    setCurrentLane(laneId: LaneId, exported?: boolean): void;
    cleanTmpFolder(): Promise<void>;
    /**
     * Running migration process for consumer to update the stores (.bit.map.json) to the current version
     *
     * @param {any} verbose - print debug logs
     * @returns {Object} - wether the process run and wether it succeeded
     * @memberof Consumer
     */
    migrate(verbose: any): Record<string, any>;
    write(): Promise<Consumer>;
    getPath(): PathOsBased;
    toAbsolutePath(pathStr: PathRelative): PathOsBasedAbsolute;
    getPathRelativeToConsumer(pathToCheck: PathRelative | PathAbsolute): PathOsBasedRelative;
    getParsedId(id: BitIdStr, useVersionFromBitmap?: boolean, searchWithoutScopeInProvidedId?: boolean): BitId;
    getParsedIdIfExist(id: BitIdStr, useVersionFromBitmap?: boolean, searchWithoutScopeInProvidedId?: boolean): BitId | undefined;
    /**
     * throws a ComponentNotFound exception if not found in the model
     */
    loadComponentFromModel(id: BitId): Promise<Component>;
    /**
     * return a component only when it's stored locally.
     * don't go to any remote server and don't throw an exception if the component is not there.
     */
    loadComponentFromModelIfExist(id: BitId): Promise<Component | undefined>;
    loadAllVersionsOfComponentFromModel(id: BitId): Promise<Component[]>;
    /**
     * For legacy, it loads all the dependencies. For Harmony, it's not needed.
     */
    loadComponentWithDependenciesFromModel(id: BitId, throwIfNotExist?: boolean): Promise<ComponentWithDependencies>;
    loadComponent(id: BitId, loadOpts?: ComponentLoadOptions): Promise<Component>;
    loadComponents(ids: BitIds, throwOnFailure?: boolean, loadOpts?: ComponentLoadOptions): Promise<LoadManyResult>;
    shouldDependenciesSavedAsComponents(bitIds: BitId[], saveDependenciesAsComponents?: boolean): Promise<{
        id: BitId;
        saveDependenciesAsComponents: boolean;
    }[]>;
    listComponentsForAutoTagging(modifiedComponents: BitIds): Promise<Component[]>;
    /**
     * Check whether a model representation and file-system representation of the same component is the same.
     * The way how it is done is by converting the file-system representation of the component into
     * a Version object. Once this is done, we have two Version objects, and we can compare their hashes
     */
    isComponentModified(componentFromModel: Version, componentFromFileSystem: Component): Promise<boolean>;
    /**
     * Check whether the component files from the model and from the file-system of the same component is the same.
     */
    isComponentSourceCodeModified(componentFromModel: Version, componentFromFileSystem: Component): Promise<boolean>;
    getManyComponentsStatuses(ids: BitId[]): Promise<ComponentStatusResult[]>;
    getComponentStatusById(id: BitId): Promise<ComponentStatus>;
    updateNextVersionOnBitmap(componentsToTag: Component[], preRelease?: string): void;
    getComponentIdFromNodeModulesPath(requirePath: string, bindingPrefix: string): BitId;
    /**
     * e.g.
     * input: @bit/my-scope.my-name/internal-path.js
     * output: { packageName: '@bit/my-scope', internalPath: 'internal-path.js' }
     */
    splitPackagePathToNameAndFile(packagePath: string): {
        packageName: string;
        internalPath: string;
    };
    private stripNodeModulesFromPackagePath;
    composeRelativeComponentPath(bitId: BitId): PathLinuxRelative;
    composeComponentPath(bitId: BitId): PathOsBasedAbsolute;
    composeRelativeDependencyPath(bitId: BitId): PathOsBased;
    composeDependencyPath(bitId: BitId): PathOsBased;
    static create(projectPath: PathOsBasedAbsolute, noGit?: boolean, workspaceConfigProps?: WorkspaceConfigProps): Promise<Consumer>;
    static _getScopePath(projectPath: PathOsBasedAbsolute, noGit: boolean): PathOsBasedAbsolute;
    static ensure(projectPath: PathOsBasedAbsolute, standAlone?: boolean, workspaceConfigProps?: WorkspaceConfigProps): Promise<Consumer>;
    /**
     * if resetHard, delete consumer-files: bitMap and bit.json and also the local scope (.bit dir).
     * otherwise, delete the consumer-files only when they are corrupted
     */
    static reset(projectPath: PathOsBasedAbsolute, resetHard: boolean, noGit?: boolean): Promise<void>;
    resetNew(): Promise<void>;
    static locateProjectScope(projectPath: string): string | undefined;
    static load(currentPath: PathOsBasedAbsolute): Promise<Consumer>;
    /**
     * legacy is a workspace uses the old bit.json or "bit" prop of package.json.
     * new workspaces use workspace.jsonc file
     */
    get isLegacy(): boolean;
    /**
     * clean up removed components from bitmap
     * @param {BitIds} componentsToRemoveFromFs - delete component that are used by other components.
     */
    cleanFromBitMap(componentsToRemoveFromFs: BitIds): Promise<void>;
    cleanOrRevertFromBitMapWhenOnLane(ids: BitIds): Promise<void>;
    addRemoteAndLocalVersionsToDependencies(component: Component, loadedFromFileSystem: boolean): Promise<void>;
    getIdsOfDefaultLane(): Promise<BitIds>;
    getAuthoredAndImportedDependentsIdsOf(components: Component[]): Promise<BitIds>;
    writeBitMap(): Promise<void>;
    private backupBitMap;
    private currentDateAndTimeToFileName;
    onDestroy(): Promise<void>;
}
export {};
