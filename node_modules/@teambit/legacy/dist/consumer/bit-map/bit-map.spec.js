"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chai() {
  const data = require("chai");
  _chai = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _bitMap() {
  const data = _interopRequireDefault(require("./bit-map"));
  _bitMap = function () {
    return data;
  };
  return data;
}
function _duplicateRootDir() {
  const data = require("./exceptions/duplicate-root-dir");
  _duplicateRootDir = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const scope = {
  path: path().join(__dirname, '.bit'),
  lanes: {
    getCurrentLaneName: () => 'main'
  }
};
const getBitmapInstance = async () => {
  const consumer = {
    getPath: () => __dirname,
    isLegacy: false,
    scope
  };
  // @ts-ignore
  return _bitMap().default.load(consumer);
};
const addComponentParamsFixture = {
  componentId: new (_bitId().BitId)({
    name: 'is-string'
  }),
  files: [{
    name: 'is-string.js',
    relativePath: 'is-string.js',
    test: false
  }],
  mainFile: 'is-string.js'
};
describe('BitMap', function () {
  // @ts-ignore
  _logger().default.debug = () => {};
  // @ts-ignore
  _logger().default.info = () => {};
  // @ts-ignore
  this.timeout(0);
  describe('toObject', () => {
    let bitMap;
    let componentMap;
    before(async () => {
      bitMap = await getBitmapInstance();
      bitMap.addComponent(addComponentParamsFixture);
      const allComponents = bitMap.toObjects();
      componentMap = allComponents['is-string'];
    });
    it('should remove the "id" property', () => {
      (0, _chai().expect)(componentMap).to.not.have.property('id');
    });
    it('should sort the components alphabetically', async () => {
      const exampleComponent = _objectSpread({}, addComponentParamsFixture);
      bitMap = await getBitmapInstance();
      exampleComponent.componentId = new (_bitId().BitId)({
        scope: 'my-scope',
        name: 'is-string1',
        version: '0.0.1'
      });
      bitMap.addComponent(exampleComponent);
      exampleComponent.componentId = new (_bitId().BitId)({
        scope: 'my-scope',
        name: 'is-string3',
        version: '0.0.1'
      });
      bitMap.addComponent(exampleComponent);
      exampleComponent.componentId = new (_bitId().BitId)({
        scope: 'my-scope',
        name: 'is-string2',
        version: '0.0.1'
      });
      bitMap.addComponent(exampleComponent);
      const allComponents = bitMap.toObjects();
      const ids = Object.keys(allComponents);
      (0, _chai().expect)(ids[0]).to.equal('is-string1');
      (0, _chai().expect)(ids[1]).to.equal('is-string2');
      (0, _chai().expect)(ids[2]).to.equal('is-string3');
    });
  });
  describe('loadComponents', () => {
    let bitMap;
    before(async () => {
      bitMap = await getBitmapInstance();
    });
    it('should throw DuplicateRootDir error when multiple ids have the same rootDir', () => {
      const invalidBitMap = {
        comp1: {
          mainFile: 'index.js',
          rootDir: 'comp1'
        },
        comp2: {
          mainFile: 'index.js',
          rootDir: 'comp1'
        }
      };
      (0, _chai().expect)(() => bitMap.loadComponents(invalidBitMap)).to.throw(_duplicateRootDir().DuplicateRootDir);
    });
    it('should throw when a component has scope but not version', () => {
      const invalidBitMap = {
        'scope/comp1': {
          mainFile: 'index.js',
          rootDir: 'comp1',
          exported: true
        }
      };
      (0, _chai().expect)(() => bitMap.loadComponents(invalidBitMap)).to.throw('.bitmap entry of "scope/comp1" is invalid, it has a scope-name "scope", however, it does not have any version');
    });
  });
});