"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _prop2() {
  const data = _interopRequireDefault(require("ramda/src/prop"));
  _prop2 = function () {
    return data;
  };
  return data;
}
function _sortBy2() {
  const data = _interopRequireDefault(require("ramda/src/sortBy"));
  _sortBy2 = function () {
    return data;
  };
  return data;
}
function _filter2() {
  const data = _interopRequireDefault(require("ramda/src/filter"));
  _filter2 = function () {
    return data;
  };
  return data;
}
function _isNil2() {
  const data = _interopRequireDefault(require("ramda/src/isNil"));
  _isNil2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _validationError() {
  const data = _interopRequireDefault(require("../../error/validation-error"));
  _validationError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _lastModified() {
  const data = require("../../utils/fs/last-modified");
  _lastModified = function () {
    return data;
  };
  return data;
}
function _addComponents() {
  const data = require("../component-ops/add-components/add-components");
  _addComponents = function () {
    return data;
  };
  return data;
}
function _extensionData() {
  const data = require("../config/extension-data");
  _extensionData = function () {
    return data;
  };
  return data;
}
function _outsideRootDir() {
  const data = _interopRequireDefault(require("./exceptions/outside-root-dir"));
  _outsideRootDir = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class ComponentMap {
  // reason why trackDir and not re-use rootDir is because using rootDir requires all paths to be
  // relative to rootDir for consistency, then, when saving into the model changing them back to
  // be relative to consumer-root. (we can't save in the model relative to rootDir, otherwise the
  // dependencies paths won't work).
  // relevant for AUTHORED only when a component was added as a directory, used for tracking changes in that dir
  // a wrapper directory needed when a user adds a package.json file to the component root so then it won't collide with Bit generated one
  // wether the compiler / tester are detached from the workspace global configuration
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  // relevant for authored components only, it helps finding out whether a component has a scope
  // whether a component is available only on lanes and not on main
  // if a component was created on another lane, it might not be available on the current lane
  // for soft-tag (harmony only), this data is used in the CI to persist
  // eventually the timestamp is saved in the filesystem cache so it won't be re-tracked if not changed
  // Harmony only. empty string if new/staged. (undefined if legacy).
  // Harmony only. empty string if new. (undefined if legacy).
  // set if during finding the files an error was found

  constructor({
    id,
    files,
    defaultScope,
    mainFile,
    rootDir,
    trackDir,
    wrapDir,
    onLanesOnly,
    isAvailableOnCurrentLane,
    nextVersion,
    config
  }) {
    (0, _defineProperty2().default)(this, "id", void 0);
    (0, _defineProperty2().default)(this, "files", void 0);
    (0, _defineProperty2().default)(this, "defaultScope", void 0);
    (0, _defineProperty2().default)(this, "mainFile", void 0);
    (0, _defineProperty2().default)(this, "rootDir", void 0);
    (0, _defineProperty2().default)(this, "trackDir", void 0);
    (0, _defineProperty2().default)(this, "wrapDir", void 0);
    (0, _defineProperty2().default)(this, "markBitMapChangedCb", void 0);
    (0, _defineProperty2().default)(this, "exported", void 0);
    (0, _defineProperty2().default)(this, "onLanesOnly", false);
    (0, _defineProperty2().default)(this, "isAvailableOnCurrentLane", true);
    (0, _defineProperty2().default)(this, "nextVersion", void 0);
    (0, _defineProperty2().default)(this, "recentlyTracked", void 0);
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "version", void 0);
    (0, _defineProperty2().default)(this, "noFilesError", void 0);
    (0, _defineProperty2().default)(this, "config", void 0);
    this.id = id;
    this.files = files;
    this.defaultScope = defaultScope;
    this.mainFile = mainFile;
    this.rootDir = rootDir;
    this.trackDir = trackDir;
    this.wrapDir = wrapDir;
    this.onLanesOnly = onLanesOnly;
    this.isAvailableOnCurrentLane = typeof isAvailableOnCurrentLane === 'undefined' ? true : isAvailableOnCurrentLane;
    this.nextVersion = nextVersion;
    this.config = config;
  }
  static fromJson(componentMapObj) {
    return new ComponentMap(componentMapObj);
  }
  toPlainObject() {
    let res = {
      scope: this.scope,
      version: this.version,
      files: null,
      defaultScope: this.defaultScope,
      mainFile: this.mainFile,
      rootDir: this.rootDir,
      trackDir: this.trackDir,
      wrapDir: this.wrapDir,
      exported: this.exported,
      onLanesOnly: this.onLanesOnly || null,
      // if false, change to null so it won't be written
      isAvailableOnCurrentLane: this.isAvailableOnCurrentLane,
      nextVersion: this.nextVersion,
      config: this.configToObject()
    };
    const notNil = val => {
      return !(0, _isNil2().default)(val);
    };
    res = (0, _filter2().default)(notNil, res);
    return res;
  }
  configToObject() {
    if (!this.config) return undefined;
    const config = {};
    Object.keys(this.config).forEach(aspectId => {
      var _this$config;
      config[aspectId] = (0, _extensionData().removeInternalConfigFields)((_this$config = this.config) === null || _this$config === void 0 ? void 0 : _this$config[aspectId]);
    });
    return config;
  }
  static getPathWithoutRootDir(rootDir, filePath) {
    const newPath = (0, _utils().pathRelativeLinux)(rootDir, filePath);
    if (newPath.startsWith('..')) {
      // this is forbidden for security reasons. Allowing files to be written outside the components directory may
      // result in overriding OS files.
      throw new (_outsideRootDir().default)(filePath, rootDir);
    }
    return newPath;
  }
  static changeFilesPathAccordingToItsRootDir(existingRootDir, files) {
    const changes = [];
    files.forEach(file => {
      const newPath = this.getPathWithoutRootDir(existingRootDir, file.relativePath);
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      changes.push({
        from: file.relativePath,
        to: newPath
      });
      file.relativePath = newPath;
    });
    return changes;
  }
  setMarkAsChangedCb(markAsChangedBinded) {
    this.markBitMapChangedCb = markAsChangedBinded;
  }
  _findFile(fileName) {
    return this.files.find(file => {
      const filePath = this.rootDir ? (0, _utils().pathJoinLinux)(this.rootDir, file.relativePath) : file.relativePath;
      return filePath === fileName;
    });
  }
  changeRootDirAndUpdateFilesAccordingly(newRootDir) {
    if (this.rootDir === newRootDir) return;
    this.files.forEach(file => {
      const filePathRelativeToConsumer = this.rootDir ? (0, _utils().pathJoinLinux)(this.rootDir, file.relativePath) : file.relativePath;
      const newPath = ComponentMap.getPathWithoutRootDir(newRootDir, filePathRelativeToConsumer);
      if (this.mainFile === file.relativePath) this.mainFile = newPath;
      file.relativePath = newPath;
    });
    this.rootDir = newRootDir;
    this.trackDir = undefined; // if there is trackDir, it's not needed anymore.
  }

  addRootDirToDistributedFiles(rootDir) {
    this.files.forEach(file => {
      file.relativePath = file.name;
    });
    this.rootDir = (0, _utils().pathNormalizeToLinux)(rootDir);
    this.mainFile = path().basename(this.mainFile);
    this.validate();
  }
  updateFileLocation(fileFrom, fileTo) {
    fileFrom = (0, _utils().pathNormalizeToLinux)(fileFrom);
    fileTo = (0, _utils().pathNormalizeToLinux)(fileTo);
    const currentFile = this._findFile(fileFrom);
    const changes = [];
    if (currentFile) {
      const rootDir = this.rootDir;
      const newLocation = rootDir ? ComponentMap.getPathWithoutRootDir(rootDir, fileTo) : fileTo;
      _logger().default.debug(`updating file location from ${currentFile.relativePath} to ${newLocation}`);
      if (this.mainFile === currentFile.relativePath) this.mainFile = newLocation;
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      changes.push({
        from: currentFile.relativePath,
        to: newLocation
      });
      currentFile.relativePath = newLocation;
      currentFile.name = path().basename(newLocation);
    }
    this.validate();
    return changes;
  }
  updateDirLocation(dirFrom, dirTo) {
    dirFrom = (0, _utils().pathNormalizeToLinux)(dirFrom);
    dirTo = (0, _utils().pathNormalizeToLinux)(dirTo);
    const changes = [];
    if (this.rootDir && this.rootDir.startsWith(dirFrom)) {
      const rootDir = this.rootDir;
      const newRootDir = rootDir.replace(dirFrom, dirTo);
      const newRootDirNormalized = (0, _utils().pathNormalizeToLinux)(newRootDir);
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      changes.push({
        from: rootDir,
        to: newRootDirNormalized
      });
      _logger().default.debug(`updating rootDir location from ${rootDir} to ${newRootDirNormalized}`);
      this.rootDir = newRootDirNormalized;
      return changes;
    }
    this.files.forEach(file => {
      const filePath = this.rootDir ? path().join(this.rootDir, file.relativePath) : file.relativePath;
      if (filePath.startsWith(dirFrom)) {
        const fileTo = filePath.replace(dirFrom, dirTo);
        const newLocation = this.rootDir ? ComponentMap.getPathWithoutRootDir(this.rootDir, fileTo) : fileTo;
        _logger().default.debug(`updating file location from ${file.relativePath} to ${newLocation}`);
        if (this.mainFile === file.relativePath) this.mainFile = newLocation;
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        changes.push({
          from: file.relativePath,
          to: newLocation
        });
        file.relativePath = newLocation;
      }
    });
    this.validate();
    return changes;
  }
  getFilesRelativeToConsumer() {
    return this.files.map(file => {
      return this.rootDir ? (0, _utils().pathJoinLinux)(this.rootDir, file.relativePath) : file.relativePath;
    });
  }
  getAllFilesPaths() {
    return this.files.map(file => file.relativePath);
  }
  getFilesGroupedByBeingTests() {
    const allFiles = [];
    const nonTestsFiles = [];
    const testsFiles = [];
    this.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      allFiles.push(file.relativePath);
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      if (file.test) testsFiles.push(file.relativePath);
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      else nonTestsFiles.push(file.relativePath);
    });
    return {
      allFiles,
      nonTestsFiles,
      testsFiles
    };
  }

  /**
   * this.rootDir is not defined for author. instead, the current workspace is the rootDir
   * also, for imported environments (compiler/tester) components the rootDir is empty
   */
  getRootDir() {
    return this.rootDir || '.';
  }
  hasRootDir() {
    return Boolean(this.rootDir && this.rootDir !== '.');
  }
  getComponentDir() {
    return this.rootDir;
  }
  doesAuthorHaveRootDir() {
    return Boolean(this.rootDir);
  }

  /**
   * if the component dir has changed since the last tracking, re-scan the component-dir to get the
   * updated list of the files
   */
  async trackDirectoryChangesHarmony(consumer, id) {
    const trackDir = this.rootDir;
    if (!trackDir) {
      return;
    }
    const trackDirAbsolute = path().join(consumer.getPath(), trackDir);
    const lastTrack = await consumer.componentFsCache.getLastTrackTimestamp(id.toString());
    const wasModifiedAfterLastTrack = async () => {
      const lastModified = await (0, _lastModified().getLastModifiedDirTimestampMs)(trackDirAbsolute);
      return lastModified > lastTrack;
    };
    if (!(await wasModifiedAfterLastTrack())) {
      return;
    }
    const gitIgnore = (0, _addComponents().getGitIgnoreHarmony)(consumer.getPath());
    this.files = await (0, _addComponents().getFilesByDir)(trackDir, consumer.getPath(), gitIgnore);
  }
  updateNextVersion(nextVersion) {
    this.nextVersion = nextVersion;
    this.validate();
  }
  clearNextVersion() {
    delete this.nextVersion;
  }
  removeFiles(files) {
    const relativePaths = files.map(file => file.relativePath);
    this.files = this.files.reduce((accumulator, file) => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return relativePaths.includes(file.relativePath) ? accumulator : accumulator.concat(file);
    }, []);
    this.validate();
  }
  isRemoved() {
    var _this$config2;
    const removeAspectConf = (_this$config2 = this.config) === null || _this$config2 === void 0 ? void 0 : _this$config2[_constants().Extensions.remove];
    if (!removeAspectConf) return false;
    return removeAspectConf !== '-' && removeAspectConf.removed;
  }
  sort() {
    this.files = (0, _sortBy2().default)((0, _prop2().default)('relativePath'), this.files);
  }
  clone() {
    // @ts-ignore - there is some issue with the config dir type
    return new ComponentMap(this);
  }
  validate() {
    const errorMessage = `failed adding or updating a ${_constants().BIT_MAP} record of ${this.id.toString()}.`;
    if (!this.mainFile) throw new (_validationError().default)(`${errorMessage} mainFile attribute is missing`);
    if (!(0, _utils().isValidPath)(this.mainFile)) {
      throw new (_validationError().default)(`${errorMessage} mainFile attribute ${this.mainFile} is invalid`);
    }
    if (this.rootDir && !(0, _utils().isValidPath)(this.rootDir)) {
      throw new (_validationError().default)(`${errorMessage} rootDir attribute ${this.rootDir} is invalid`);
    }
    if (this.rootDir && this.rootDir === '.') {
      throw new (_validationError().default)(`${errorMessage} rootDir attribute ${this.rootDir} is invalid`);
    }
    if (this.nextVersion && !this.nextVersion.version) {
      throw new (_validationError().default)(`${errorMessage} version attribute should be set when nextVersion prop is set`);
    }
    if (!this.files || !this.files.length) throw new (_validationError().default)(`${errorMessage} files list is missing`);
    this.files.forEach(file => {
      if (!(0, _utils().isValidPath)(file.relativePath)) {
        throw new (_validationError().default)(`${errorMessage} file path ${file.relativePath} is invalid`);
      }
    });
    const foundMainFile = this.files.find(file => file.relativePath === this.mainFile);
    if (!foundMainFile || (0, _isEmpty2().default)(foundMainFile)) {
      throw new (_validationError().default)(`${errorMessage} mainFile ${this.mainFile} is not in the files list.
if you renamed the mainFile, please re-add the component with the "--main" flag pointing to the correct main-file`);
    }
    const filesPaths = this.files.map(file => file.relativePath);
    const duplicateFiles = filesPaths.filter(file => filesPaths.filter(f => file.toLowerCase() === f.toLowerCase()).length > 1);
    if (duplicateFiles.length) {
      throw new (_validationError().default)(`${errorMessage} the following files are duplicated ${duplicateFiles.join(', ')}`);
    }
  }
}
exports.default = ComponentMap;