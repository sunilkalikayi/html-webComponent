/// <reference types="node" />
import { LaneId } from '@teambit/lane-id';
import type { Consumer } from '..';
import { BitId, BitIds } from '../../bit-id';
import { BitIdStr } from '../../bit-id/bit-id';
import { PathLinux, PathOsBasedAbsolute, PathOsBasedRelative, PathRelative } from '../../utils/path';
import ComponentMap, { ComponentMapFile, Config, PathChange } from './component-map';
import { Lane } from '../../scope/models';
export declare type PathChangeResult = {
    id: BitId;
    changes: PathChange[];
};
export declare type IgnoreFilesDirs = {
    files: PathLinux[];
    dirs: PathLinux[];
};
export declare type GetBitMapComponentOptions = {
    ignoreVersion?: boolean;
    ignoreScopeAndVersion?: boolean;
};
export declare const LANE_KEY = "_bit_lane";
export declare const CURRENT_BITMAP_SCHEMA = "15.0.0";
export declare const SCHEMA_FIELD = "$schema-version";
export default class BitMap {
    projectRoot: string;
    mapPath: string;
    schema: string;
    laneId?: LaneId | undefined;
    isLaneExported: boolean;
    components: ComponentMap[];
    hasChanged: boolean;
    paths: {
        [path: string]: BitId;
    };
    pathsLowerCase: {
        [path: string]: BitId;
    };
    markAsChangedBinded: Function;
    _cacheIdsAll: BitIds | undefined;
    _cacheIdsLane: BitIds | undefined;
    allTrackDirs: {
        [trackDir: string]: BitId;
    } | null | undefined;
    private updatedIds;
    constructor(projectRoot: string, mapPath: string, schema: string, laneId?: LaneId | undefined, isLaneExported?: boolean);
    markAsChanged(): void;
    setComponent(bitId: BitId, componentMap: ComponentMap): void;
    /**
     * in case the added component's root-dir is a parent-dir of other components
     * or other component's root-dir is a parent root-dir of this component, throw an error
     */
    private throwForExistingParentDir;
    setComponentProp(id: BitId, propName: keyof ComponentMap, val: any): ComponentMap;
    isEmpty(): any;
    removeComponentProp(id: BitId, propName: keyof ComponentMap): ComponentMap;
    static load(consumer: Consumer): Promise<BitMap>;
    static removeNonComponentFields(componentsJson: Record<string, any>): void;
    loadFiles(): Promise<void>;
    static loadRawSync(dirPath: PathOsBasedAbsolute): Buffer | undefined;
    static getBitMapLocation(dirPath: PathOsBasedAbsolute): {
        currentLocation: string | undefined;
        defaultLocation: string;
    };
    /**
     * if resetHard, delete the bitMap file.
     * Otherwise, try to load it and only if the file is corrupted then delete it.
     */
    static reset(dirPath: PathOsBasedAbsolute, resetHard: boolean): void;
    resetToNewComponents(): void;
    private throwForDuplicateRootDirs;
    loadComponents(componentsJson: Record<string, any>): void;
    static getBitIdFromComponentJson(componentId: string, componentFromJson: Record<string, any>): BitId;
    getAllComponents(): ComponentMap[];
    /**
     * important! you probably want to use "getAllIdsAvailableOnLane".
     * this method returns ids that are not available on the current lane and will throw errors when
     * trying to load them.
     */
    getAllBitIdsFromAllLanes(): BitIds;
    getAllIdsAvailableOnLane(): BitIds;
    getRemoved(): BitIds;
    isIdAvailableOnCurrentLane(id: BitId): boolean;
    /**
     * get existing bitmap bit-id by bit-id.
     * throw an exception if not found
     * @see also getBitIdIfExist
     */
    getBitId(bitId: BitId, { ignoreVersion, ignoreScopeAndVersion }?: GetBitMapComponentOptions): BitId;
    /**
     * get existing bitmap bit-id by bit-id
     * don't throw an exception if not found
     * @see also getBitId
     */
    getBitIdIfExist(bitId: BitId, { ignoreVersion, ignoreScopeAndVersion, }?: {
        ignoreVersion?: boolean;
        ignoreScopeAndVersion?: boolean;
    }): BitId | undefined;
    /**
     * get componentMap from bitmap by bit-id.
     * throw an exception if not found.
     * @see also getComponentIfExist
     */
    getComponent(bitId: BitId, { ignoreVersion, ignoreScopeAndVersion }?: GetBitMapComponentOptions): ComponentMap;
    /**
     * get componentMap from bitmap by bit-id
     * don't throw an exception if not found
     * @see also getComponent
     */
    getComponentIfExist(bitId: BitId, { ignoreVersion, ignoreScopeAndVersion }?: GetBitMapComponentOptions): ComponentMap | undefined;
    getAllBitIds(): BitIds;
    /**
     * warning! don't use this function. the versions you'll get are not necessarily belong to main.
     * instead, use `consumer.getIdsOfDefaultLane()`
     */
    getAuthoredAndImportedBitIdsOfDefaultLane(): BitIds;
    getExportedComponents(): BitId[];
    getAuthoredNonExportedComponents(): BitId[];
    _makePathRelativeToProjectRoot(pathToChange: PathRelative): PathOsBasedRelative;
    /**
     * find ids that have the same name but different version
     * if compareWithoutScope is false, the scope should be identical in addition to the name
     */
    findSimilarIds(id: BitId, compareWithoutScope?: boolean): BitIds;
    deleteOlderVersionsOfComponent(componentId: BitId): void;
    /**
     * --- Don't use this function when you have the ID parsed. Use this.getBitId() instead ---
     *
     * id entered by the user may or may not include scope-name
     * search for a similar id in the bitmap and return the full BitId
     */
    getExistingBitId(id: BitIdStr, shouldThrow?: boolean, searchWithoutScopeInProvidedId?: boolean): BitId | undefined;
    /**
     * check if both arrays are equal according to their 'relativePath', regardless the order
     */
    _areFilesArraysEqual(filesA: ComponentMapFile[], filesB: ComponentMapFile[]): boolean;
    /**
     * add files from filesB that are not in filesA
     */
    mergeFilesArray(filesA: ComponentMapFile[], filesB: ComponentMapFile[]): ComponentMapFile[];
    addComponent({ componentId, files, defaultScope, mainFile, rootDir, onLanesOnly, config, }: {
        componentId: BitId;
        files: ComponentMapFile[];
        defaultScope?: string;
        mainFile: PathLinux;
        rootDir?: PathOsBasedAbsolute | PathOsBasedRelative;
        onLanesOnly?: boolean;
        config?: Config;
    }): ComponentMap;
    addFilesToComponent({ componentId, files }: {
        componentId: BitId;
        files: ComponentMapFile[];
    }): ComponentMap;
    syncWithLanes(lane?: Lane): void;
    sortValidateAndMarkAsChanged(componentMap: ComponentMap): void;
    _invalidateCache: () => void;
    _removeFromComponentsArray(componentId: BitId): void;
    removeComponent(bitId: BitId): BitId | undefined;
    removeComponents(ids: BitIds): (BitId | undefined)[];
    isExistWithSameVersion(id: BitId): boolean;
    /**
     * needed after exporting or tagging a component.
     * We don't support export/tag of nested components, only authored or imported. For authored/imported components, could be
     * in the file-system only one instance with the same component-name. As a result, we can strip the
     * scope-name and the version, find the older version in bit.map and update the id with the new one.
     */
    updateComponentId(id: BitId, updateScopeOnly?: boolean, revertToMain?: boolean): BitId;
    removeConfig(id: BitId): void;
    /**
     * Return a component id as listed in bit.map file
     * by a path exist in the files object
     *
     * @param {string} componentPath relative to consumer - as stored in bit.map files object
     * @returns {BitId} component id
     * @memberof BitMap
     */
    getComponentIdByPath(componentPath: PathLinux, caseSensitive?: boolean): BitId;
    _populateAllPaths(): void;
    getAllTrackDirs(): {
        [trackDir: string]: BitId;
    };
    updatePathLocation(from: PathOsBasedRelative, to: PathOsBasedRelative, existingPath: PathOsBasedAbsolute): PathChangeResult[];
    /**
     * avoid calling this method directly.
     * prefer `consumer.setCurrentLane()`
     */
    setCurrentLane(laneId: LaneId, exported?: boolean): void;
    /**
     * remove the id property before saving the components to the file as they are redundant with the keys
     */
    toObjects(): Record<string, any>;
    /**
     * do not call this function directly, let consumer.onDestroy() call it.
     * consumer.onDestroy() is being called (manually) at the end of the command process.
     * the risk of calling this method in other places is a parallel writing of this file, which
     * may result in a damaged file
     */
    write(): Promise<any>;
    private contentToString;
    getContent(): Record<string, any>;
}
