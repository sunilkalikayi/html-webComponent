"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SCHEMA_FIELD = exports.LANE_KEY = exports.CURRENT_BITMAP_SCHEMA = void 0;
function _prop2() {
  const data = _interopRequireDefault(require("ramda/src/prop"));
  _prop2 = function () {
    return data;
  };
  return data;
}
function _eqBy2() {
  const data = _interopRequireDefault(require("ramda/src/eqBy"));
  _eqBy2 = function () {
    return data;
  };
  return data;
}
function _unionWith2() {
  const data = _interopRequireDefault(require("ramda/src/unionWith"));
  _unionWith2 = function () {
    return data;
  };
  return data;
}
function _differenceWith2() {
  const data = _interopRequireDefault(require("ramda/src/differenceWith"));
  _differenceWith2 = function () {
    return data;
  };
  return data;
}
function _is2() {
  const data = _interopRequireDefault(require("ramda/src/is"));
  _is2 = function () {
    return data;
  };
  return data;
}
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _commentJson() {
  const data = _interopRequireDefault(require("comment-json"));
  _commentJson = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));
  _showDoctorError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _addComponents() {
  const data = require("../component-ops/add-components/add-components");
  _addComponents = function () {
    return data;
  };
  return data;
}
function _componentMap() {
  const data = _interopRequireDefault(require("./component-map"));
  _componentMap = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _duplicateRootDir() {
  const data = require("./exceptions/duplicate-root-dir");
  _duplicateRootDir = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const LANE_KEY = '_bit_lane';
exports.LANE_KEY = LANE_KEY;
const CURRENT_BITMAP_SCHEMA = '15.0.0';
exports.CURRENT_BITMAP_SCHEMA = CURRENT_BITMAP_SCHEMA;
const SCHEMA_FIELD = '$schema-version';
exports.SCHEMA_FIELD = SCHEMA_FIELD;
class BitMap {
  // path => componentId
  // path => componentId

  // needed for out-of-sync where the id is changed during the process
  constructor(projectRoot, mapPath, schema, laneId, isLaneExported = false) {
    this.projectRoot = projectRoot;
    this.mapPath = mapPath;
    this.schema = schema;
    this.laneId = laneId;
    this.isLaneExported = isLaneExported;
    (0, _defineProperty2().default)(this, "components", void 0);
    (0, _defineProperty2().default)(this, "hasChanged", void 0);
    (0, _defineProperty2().default)(this, "paths", void 0);
    (0, _defineProperty2().default)(this, "pathsLowerCase", void 0);
    (0, _defineProperty2().default)(this, "markAsChangedBinded", void 0);
    (0, _defineProperty2().default)(this, "_cacheIdsAll", void 0);
    (0, _defineProperty2().default)(this, "_cacheIdsLane", void 0);
    (0, _defineProperty2().default)(this, "allTrackDirs", void 0);
    (0, _defineProperty2().default)(this, "updatedIds", {});
    (0, _defineProperty2().default)(this, "_invalidateCache", () => {
      this.paths = {};
      this.pathsLowerCase = {};
      this._cacheIdsAll = undefined;
      this._cacheIdsLane = undefined;
      this.allTrackDirs = undefined;
    });
    this.components = [];
    this.hasChanged = false;
    this.paths = {};
    this.pathsLowerCase = {};
    this.markAsChangedBinded = this.markAsChanged.bind(this);
  }
  markAsChanged() {
    this.hasChanged = true;
    this._invalidateCache();
  }
  setComponent(bitId, componentMap) {
    const id = bitId.toString();
    if (!bitId.hasVersion() && bitId.scope) {
      throw new (_showDoctorError().default)(`invalid bitmap id ${id}, a component must have a version when a scope-name is included`);
    }
    // make sure there are no duplications (same name)
    const similarIds = this.findSimilarIds(bitId, true);
    if (similarIds.length) {
      throw new (_showDoctorError().default)(`your id ${id} is duplicated with ${similarIds.toString()}`);
    }
    componentMap.id = bitId;
    this.components.push(componentMap);
    this.markAsChanged();
  }

  /**
   * in case the added component's root-dir is a parent-dir of other components
   * or other component's root-dir is a parent root-dir of this component, throw an error
   */
  throwForExistingParentDir({
    id,
    rootDir
  }) {
    const isParentDir = (parent, child) => {
      const relative = path().relative(parent, child);
      return relative && !relative.startsWith('..');
    };
    this.components.forEach(existingComponentMap => {
      if (!existingComponentMap.rootDir) return;
      if (isParentDir(existingComponentMap.rootDir, rootDir)) {
        throw new (_generalError().default)(`unable to add "${id.toString()}", its rootDir ${rootDir} is inside ${existingComponentMap.rootDir} which used by another component "${existingComponentMap.id.toString()}"`);
      }
      if (isParentDir(rootDir, existingComponentMap.rootDir)) {
        throw new (_generalError().default)(`unable to add "${id.toString()}", its rootDir ${rootDir} is used by another component ${existingComponentMap.id.toString()}`);
      }
    });
  }
  setComponentProp(id, propName, val) {
    const componentMap = this.getComponent(id, {
      ignoreScopeAndVersion: true
    });
    componentMap[propName] = val;
    this.markAsChanged();
    return componentMap;
  }
  isEmpty() {
    return (0, _isEmpty2().default)(this.components);
  }

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  removeComponentProp(id, propName) {
    const componentMap = this.getComponent(id, {
      ignoreScopeAndVersion: true
    });
    delete componentMap[propName];
    this.markAsChanged();
    return componentMap;
  }
  static async load(consumer) {
    const dirPath = consumer.getPath();
    const {
      currentLocation,
      defaultLocation
    } = BitMap.getBitMapLocation(dirPath);
    const mapFileContent = BitMap.loadRawSync(dirPath);
    if (!mapFileContent || !currentLocation) {
      return new BitMap(dirPath, defaultLocation, CURRENT_BITMAP_SCHEMA);
    }
    let componentsJson;
    try {
      componentsJson = _commentJson().default.parse(mapFileContent.toString('utf8'), undefined, true);
    } catch (e) {
      _logger().default.error(`invalid bitmap at ${currentLocation}`, e);
      throw new (_exceptions().InvalidBitMap)(currentLocation, e.message);
    }
    const schema = componentsJson[SCHEMA_FIELD] || componentsJson.version;
    let isLaneExported = false;
    let laneId;
    if (componentsJson[LANE_KEY]) {
      if (componentsJson[LANE_KEY].name) {
        // backward compatibility
        throw new Error(`enable to migrate to the new Lane format of .bitmap. change to the previous Bit version, switch to main, then upgrade again`);
      } else {
        laneId = new (_laneId().LaneId)(componentsJson[LANE_KEY].id);
        isLaneExported = componentsJson[LANE_KEY].exported;
      }
    }
    BitMap.removeNonComponentFields(componentsJson);
    const bitMap = new BitMap(dirPath, currentLocation, schema, laneId, isLaneExported);
    bitMap.loadComponents(componentsJson);
    await bitMap.loadFiles();
    return bitMap;
  }
  static removeNonComponentFields(componentsJson) {
    // Don't treat version like component
    componentsJson[SCHEMA_FIELD] ? delete componentsJson[SCHEMA_FIELD] : delete componentsJson.version;
    delete componentsJson[LANE_KEY];
  }
  async loadFiles() {
    const gitIgnore = (0, _addComponents().getGitIgnoreHarmony)(this.projectRoot);
    await Promise.all(this.components.map(async componentMap => {
      const rootDir = componentMap.rootDir;
      if (!rootDir) return;
      try {
        componentMap.files = await (0, _addComponents().getFilesByDir)(rootDir, this.projectRoot, gitIgnore);
        componentMap.recentlyTracked = true;
      } catch (err) {
        componentMap.files = [];
        componentMap.noFilesError = err;
      }
    }));
  }
  static loadRawSync(dirPath) {
    const {
      currentLocation
    } = BitMap.getBitMapLocation(dirPath);
    if (!currentLocation) {
      _logger().default.info(`bit.map: unable to find an existing ${_constants().BIT_MAP} file. Will create a new one if needed`);
      return undefined;
    }
    const mapFileContent = _fsExtra().default.readFileSync(currentLocation);
    return mapFileContent;
  }
  static getBitMapLocation(dirPath) {
    const defaultLocation = path().join(dirPath, _constants().BIT_MAP);
    const oldLocation = path().join(dirPath, _constants().OLD_BIT_MAP);
    const getCurrentLocation = () => {
      if (_fsExtra().default.existsSync(defaultLocation)) return defaultLocation;
      if (_fsExtra().default.existsSync(oldLocation)) return oldLocation;
      return undefined;
    };
    const currentLocation = getCurrentLocation();
    return {
      currentLocation,
      defaultLocation
    };
  }

  /**
   * if resetHard, delete the bitMap file.
   * Otherwise, try to load it and only if the file is corrupted then delete it.
   */
  static reset(dirPath, resetHard) {
    const bitMapPath = path().join(dirPath, _constants().BIT_MAP);
    const deleteBitMapFile = () => {
      _logger().default.info(`deleting the bitMap file at ${bitMapPath}`);
      _fsExtra().default.removeSync(bitMapPath);
    };
    if (resetHard) {
      deleteBitMapFile();
      // @todo: delete workspace lanes as well? maybe they're already taken care of within scope.reset
      return;
    }
    try {
      const mapFileContent = BitMap.loadRawSync(dirPath);
      if (!mapFileContent) return;
      _commentJson().default.parse(mapFileContent.toString('utf8'), undefined, true);
    } catch (err) {
      deleteBitMapFile();
    }
  }
  resetToNewComponents() {
    this.components = this.components.map(component => new (_componentMap().default)({
      id: component.id.changeVersion(undefined).changeScope(undefined),
      mainFile: component.mainFile,
      rootDir: component.rootDir,
      exported: false,
      files: component.files,
      onLanesOnly: false
    }));
  }
  throwForDuplicateRootDirs(componentsJson) {
    const rootDirs = (0, _lodash().compact)(Object.keys(componentsJson).map(c => componentsJson[c].rootDir));
    if ((0, _lodash().uniq)(rootDirs).length === rootDirs.length) {
      return; // no duplications
    }

    Object.keys(componentsJson).forEach(componentId => {
      const rootDir = componentsJson[componentId].rootDir;
      if (!rootDir) return;
      const idsWithSameRootDir = Object.keys(componentsJson).filter(id => componentsJson[id].rootDir === rootDir);
      if (idsWithSameRootDir.length > 1) {
        throw new (_duplicateRootDir().DuplicateRootDir)(rootDir, idsWithSameRootDir);
      }
    });
  }
  loadComponents(componentsJson) {
    this.throwForDuplicateRootDirs(componentsJson);
    Object.keys(componentsJson).forEach(componentId => {
      const componentFromJson = componentsJson[componentId];
      const bitId = BitMap.getBitIdFromComponentJson(componentId, componentFromJson);
      if (bitId.hasScope() && !bitId.hasVersion()) {
        throw new (_bitError().BitError)(`.bitmap entry of "${componentId}" is invalid, it has a scope-name "${bitId.scope}", however, it does not have any version`);
      }
      componentFromJson.id = bitId;
      const componentMap = _componentMap().default.fromJson(componentFromJson);
      componentMap.setMarkAsChangedCb(this.markAsChangedBinded);
      this.components.push(componentMap);
    });
  }
  static getBitIdFromComponentJson(componentId, componentFromJson) {
    // on Harmony, to parse the id, the old format used "exported" prop, the current format
    // uses "scope" and "version" props.
    const newHarmonyFormat = ('scope' in componentFromJson);
    if (newHarmonyFormat) {
      const bitId = new (_bitId().BitId)({
        scope: componentFromJson.scope,
        name: componentId,
        version: componentFromJson.version
      });
      // it needs to be parsed for 1) validation 2) adding "latest" to the version if needed.
      return _bitId().BitId.parse(bitId.toString(), bitId.hasScope());
    }
    const idHasScope = () => {
      if ('exported' in componentFromJson) {
        if (typeof componentFromJson.exported !== 'boolean') {
          throw new (_bitError().BitError)(`fatal: .bitmap record of "${componentId}" is invalid, the exported property must be boolean, got "${typeof componentFromJson.exported}" instead.`);
        }
        return componentFromJson.exported;
      }
      // on Harmony, if there is no "exported" we default to "true" as this is the most commonly
      // used. so it's better to have as little as possible of these props.
      componentFromJson.exported = true;
      return true;
    };
    return _bitId().BitId.parse(componentId, idHasScope());
  }
  getAllComponents() {
    return this.components;
  }

  /**
   * important! you probably want to use "getAllIdsAvailableOnLane".
   * this method returns ids that are not available on the current lane and will throw errors when
   * trying to load them.
   */
  getAllBitIdsFromAllLanes() {
    const ids = componentMaps => _bitId().BitIds.fromArray(componentMaps.map(c => c.id));
    if (this._cacheIdsAll) return this._cacheIdsAll;
    const components = this.components;
    const componentIds = ids(components);
    this._cacheIdsAll = componentIds;
    return componentIds;
  }
  getAllIdsAvailableOnLane() {
    if (!this._cacheIdsLane) {
      const components = this.components.filter(c => !c.isRemoved()).filter(c => c.isAvailableOnCurrentLane || !c.onLanesOnly);
      const componentIds = _bitId().BitIds.fromArray(components.map(c => c.id));
      this._cacheIdsLane = componentIds;
      Object.freeze(this._cacheIdsLane);
    }
    return this._cacheIdsLane;
  }
  getRemoved() {
    const components = this.components.filter(c => c.isRemoved()).filter(c => c.isAvailableOnCurrentLane || !c.onLanesOnly);
    return _bitId().BitIds.fromArray(components.map(c => c.id));
  }
  isIdAvailableOnCurrentLane(id) {
    const allIdsOfCurrentLane = this.getAllIdsAvailableOnLane();
    return allIdsOfCurrentLane.hasWithoutScopeAndVersion(id);
  }

  /**
   * get existing bitmap bit-id by bit-id.
   * throw an exception if not found
   * @see also getBitIdIfExist
   */
  getBitId(bitId, {
    ignoreVersion = false,
    ignoreScopeAndVersion = false
  } = {}) {
    if (bitId.constructor.name !== _bitId().BitId.name) {
      throw new TypeError(`BitMap.getBitId expects bitId to be an instance of BitId, instead, got ${bitId}`);
    }
    const allIds = this.getAllBitIdsFromAllLanes();
    const exactMatch = allIds.search(bitId);
    if (exactMatch) return exactMatch;
    if (ignoreVersion) {
      const matchWithoutVersion = allIds.searchWithoutVersion(bitId);
      if (matchWithoutVersion) return matchWithoutVersion;
    }
    if (ignoreScopeAndVersion) {
      const matchWithoutScopeAndVersion = allIds.searchWithoutScopeAndVersion(bitId);
      if (matchWithoutScopeAndVersion) return matchWithoutScopeAndVersion;
    }
    if (this.updatedIds[bitId.toString()]) {
      return this.updatedIds[bitId.toString()].id;
    }
    throw new (_exceptions().MissingBitMapComponent)(bitId.toString());
  }

  /**
   * get existing bitmap bit-id by bit-id
   * don't throw an exception if not found
   * @see also getBitId
   */
  getBitIdIfExist(bitId, {
    ignoreVersion = false,
    ignoreScopeAndVersion = false
  } = {}) {
    try {
      const existingBitId = this.getBitId(bitId, {
        ignoreVersion,
        ignoreScopeAndVersion
      });
      return existingBitId;
    } catch (err) {
      if (err instanceof _exceptions().MissingBitMapComponent) return undefined;
      throw err;
    }
  }

  /**
   * get componentMap from bitmap by bit-id.
   * throw an exception if not found.
   * @see also getComponentIfExist
   */
  getComponent(bitId, {
    ignoreVersion = false,
    ignoreScopeAndVersion = false
  } = {}) {
    const existingBitId = this.getBitId(bitId, {
      ignoreVersion,
      ignoreScopeAndVersion
    });
    return this.components.find(c => c.id.isEqual(existingBitId));
  }

  /**
   * get componentMap from bitmap by bit-id
   * don't throw an exception if not found
   * @see also getComponent
   */
  getComponentIfExist(bitId, {
    ignoreVersion = false,
    ignoreScopeAndVersion = false
  } = {}) {
    try {
      const componentMap = this.getComponent(bitId, {
        ignoreVersion,
        ignoreScopeAndVersion
      });
      return componentMap;
    } catch (err) {
      if (err instanceof _exceptions().MissingBitMapComponent) return undefined;
      throw err;
    }
  }
  getAllBitIds() {
    return this.getAllIdsAvailableOnLane();
  }

  /**
   * warning! don't use this function. the versions you'll get are not necessarily belong to main.
   * instead, use `consumer.getIdsOfDefaultLane()`
   */
  getAuthoredAndImportedBitIdsOfDefaultLane() {
    const all = this.getAllBitIds();
    const filteredWithDefaultVersion = all.map(id => {
      const componentMap = this.getComponent(id);
      if (componentMap.onLanesOnly) return null;
      return componentMap.id;
    });
    return _bitId().BitIds.fromArray((0, _lodash().compact)(filteredWithDefaultVersion));
  }
  getExportedComponents() {
    const authoredIds = this.getAllIdsAvailableOnLane();
    return authoredIds.filter(id => id.hasScope());
  }
  getAuthoredNonExportedComponents() {
    const authoredIds = this.getAllIdsAvailableOnLane();
    return authoredIds.filter(id => !id.hasScope());
  }
  _makePathRelativeToProjectRoot(pathToChange) {
    const absolutePath = path().resolve(pathToChange);
    return path().relative(this.projectRoot, absolutePath);
  }

  /**
   * find ids that have the same name but different version
   * if compareWithoutScope is false, the scope should be identical in addition to the name
   */
  findSimilarIds(id, compareWithoutScope = false) {
    const allIds = this.getAllBitIdsFromAllLanes();
    const similarIds = allIds.filter(existingId => {
      const isSimilar = compareWithoutScope ? existingId.isEqualWithoutScopeAndVersion(id) : existingId.isEqualWithoutVersion(id);
      return isSimilar && !existingId.isEqual(id);
    });
    return _bitId().BitIds.fromArray(similarIds);
  }
  deleteOlderVersionsOfComponent(componentId) {
    const similarIds = this.findSimilarIds(componentId);
    similarIds.forEach(id => {
      const idStr = id.toString();
      _logger().default.debugAndAddBreadCrumb('BitMap.deleteOlderVersionsOfComponent', 'deleting an older version {idStr} of an existing component {componentId}', {
        idStr,
        componentId: componentId.toString()
      });
      this._removeFromComponentsArray(id);
    });
  }

  /**
   * --- Don't use this function when you have the ID parsed. Use this.getBitId() instead ---
   *
   * id entered by the user may or may not include scope-name
   * search for a similar id in the bitmap and return the full BitId
   */
  getExistingBitId(id, shouldThrow = true, searchWithoutScopeInProvidedId = false) {
    if (!(0, _is2().default)(String, id)) {
      throw new TypeError(`BitMap.getExistingBitId expects id to be a string, instead, got ${typeof id}`);
    }
    const idHasVersion = id.includes(_constants().VERSION_DELIMITER);

    // start with a more strict comparison. assume the id from the user has a scope name
    const componentWithScope = this.components.find(componentMap => {
      return idHasVersion ? componentMap.id.toString() === id : componentMap.id.toStringWithoutVersion() === id;
    });
    if (componentWithScope) return componentWithScope.id;

    // continue with searching without the scope name (in the bitmap)
    const idWithoutVersion = _bitId().BitId.getStringWithoutVersion(id);
    const componentWithoutScope = this.components.find(componentMap => {
      return idHasVersion ? componentMap.id.toStringWithoutScope() === id : componentMap.id.toStringWithoutScopeAndVersion() === idWithoutVersion;
    });
    if (componentWithoutScope) return componentWithoutScope.id;
    if (searchWithoutScopeInProvidedId) {
      // continue with searching without the scope name (in the provided id)
      const delimiterIndex = id.indexOf('/');
      if (delimiterIndex !== -1) {
        const idWithoutScope = _bitId().BitId.getScopeAndName(id).name;
        const matches = this.components.filter(componentMap => {
          return idHasVersion ? componentMap.id.toString() === idWithoutScope : componentMap.id.toStringWithoutVersion() === idWithoutScope;
        });
        if (matches && matches.length > 1) {
          throw new (_exceptions().MultipleMatches)(id);
        }
        if (matches && matches.length === 1) {
          return matches[0].id;
        }
        if (this.updatedIds[idWithoutScope]) {
          return this.updatedIds[idWithoutScope].id;
        }
      }
    }
    if (this.updatedIds[id]) {
      return this.updatedIds[id].id;
    }
    if (shouldThrow) {
      throw new (_exceptions().MissingBitMapComponent)(id);
    }
    return undefined;
  }

  /**
   * check if both arrays are equal according to their 'relativePath', regardless the order
   */
  _areFilesArraysEqual(filesA, filesB) {
    if (filesA.length !== filesB.length) return false;
    const cmp = (x, y) => x.relativePath === y.relativePath;
    const diff = (0, _differenceWith2().default)(cmp, filesA, filesB);
    if (!diff.length) return true;
    return false;
  }

  /**
   * add files from filesB that are not in filesA
   */
  mergeFilesArray(filesA, filesB) {
    return (0, _unionWith2().default)((0, _eqBy2().default)((0, _prop2().default)('relativePath')), filesA, filesB);
  }
  addComponent({
    componentId,
    files,
    defaultScope,
    mainFile,
    rootDir,
    onLanesOnly,
    config
  }) {
    const componentIdStr = componentId.toString();
    _logger().default.debug(`adding to bit.map ${componentIdStr}`);
    const getOrCreateComponentMap = () => {
      const ignoreVersion = true; // legacy can have two components on .bitmap with different versions
      const componentMap = this.getComponentIfExist(componentId, {
        ignoreVersion
      });
      if (componentMap) {
        _logger().default.info(`bit.map: updating an exiting component ${componentMap.id.toString()}`);
        componentMap.files = files;
        if (!this.laneId && componentMap.onLanesOnly) {
          // happens when merging from another lane to main and main is empty
          componentMap.onLanesOnly = false;
        }
        componentMap.id = componentId;
        return componentMap;
      }
      // if there are older versions, the user is updating an existing component, delete old ones from bit.map
      this.deleteOlderVersionsOfComponent(componentId);
      // @ts-ignore not easy to fix, we can't instantiate ComponentMap with mainFile because we don't have it yet
      const newComponentMap = new (_componentMap().default)({
        files,
        onLanesOnly: Boolean(this.laneId) && componentId.hasVersion()
      });
      newComponentMap.setMarkAsChangedCb(this.markAsChangedBinded);
      this.setComponent(componentId, newComponentMap);
      return newComponentMap;
    };
    const componentMap = getOrCreateComponentMap();
    componentMap.mainFile = mainFile;
    if (rootDir) {
      componentMap.rootDir = (0, _utils().pathNormalizeToLinux)(rootDir);
      this.throwForExistingParentDir(componentMap);
    }
    if (onLanesOnly) {
      componentMap.onLanesOnly = onLanesOnly;
    }
    if (defaultScope) {
      componentMap.defaultScope = defaultScope;
    }
    if (config) {
      componentMap.config = config;
    }
    componentMap.isAvailableOnCurrentLane = true;
    this.sortValidateAndMarkAsChanged(componentMap);
    return componentMap;
  }
  addFilesToComponent({
    componentId,
    files
  }) {
    const componentIdStr = componentId.toString();
    const componentMap = this.getComponentIfExist(componentId);
    if (!componentMap) {
      throw new (_showDoctorError().default)(`unable to add files to a non-exist component ${componentIdStr}`);
    }
    _logger().default.info(`bit.map: updating an exiting component ${componentIdStr}`);
    componentMap.files = files;
    this.sortValidateAndMarkAsChanged(componentMap);
    return componentMap;
  }
  syncWithLanes(lane) {
    if (!lane) {
      this.laneId = undefined;
      this.isLaneExported = false;
      this.components.forEach(componentMap => {
        componentMap.isAvailableOnCurrentLane = !componentMap.onLanesOnly;
      });
    } else {
      this.laneId = lane.toLaneId();
      const laneIds = lane.toBitIds();
      this.components.forEach(componentMap => {
        componentMap.isAvailableOnCurrentLane = laneIds.hasWithoutVersion(componentMap.id) || !componentMap.onLanesOnly;
      });
    }
    this._invalidateCache();
    this.markAsChanged();
  }
  sortValidateAndMarkAsChanged(componentMap) {
    componentMap.sort();
    componentMap.validate();
    this.markAsChanged();
  }
  _removeFromComponentsArray(componentId) {
    _logger().default.debug(`bit-map: _removeFromComponentsArray ${componentId.toString()}`);
    this.components = this.components.filter(componentMap => !componentMap.id.isEqual(componentId));
    this.markAsChanged();
  }
  removeComponent(bitId) {
    const bitmapComponent = this.getBitIdIfExist(bitId, {
      ignoreScopeAndVersion: true
    });
    if (bitmapComponent) this._removeFromComponentsArray(bitmapComponent);
    return bitmapComponent;
  }
  removeComponents(ids) {
    return ids.map(id => this.removeComponent(id));
  }
  isExistWithSameVersion(id) {
    return Boolean(id.hasVersion() && this.getComponentIfExist(id));
  }

  /**
   * needed after exporting or tagging a component.
   * We don't support export/tag of nested components, only authored or imported. For authored/imported components, could be
   * in the file-system only one instance with the same component-name. As a result, we can strip the
   * scope-name and the version, find the older version in bit.map and update the id with the new one.
   */
  updateComponentId(id, updateScopeOnly = false, revertToMain = false) {
    const newIdString = id.toString();
    const similarIds = this.findSimilarIds(id, true);
    if (!similarIds.length) {
      _logger().default.debug(`bit-map: no need to update ${newIdString}`);
      return id;
    }
    if (similarIds.length > 1) {
      throw new (_showDoctorError().default)(`Your ${_constants().BIT_MAP} file has more than one version of ${id.toStringWithoutScopeAndVersion()} and they
      are authored or imported. This scenario is not supported`);
    }
    const oldId = similarIds[0];
    const oldIdStr = oldId.toString();
    const newId = updateScopeOnly ? oldId.changeScope(id.scope) : id;
    if (newId.isEqual(oldId)) {
      _logger().default.debug(`bit-map: no need to update ${oldIdStr}`);
      return oldId;
    }
    _logger().default.debug(`BitMap: updating an older component ${oldIdStr} with a newer component ${newId.toString()}`);
    const componentMap = this.getComponent(oldId);
    if (this.laneId && !updateScopeOnly && !newId.hasVersion()) {
      // component was un-snapped and is back to "new".
      componentMap.onLanesOnly = false;
    }
    if (revertToMain) {
      // happens during "bit remove" when on a lane
      componentMap.onLanesOnly = false;
    }
    if (updateScopeOnly) {
      // in case it had defaultScope, no need for it anymore.
      delete componentMap.defaultScope;
    }
    this._removeFromComponentsArray(oldId);
    this.setComponent(newId, componentMap);
    this.markAsChanged();
    this.updatedIds[oldIdStr] = componentMap;
    return newId;
  }
  removeConfig(id) {
    const componentMap = this.getComponent(id);
    delete componentMap.config;
    this.markAsChanged();
  }

  /**
   * Return a component id as listed in bit.map file
   * by a path exist in the files object
   *
   * @param {string} componentPath relative to consumer - as stored in bit.map files object
   * @returns {BitId} component id
   * @memberof BitMap
   */
  getComponentIdByPath(componentPath, caseSensitive = true) {
    this._populateAllPaths();
    return caseSensitive ? this.paths[componentPath] : this.pathsLowerCase[componentPath.toLowerCase()];
  }
  _populateAllPaths() {
    if ((0, _isEmpty2().default)(this.paths)) {
      this.components.forEach(component => {
        component.files.forEach(file => {
          const relativeToConsumer = component.rootDir ? (0, _utils().pathJoinLinux)(component.rootDir, file.relativePath) : file.relativePath;
          this.paths[relativeToConsumer] = component.id;
          this.pathsLowerCase[relativeToConsumer.toLowerCase()] = component.id;
        });
      });
    }
  }
  getAllTrackDirs() {
    if (!this.allTrackDirs) {
      this.allTrackDirs = {};
      this.components.forEach(component => {
        const trackDir = component.getRootDir();
        if (!trackDir) return;
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        this.allTrackDirs[trackDir] = component.id;
      });
    }
    return this.allTrackDirs;
  }
  updatePathLocation(from, to, existingPath) {
    const isPathDir = (0, _utils().isDir)(existingPath);
    const allChanges = [];
    this.components.forEach(componentMap => {
      const changes = isPathDir ? componentMap.updateDirLocation(from, to) : componentMap.updateFileLocation(from, to);
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      if (changes && changes.length) allChanges.push({
        id: componentMap.id.clone(),
        changes
      });
    });
    if ((0, _isEmpty2().default)(allChanges)) {
      const errorMsg = isPathDir ? `directory ${from} is not a tracked component` : `the file ${existingPath} is untracked`;
      throw new (_showDoctorError().default)(errorMsg);
    }
    this.markAsChanged();
    return allChanges;
  }

  /**
   * avoid calling this method directly.
   * prefer `consumer.setCurrentLane()`
   */
  setCurrentLane(laneId, exported = true) {
    if (laneId.isDefault()) {
      this.laneId = undefined;
    } else {
      this.laneId = laneId;
      this.isLaneExported = exported;
    }
    this.hasChanged = true;
  }

  /**
   * remove the id property before saving the components to the file as they are redundant with the keys
   */
  toObjects() {
    const components = {};
    this.components.forEach(componentMap => {
      const componentMapCloned = componentMap.clone();
      let idStr = componentMapCloned.id.toString();
      // no need for "exported" property as there are scope and version props
      // if not exist, we still need these properties so we know later to parse them correctly.
      componentMapCloned.scope = componentMapCloned.id.hasScope() ? componentMapCloned.id.scope : '';
      componentMapCloned.version = componentMapCloned.id.hasVersion() ? componentMapCloned.id.version : '';
      if (componentMapCloned.isAvailableOnCurrentLane && !componentMapCloned.onLanesOnly) {
        delete componentMapCloned.isAvailableOnCurrentLane;
      }
      idStr = componentMapCloned.id.name;
      // @ts-ignore
      componentMapCloned === null || componentMapCloned === void 0 ? true : delete componentMapCloned.id;
      components[idStr] = componentMapCloned.toPlainObject();
    });
    return (0, _utils().sortObject)(components);
  }

  /**
   * do not call this function directly, let consumer.onDestroy() call it.
   * consumer.onDestroy() is being called (manually) at the end of the command process.
   * the risk of calling this method in other places is a parallel writing of this file, which
   * may result in a damaged file
   */
  async write() {
    if (!this.hasChanged) return;
    _logger().default.debug('writing to bit.map');
    await (0, _utils().outputFile)({
      filePath: this.mapPath,
      content: this.contentToString(),
      prefixMessage: _constants().BITMAP_PREFIX_MESSAGE
    });
    this.hasChanged = false;
  }
  contentToString() {
    return JSON.stringify(this.getContent(), null, 4);
  }
  getContent() {
    const bitMapContent = _objectSpread(_objectSpread({}, this.toObjects()), {}, {
      [SCHEMA_FIELD]: this.schema
    });
    if (this.laneId) {
      bitMapContent[LANE_KEY] = {
        id: this.laneId,
        exported: this.isLaneExported
      };
    }
    return bitMapContent;
  }
}
exports.default = BitMap;