import { BitId } from '../../bit-id';
import { PathLinux, PathLinuxRelative, PathOsBased, PathOsBasedRelative } from '../../utils/path';
import Consumer from '../consumer';
export declare type Config = {
    [aspectId: string]: Record<string, any> | '-';
};
export declare type ComponentMapFile = {
    name: string;
    relativePath: PathLinux;
    test: boolean;
};
export declare type NextVersion = {
    version: 'patch' | 'minor' | 'major' | 'prerelease' | string;
    preRelease?: string;
    message?: string;
    username?: string;
    email?: string;
};
export declare type ComponentMapData = {
    id: BitId;
    files: ComponentMapFile[];
    defaultScope?: string;
    mainFile: PathLinux;
    rootDir: PathLinux;
    trackDir?: PathLinux;
    wrapDir?: PathLinux;
    exported?: boolean;
    onLanesOnly: boolean;
    isAvailableOnCurrentLane?: boolean;
    nextVersion?: NextVersion;
    config?: Config;
};
export declare type PathChange = {
    from: PathLinux;
    to: PathLinux;
};
export default class ComponentMap {
    id: BitId;
    files: ComponentMapFile[];
    defaultScope?: string;
    mainFile: PathLinux;
    rootDir: PathLinux;
    trackDir: PathLinux | undefined;
    wrapDir: PathLinux | undefined;
    markBitMapChangedCb: Function;
    exported: boolean | null | undefined;
    onLanesOnly?: boolean | undefined;
    isAvailableOnCurrentLane?: boolean | undefined;
    nextVersion?: NextVersion;
    recentlyTracked?: boolean;
    scope?: string | null;
    version?: string;
    noFilesError?: Error;
    config?: {
        [aspectId: string]: Record<string, any> | '-';
    };
    constructor({ id, files, defaultScope, mainFile, rootDir, trackDir, wrapDir, onLanesOnly, isAvailableOnCurrentLane, nextVersion, config, }: ComponentMapData);
    static fromJson(componentMapObj: ComponentMapData): ComponentMap;
    toPlainObject(): Record<string, any>;
    private configToObject;
    static getPathWithoutRootDir(rootDir: PathLinux, filePath: PathLinux): PathLinux;
    static changeFilesPathAccordingToItsRootDir(existingRootDir: PathLinux, files: ComponentMapFile[]): PathChange[];
    setMarkAsChangedCb(markAsChangedBinded: Function): void;
    _findFile(fileName: PathLinux): ComponentMapFile | undefined;
    changeRootDirAndUpdateFilesAccordingly(newRootDir: PathLinuxRelative): void;
    addRootDirToDistributedFiles(rootDir: PathOsBased): void;
    updateFileLocation(fileFrom: PathOsBased, fileTo: PathOsBased): PathChange[];
    updateDirLocation(dirFrom: PathOsBasedRelative, dirTo: PathOsBasedRelative): PathChange[];
    getFilesRelativeToConsumer(): PathLinux[];
    getAllFilesPaths(): PathLinux[];
    getFilesGroupedByBeingTests(): {
        allFiles: string[];
        nonTestsFiles: string[];
        testsFiles: string[];
    };
    /**
     * this.rootDir is not defined for author. instead, the current workspace is the rootDir
     * also, for imported environments (compiler/tester) components the rootDir is empty
     */
    getRootDir(): PathLinuxRelative;
    hasRootDir(): boolean;
    getComponentDir(): PathLinux;
    doesAuthorHaveRootDir(): boolean;
    /**
     * if the component dir has changed since the last tracking, re-scan the component-dir to get the
     * updated list of the files
     */
    trackDirectoryChangesHarmony(consumer: Consumer, id: BitId): Promise<void>;
    updateNextVersion(nextVersion: NextVersion): void;
    clearNextVersion(): void;
    removeFiles(files: ComponentMapFile[]): void;
    isRemoved(): any;
    sort(): void;
    clone(): ComponentMap;
    validate(): void;
}
