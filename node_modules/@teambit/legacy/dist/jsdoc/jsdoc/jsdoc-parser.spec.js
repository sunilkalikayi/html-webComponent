"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
function _chai() {
  const data = require("chai");
  _chai = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _() {
  const data = _interopRequireDefault(require("./"));
  _ = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const fixtures = path().join(__dirname, '../../..', 'fixtures', 'jsdoc');
function parseFile(filePath) {
  return (0, _().default)(_fsExtra().default.readFileSync(filePath).toString(), 'my-file.js');
}
describe('JSDoc Parser', () => {
  describe('parse()', () => {
    describe('Function Declaration', function () {
      let doclet;
      before(async () => {
        const functionDeclarationFile = path().join(fixtures, 'functionDeclaration.js');
        const doclets = await parseFile(functionDeclarationFile);
        (0, _chai().expect)(doclets).to.be.a('array');
        (0, _chai().expect)(doclets).to.have.lengthOf(1);
        doclet = doclets[0];
      });
      it('should have all the proper keys', () => {
        (0, _chai().expect)(doclet).to.include.keys('name', 'description', 'returns', 'args', 'access', 'examples', 'static');
      });
      it('should extract the correct name', () => {
        (0, _chai().expect)(doclet.name).to.equal('add');
      });
      it('should extract the correct description', () => {
        (0, _chai().expect)(doclet.description).to.equal('Adds two numbers.');
      });
      it('should extract the correct args', () => {
        const args = doclet.args;
        (0, _chai().expect)(args).to.be.a('array');
        (0, _chai().expect)(args).to.have.lengthOf(2);
        for (const arg of args) {
          (0, _chai().expect)(arg).to.include.keys('name', 'type', 'description');
        }
        (0, _chai().expect)(args[0].name).to.equal('a');
        (0, _chai().expect)(args[1].name).to.equal('b');
        (0, _chai().expect)(args[0].description).to.equal('The first number in an addition.');
        (0, _chai().expect)(args[1].description).to.equal('The second number in an addition.');
        (0, _chai().expect)(args[0].type).to.equal('number');
        (0, _chai().expect)(args[1].type).to.equal('number');
      });
      it('should extract the correct returns', () => {
        (0, _chai().expect)(doclet.returns).to.include.keys('type', 'description');
        (0, _chai().expect)(doclet.returns.description).to.equal('Returns the total.');
        (0, _chai().expect)(doclet.returns.type).to.equal('number');
      });
      it('should extract the correct access from the @public annotation', () => {
        (0, _chai().expect)(doclet.access).to.equal('public');
      });
      it('should extract the static attribute from the @static annotation', () => {
        (0, _chai().expect)(doclet.static).to.be.true;
      });
    });
    describe('Invalid code', () => {
      it('should returns an empty array', async () => {
        const doclets = await (0, _().default)('this is an invalid code', 'some-file');
        (0, _chai().expect)(doclets).to.be.a('array');
        (0, _chai().expect)(doclets).to.have.lengthOf(0);
      });
    });
    describe('Doc ending with more than one star', () => {
      let doclets;
      before(async () => {
        const file = path().join(fixtures, 'endWithTwoStars.js');
        doclets = await parseFile(file);
        (0, _chai().expect)(doclets).to.be.an('array');
      });
      it('should parse the doc and not hang due to catastrophic backtracking', () => {
        const doclet = doclets[0];
        (0, _chai().expect)(doclet).to.have.property('description').that.is.equal('Basic accordion component');
      });
    });
    describe('Method Declaration and Class Declaration', () => {
      let doclets;
      before(async () => {
        const methodDeclarationFile = path().join(fixtures, 'methodDeclaration.js');
        doclets = await parseFile(methodDeclarationFile);
      });
      it('should be a populated array', () => {
        (0, _chai().expect)(doclets).to.be.an('array');
        (0, _chai().expect)(doclets).to.have.length.of.at.least(2);
      });
      it('should recognize the constructor', () => {
        const doclet = doclets[0];
        (0, _chai().expect)(doclet).to.have.property('name').that.equals('constructor');
        (0, _chai().expect)(doclet).to.have.property('description').that.equals('Create a point.');
        (0, _chai().expect)(doclet).to.have.property('access').that.equals('public');
        (0, _chai().expect)(doclet).to.have.property('static').that.is.false;
        (0, _chai().expect)(doclet).to.have.property('returns').that.is.an('object').that.is.empty;
        (0, _chai().expect)(doclet).to.have.property('examples').that.is.an('array').that.is.empty;
      });
      it("should extract the constructor's args correctly", () => {
        const doclet = doclets[0];
        (0, _chai().expect)(doclet).to.have.property('args').that.is.an('array').with.lengthOf(2);
        const args = doclet.args;
        for (const arg of args) {
          (0, _chai().expect)(arg).to.include.keys('name', 'type', 'description');
          (0, _chai().expect)(arg.type).to.equal('number');
        }
        (0, _chai().expect)(args[0].name).to.equal('x');
        (0, _chai().expect)(args[1].name).to.equal('y');
        (0, _chai().expect)(args[0].description).to.equal('The x value.');
        (0, _chai().expect)(args[1].description).to.equal('The y value.');
      });
      it('should recognize the getX method', () => {
        const doclet = doclets[1];
        (0, _chai().expect)(doclet).to.have.property('name').that.equals('getX');
        (0, _chai().expect)(doclet).to.have.property('description').that.equals('Get the x value.');
        (0, _chai().expect)(doclet).to.have.property('access').that.equals('public');
        (0, _chai().expect)(doclet).to.have.property('static').that.is.false;
        (0, _chai().expect)(doclet).to.have.property('returns').that.is.an('object').that.is.not.empty;
        (0, _chai().expect)(doclet).to.have.property('examples').that.is.an('array').that.is.empty;
        (0, _chai().expect)(doclet).to.have.property('args').that.is.an('array').that.is.empty;
      });
      it('should recognize the getY method', () => {
        const doclet = doclets[2];
        (0, _chai().expect)(doclet).to.have.property('name').that.equals('getY');
        (0, _chai().expect)(doclet).to.have.property('description').that.equals('Get the y value.');
      });
      it('should recognize the fromString method as the last doclet', function () {
        // @ts-ignore
        this.timeout(0);
        const doclet = doclets[doclets.length - 1];
        (0, _chai().expect)(doclet).to.have.property('name').that.equals('fromString');
        (0, _chai().expect)(doclet).to.have.property('description').that.equals('Convert a string containing two comma-separated numbers into a point.');
      });
    });
    describe('Variable Declaration', () => {
      let doclets;
      before(async () => {
        const variableDeclarationFile = path().join(fixtures, 'variableDeclaration.js');
        doclets = await parseFile(variableDeclarationFile);
      });
      it('should be an array of one Doclet', () => {
        (0, _chai().expect)(doclets).to.be.an('array').and.to.have.lengthOf(1);
      });
      it('should parse the doc correctly', () => {
        const doclet = doclets[0];
        (0, _chai().expect)(doclet).to.have.property('name').that.equals('add');
        (0, _chai().expect)(doclet).to.have.property('description').that.equals('Adds two numbers.');
        (0, _chai().expect)(doclet).to.have.property('access').that.equals('public');
        (0, _chai().expect)(doclet).to.have.property('static').that.is.false;
        (0, _chai().expect)(doclet).to.have.property('returns').that.is.an('object').that.is.not.empty;
        (0, _chai().expect)(doclet).to.have.property('examples').that.is.an('array').that.is.not.empty;
        (0, _chai().expect)(doclet).to.have.property('args').that.is.an('array').that.have.lengthOf(2);
      });
    });
    describe('Various Param Types', () => {
      let args;
      before(async () => {
        const file = path().join(fixtures, 'variousParamTypes.js');
        const doclets = await parseFile(file);
        (0, _chai().expect)(doclets).to.be.an('array').and.to.have.lengthOf(1);
        const doclet = doclets[0];
        (0, _chai().expect)(doclet).to.have.property('args').that.is.an('array').that.is.not.empty;
        args = doclet.args;
      });
      it('should recognize "*" as "*"', () => {
        const anyArg = args.find(arg => arg.name === 'anyType');
        (0, _chai().expect)(anyArg.type).to.equal('*');
      });
      it('should recognize "[]" as "[]"', () => {
        const anyArg = args.find(arg => arg.name === 'arrayType');
        (0, _chai().expect)(anyArg.type).to.equal('[]');
      });
      it('should recognize Union type correctly', () => {
        const anyArg = args.find(arg => arg.name === 'unionType');
        (0, _chai().expect)(anyArg.type).to.equal('(number | [])');
      });
      it('should recognize custom type correctly', () => {
        const anyArg = args.find(arg => arg.name === 'myCustomType');
        (0, _chai().expect)(anyArg.type).to.equal('CustomType');
      });
      it('should recognize Object type', () => {
        const anyArg = args.find(arg => arg.name === 'objectType');
        (0, _chai().expect)(anyArg.type).to.equal('Object');
      });
      it('should recognize Function type', () => {
        const anyArg = args.find(arg => arg.name === 'functionType');
        (0, _chai().expect)(anyArg.type).to.equal('Function');
      });
      it('should recognize Array of one type', () => {
        const anyArg = args.find(arg => arg.name === 'arrayOfType');
        (0, _chai().expect)(anyArg.type).to.equal('Array<string>');
      });
      it('should recognize Array of union', () => {
        const anyArg = args.find(arg => arg.name === 'arrayOfUnion');
        (0, _chai().expect)(anyArg.type).to.equal('Array<(number | Object)>');
      });
      it('should recognize Optional Parameter', () => {
        const anyArg = args.find(arg => arg.name === 'optionalParameter');
        (0, _chai().expect)(anyArg.type).to.equal('string?');
      });
      it('should recognize Optional Parameter with Default Value', () => {
        const anyArg = args.find(arg => arg.name === 'optionalParameterWithDefaultValue');
        (0, _chai().expect)(anyArg.type).to.equal('string?');
        (0, _chai().expect)(anyArg.default).to.equal('value');
      });
    });
    describe('Flow Type File', () => {
      it('should parse the file with no errors', async () => {
        const file = path().join(fixtures, 'flowTypeFile.js');
        const doclets = await parseFile(file);
        (0, _chai().expect)(doclets).to.be.an('array').and.to.have.lengthOf(1);
        const doclet = doclets[0];
        (0, _chai().expect)(doclet).to.have.property('name').that.equals('first');
        (0, _chai().expect)(doclet).to.have.property('description').that.equals('returns the first element of an array reference.');
        (0, _chai().expect)(doclet).to.have.property('access').that.equals('public');
        (0, _chai().expect)(doclet).to.have.property('static').that.is.false;
        (0, _chai().expect)(doclet).to.have.property('returns').that.is.an('object').that.is.not.empty;
        (0, _chai().expect)(doclet).to.have.property('examples').that.is.an('array').that.is.not.empty;
        (0, _chai().expect)(doclet).to.have.property('args').that.is.an('array').that.is.not.empty;
      });
    });
    describe('Description Tag', () => {
      let doclets;
      before(async () => {
        const file = path().join(fixtures, 'descriptionTag.js');
        doclets = await parseFile(file);
        (0, _chai().expect)(doclets).to.be.an('array').and.to.have.lengthOf(3);
      });
      it('should ignore an invalid description', () => {
        const doclet = doclets[0];
        (0, _chai().expect)(doclet.name).to.equal('invalidDescription');
        (0, _chai().expect)(doclet.description).to.equal('');
      });
      it('should recognize the description tag', () => {
        const doclet = doclets[1];
        (0, _chai().expect)(doclet.name).to.equal('descriptionTag');
        (0, _chai().expect)(doclet.description).to.equal('Adds two numbers.');
      });
      it('should recognize the synonym "desc"', () => {
        const doclet = doclets[2];
        (0, _chai().expect)(doclet.name).to.equal('descTag');
        (0, _chai().expect)(doclet.description).to.equal('Adds two numbers.');
      });
    });
    describe('Access property', () => {
      let doclets;
      before(async () => {
        const file = path().join(fixtures, 'misc.js');
        doclets = await parseFile(file);
        (0, _chai().expect)(doclets).to.be.an('array');
      });
      it('should find only public functions', () => {
        (0, _chai().expect)(doclets.find(doclet => doclet.name === 'publicFunc')).not.to.be.undefined;
        (0, _chai().expect)(doclets.find(doclet => doclet.name === 'privateFunc')).to.be.undefined;
      });
    });
    describe('Properties property', () => {
      let doclets;
      before(async () => {
        const file = path().join(fixtures, 'properties.js');
        doclets = await parseFile(file);
        (0, _chai().expect)(doclets).to.be.an('array');
      });
      it('should parse the property tag correctly', () => {
        const doclet = doclets[0];
        (0, _chai().expect)(doclet).to.have.property('properties').that.is.an('array').that.have.lengthOf(5);
        (0, _chai().expect)(doclet.properties[0].name).to.equal('defaults');
        (0, _chai().expect)(doclet.properties[0].type).to.equal('object');
        (0, _chai().expect)(doclet.properties[0].description).to.equal('The default values for parties.');
      });
    });
  });
});