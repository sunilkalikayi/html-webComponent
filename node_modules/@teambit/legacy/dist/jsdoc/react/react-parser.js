"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parse;
function _doctrine() {
  const data = _interopRequireDefault(require("doctrine"));
  _doctrine = function () {
    return data;
  };
  return data;
}
function reactDocs() {
  const data = _interopRequireWildcard(require("react-docgen"));
  reactDocs = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _extractDataRegex() {
  const data = _interopRequireDefault(require("../extract-data-regex"));
  _extractDataRegex = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function formatProperties(props) {
  const parseDescription = description => {
    // an extra step is needed to parse the properties description correctly. without this step
    // it'd show the entire tag, e.g. `@property {propTypes.string} text - Button text.`
    // instead of just `text - Button text.`.
    try {
      const descriptionAST = _doctrine().default.parse(description, {
        unwrap: true,
        recoverable: true,
        sloppy: true
      });
      if (descriptionAST && descriptionAST.tags[0]) return descriptionAST.tags[0].description;
    } catch (err) {
      // failed to parse the react property, that's fine, it'll return the original description
    }
    return description;
  };
  return Object.keys(props).map(name => {
    const {
      type,
      description,
      required,
      defaultValue,
      flowType,
      tsType
    } = props[name];
    return {
      name,
      description: parseDescription(description),
      required,
      type: stringifyType(type || flowType || tsType),
      defaultValue
    };
  });
}
function formatMethods(methods) {
  return Object.keys(methods).map(key => {
    const {
      returns,
      modifiers,
      params,
      docblock,
      name
    } = methods[key];
    return {
      name,
      description: docblock,
      returns,
      modifiers,
      params
    };
  });
}
function fromReactDocs({
  description,
  displayName,
  props,
  methods
}, filePath) {
  return {
    filePath: (0, _utils().pathNormalizeToLinux)(filePath),
    name: displayName,
    description,
    properties: formatProperties(props),
    access: 'public',
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    methods: formatMethods(methods)
  };
}
function stringifyType(prop) {
  if (!prop) return '?'; // TODO!

  const {
    name
  } = prop;
  let transformed;
  switch (name) {
    default:
      transformed = name;
      break;
    case 'func':
      transformed = 'function';
      break;
    case 'shape':
      transformed = JSON.stringify(Object.keys(prop.value).reduce((acc = {}, current) => {
        acc[current] = stringifyType(prop.value[current]);
        return acc;
      }, {}));
      break;
    case 'enum':
      transformed = prop.value.map(enumProp => enumProp.value).join(' | ');
      break;
    case 'instanceOf':
      transformed = prop.value;
      break;
    case 'union':
      transformed = prop.value ? prop.value.map(p => stringifyType(p)).join(' | ') : prop.raw;
      break;
    case 'arrayOf':
      transformed = `${stringifyType(prop.value)}[]`;
      break;
  }
  return transformed;
}
async function parse(data, filePath) {
  const doclets = [];
  try {
    const componentsInfo = reactDocs().parse(data, reactDocs().resolver.findAllExportedComponentDefinitions, undefined, {
      configFile: false,
      filename: filePath // should we use pathNormalizeToLinux(filePath) ?
    });

    if (componentsInfo) {
      return componentsInfo.map(componentInfo => {
        const formatted = fromReactDocs(componentInfo, filePath);
        formatted.args = [];
        // this is a workaround to get the 'example' tag parsed when using react-docs
        // because as of now Docgen doesn't parse @example tag, instead, it shows it inside
        // the @description tag.
        (0, _extractDataRegex().default)(formatted.description, doclets, filePath, false);
        formatted.description = doclets[0].description;
        formatted.examples = doclets[0].examples;
        return formatted;
      });
    }
  } catch (err) {
    _logger().default.trace(`failed parsing docs using docgen on path ${filePath} with error`, err);
  }
  return undefined;
}