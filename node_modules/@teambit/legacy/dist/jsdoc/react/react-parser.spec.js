"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.promise.js");
function _chai() {
  const data = require("chai");
  _chai = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _() {
  const data = _interopRequireDefault(require("./"));
  _ = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const fixtures = path().join(__dirname, '../../..', 'fixtures', 'jsdoc');
function parseFile(filePath) {
  return (0, _().default)(_fsExtra().default.readFileSync(filePath).toString(), 'my-file.js');
}
describe('React docs Parser', () => {
  describe('parse()', () => {
    describe('Invalid code', () => {
      it('should returns an empty array', async () => {
        const doclets = await (0, _().default)('this is an invalid code', 'some-file');
        (0, _chai().expect)(doclets).to.be.undefined;
      });
    });
    describe('React Docs', () => {
      let doclet;
      before(async () => {
        const file = path().join(fixtures, 'react/react-docs.js');
        const doclets = await parseFile(file);
        // @ts-ignore
        doclet = doclets[0];
      });
      it('should have properties parsed', () => {
        (0, _chai().expect)(doclet).to.have.property('properties');
        (0, _chai().expect)(doclet.properties).to.be.an('array').with.lengthOf(3);
      });
      it('should have methods parsed', () => {
        (0, _chai().expect)(doclet).to.have.property('methods');
        (0, _chai().expect)(doclet.methods).to.be.an('array').with.lengthOf(2);
      });
      it('should parse the description correctly', () => {
        (0, _chai().expect)(doclet).to.have.property('description').that.is.equal('Styled button component for the rich and famous!');
      });
      it('should parse the examples correctly', () => {
        (0, _chai().expect)(doclet).to.have.property('examples').that.is.an('array').with.lengthOf(1);
      });
      it('should preserve the spaces in the example', () => {
        const example = doclet.examples[0].raw;
        (0, _chai().expect)(example).to.string('  text');
      });
      it('should parse the properties description correctly', () => {
        (0, _chai().expect)(doclet).to.have.property('properties').that.is.an('array');
        (0, _chai().expect)(doclet.properties[0].description).to.equal('Button text.');
      });
    });
    describe('elevation', () => {
      let doclet;
      before(async () => {
        const file = path().join(fixtures, 'react/elevation.tsx');
        const doclets = await parseFile(file);
        // @ts-ignore
        doclet = doclets[0];
        (0, _chai().expect)(doclet).to.be.an('object');
      });
      it('should have properties parsed', () => {
        (0, _chai().expect)(doclet).to.have.property('properties');
        (0, _chai().expect)(doclet.properties).to.be.an('array').with.lengthOf(1);
      });
      it('should parse the description correctly', () => {
        (0, _chai().expect)(doclet).to.have.property('description').that.is.equal('A wrapper resembling a physical card, grouping elements and improve readability.');
      });
      it('should parse the properties type correctly', () => {
        (0, _chai().expect)(doclet).to.have.property('properties').that.is.an('array');
        (0, _chai().expect)(doclet.properties[0].type).to.equal("'none' | 'low' | 'medium' | 'high'");
      });
    });
  });
});