"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _network() {
  const data = require("../scope/network");
  _network = function () {
    return data;
  };
  return data;
}
function _ssh() {
  const data = require("../scope/network/ssh/ssh");
  _ssh = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
/**
 * @ctx bit, primary, remote
 */
function isPrimary(alias) {
  return alias.includes('!');
}
class Remote {
  constructor(host, name, primary = false, localScopeName) {
    this.localScopeName = localScopeName;
    (0, _defineProperty2().default)(this, "primary", false);
    (0, _defineProperty2().default)(this, "host", void 0);
    (0, _defineProperty2().default)(this, "name", void 0);
    this.name = name || '';
    this.host = host;
    this.primary = primary;
  }
  connect(strategiesNames) {
    return (0, _network().connect)(this.host, this.name, strategiesNames, this.localScopeName);
  }
  toPlainObject() {
    return {
      host: this.host,
      name: this.name
    };
  }
  scope() {
    return this.connect().then(network => {
      return network.describeScope();
    });
  }
  list(namespacesUsingWildcards, strategiesNames = _ssh().DEFAULT_READ_STRATEGIES) {
    return this.connect(strategiesNames).then(network => network.list(namespacesUsingWildcards));
  }
  show(bitId, strategiesNames = _ssh().DEFAULT_READ_STRATEGIES) {
    return this.connect(strategiesNames).then(network => network.show(bitId));
  }
  graph(bitId, strategiesNames = _ssh().DEFAULT_READ_STRATEGIES) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return this.connect(strategiesNames).then(network => network.graph(bitId));
  }
  fetch(ids, fetchOptions, context, strategiesNames = _ssh().DEFAULT_READ_STRATEGIES) {
    return this.connect(strategiesNames).then(network => network.fetch(ids, fetchOptions, context));
  }
  latestVersions(bitIds, strategiesNames = _ssh().DEFAULT_READ_STRATEGIES) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return this.connect(strategiesNames).then(network => network.latestVersions(bitIds));
  }
  validate() {
    if (!(0, _utils().isBitUrl)(this.host)) throw new (_exceptions().InvalidRemote)();
  }
  push(componentObjects) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return this.connect().then(network => network.push(componentObjects));
  }
  async pushMany(objectList, pushOptions, context) {
    const network = await this.connect();
    _logger().default.debug(`[-] Running pushMany on a remote, pushOptions: ${JSON.stringify(pushOptions)}`);
    const results = await network.pushMany(objectList, pushOptions, context);
    _logger().default.debug('[-] Returning from a remote');
    return results;
  }
  deleteMany(ids, force, context, idsAreLanes = false) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return this.connect().then(network => network.deleteMany(ids, force, context, idsAreLanes));
  }
  log(id) {
    return this.connect().then(network => network.log(id));
  }
  listLanes(name, mergeData) {
    return this.connect().then(network => network.listLanes(name, mergeData));
  }
  async action(name, options) {
    const network = await this.connect();
    _logger().default.debug(`[-] Running action ${name} on a remote ${this.name}, options: ${JSON.stringify(options)}`);
    const results = await network.action(name, options);
    _logger().default.debug(`[-] Returning from running action ${name} on a remote ${this.name}`);
    return results;
  }
  static load(name, host, thisScope) {
    const primary = isPrimary(name);
    if (primary) name = (0, _utils().cleanBang)(name);
    return new Remote(name, host, primary, thisScope === null || thisScope === void 0 ? void 0 : thisScope.name);
  }
}
exports.default = Remote;