import { FETCH_OPTIONS } from '../api/scope/lib/fetch';
import { BitId } from '../bit-id';
import DependencyGraph from '../scope/graph/scope-graph';
import Scope from '../scope/scope';
import Remote from './remote';
import { ObjectItemsStream } from '../scope/objects/object-list';
export default class Remotes extends Map<string, Remote> {
    constructor(remotes?: [string, Remote][]);
    validate(): void;
    resolve(scopeName: string, thisScope?: Scope | undefined): Promise<Remote>;
    isHub(scope: string): boolean;
    fetch(idsGroupedByScope: {
        [scopeName: string]: string[];
    }, // option.type determines the id: component-id/lane-id/object-id (hash)
    thisScope: Scope, options?: Partial<FETCH_OPTIONS>, context?: Record<string, any>): Promise<{
        [remoteName: string]: ObjectItemsStream;
    }>;
    latestVersions(ids: BitId[], thisScope: Scope): Promise<BitId[]>;
    /**
     * returns scope graphs of the given bit-ids.
     * it is possible to improve it by returning only the connected-graph of the given id and not the
     * entire scope graph. however, when asking for multiple ids in the same scope, which is more
     * likely to happen, it'll harm the performance.
     */
    scopeGraphs(ids: BitId[], thisScope: Scope): Promise<DependencyGraph[]>;
    _groupByScopeName(ids: BitId[]): {
        [scopeName: string]: BitId[];
    };
    toPlainObject(): {};
    static getScopeRemote(scopeName: string): Promise<Remote>;
    static getGlobalRemotes(): Promise<Remotes>;
    static load(remotes: {
        [key: string]: string;
    }, thisScope?: Scope): Remotes;
}
