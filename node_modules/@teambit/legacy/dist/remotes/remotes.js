"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _prop2() {
  const data = _interopRequireDefault(require("ramda/src/prop"));
  _prop2 = function () {
    return data;
  };
  return data;
}
function _groupBy2() {
  const data = _interopRequireDefault(require("ramda/src/groupBy"));
  _groupBy2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pMap() {
  const data = _interopRequireDefault(require("p-map"));
  _pMap = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _globalRemotes() {
  const data = _interopRequireDefault(require("../global-config/global-remotes"));
  _globalRemotes = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("../scope/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _exceptions2() {
  const data = require("./exceptions");
  _exceptions2 = function () {
    return data;
  };
  return data;
}
function _remote() {
  const data = _interopRequireDefault(require("./remote"));
  _remote = function () {
    return data;
  };
  return data;
}
function _remoteResolver() {
  const data = _interopRequireDefault(require("./remote-resolver/remote-resolver"));
  _remoteResolver = function () {
    return data;
  };
  return data;
}
function _exceptions3() {
  const data = require("../scope/network/exceptions");
  _exceptions3 = function () {
    return data;
  };
  return data;
}
function _concurrency() {
  const data = require("../utils/concurrency");
  _concurrency = function () {
    return data;
  };
  return data;
}
function _scopeNotFoundOrDenied() {
  const data = require("./exceptions/scope-not-found-or-denied");
  _scopeNotFoundOrDenied = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class Remotes extends Map {
  constructor(remotes = []) {
    super(remotes);
  }
  validate() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const primary = this.values.filter(remote => remote.primary);
    if (primary.length > 1) throw new (_exceptions2().PrimaryOverloaded)();
    return this.forEach(remote => remote.validate());
  }
  async resolve(scopeName, thisScope) {
    const remote = super.get(scopeName);
    if (remote) return Promise.resolve(remote);
    const scopeHost = await (0, _remoteResolver().default)(scopeName, thisScope);
    return new (_remote().default)(scopeHost, scopeName, undefined, thisScope === null || thisScope === void 0 ? void 0 : thisScope.name);
  }
  isHub(scope) {
    // if a scope is listed as a remote, it doesn't go to the hub
    return !this.get(scope);
  }
  async fetch(idsGroupedByScope,
  // option.type determines the id: component-id/lane-id/object-id (hash)
  thisScope, options = {}, context) {
    const fetchOptions = _objectSpread({
      type: 'component',
      withoutDependencies: true,
      includeArtifacts: false,
      allowExternal: false
    }, options);
    _logger().default.debug('[-] Running fetch on remotes, with the following options', fetchOptions);
    // when importing directly from a remote scope, throw for ScopeNotFound. otherwise, when
    // fetching flattened dependencies (withoutDependencies=true), ignore this error
    const shouldThrowOnUnavailableScope = !fetchOptions.withoutDependencies;
    const objectsStreamPerRemote = {};
    const failedScopes = {};
    const concurrency = (0, _concurrency().concurrentFetchLimit)();
    await (0, _pMap().default)(Object.keys(idsGroupedByScope), async scopeName => {
      try {
        const remote = await this.resolve(scopeName, thisScope);
        const objectsStream = await remote.fetch(idsGroupedByScope[scopeName], fetchOptions, context);
        objectsStreamPerRemote[scopeName] = objectsStream;
        return objectsStream;
      } catch (err) {
        if (err instanceof _exceptions().ScopeNotFound || err instanceof _scopeNotFoundOrDenied().ScopeNotFoundOrDenied) {
          const msgPrefix = `failed accessing the scope "${scopeName}", which was needed for the following IDs: ${idsGroupedByScope[scopeName].join('\n')}`;
          if (shouldThrowOnUnavailableScope) {
            _logger().default.error(`${msgPrefix}\nstopping the process`);
            throw err;
          } else {
            _logger().default.error(`${msgPrefix}\ncontinuing without this scope.`);
          }
        } else if (err instanceof _exceptions3().UnexpectedNetworkError) {
          _logger().default.error(`failed fetching from ${scopeName}`, err);
          failedScopes[scopeName] = err;
        } else {
          throw err;
        }
        return null;
      }
    }, {
      concurrency
    });
    if (Object.keys(failedScopes).length) {
      const failedScopesErr = Object.keys(failedScopes).map(failedScope => `${failedScope} - ${failedScopes[failedScope].message}`);
      throw new Error(`unexpected network error has occurred during fetching scopes: ${Object.keys(failedScopes).join(', ')}
server responded with the following error messages:
${failedScopesErr.join('\n')}`);
    }
    _logger().default.debug('[-] Returning from the remotes');
    return objectsStreamPerRemote;
  }
  async latestVersions(ids, thisScope) {
    const groupedIds = this._groupByScopeName(ids);
    const promises = Object.entries(groupedIds).map(([scopeName, scopeIds]) => this.resolve(scopeName, thisScope).then(remote => remote.latestVersions(scopeIds)));
    const components = await Promise.all(promises);
    const flattenComponents = (0, _utils().flatten)(components);
    return flattenComponents.map(componentId => _bitId().BitId.parse(componentId, true));
  }

  /**
   * returns scope graphs of the given bit-ids.
   * it is possible to improve it by returning only the connected-graph of the given id and not the
   * entire scope graph. however, when asking for multiple ids in the same scope, which is more
   * likely to happen, it'll harm the performance.
   */
  async scopeGraphs(ids, thisScope) {
    const groupedIds = this._groupByScopeName(ids);
    const graphsP = Object.keys(groupedIds).map(async scopeName => {
      const remote = await this.resolve(scopeName, thisScope);
      const dependencyGraph = await remote.graph();
      dependencyGraph.setScopeName(scopeName);
      return dependencyGraph;
    });
    return Promise.all(graphsP);
  }
  _groupByScopeName(ids) {
    const byScope = (0, _groupBy2().default)((0, _prop2().default)('scope'));
    return byScope(ids);
  }
  toPlainObject() {
    const object = {};
    this.forEach(remote => {
      let name = remote.name;
      if (remote.primary) name = (0, _utils().prependBang)(remote.name);
      object[name] = remote.host;
    });
    return object;
  }
  static async getScopeRemote(scopeName) {
    const remotes = await Remotes.getGlobalRemotes();
    return remotes.resolve(scopeName);
  }
  static async getGlobalRemotes() {
    const globalRemotes = await _globalRemotes().default.load();
    const remotes = globalRemotes.toPlainObject();
    return Remotes.load(remotes);
  }
  static load(remotes, thisScope) {
    const models = [];
    if (!remotes) return new Remotes();
    (0, _utils().forEach)(remotes, (name, host) => {
      const remote = _remote().default.load(name, host, thisScope);
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      models.push([remote.name, remote]);
    });
    return new Remotes(models);
  }
}
exports.default = Remotes;