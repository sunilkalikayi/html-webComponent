"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearCache = clearCache;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _v8CompileCache() {
  const data = require("v8-compile-cache");
  _v8CompileCache = function () {
    return data;
  };
  return data;
}
function _consumer() {
  const data = require("../../../consumer");
  _consumer = function () {
    return data;
  };
  return data;
}
function _componentFsCache() {
  const data = require("../../../consumer/component/component-fs-cache");
  _componentFsCache = function () {
    return data;
  };
  return data;
}
function _scopeLoader() {
  const data = require("../../../scope/scope-loader");
  _scopeLoader = function () {
    return data;
  };
  return data;
}
// it's a hack, but I didn't find a better way to access the getCacheDir() function

class CacheClearer {
  constructor() {
    (0, _defineProperty2().default)(this, "cacheCleared", []);
  }
  async clear() {
    this.clearV8CompiledCode();
    await this.clearFSCache();
    await this.clearScopeIndex();
    return this.cacheCleared;
  }
  clearV8CompiledCode() {
    const cacheDir = _v8CompileCache().__TEST__.getCacheDir();
    _fsExtra().default.removeSync(cacheDir);
    this.cacheCleared.push('v8-compile-cache code');
  }
  async clearFSCache() {
    const fsCachePath = await this.getFSCachePath();
    if (fsCachePath) {
      _fsExtra().default.removeSync(fsCachePath);
      this.cacheCleared.push('components cache on the filesystem');
    }
  }
  async getConsumerGracefully() {
    try {
      return await (0, _consumer().loadConsumerIfExist)();
    } catch (err) {
      return undefined;
    }
  }
  async getScopeGracefully() {
    try {
      return await (0, _scopeLoader().loadScopeIfExist)();
    } catch (err) {
      return undefined;
    }
  }
  async getFSCachePath() {
    const consumer = await this.getConsumerGracefully();
    if (consumer) {
      return consumer.componentFsCache.basePath;
    }
    const consumerInfo = await (0, _consumer().getConsumerInfo)(process.cwd());
    if (!consumerInfo) {
      return null; // no workspace around, nothing to do.
    }

    const scope = await this.getScopeGracefully();
    if (!scope) return null;
    const componentFsCache = new (_componentFsCache().ComponentFsCache)(scope.path);
    return componentFsCache.basePath;
  }
  async clearScopeIndex() {
    const scope = await (0, _scopeLoader().loadScopeIfExist)();
    if (scope) {
      await scope.objects.scopeIndex.deleteFile();
      this.cacheCleared.push('scope-index file');
    }
  }
}
async function clearCache() {
  return new CacheClearer().clear();
}