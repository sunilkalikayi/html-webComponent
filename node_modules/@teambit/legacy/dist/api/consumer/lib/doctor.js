"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = runAll;
exports.listDiagnoses = listDiagnoses;
exports.runOne = runOne;
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _os() {
  const data = _interopRequireDefault(require("os"));
  _os = function () {
    return data;
  };
  return data;
}
function _tarStream() {
  const data = _interopRequireDefault(require("tar-stream"));
  _tarStream = function () {
    return data;
  };
  return data;
}
function _bootstrap() {
  const data = require("../../../bootstrap");
  _bootstrap = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _bitMap() {
  const data = _interopRequireDefault(require("../../../consumer/bit-map"));
  _bitMap = function () {
    return data;
  };
  return data;
}
function _workspaceConfig() {
  const data = _interopRequireDefault(require("../../../consumer/config/workspace-config"));
  _workspaceConfig = function () {
    return data;
  };
  return data;
}
function _consumerLocator() {
  const data = require("../../../consumer/consumer-locator");
  _consumerLocator = function () {
    return data;
  };
  return data;
}
function _doctorRegistrar() {
  const data = _interopRequireDefault(require("../../../doctor/doctor-registrar"));
  _doctorRegistrar = function () {
    return data;
  };
  return data;
}
function _doctorRegistrarBuilder() {
  const data = _interopRequireDefault(require("../../../doctor/doctor-registrar-builder"));
  _doctorRegistrarBuilder = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _npmClient() {
  const data = _interopRequireDefault(require("../../../npm-client"));
  _npmClient = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../../../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _diagnosisNotFound() {
  const data = _interopRequireDefault(require("./exceptions/diagnosis-not-found"));
  _diagnosisNotFound = function () {
    return data;
  };
  return data;
}
function _missingDiagnosisName() {
  const data = _interopRequireDefault(require("./exceptions/missing-diagnosis-name"));
  _missingDiagnosisName = function () {
    return data;
  };
  return data;
}
function globalConfig() {
  const data = _interopRequireWildcard(require("./global-config"));
  globalConfig = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
let runningTimeStamp;
async function runAll({
  filePath
}) {
  (0, _doctorRegistrarBuilder().default)();
  runningTimeStamp = _getTimeStamp();
  const doctorRegistrar = _doctorRegistrar().default.getInstance();
  const examineP = doctorRegistrar.diagnoses.map(diagnosis => diagnosis.examine());
  const examineResults = await Promise.all(examineP);
  const envMeta = await _getEnvMeta();
  const savedFilePath = await _saveExamineResultsToFile(examineResults, envMeta, filePath);
  return {
    examineResults,
    savedFilePath,
    metaData: envMeta
  };
}
async function runOne({
  diagnosisName,
  filePath
}) {
  if (!diagnosisName) {
    throw new (_missingDiagnosisName().default)();
  }
  (0, _doctorRegistrarBuilder().default)();
  runningTimeStamp = _getTimeStamp();
  const doctorRegistrar = _doctorRegistrar().default.getInstance();
  const diagnosis = doctorRegistrar.getDiagnosisByName(diagnosisName);
  if (!diagnosis) {
    throw new (_diagnosisNotFound().default)(diagnosisName);
  }
  const examineResult = await diagnosis.examine();
  const envMeta = await _getEnvMeta();
  const savedFilePath = await _saveExamineResultsToFile([examineResult], envMeta, filePath);
  return {
    examineResult,
    savedFilePath,
    metaData: envMeta
  };
}
async function listDiagnoses() {
  (0, _doctorRegistrarBuilder().default)();
  const doctorRegistrar = _doctorRegistrar().default.getInstance();
  return Promise.resolve(doctorRegistrar.diagnoses);
}
async function _saveExamineResultsToFile(examineResults, envMeta, filePath) {
  if (!filePath) {
    return Promise.resolve(undefined);
  }
  const finalFilePath = _calculateFinalFileName(filePath);
  const packStream = await _generateExamineResultsTarFile(examineResults, envMeta);
  const yourTarball = _fsExtra().default.createWriteStream(finalFilePath);
  packStream.pipe(yourTarball);
  return new Promise(resolve => {
    yourTarball.on('close', function () {
      _logger().default.info(`wrote a file by bit doctor, file path: ${finalFilePath}`);
      resolve(finalFilePath);
      // fs.stat(finalFilePath, function (err, stats) {
      //   if (err) throw err
      //   console.log(stats)
      //   console.log('Got file info successfully!')
      // })
    });
  });
}

function _calculateFinalFileName(fileName) {
  if (fileName === '.') {
    return _getDefaultFileName();
  }
  let finalFileName = fileName;
  if ((0, _utils().getExt)(fileName) !== 'tar' && (0, _utils().getExt)(fileName) !== 'tar.gz') {
    finalFileName = `${(0, _utils().getWithoutExt)(finalFileName)}.tar`;
  }
  return finalFileName;
}
function _getDefaultFileName() {
  const timestamp = runningTimeStamp || _getTimeStamp();
  return `doctor-results-${timestamp}.tar`;
}

// TODO: move to utils
function _getTimeStamp() {
  const d = new Date();
  const timestamp = d.getTime();
  return timestamp;
}
async function _generateExamineResultsTarFile(examineResults, envMeta) {
  const pack = _tarStream().default.pack(); // pack is a streams2 stream
  const debugLog = await _getDebugLogAsBuffer();
  const consumerInfo = await _getConsumerInfo();
  let bitmap;
  if (consumerInfo && consumerInfo.path) {
    bitmap = _getBitMap(consumerInfo.path);
  }
  pack.entry({
    name: 'env-meta.json'
  }, JSON.stringify(envMeta, null, 2));
  pack.entry({
    name: 'doc-results.json'
  }, JSON.stringify(examineResults, null, 2));
  if (debugLog) {
    pack.entry({
      name: 'debug.log'
    }, debugLog);
  }
  if (bitmap) {
    pack.entry({
      name: '.bitmap'
    }, bitmap);
  }
  if (consumerInfo && consumerInfo.hasConsumerConfig) {
    // TODO: support new config as well
    const config = await _workspaceConfig().default.loadIfExist(consumerInfo.path);
    const legacyPlainConfig = config === null || config === void 0 ? void 0 : config._legacyPlainObject();
    if (legacyPlainConfig) {
      pack.entry({
        name: 'config.json'
      }, JSON.stringify(legacyPlainConfig, null, 4));
    }
  }
  pack.finalize();
  return pack;
}
async function _getEnvMeta() {
  const env = {
    nodeVersion: process.version,
    runningTimestamp: runningTimeStamp || _getTimeStamp(),
    platform: _os().default.platform(),
    bitVersion: (0, _bootstrap().getHarmonyVersion)(),
    npmVersion: await _npmClient().default.getNpmVersion(),
    yarnVersion: await _npmClient().default.getYarnVersion(),
    userDetails: _getUserDetails()
  };

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  return env;
}
function _getUserDetails() {
  const name = globalConfig().getSync(_constants().CFG_USER_NAME_KEY) || '';
  const email = globalConfig().getSync(_constants().CFG_USER_EMAIL_KEY) || '';
  return `${name}<${email}>`;
}
async function _getDebugLogAsBuffer() {
  const exists = await _fsExtra().default.pathExists(_constants().DEBUG_LOG);
  if (!exists) return null;
  const log = await _fsExtra().default.readFile(_constants().DEBUG_LOG, 'utf-8');
  const logWithoutChalk = (0, _utils().removeChalkCharacters)(log);
  return Buffer.from(logWithoutChalk);
}
async function _getConsumerInfo() {
  const consumerInfo = await (0, _consumerLocator().getConsumerInfo)(process.cwd());
  return consumerInfo;
}
function _getBitMap(workspaceDir) {
  return _bitMap().default.loadRawSync(workspaceDir);
}