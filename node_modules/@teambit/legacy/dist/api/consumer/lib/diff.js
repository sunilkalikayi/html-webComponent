"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = diff;
function _bitId() {
  const data = require("../../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _consumer() {
  const data = require("../../../consumer");
  _consumer = function () {
    return data;
  };
  return data;
}
function _componentsDiff() {
  const data = _interopRequireDefault(require("../../../consumer/component-ops/components-diff"));
  _componentsDiff = function () {
    return data;
  };
  return data;
}
function _componentsList() {
  const data = _interopRequireDefault(require("../../../consumer/component/components-list"));
  _componentsList = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _hasWildcard() {
  const data = _interopRequireDefault(require("../../../utils/string/has-wildcard"));
  _hasWildcard = function () {
    return data;
  };
  return data;
}
async function diff(values, verbose, table) {
  const consumer = await (0, _consumer().loadConsumer)();
  const {
    bitIds,
    version,
    toVersion
  } = await parseValues(consumer, values);
  if (!bitIds || !bitIds.length) {
    throw new (_generalError().default)('there are no modified components to diff');
  }
  const diffResults = await (0, _componentsDiff().default)(consumer, bitIds, version, toVersion, {
    verbose,
    formatDepsAsTable: table
  });
  await consumer.onDestroy();
  return diffResults;
}
async function parseValues(consumer, values) {
  // option #1: bit diff
  // no arguments
  if (!values.length) {
    const componentsList = new (_componentsList().default)(consumer);
    const bitIds = await componentsList.listModifiedComponents();
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return {
      bitIds
    };
  }
  const firstValue = values[0];
  const lastValue = values[values.length - 1];
  const oneBeforeLastValue = values[values.length - 2];
  const isLastItemVersion = _bitId().BitId.isValidVersion(lastValue);
  const isOneBeforeLastItemVersion = _bitId().BitId.isValidVersion(oneBeforeLastValue);
  // option #2: bit diff [ids...]
  // all arguments are ids
  if (!isLastItemVersion) {
    return {
      bitIds: getBitIdsForDiff(consumer, values)
    };
  }
  // option #3: bit diff [id] [version]
  // last argument is a version, first argument is id
  if (!isOneBeforeLastItemVersion) {
    if (values.length !== 2) {
      throw new (_generalError().default)(`bit diff [id] [version] syntax was used, however, ${values.length} arguments were given instead of 2`);
    }
    return {
      bitIds: getBitIdsForDiff(consumer, [firstValue]),
      version: lastValue
    };
  }
  // option #4: bit diff [id] [version] [to_version]
  // last argument and one before the last are versions, first argument is id
  if (values.length !== 3) {
    throw new (_generalError().default)(`bit diff [id] [version] [to_version] syntax was used, however, ${values.length} arguments were given instead of 3`);
  }
  return {
    bitIds: getBitIdsForDiff(consumer, [firstValue]),
    version: oneBeforeLastValue,
    toVersion: lastValue
  };
}
function getBitIdsForDiff(consumer, ids) {
  if ((0, _hasWildcard().default)(ids)) {
    const componentsList = new (_componentsList().default)(consumer);
    return componentsList.listComponentsByIdsWithWildcard(ids);
  }
  return ids.map(id => consumer.getParsedId(id));
}