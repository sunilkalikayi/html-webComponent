"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fetch;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _hooks() {
  const data = _interopRequireDefault(require("../../../hooks"));
  _hooks = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../../../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = require("../../../scope");
  _scope = function () {
    return data;
  };
  return data;
}
function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("../../../scope/component-ops/scope-components-importer"));
  _scopeComponentsImporter = function () {
    return data;
  };
  return data;
}
function _objects() {
  const data = require("../../../scope/objects");
  _objects = function () {
    return data;
  };
  return data;
}
function _objectList() {
  const data = require("../../../scope/objects/object-list");
  _objectList = function () {
    return data;
  };
  return data;
}
function _objectsReadableGenerator() {
  const data = require("../../../scope/objects/objects-readable-generator");
  _objectsReadableGenerator = function () {
    return data;
  };
  return data;
}
function _laneNotFound() {
  const data = require("./exceptions/lane-not-found");
  _laneNotFound = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const HooksManagerInstance = _hooks().default.getInstance();
async function fetch(path, ids,
// ids type are determined by the fetchOptions.type
fetchOptions, headers) {
  _logger().default.debug(`scope.fetch started, path ${path}, options`, fetchOptions);
  if (!fetchOptions.type) fetchOptions.type = 'component'; // for backward compatibility
  const args = _objectSpread({
    path,
    ids
  }, fetchOptions);
  // This might be undefined in case of fork process like during bit test command
  if (HooksManagerInstance) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    HooksManagerInstance.triggerHook(_constants().PRE_SEND_OBJECTS, args, headers);
  }

  // it should be safe to use the cached scope. when fetching without deps, there is no risk as it
  // just fetches local objects. when fetching with deps, there is a lock mechanism that allows
  // only one fetch at a time. the reason for not creating a new scope instance here is the high
  // memory consumption it causes as it caches many objects in-memory.
  const useCachedScope = true;
  const scope = await (0, _scope().loadScope)(path, useCachedScope);
  const objectList = new (_objectList().ObjectList)();
  const objectsReadableGenerator = new (_objectsReadableGenerator().ObjectsReadableGenerator)(scope.objects);
  switch (fetchOptions.type) {
    case 'component':
      {
        const bitIds = _bitId().BitIds.deserialize(ids);
        const {
          withoutDependencies,
          includeArtifacts,
          allowExternal,
          onlyIfBuilt
        } = fetchOptions;
        const collectParents = !withoutDependencies;

        // important! don't create a new instance of ScopeComponentImporter. Otherwise, the Mutex will be created
        // every request, and won't do anything.
        const scopeComponentsImporter = scope.scopeImporter;
        const laneId = fetchOptions.laneId ? _laneId().LaneId.parse(fetchOptions.laneId) : null;
        const lane = laneId ? await scope.loadLane(laneId) : null;
        const getBitIds = () => {
          if (!lane) return bitIds;
          const laneIds = lane.toBitIds();
          return _bitId().BitIds.fromArray(bitIds.map(bitId => {
            const inLane = laneIds.searchWithoutVersion(bitId);
            return inLane || bitId;
          }));
        };
        const bitIdsToFetch = getBitIds();
        const getComponentsWithOptions = async () => {
          if (withoutDependencies) {
            const componentsVersions = await scopeComponentsImporter.fetchWithoutDeps(bitIdsToFetch, allowExternal, fetchOptions.ignoreMissingHead);
            return componentsVersions.map(compVersion => ({
              component: compVersion.component,
              version: compVersion.version,
              collectArtifacts: includeArtifacts,
              collectParents
            }));
          }
          const versionsDependencies = await scopeComponentsImporter.fetchWithDeps(bitIdsToFetch, allowExternal, onlyIfBuilt);
          const flatDeps = versionsDependencies.map(versionDep => [{
            component: versionDep.component.component,
            version: versionDep.component.version,
            collectArtifacts: includeArtifacts,
            collectParents
          }, ...versionDep.allDependencies.map(verDep => ({
            component: verDep.component,
            version: verDep.version,
            collectArtifacts: includeArtifacts,
            collectParents: false // for dependencies, no need to traverse the entire history
          }))]).flat().reduce((uniqueDeps, dep) => {
            const key = `${dep.component.id()}@${dep.version}`;
            if (!uniqueDeps[key] || !uniqueDeps[key].collectParents && dep.collectParents) {
              uniqueDeps[key] = dep;
            }
            return uniqueDeps;
          }, {});
          return Object.values(flatDeps);
        };
        const componentsWithOptions = await getComponentsWithOptions();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        objectsReadableGenerator.pushObjectsToReadable(componentsWithOptions);
        break;
      }
    case 'component-delta':
      {
        const bitIdsWithHashToStop = _bitId().BitIds.deserialize(ids);
        const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(scope);
        const laneId = fetchOptions.laneId ? _laneId().LaneId.parse(fetchOptions.laneId) : null;
        const lane = laneId ? await scope.loadLane(laneId) : null;
        const bitIdsLatest = bitIdsToLatest(bitIdsWithHashToStop, lane);
        const importedComponents = await scopeComponentsImporter.fetchWithoutDeps(bitIdsLatest, fetchOptions.allowExternal, fetchOptions.ignoreMissingHead);
        const componentsWithOptions = importedComponents.map(compVersion => {
          var _bitIdsWithHashToStop;
          const hashToStop = (_bitIdsWithHashToStop = bitIdsWithHashToStop.searchWithoutVersion(compVersion.id)) === null || _bitIdsWithHashToStop === void 0 ? void 0 : _bitIdsWithHashToStop.version;
          return {
            component: compVersion.component,
            version: compVersion.version,
            collectArtifacts: fetchOptions.includeArtifacts,
            collectParents: true,
            collectParentsUntil: hashToStop ? _objects().Ref.from(hashToStop) : null
          };
        });
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        objectsReadableGenerator.pushObjectsToReadable(componentsWithOptions);
        break;
      }
    case 'lane':
      {
        const laneIds = ids.map(id => _laneId().LaneId.parse(id));
        const lanes = await scope.listLanes();
        const lanesToFetch = laneIds.map(laneId => {
          const laneToFetch = lanes.find(lane => lane.name === laneId.name);
          if (!laneToFetch) {
            throw new (_laneNotFound().LaneNotFound)(scope.name, laneId.name);
          }
          return laneToFetch;
        });
        lanesToFetch.forEach(laneToFetch => {
          laneToFetch.scope = scope.name;
        });
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        objectsReadableGenerator.pushLanes(lanesToFetch);
        break;
      }
    case 'object':
      {
        const refs = ids.map(id => new (_objects().Ref)(id));
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        objectsReadableGenerator.pushObjects(refs, scope);
        break;
      }
    default:
      throw new Error(`type ${fetchOptions.type} was not implemented`);
  }
  if (HooksManagerInstance) {
    await HooksManagerInstance.triggerHook(_constants().POST_SEND_OBJECTS, {
      objectList,
      scopePath: path,
      ids,
      scopeName: scope.scopeJson.name
    },
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    headers);
  }
  _logger().default.debug('scope.fetch returns readable');
  return objectsReadableGenerator.readable;
}
function bitIdsToLatest(bitIds, lane) {
  if (!lane) {
    return bitIds.toVersionLatest();
  }
  const laneIds = lane.toBitIds();
  return _bitId().BitIds.fromArray(bitIds.map(bitId => {
    const inLane = laneIds.searchWithoutVersion(bitId);
    return inLane || bitId.changeVersion(_constants().LATEST_BIT_VERSION);
  }));
}