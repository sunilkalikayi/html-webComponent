"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));
  _flatten2 = function () {
    return data;
  };
  return data;
}
function _forEachObjIndexed2() {
  const data = _interopRequireDefault(require("ramda/src/forEachObjIndexed"));
  _forEachObjIndexed2 = function () {
    return data;
  };
  return data;
}
function _concat2() {
  const data = _interopRequireDefault(require("ramda/src/concat"));
  _concat2 = function () {
    return data;
  };
  return data;
}
function _is2() {
  const data = _interopRequireDefault(require("ramda/src/is"));
  _is2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pick2() {
  const data = _interopRequireDefault(require("ramda/src/pick"));
  _pick2 = function () {
    return data;
  };
  return data;
}
function _isNil2() {
  const data = _interopRequireDefault(require("ramda/src/isNil"));
  _isNil2 = function () {
    return data;
  };
  return data;
}
function _reject2() {
  const data = _interopRequireDefault(require("ramda/src/reject"));
  _reject2 = function () {
    return data;
  };
  return data;
}
function _toPairs2() {
  const data = _interopRequireDefault(require("ramda/src/toPairs"));
  _toPairs2 = function () {
    return data;
  };
  return data;
}
function _join2() {
  const data = _interopRequireDefault(require("ramda/src/join"));
  _join2 = function () {
    return data;
  };
  return data;
}
function _map2() {
  const data = _interopRequireDefault(require("ramda/src/map"));
  _map2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _child_process() {
  const data = require("child_process");
  _child_process = function () {
    return data;
  };
  return data;
}
function _execa() {
  const data = _interopRequireDefault(require("execa"));
  _execa = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _semver() {
  const data = _interopRequireDefault(require("semver"));
  _semver = function () {
    return data;
  };
  return data;
}
function _analytics() {
  const data = require("../analytics/analytics");
  _analytics = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _showDoctorError() {
  const data = _interopRequireDefault(require("../error/show-doctor-error"));
  _showDoctorError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const objectToArray = obj => (0, _map2().default)((0, _join2().default)('@'), (0, _toPairs2().default)(obj));
const rejectNils = (0, _reject2().default)(_isNil2().default);
const defaultNpmArgs = [];
const defaultYarnArgs = [];
const defaultPnpmArgs = [];
const defaultPackageManagerArgs = {
  npm: defaultNpmArgs,
  yarn: defaultYarnArgs,
  pnpm: defaultPnpmArgs
};
const defaultPackageManagerProcessOptions = {
  cwd: process.cwd
};
const warningPrefix = packageManager => {
  return packageManager === 'npm' ? 'npm WARN' : 'warning';
};
const errorPrefix = packageManager => {
  return packageManager === 'npm' ? 'npm ERR!' : 'error';
};
const peerDependenciesMissing = packageManager => {
  return packageManager === 'npm' ? 'requires a peer' : 'unmet peer';
};
const stripNonNpmErrors = (errors, packageManager) => {
  // a workaround to remove all 'npm warn' and 'npm notice'.
  // NPM itself returns them even when --loglevel = error or when --silent/--quiet flags are set
  const prefix = errorPrefix(packageManager);
  return errors.split('\n').filter(error => error.startsWith(prefix)).join('\n');
};
const stripNonPeerDependenciesWarnings = (errors, packageManager) => {
  const prefix = warningPrefix(packageManager);
  const peer = peerDependenciesMissing(packageManager);
  return errors.split('\n').filter(error => error.startsWith(prefix) && error.includes(peer)).join('\n');
};

/**
 * Pick only allowed to be overridden options
 * @param {Object} userOptions
 */
const getAllowdPackageManagerProcessOptions = userOptions => {
  const allowdOptions = ['shell', 'env', 'extendEnv', 'uid', 'gid', 'preferLocal', 'localDir', 'timeout'];
  return (0, _pick2().default)(allowdOptions, userOptions);
};
/**
 * Install packages in specific directory
 */
const _installInOneDirectory = ({
  modules = [],
  packageManager = _constants().DEFAULT_PACKAGE_MANAGER,
  packageManagerArgs = [],
  packageManagerProcessOptions = {},
  dir,
  installProdPackagesOnly = false,
  verbose = false
}) => {
  // Handle process options
  const allowedPackageManagerProcessOptions = getAllowdPackageManagerProcessOptions(packageManagerProcessOptions);
  const concretePackageManagerProcessOptions = _objectSpread(_objectSpread({}, defaultPackageManagerProcessOptions), allowedPackageManagerProcessOptions);
  concretePackageManagerProcessOptions.cwd = dir || concretePackageManagerProcessOptions.cwd;
  const cwd = concretePackageManagerProcessOptions.cwd;

  // taking care of object case
  const processedModules = (0, _is2().default)(Object, modules) && !Array.isArray(modules) ? objectToArray(modules) : modules;
  const defaultArgs = defaultPackageManagerArgs[packageManager] ? defaultPackageManagerArgs[packageManager] : [];
  // Handle process args
  const concretePackageManagerDefaultArgs = ['install', ...processedModules, ...defaultArgs];
  const concretePackageManagerArgs = rejectNils((0, _concat2().default)(concretePackageManagerDefaultArgs, packageManagerArgs));

  // Add npm verbose flag
  if (verbose && packageManager === 'npm') {
    // we may want to use it later. For now, it print too much information
    // concretePackageManagerArgs.push('--verbose');
  }
  if (installProdPackagesOnly) {
    concretePackageManagerArgs.push('--production');
  }
  _fsExtra().default.ensureDirSync(path().join(cwd, 'node_modules'));
  _logger().default.debug(`installing npm packages using ${packageManager} at ${cwd} with args: ${concretePackageManagerArgs} and options:`, concretePackageManagerProcessOptions);
  // Set the shell to true to prevent problems with post install scripts when running as root
  const packageManagerClientName = packageManager;
  const childProcess = (0, _execa().default)(packageManagerClientName, concretePackageManagerArgs, concretePackageManagerProcessOptions);

  // Remove the install from args since it's always there
  const printArgs = concretePackageManagerArgs.filter(arg => arg !== 'install');
  const argsString = printArgs && printArgs.length > 0 ? `with args: ${printArgs}` : '';
  return childProcess.then(({
    stdout,
    stderr
  }) => {
    const successMessage = `\nsuccessfully ran ${packageManager} install at ${cwd} ${argsString}`;
    const peerWarnings = stripNonPeerDependenciesWarnings(stderr, packageManager);
    stdout = verbose ? stdout + successMessage : _chalk().default.white(peerWarnings) + successMessage;
    stderr = verbose ? stderr : '';
    return {
      stdout,
      stderr
    };
  }).catch(err => {
    let stderr = `failed running ${packageManager} install at ${cwd} ${argsString}  \n`;
    stderr += verbose ? err.stderr : stripNonNpmErrors(err.stderr, packageManager);
    throw new (_showDoctorError().default)(`${stderr}\n\n${_chalk().default.yellow(`see troubleshooting at https://${_constants().BASE_DOCS_DOMAIN}/dependencies/dependency-installation`)}`);
  });
};
const _getNpmList = async (packageManager, dir) => {
  // We don't use here execa since there is a bug with execa (2.*) with some node versions
  // execa uses util.getSystemErrorName which not available in some node versions
  // see more here - https://github.com/sindresorhus/execa/issues/318
  // We also use spwan instead of exec since the output might be very long and exec is limited with
  // handling such long outputs
  // once we stop support node < 10 we can replace it with something like
  // npmList = await execa(packageManager, ['list', '-j'], { cwd: dir });
  return new Promise(resolve => {
    let stdout = '';
    let stderr = '';
    const shell = _constants().IS_WINDOWS;
    const ls = (0, _child_process().spawn)(packageManager, ['list', '-j'], {
      cwd: dir,
      shell
    });
    ls.stdout.on('data', data => {
      stdout += data;
    });
    ls.stderr.on('data', data => {
      stderr += data;
    });
    ls.on('error', err => {
      stderr += err;
    });
    ls.on('close', code => {
      const res = {
        stdout,
        stderr,
        code
      };
      resolve(res);
    });
  });
};

/**
 * Get peer dependencies for directory
 * you should run this after you run npm install
 * internally it uses npm list -j
 */
const _getPeerDeps = async dir => {
  const packageManager = _constants().DEFAULT_PACKAGE_MANAGER;
  const npmList = await _getNpmList(packageManager, dir);
  // If the npmList.stdout starts with '{' it's probably a valid json so no throw an error
  if (npmList.stderr && !npmList.stdout.startsWith('{')) {
    _logger().default.error('npm-client got an error', npmList.stderr);
    throw new Error(`failed running ${packageManager} list on folder ${dir} to find the peer dependencies due to an error: ${npmList.stderr}`);
  }
  const peerDepsObject = await getPeerDepsFromNpmList(npmList.stdout, packageManager);
  return objectToArray(peerDepsObject);
};
async function getPeerDepsFromNpmList(npmList, packageManager) {
  const parsePeers = deps => {
    const result = {};
    (0, _forEachObjIndexed2().default)(dep => {
      if (dep.peerMissing) {
        const name = dep.required.name;
        const version = dep.required.version;
        result[name] = version;
      }
    }, deps);
    return result;
  };
  const npmListObject = await parseNpmListJsonGracefully(npmList, packageManager);
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  return parsePeers(npmListObject.dependencies);
}

// @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
async function parseNpmListJsonGracefully(str, packageManager) {
  try {
    const json = JSON.parse(str);
    return json;
  } catch (err) {
    _logger().default.error('npm-client got an error', err);
    if (packageManager === 'npm') {
      const version = await getNpmVersion();
      _analytics().Analytics.setExtraData('npmVersion', version);
      if (version && _semver().default.gte(version, '5.0.0') && _semver().default.lt(version, '5.1.0')) {
        // see here for more info about this issue with npm 5.0.0
        // https://github.com/npm/npm/issues/17331
        throw new Error(`error: your npm version "${version}" has issues returning json, please upgrade to 5.1.0 or above (npm install -g npm@5.1.0)`);
      }
    }
    throw new Error(`failed parsing the output of npm list due to an error: ${err.message}`);
  }
}

/**
 * A wrapper function to call the install
 * then get the peers
 * then install the peers
 */
const _installInOneDirectoryWithPeerOption = async ({
  modules = [],
  packageManager = _constants().DEFAULT_PACKAGE_MANAGER,
  packageManagerArgs = [],
  packageManagerProcessOptions = {},
  dir,
  installPeerDependencies = false,
  installProdPackagesOnly = false,
  verbose = false
}) => {
  const rootDirResults = await _installInOneDirectory({
    modules,
    packageManager,
    packageManagerArgs,
    packageManagerProcessOptions,
    dir,
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    installPeerDependencies,
    installProdPackagesOnly,
    verbose
  });
  if (installPeerDependencies) {
    const peers = await _getPeerDeps(dir);
    const peerResults = await _installInOneDirectory({
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      modules: peers,
      packageManager,
      packageManagerArgs,
      packageManagerProcessOptions,
      dir,
      installProdPackagesOnly,
      verbose
    });
    return [rootDirResults, peerResults];
  }
  return rootDirResults;
};

/**
 * when modules is empty, it runs 'npm install' without any package, which installs according to package.json file
 */
const installAction = async ({
  modules,
  packageManager = _constants().DEFAULT_PACKAGE_MANAGER,
  packageManagerArgs = [],
  packageManagerProcessOptions = {},
  useWorkspaces = false,
  dirs = [],
  rootDir,
  installRootPackageJson = false,
  installPeerDependencies = false,
  installProdPackagesOnly = false,
  verbose = false
}) => {
  if (useWorkspaces && packageManager === 'yarn') {
    await _installInOneDirectoryWithPeerOption({
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      modules,
      packageManager,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageManagerArgs,
      packageManagerProcessOptions,
      dir: rootDir,
      installPeerDependencies,
      installProdPackagesOnly,
      verbose
    });
  }
  const results = [];
  if (installRootPackageJson) {
    // installation of the root package.json has to be completed before installing the sub-directories package.json.
    const rootDirResults = await _installInOneDirectoryWithPeerOption({
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      modules,
      packageManager,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageManagerArgs,
      packageManagerProcessOptions,
      dir: rootDir,
      installPeerDependencies,
      installProdPackagesOnly,
      verbose
    });
    if (Array.isArray(rootDirResults)) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      results.concat(rootDirResults);
    } else {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      results.push(rootDirResults);
    }
  }
  const installInDir = dir => _installInOneDirectoryWithPeerOption({
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    modules,
    packageManager,
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    packageManagerArgs,
    packageManagerProcessOptions,
    dir,
    installPeerDependencies,
    installProdPackagesOnly,
    verbose
  });

  // run npm install for each one of the directories serially, not in parallel. Don’t use Promise.all() here.
  // running them in parallel result in race condition and random NPM errors. (see https://github.com/teambit/bit/issues/1617)
  const promisesResults = await (0, _pMapSeries().default)(dirs, installInDir);
  return results.concat((0, _flatten2().default)(promisesResults));
};
const printResults = ({
  stdout,
  stderr
}) => {
  _logger().default.console(_chalk().default.yellow(stdout)); // eslint-disable-line
  _logger().default.console(_chalk().default.yellow(stderr)); // eslint-disable-line
};

async function getNpmVersion() {
  try {
    const {
      stdout,
      stderr
    } = await (0, _execa().default)('npm', ['--version']);
    if (stdout && !stderr) return stdout;
  } catch (err) {
    _logger().default.debugAndAddBreadCrumb('npm-client', `got an error when executing "npm --version". ${err.message}`);
  }
  return null;
}
async function getYarnVersion() {
  try {
    const {
      stdout
    } = await (0, _execa().default)('yarn', ['-v']);
    return stdout;
  } catch (e) {
    _logger().default.debugAndAddBreadCrumb('npm-client', `can't find yarn version by running yarn -v. ${e.message}`);
  }
  return null;
}

/**
 * a situation where rootDir and subDir have package.json, some of the packages may be shared
 * and some may be conflicted. And the "npm/yarn install" is done from the root dir.
 * package managers install the shared packages only once in the rootDir.
 * however, as to the conflicted packages, only npm@5 and above install it in the subDir.
 * others, install it in the root, which, result in an incorrect package resolution for the subDir.
 */
async function isSupportedInstallationOfSubDirFromRoot(packageManager) {
  if (packageManager === 'npm') {
    const version = await getNpmVersion();
    if (version && _semver().default.gte(version, '5.0.0')) {
      return true;
    }
  }
  return false;
}
async function getPackageLatestVersion(packageName) {
  try {
    const {
      stdout
    } = await (0, _execa().default)('npm', ['show', packageName, 'version']);
    return stdout;
  } catch (e) {
    _logger().default.debugAndAddBreadCrumb('npm-client', `can't find ${packageName} version by running npm show ${packageName} version. ${e.message}`);
  }
  return null;
}
var _default = {
  install: installAction,
  printResults,
  isSupportedInstallationOfSubDirFromRoot,
  getNpmVersion,
  getYarnVersion,
  getPeerDepsFromNpmList,
  getPackageLatestVersion
};
exports.default = _default;