"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllRootDirectoriesFor = getAllRootDirectoriesFor;
exports.installNpmPackagesForComponents = installNpmPackagesForComponents;
exports.installPackages = installPackages;
function _uniq2() {
  const data = _interopRequireDefault(require("ramda/src/uniq"));
  _uniq2 = function () {
    return data;
  };
  return data;
}
function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));
  _flatten2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("../cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
function _loaderMessages() {
  const data = require("../cli/loader/loader-messages");
  _loaderMessages = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _filterAsync() {
  const data = _interopRequireDefault(require("../utils/array/filter-async"));
  _filterAsync = function () {
    return data;
  };
  return data;
}
function _() {
  const data = _interopRequireDefault(require("."));
  _ = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
async function installPackages(consumer, dirs, verbose,
// true shows all messages, false shows only a successful message
installRootPackageJson = false, silentPackageManagerResult = false,
// don't shows packageManager results at all
installPeerDependencies = false,
// also install peer dependencies
installProdPackagesOnly = false) {
  var _consumer$config$depe, _consumer$config$depe2;
  const dirsWithPkgJson = await filterDirsWithoutPackageJson(dirs);
  const packageManager = consumer.config.packageManager || _constants().DEFAULT_PACKAGE_MANAGER;
  const packageManagerArgs = consumer.packageManagerArgs.length ? consumer.packageManagerArgs : ((_consumer$config$depe = consumer.config.dependencyResolver) === null || _consumer$config$depe === void 0 ? void 0 : _consumer$config$depe.extraArgs) || [];
  const packageManagerProcessOptions = ((_consumer$config$depe2 = consumer.config.dependencyResolver) === null || _consumer$config$depe2 === void 0 ? void 0 : _consumer$config$depe2.packageManagerProcessOptions) || {};
  const useWorkspaces = consumer.config._useWorkspaces;
  _loader().default.start(_loaderMessages().BEFORE_INSTALL_NPM_DEPENDENCIES);

  // don't pass the packages to npmClient.install function.
  // otherwise, it'll try to npm install the packages in one line 'npm install packageA packageB' and when
  // there are mix of public and private packages it fails with 404 error.
  // passing an empty array, results in installing packages from the package.json file
  let results = await _().default.install({
    modules: [],
    packageManager,
    packageManagerArgs,
    packageManagerProcessOptions,
    useWorkspaces: !!useWorkspaces,
    dirs: dirsWithPkgJson,
    rootDir: consumer.getPath(),
    installRootPackageJson,
    installPeerDependencies,
    installProdPackagesOnly,
    verbose
  });
  _loader().default.stop();
  if (!Array.isArray(results)) {
    results = [results];
  }
  if (!silentPackageManagerResult || verbose) {
    results.forEach(result => {
      if (result) _().default.printResults(result);
    });
  }
}
async function installNpmPackagesForComponents({
  consumer,
  basePath,
  componentsWithDependencies,
  verbose = false,
  silentPackageManagerResult = false,
  installPeerDependencies = false,
  installProdPackagesOnly = false
}) {
  const componentDirsRelative = getAllRootDirectoriesFor(componentsWithDependencies);
  const componentDirs = componentDirsRelative.map(dir => basePath ? path().join(basePath, dir) : dir);
  return installPackages(consumer, componentDirs, verbose, false, silentPackageManagerResult, installPeerDependencies, installProdPackagesOnly);
}
function getAllRootDirectoriesFor(componentsWithDependencies) {
  // if dependencies are installed as bit-components, go to each one of the dependencies and install npm packages
  // otherwise, if the dependencies are installed as npm packages, npm already takes care of that
  const componentsWithDependenciesFlatten = (0, _flatten2().default)(componentsWithDependencies.map(oneComponentWithDependencies => {
    return oneComponentWithDependencies.component.dependenciesSavedAsComponents ? [oneComponentWithDependencies.component, ...oneComponentWithDependencies.dependencies] : [oneComponentWithDependencies.component];
  }));
  const componentDirsRelative = componentsWithDependenciesFlatten.map(component => component.writtenPath);
  return (0, _uniq2().default)(componentDirsRelative);
}
async function filterDirsWithoutPackageJson(dirs) {
  return (0, _filterAsync().default)(dirs, dir => _fsExtra().default.pathExists(path().join(dir, _constants().PACKAGE_JSON)));
}