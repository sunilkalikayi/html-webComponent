import CommandHelper from './e2e-command-helper';
import FsHelper from './e2e-fs-helper';
import NpmHelper from './e2e-npm-helper';
import PackageJsonHelper from './e2e-package-json-helper';
import ScopeHelper from './e2e-scope-helper';
import ScopesData from './e2e-scopes';
export default class FixtureHelper {
    fs: FsHelper;
    command: CommandHelper;
    scopes: ScopesData;
    debugMode: boolean;
    npm: NpmHelper;
    packageJson: PackageJsonHelper;
    scopeHelper: ScopeHelper;
    constructor(fsHelper: FsHelper, commandHelper: CommandHelper, npmHelper: NpmHelper, scopes: ScopesData, debugMode: boolean, packageJson: PackageJsonHelper, scopeHelper: ScopeHelper);
    createComponentBarFoo(impl?: string): void;
    createComponentUtilsIsType(impl?: string): void;
    createComponentUtilsIsString(impl?: string): void;
    addComponentBarFoo(): string;
    addComponentBarFooAsDir(): string;
    addComponentUtilsIsType(): string;
    createComponentIsType(): void;
    addComponentUtilsIsTypeAsDir(): string;
    createComponentIsString(impl?: string): void;
    addComponentUtilsIsString(): string;
    addComponentUtilsIsStringAsDir(): string;
    tagComponentBarFoo(): string;
    getFixturesDir(): string;
    copyFixtureDir(src: string, dest: string): void;
    copyFixtureComponents(dir?: string, dest?: string): void;
    copyFixtureExtensions(dir?: string, cwd?: string): void;
    copyFixtureFile(pathToFile?: string, newName?: string, cwd?: string): void;
    /**
     * populates the local workspace with the following components:
     * 'bar/foo'         => requires a file from 'utils/is-string' component
     * 'utils/is-string' => requires a file from 'utils/is-type' component
     * 'utils/is-type'
     * in other words, the dependency chain is: bar/foo => utils/is-string => utils/is-type
     */
    populateWorkspaceWithThreeComponents(): void;
    populateWorkspaceWithComponentsWithV2(): void;
    populateWorkspaceWithThreeComponentsAndModulePath(useDefaultScope?: boolean): void;
    /**
     * @deprecated use populateWorkspaceWithThreeComponents()
     */
    populateWorkspaceWithComponents(): void;
    /**
     * important: use only this function. ignore other populateWorkspaceWith* functions, they're for
     * legacy code (which adds files instead of directory).
     *
     * it creates and adds components that require each other.
     * e.g. when creating 3 components, the workspace is: comp1 => comp2 => comp3.
     * meaning, comp1 requires comp2 and comp2 requires comp2.
     *
     * it also adds app.js file.
     * in the case of the 3 components above, the output is: "comp1 and comp2 and comp3".
     *
     * @returns the expected output in case "node app.js" is running
     */
    populateComponents(numOfComponents?: number, rewire?: boolean, additionalStr?: string, compile?: boolean, esm?: boolean): string;
    private getCjsImplForPopulate;
    private getEsmImplForPopulate;
    /**
     * This will populate extensions that does nothing
     * its purpose is to check different config merges
     *
     * @param {number} [numOfExtensions=3]
     * @returns {string}
     * @memberof FixtureHelper
     */
    populateExtensions(numOfExtensions?: number): void;
    populateComponentsTS(numOfComponents?: number, owner?: string, isHarmony?: boolean): string;
    /**
     * populates the local workspace with the following components:
     * 'utils/is-string' => requires a file from 'utils/is-type' component
     * 'utils/is-type'
     * in other words, the dependency chain is: utils/is-string => utils/is-type
     */
    populateWorkspaceWithTwoComponents(): void;
    /**
     * populates the local workspace with the one component "utils/is-type".
     */
    populateWorkspaceWithUtilsIsType(): void;
    /**
     * populates the local workspace with the following components:
     * 'bar/foo'         => requires a file from 'utils/is-string' component
     * 'utils/is-string' => requires a file from 'utils/is-type' component
     * 'utils/is-type'   => requires the left-pad package
     * in other words, the dependency chain is: bar/foo => utils/is-string => utils/is-type => left-pad
     */
    populateWorkspaceWithComponentsAndPackages(): void;
    /**
     * extract the global-remote g-zipped scope into the e2e-test, so it'll be ready to consume.
     * this is an alternative to import directly from bit-dev.
     *
     * to add more components to the .tgz file, extract it, add it as a remote, then from your
     * workspace import the component you want and fork it into this remote, e.g.
     * # extract the file into `/tmp` so then the scope is in `/tmp/global-remote`.
     * cp e2e/fixtures/scopes/global-remote.tgz /tmp/
     * cd tmp && tar -xzvf global-remote.tgz
     * # go to your workspace and run the following
     * bit remote add file:///tmp/global-remote
     * bit import bit.envs/compilers/typescript
     * bit export global-remote bit.envs/compilers/typescript --include-dependencies --force --rewire
     * # then, cd into /tmp and tar the directory
     * cd /tmp && tar -czf global-remote.tgz global-remote
     * # copy the file to the fixtures/scopes directory.
     * cp /tmp/global-remote.tgz e2e/fixtures/scopes/
     */
    ensureGlobalRemoteScope(): void;
    extractCompressedFixture(filePathRelativeToFixtures: string, destDir: string): void;
}
