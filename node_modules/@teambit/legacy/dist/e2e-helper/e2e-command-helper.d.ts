/// <reference types="node" />
import { StdioOptions } from 'child_process';
import { InteractiveInputs } from '../interactive/utils/run-interactive-cmd';
import ScopesData from './e2e-scopes';
/**
 * to enable a feature for Helper instance, in the e2e-test file add `helper.command.setFeatures('your-feature');`
 * to enable a feature for a single command, add the feature to the runCmd, e.g. `runCmd(cmd, cwd, stdio, 'your-feature');`
 * if you set both, the runCmd wins.
 * more about feature-toggle head to feature-toggle.ts file.
 */
export default class CommandHelper {
    scopes: ScopesData;
    debugMode: boolean;
    bitBin: string;
    featuresToggle: string | string[] | undefined;
    constructor(scopes: ScopesData, debugMode: boolean);
    setFeatures(featuresToggle: string | string[]): void;
    resetFeatures(): void;
    runCmd(cmd: string, cwd?: string, stdio?: StdioOptions, overrideFeatures?: string, getStderrAsPartOfTheOutput?: boolean): string;
    _getFeatureToggleCmdPrefix(overrideFeatures?: string): string;
    listRemoteScope(raw?: boolean, options?: string): string;
    listRemoteScopeIds(options?: string): string;
    list(options?: string): string;
    listParsed(options?: string): Record<string, any>[];
    listLocalScope(options?: string): string;
    listLocalScopeParsed(options?: string): Record<string, any>[];
    listRemoteScopeParsed(options?: string): any;
    listScopeParsed(scope: string, options?: string): any;
    catScope(includeExtraData?: boolean, cwd?: string): any;
    catObject(hash: string, parse?: boolean): any;
    catComponent(id: string, cwd?: string, parse?: boolean): Record<string, any>;
    catLane(id: string, cwd?: string): Record<string, any>;
    add(dir: string, flag?: string): string;
    addComponent(filePaths: string, options?: Record<string, any> | string, cwd?: string): string;
    addLaneReadme(id: string, laneName?: string): string;
    removeLaneReadme(laneName?: string): string;
    sign(ids: string[], flags?: string, cwd?: string): string;
    artifacts(id?: string, flags?: string): string;
    updateDependencies(data: Record<string, any>, flags?: string, cwd?: string): string;
    getConfig(configName: string): string;
    delConfig(configName: string): string;
    setConfig(configName: string, configVal: string): string;
    setScope(scopeName: string, component: string): string;
    renameScope(oldScope: string, newScope: string, flags?: string): string;
    setEnv(compId: string, envId: string): string;
    unsetEnv(compId: string): string;
    replaceEnv(oldEnv: string, newEnv: string): string;
    setAspect(pattern: string, aspectId: string, config?: Record<string, any>, flags?: string): string;
    unsetAspect(pattern: string, aspectId: string, flags?: string): string;
    updateAspect(aspectId: string, pattern?: string, flags?: string): string;
    removeComponent(id: string, flags?: string): string;
    deprecateComponent(id: string, flags?: string): string;
    undeprecateComponent(id: string, flags?: string): string;
    fork(sourceId: string, values?: string): string;
    forkScope(originalScope: string, newScope: string): string;
    rename(sourceId: string, targetId: string, flags?: string): string;
    refactorDependencyName(oldId: string, newId: string, flags?: string): string;
    use(aspectId: string, flags?: string): string;
    dependenciesGet(values?: string): string;
    dependenciesSet(pattern: string, pkg: string, flags?: string): string;
    dependenciesRemove(pattern: string, pkg: string, flags?: string): string;
    tagComponent(id: string, tagMsg?: string, options?: string): string;
    tagWithoutMessage(id: string, version?: string, options?: string): string;
    tagAllComponents(options?: string, version?: string, assertTagged?: boolean): string;
    tagAllWithoutBuild(options?: string): string;
    tagWithoutBuild(id?: string, options?: string): string;
    rewireAndTagAllComponents(options?: string, version?: string, assertTagged?: boolean): string;
    tagIncludeUnmodified(version?: string, message?: string, options?: string): string;
    tagIncludeUnmodifiedWithoutBuild(version?: string, options?: string): string;
    softTag(options?: string): string;
    persistTag(options?: string): string;
    persistTagWithoutBuild(options?: string): string;
    snapComponent(id: string, tagMsg?: string, options?: string): string;
    snapComponentWithoutBuild(id: string, options?: string): string;
    snapAllComponents(options?: string, assertSnapped?: boolean): string;
    snapAllComponentsWithoutBuild(options?: string, assertSnapped?: boolean): string;
    createLane(laneName?: string, options?: string): string;
    changeLaneScope(laneName: string, newScope: string): string;
    clearCache(): string;
    removeLane(laneName?: string, options?: string): string;
    removeRemoteLane(laneName?: string, options?: string): string;
    writeTsconfig(flags?: string): string;
    writeTsconfigDryRun(flags?: string): any;
    showOneLane(name: string): string;
    showOneLaneParsed(name: string): any;
    listLanes(options?: string): string;
    listLanesParsed(options?: string): any;
    expectCurrentLaneToBe(laneName: string): void;
    listRemoteLanesParsed(options?: string): any;
    diffLane(args?: string, onScope?: boolean): string;
    getHead(id: string, cwd?: string): any;
    getHeadShort(id: string, cwd?: string): any;
    getHeadOfLane(laneName: string, componentName: string, cwd?: string): any;
    getArtifacts(id: string): any;
    untag(id: string, head?: boolean, flag?: string): string;
    untagAll(options?: string): string;
    untagSoft(id: string): string;
    exportIds(ids: string, flags?: string, assert?: boolean): string;
    exportLane(assert?: boolean): string;
    export(options?: string): string;
    resumeExport(exportId: string, remotes: string[]): string;
    ejectComponents(ids: string, flags?: string): string;
    ejectComponentsParsed(ids: string, flags?: string): any;
    importComponent(id: string, flags?: string): string;
    import(value?: string): string;
    importLane(laneName: string, flags?: string): string;
    fetchLane(id: string): string;
    fetchRemoteLane(id: string): string;
    fetchAllLanes(): string;
    fetchAllComponents(): string;
    renameLane(oldName: string, newName: string): string;
    importManyComponents(ids: string[]): string;
    importComponentWithOptions(id: string | undefined, options: Record<string, any>): string;
    importAllComponents(writeToFileSystem?: boolean): string;
    /**
     * returns the capsule dir in case there is --json flag
     */
    createCapsuleHarmony(id: string, options?: Record<string, any>): string;
    capsuleListParsed(): any;
    getCapsuleOfComponent(id: string): any;
    importExtension(id: string): string;
    build(id?: string, flags?: string, getStderrAsPartOfTheOutput?: boolean): string;
    test(flags?: string, getStderrAsPartOfTheOutput?: boolean): string;
    testComponent(id?: string, flags?: string): string;
    testAllWithJunit(): string;
    status(flags?: string): string;
    statusJson(cwd?: string): any;
    isDeprecated(compName: string): boolean;
    getStagedIdsFromStatus(stripScopeName?: boolean): string[];
    expectStatusToBeClean(exclude?: string[]): void;
    expectStatusToHaveIssue(issueName: string): void;
    expectStatusToNotHaveIssue(issueName: string): void;
    getAllIssuesFromStatus(): string[];
    expectStatusToNotHaveIssues(cwd?: string): void;
    statusComponentIsModified(fullIdWithVersion: string): boolean;
    statusComponentIsStaged(id: string): boolean;
    statusComponentHasIssues(id: string): boolean;
    showComponent(id?: string): string;
    showComponentParsed(id?: string): any;
    showComponentParsedHarmony(id?: string): any;
    showAspectConfig(compId: string, aspectId: string): any;
    getComponentFiles(id: string): string[];
    showComponentWithOptions(id: string | undefined, options: Record<string, any>): string;
    checkoutVersion(version: string, ids: string, flags?: string, cwd?: string): string;
    checkout(values: string): string;
    checkoutHead(values?: string): string;
    checkoutReset(values?: string): string;
    switchLocalLane(lane: string, flags?: string): string;
    switchRemoteLane(lane: string, flags?: string, getAll?: boolean): string;
    mergeVersion(version: string, ids: string, flags?: string): string;
    merge(values: string): string;
    mergeLane(laneName: string, options?: string): string;
    mergeLaneFromScope(cwd: string, laneName: string, options?: string): string;
    tagFromScope(cwd: string, ids: string, options?: string): string;
    diff(id?: string): string | null | undefined;
    log(id: string, flags?: string): string;
    logParsed(id: string, flags?: string): any;
    move(from: string, to: string): string;
    runTask(taskName: string): string;
    create(templateName: string, componentName: string, flags?: string, cwd?: string): string;
    new(templateName: string, flags?: string, workspaceName?: string, cwd?: string): string;
    runApp(name: string): string;
    link(flags?: string): string;
    install(packages?: string, options?: Record<string, any>, cwd?: string): string;
    update(flags?: string): string;
    uninstall(flags?: string): string;
    linkAndRewire(ids?: string): string;
    linkAndCompile(linkFlags?: string, compileId?: string, compileFlags?: Record<string, string>): string;
    packComponent(id: string, options: Record<string, any>, extract?: boolean): string;
    publish(id: string, flags?: string): string;
    ejectConf(id?: string, options?: Record<string, any>): string;
    runAction(actionName: string, remote: string, options: Record<string, any>): string;
    compile(id?: string, options?: Record<string, any>): string;
    doctor(options: Record<string, any>): string;
    doctorOne(diagnosisName: string, options: Record<string, any>, cwd?: string): string;
    doctorList(options: Record<string, any>): string;
    doctorJsonParsed(): any;
    parseOptions(options?: Record<string, any>): string;
    init(options?: string): string;
    runInteractiveCmd({ args, inputs, processOpts, opts, }: {
        args: string[];
        inputs: InteractiveInputs;
        processOpts: Record<string, any>;
        opts: {
            defaultIntervalBetweenInputs: number;
            verbose: boolean;
        };
    }): Promise<string>;
}
