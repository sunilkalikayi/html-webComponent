"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _commentJson() {
  const data = require("comment-json");
  _commentJson = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// TODO: improve this by combine into a base class shared between this and e2e-bit-json-helper
class BitJsoncHelper {
  constructor(scopes) {
    (0, _defineProperty2().default)(this, "scopes", void 0);
    this.scopes = scopes;
  }
  read(bitJsoncDir = this.scopes.localPath) {
    const bitJsoncPath = composePath(bitJsoncDir);
    if (_fsExtra().default.existsSync(bitJsoncPath)) {
      const content = _fsExtra().default.readFileSync(bitJsoncPath).toString();
      return (0, _commentJson().parse)(content);
    }
    return {};
  }
  write(bitJsonc, bitJsoncDir = this.scopes.localPath) {
    const bitJsoncPath = composePath(bitJsoncDir);
    const content = (0, _commentJson().stringify)(bitJsonc, null, 2);
    return _fsExtra().default.writeFileSync(bitJsoncPath, content);
  }
  addKeyVal(key, val, bitJsoncDir = this.scopes.localPath) {
    const bitJsonc = this.read(bitJsoncDir);
    // Using this to keep the comments
    const obj = {
      [key]: val
    };
    const updated = (0, _commentJson().assign)(bitJsonc, obj);
    this.write(updated, bitJsoncDir);
  }
  addToVariant(variant, key, val, replaceExisting = false, bitJsoncDir = this.scopes.localPath) {
    var _variants$variant;
    const bitJsonc = this.read(bitJsoncDir);
    const variants = bitJsonc['teambit.workspace/variants'];
    const newVariant = replaceExisting ? {} : (_variants$variant = variants[variant]) !== null && _variants$variant !== void 0 ? _variants$variant : {};
    (0, _commentJson().assign)(newVariant, {
      [key]: val
    });
    this.setVariant(bitJsoncDir, variant, newVariant);
  }

  /**
   * Replace the entire variant config with the provided config.
   * In case you only want to add new extension to variant you probably want to use addToVariant
   * @param bitJsoncDir
   * @param variant
   * @param config
   */
  setVariant(bitJsoncDir = this.scopes.localPath, variant, config) {
    const bitJsonc = this.read(bitJsoncDir);
    const variants = bitJsonc['teambit.workspace/variants'];
    const newVariant = config;
    (0, _commentJson().assign)(variants, {
      [variant]: newVariant
    });
    this.addKeyVal('teambit.workspace/variants', variants, bitJsoncDir);
  }
  setPolicyToVariant(variant, policy) {
    const config = {
      'teambit.dependencies/dependency-resolver': {
        policy
      }
    };
    this.setVariant(undefined, variant, config);
  }
  addKeyValToWorkspace(key, val, bitJsoncDir = this.scopes.localPath) {
    const bitJsonc = this.read(bitJsoncDir);
    const workspace = bitJsonc['teambit.workspace/workspace'];
    (0, _commentJson().assign)(workspace, {
      [key]: val
    });
    this.addKeyVal('teambit.workspace/workspace', workspace, bitJsoncDir);
  }
  addKeyValToDependencyResolver(key, val, bitJsoncDir = this.scopes.localPath) {
    const bitJsonc = this.read(bitJsoncDir);
    const depResolver = bitJsonc['teambit.dependencies/dependency-resolver'];
    (0, _commentJson().assign)(depResolver, {
      [key]: val
    });
    this.addKeyVal('teambit.dependencies/dependency-resolver', depResolver, bitJsoncDir);
  }
  getPolicyFromDependencyResolver() {
    const bitJsonc = this.read();
    const depResolver = bitJsonc['teambit.dependencies/dependency-resolver'];
    return depResolver.policy;
  }
  addPolicyToDependencyResolver(policy) {
    const currentPolicy = this.getPolicyFromDependencyResolver();
    (0, _commentJson().assign)(currentPolicy, policy);
    this.addKeyValToDependencyResolver('policy', currentPolicy);
  }
  addDefaultScope(scope = this.scopes.remote) {
    this.addKeyValToWorkspace('defaultScope', scope);
  }
  setComponentsDir(compDir) {
    this.addKeyValToWorkspace('defaultDirectory', compDir);
  }
  setPackageManager(packageManager = 'teambit.dependencies/yarn') {
    this.addKeyValToDependencyResolver('packageManager', packageManager);
  }
  addDefaultOwner(owner) {
    this.addKeyValToWorkspace('defaultOwner', owner);
  }
  corrupt() {
    const bitJsoncPath = composePath(this.scopes.localPath);
    _fsExtra().default.writeFileSync(bitJsoncPath, '"corrupted');
  }
  disablePreview() {
    this.addKeyVal('teambit.preview/preview', {
      disabled: true
    });
  }
  setupDefault() {
    this.disablePreview();
    this.addDefaultScope();
  }
}
exports.default = BitJsoncHelper;
function composePath(dir) {
  return path().join(dir, _constants().WORKSPACE_JSONC);
}