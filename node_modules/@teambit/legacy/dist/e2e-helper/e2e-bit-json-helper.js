"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _pathOr2() {
  const data = _interopRequireDefault(require("ramda/src/pathOr"));
  _pathOr2 = function () {
    return data;
  };
  return data;
}
function _path2() {
  const data = _interopRequireDefault(require("ramda/src/path"));
  _path2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = _interopRequireDefault(require("lodash.set"));
  _lodash = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class BitJsonHelper {
  constructor(scopes) {
    (0, _defineProperty2().default)(this, "scopes", void 0);
    this.scopes = scopes;
  }
  read(bitJsonDir = this.scopes.localPath) {
    const bitJsonPath = path().join(bitJsonDir, 'bit.json');
    return _fsExtra().default.existsSync(bitJsonPath) ? _fsExtra().default.readJSONSync(bitJsonPath) : {};
  }
  write(bitJson, bitJsonDir = this.scopes.localPath) {
    const bitJsonPath = path().join(bitJsonDir, 'bit.json');
    return _fsExtra().default.writeJSONSync(bitJsonPath, bitJson, {
      spaces: 2
    });
  }
  addKeyVal(key, val, bitJsonDir = this.scopes.localPath) {
    const bitJson = this.read(bitJsonDir);
    bitJson[key] = val;
    this.write(bitJson, bitJsonDir);
  }
  addOverrides(overrides) {
    const bitJson = this.read();
    bitJson.overrides = overrides;
    this.write(bitJson);
  }
  addDefaultScope(scope = this.scopes.remote) {
    this.addKeyVal('defaultScope', scope);
  }
  getEnvByType(bitJson, envType) {
    const basePath = ['env', envType];
    const env = (0, _path2().default)(basePath, bitJson);
    const envName = Object.keys(env)[0];
    return env[envName];
  }
  addToRawConfigOfEnv(bitJsonPath = this.scopes.localPath, key, val, envType) {
    this._addKeyValToEnvProp(bitJsonPath, 'rawConfig', key, val, envType);
  }
  manageWorkspaces(withWorkspaces = true) {
    const bitJson = this.read();
    bitJson.packageManager = 'yarn';
    bitJson.manageWorkspaces = withWorkspaces;
    bitJson.useWorkspaces = withWorkspaces;
    this.write(bitJson);
  }
  setComponentsDir(content) {
    const bitJson = this.read();
    bitJson.componentsDefaultDirectory = content;
    this.write(bitJson);
  }
  corrupt(bitJsonPath = path().join(this.scopes.localPath, 'bit.json')) {
    _fsExtra().default.writeFileSync(bitJsonPath, '"corrupted');
  }
  modifyField(key, value) {
    const bitJson = this.read();
    bitJson[key] = value;
    this.write(bitJson);
  }
  _getEnvNameByType(bitJson, envType) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const env = bitJson.env[envType];
    const envName = typeof env === 'string' ? env : Object.keys(env)[0];
    return envName;
  }
  _addKeyValToEnvProp(bitJsonDir = this.scopes.localPath, propName, key, val, envType) {
    const bitJson = this.read(bitJsonDir);
    const envName = this._getEnvNameByType(bitJson, envType);
    const propPath = ['env', envType, envName, propName];
    const prop = (0, _pathOr2().default)({}, propPath, bitJson);
    prop[key] = val;
    (0, _lodash().default)(bitJson, propPath, prop);
    this.write(bitJson, bitJsonDir);
  }
}
exports.default = BitJsonHelper;