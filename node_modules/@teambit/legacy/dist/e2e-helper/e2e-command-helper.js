"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chai() {
  const data = require("chai");
  _chai = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _child_process() {
  const data = _interopRequireDefault(require("child_process"));
  _child_process = function () {
    return data;
  };
  return data;
}
function _padRight() {
  const data = _interopRequireDefault(require("pad-right"));
  _padRight = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _tar() {
  const data = _interopRequireDefault(require("tar"));
  _tar = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _featureToggle() {
  const data = require("../api/consumer/lib/feature-toggle");
  _featureToggle = function () {
    return data;
  };
  return data;
}
function _tag() {
  const data = require("../api/consumer/lib/tag");
  _tag = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _runInteractiveCmd() {
  const data = _interopRequireDefault(require("../interactive/utils/run-interactive-cmd"));
  _runInteractiveCmd = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const DEFAULT_DEFAULT_INTERVAL_BETWEEN_INPUTS = 200;
// The default value of maxBuffer is 1024*1024, which is not enough for some of the tests.
// If a command has a lot of output, it will throw this error:
// Error: spawnSync /bin/sh ENOBUFS
const EXEC_SYNC_MAX_BUFFER = 1024 * 1024 * 10; // 10MB

/**
 * to enable a feature for Helper instance, in the e2e-test file add `helper.command.setFeatures('your-feature');`
 * to enable a feature for a single command, add the feature to the runCmd, e.g. `runCmd(cmd, cwd, stdio, 'your-feature');`
 * if you set both, the runCmd wins.
 * more about feature-toggle head to feature-toggle.ts file.
 */
class CommandHelper {
  constructor(scopes, debugMode) {
    (0, _defineProperty2().default)(this, "scopes", void 0);
    (0, _defineProperty2().default)(this, "debugMode", void 0);
    (0, _defineProperty2().default)(this, "bitBin", void 0);
    (0, _defineProperty2().default)(this, "featuresToggle", void 0);
    this.scopes = scopes;
    this.debugMode = debugMode;
    this.bitBin = process.env.npm_config_bit_bin || 'bit'; // e.g. npm run e2e-test --bit_bin=bit-dev
  }

  setFeatures(featuresToggle) {
    this.featuresToggle = featuresToggle;
  }
  resetFeatures() {
    this.featuresToggle = undefined;
  }
  runCmd(cmd, cwd = this.scopes.localPath, stdio = 'pipe', overrideFeatures, getStderrAsPartOfTheOutput = false // needed to get Jest output as they write to the stderr for some reason. see https://github.com/facebook/jest/issues/5064
  ) {
    if (this.debugMode) console.log((0, _padRight().default)(_chalk().default.green('cwd: '), 20, ' '), cwd); // eslint-disable-line no-console
    const isBitCommand = cmd.startsWith('bit ');
    if (isBitCommand) cmd = cmd.replace('bit', this.bitBin);
    const featuresTogglePrefix = isBitCommand ? this._getFeatureToggleCmdPrefix(overrideFeatures) : '';
    const cmdWithFeatures = featuresTogglePrefix + cmd;
    if (this.debugMode) console.log((0, _padRight().default)(_chalk().default.green('command: '), 20, ' '), cmdWithFeatures); // eslint-disable-line no-console
    // `spawnSync` gets the data from stderr, `shell: true` is needed for Windows to get the output.
    const cmdOutput = getStderrAsPartOfTheOutput ? _child_process().default.spawnSync(cmd.split(' ')[0], cmd.split(' ').slice(1), {
      cwd,
      stdio,
      shell: true
    }).output.toString() : _child_process().default.execSync(cmdWithFeatures, {
      cwd,
      stdio,
      maxBuffer: EXEC_SYNC_MAX_BUFFER
    });
    if (this.debugMode) console.log((0, _padRight().default)(_chalk().default.green('output: '), 20, ' '), _chalk().default.cyan(cmdOutput.toString())); // eslint-disable-line no-console
    return cmdOutput.toString();
  }
  _getFeatureToggleCmdPrefix(overrideFeatures) {
    const featuresToggle = overrideFeatures || this.featuresToggle;
    if (!featuresToggle) return '';
    const featuresToggleStr = Array.isArray(featuresToggle) ? featuresToggle.join(',') : featuresToggle;
    const bitFeaturesEnvVar = `${_featureToggle().ENV_VAR_FEATURE_TOGGLE}=${featuresToggleStr}`;
    if (process.platform === 'win32') {
      return `set "${bitFeaturesEnvVar}" && `;
    }
    return `${bitFeaturesEnvVar} `;
  }
  listRemoteScope(raw = true, options = '') {
    return this.runCmd(`bit list ${this.scopes.remote} ${options} ${raw ? '--raw' : ''}`);
  }
  listRemoteScopeIds(options = '') {
    return this.runCmd(`bit list ${this.scopes.remote} ${options} --ids`);
  }
  list(options = '') {
    return this.runCmd(`bit list ${options}`);
  }
  listParsed(options = '') {
    const output = this.runCmd(`bit list --json ${options}`);
    return JSON.parse(output);
  }
  listLocalScope(options = '') {
    return this.runCmd(`bit list --scope ${options}`);
  }
  listLocalScopeParsed(options = '') {
    const output = this.runCmd(`bit list --scope --json ${options}`);
    return JSON.parse(output);
  }
  listRemoteScopeParsed(options = '') {
    const output = this.runCmd(`bit list ${this.scopes.remote} --json ${options}`);
    return JSON.parse(output);
  }
  listScopeParsed(scope, options = '') {
    const output = this.runCmd(`bit list ${scope} --json ${options}`);
    return JSON.parse(output);
  }
  catScope(includeExtraData = false, cwd = this.scopes.localPath) {
    const extraData = includeExtraData ? '--json-extra' : '';
    const result = this.runCmd(`bit cat-scope --json ${extraData}`, cwd);
    return JSON.parse(result);
  }
  catObject(hash, parse = false) {
    const result = this.runCmd(`bit cat-object ${hash}`);
    if (!parse) return result;
    return JSON.parse(result);
  }
  catComponent(id, cwd, parse = true) {
    const result = this.runCmd(`bit cat-component ${id} --json`, cwd);
    return parse ? JSON.parse(result) : result;
  }
  catLane(id, cwd) {
    const result = this.runCmd(`bit cat-lane ${id}`, cwd);
    return JSON.parse(result);
  }
  add(dir, flag = '') {
    return this.runCmd(`bit add ${dir} ${flag}`);
  }
  addComponent(filePaths, options = {}, cwd = this.scopes.localPath) {
    const value = typeof options === 'string' ? options : Object.keys(options).map(key => `-${key} ${options[key]}`).join(' ');
    return this.runCmd(`bit add ${filePaths} ${value}`, cwd);
  }
  addLaneReadme(id, laneName = '') {
    return this.runCmd(`bit lane add-readme ${id} ${laneName}`);
  }
  removeLaneReadme(laneName = '') {
    return this.runCmd(`bit lane remove-readme ${laneName}`);
  }
  sign(ids, flags = '', cwd = this.scopes.localPath) {
    return this.runCmd(`bit sign ${ids.join(' ')} ${flags}`, cwd);
  }
  artifacts(id = '', flags = '') {
    return this.runCmd(`bit artifacts ${id} ${flags}`);
  }
  updateDependencies(data, flags = '', cwd = this.scopes.localPath) {
    return this.runCmd(`bit update-dependencies '${JSON.stringify(data)}' ${flags}`, cwd);
  }
  getConfig(configName) {
    return this.runCmd(`bit config get ${configName}`);
  }
  delConfig(configName) {
    return this.runCmd(`bit config del ${configName}`);
  }
  setConfig(configName, configVal) {
    return this.runCmd(`bit config set ${configName} ${configVal}`);
  }
  setScope(scopeName, component) {
    return this.runCmd(`bit scope set ${scopeName} ${component}`);
  }
  renameScope(oldScope, newScope, flags = '') {
    return this.runCmd(`bit scope rename ${oldScope} ${newScope} ${flags}`);
  }
  setEnv(compId, envId) {
    return this.runCmd(`bit envs set ${compId} ${envId}`);
  }
  unsetEnv(compId) {
    return this.runCmd(`bit envs unset ${compId}`);
  }
  replaceEnv(oldEnv, newEnv) {
    return this.runCmd(`bit envs replace ${oldEnv} ${newEnv}`);
  }
  setAspect(pattern, aspectId, config, flags = '') {
    const configStr = config ? JSON.stringify(JSON.stringify(config)) : '';
    return this.runCmd(`bit aspect set ${pattern} ${aspectId} ${configStr} ${flags}`);
  }
  unsetAspect(pattern, aspectId, flags = '') {
    return this.runCmd(`bit aspect unset ${pattern} ${aspectId} ${flags}`);
  }
  updateAspect(aspectId, pattern = '', flags = '') {
    return this.runCmd(`bit aspect update ${aspectId} ${pattern} ${flags}`);
  }
  removeComponent(id, flags = '') {
    return this.runCmd(`bit remove ${id} --silent ${flags}`);
  }
  deprecateComponent(id, flags = '') {
    return this.runCmd(`bit deprecate ${id} ${flags}`);
  }
  undeprecateComponent(id, flags = '') {
    return this.runCmd(`bit undeprecate ${id} ${flags}`);
  }
  fork(sourceId, values = '') {
    return this.runCmd(`bit fork ${sourceId} ${values}`);
  }
  forkScope(originalScope, newScope) {
    return this.runCmd(`bit scope fork ${originalScope} ${newScope}`);
  }
  rename(sourceId, targetId, flags = '') {
    return this.runCmd(`bit rename ${sourceId} ${targetId} ${flags}`);
  }
  refactorDependencyName(oldId, newId, flags = '') {
    return this.runCmd(`bit refactor dependency-name ${oldId} ${newId} ${flags}`);
  }
  use(aspectId, flags = '') {
    return this.runCmd(`bit use ${aspectId} ${flags}`);
  }
  dependenciesGet(values = '') {
    return this.runCmd(`bit dependencies get ${values}`);
  }
  dependenciesSet(pattern, pkg, flags = '') {
    return this.runCmd(`bit dependencies set ${pattern} ${pkg} ${flags}`);
  }
  dependenciesRemove(pattern, pkg, flags = '') {
    return this.runCmd(`bit dependencies remove ${pattern} ${pkg} ${flags}`);
  }
  tagComponent(id, tagMsg = 'tag-message', options = '') {
    return this.runCmd(`bit tag ${id} -m ${tagMsg} ${options} --build`);
  }
  tagWithoutMessage(id, version = '', options = '') {
    const ver = version ? `--ver ${version}` : '';
    return this.runCmd(`bit tag ${id} ${ver} ${options} --build`);
  }
  tagAllComponents(options = '', version = '', assertTagged = true) {
    const ver = version ? `--ver ${version}` : '';
    const result = this.runCmd(`bit tag ${ver} ${options} --build`);
    if (assertTagged) (0, _chai().expect)(result).to.not.have.string(_tag().NOTHING_TO_TAG_MSG);
    return result;
  }
  tagAllWithoutBuild(options = '') {
    const result = this.runCmd(`bit tag ${options}`, undefined, undefined, _featureToggle().BUILD_ON_CI);
    (0, _chai().expect)(result).to.not.have.string(_tag().NOTHING_TO_TAG_MSG);
    return result;
  }
  tagWithoutBuild(id = '', options = '') {
    const result = this.runCmd(`bit tag ${id} ${options}`, undefined, undefined, _featureToggle().BUILD_ON_CI);
    (0, _chai().expect)(result).to.not.have.string(_tag().NOTHING_TO_TAG_MSG);
    return result;
  }
  rewireAndTagAllComponents(options = '', version = '', assertTagged = true) {
    this.linkAndRewire();
    return this.tagAllComponents(options, version, assertTagged);
  }
  tagIncludeUnmodified(version = '', message = 'tag-message', options = '') {
    const ver = version ? `--ver ${version}` : '';
    return this.runCmd(`bit tag --unmodified ${ver} -m ${message} ${options} --build`);
  }
  tagIncludeUnmodifiedWithoutBuild(version = '', options = '') {
    const ver = version ? `--ver ${version}` : '';
    return this.runCmd(`bit tag --unmodified ${ver} ${options}`, undefined, undefined, _featureToggle().BUILD_ON_CI);
  }
  softTag(options = '') {
    return this.runCmd(`bit tag --soft ${options}`);
  }
  persistTag(options = '') {
    return this.runCmd(`bit tag --persist ${options}`);
  }
  persistTagWithoutBuild(options = '') {
    return this.runCmd(`bit tag --persist ${options}`, undefined, undefined, _featureToggle().BUILD_ON_CI);
  }
  snapComponent(id, tagMsg = 'snap-message', options = '') {
    return this.runCmd(`bit snap ${id} -m ${tagMsg} ${options}`);
  }
  snapComponentWithoutBuild(id, options = '') {
    return this.runCmd(`bit snap ${id} ${options}`, undefined, undefined, _featureToggle().BUILD_ON_CI);
  }
  snapAllComponents(options = '', assertSnapped = true) {
    const result = this.runCmd(`bit snap -a ${options} `);
    if (assertSnapped) (0, _chai().expect)(result).to.not.have.string(_constants().NOTHING_TO_SNAP_MSG);
    return result;
  }
  snapAllComponentsWithoutBuild(options = '', assertSnapped = true) {
    const result = this.runCmd(`bit snap -a ${options} `, undefined, undefined, _featureToggle().BUILD_ON_CI);
    if (assertSnapped) (0, _chai().expect)(result).to.not.have.string(_constants().NOTHING_TO_SNAP_MSG);
    return result;
  }
  createLane(laneName = 'dev', options = '') {
    return this.runCmd(`bit lane create ${laneName} ${options}`);
  }
  changeLaneScope(laneName, newScope) {
    return this.runCmd(`bit lane change-scope ${laneName} ${newScope}`);
  }
  clearCache() {
    return this.runCmd('bit clear-cache');
  }
  removeLane(laneName = 'dev', options = '') {
    return this.runCmd(`bit lane remove ${laneName} ${options} --silent`);
  }
  removeRemoteLane(laneName = 'dev', options = '') {
    return this.runCmd(`bit lane remove ${this.scopes.remote}/${laneName} ${options} --remote --silent`);
  }
  writeTsconfig(flags = '') {
    return this.runCmd(`bit write-tsconfig ${flags} --silent`);
  }
  writeTsconfigDryRun(flags = '') {
    const results = this.runCmd(`bit write-tsconfig  --dry-run ${flags} --json`);
    return JSON.parse(results);
  }
  showOneLane(name) {
    return this.runCmd(`bit lane show ${name}`);
  }
  showOneLaneParsed(name) {
    const results = this.runCmd(`bit lane show ${name} --json`);
    const parsed = JSON.parse(results);
    return parsed;
  }
  listLanes(options = '') {
    const results = this.runCmd(`bit lane list ${options}`);
    return (0, _utils().removeChalkCharacters)(results);
  }
  listLanesParsed(options = '') {
    const results = this.runCmd(`bit lane list ${options} --json`);
    return JSON.parse(results);
  }
  expectCurrentLaneToBe(laneName) {
    const lanes = this.listLanesParsed();
    (0, _chai().expect)(lanes.currentLane).to.equal(laneName);
  }
  listRemoteLanesParsed(options = '') {
    const results = this.runCmd(`bit lane list --remote ${this.scopes.remote} ${options} --json`);
    return JSON.parse(results);
  }
  diffLane(args = '', onScope = false) {
    const cwd = onScope ? this.scopes.remotePath : this.scopes.localPath;
    const output = this.runCmd(`bit lane diff ${args}`, cwd);
    return (0, _utils().removeChalkCharacters)(output);
  }
  getHead(id, cwd) {
    const comp = this.catComponent(id, cwd);
    return comp.head;
  }
  getHeadShort(id, cwd) {
    const comp = this.catComponent(id, cwd);
    return comp.head.substring(0, 9);
  }
  getHeadOfLane(laneName, componentName, cwd = this.scopes.localPath) {
    const lane = this.catLane(laneName, cwd);
    const component = lane.components.find(c => c.id.name === componentName);
    return component.head;
  }
  getArtifacts(id) {
    const comp = this.catComponent(`${id}@latest`);
    const builderExt = comp.extensions.find(ext => ext.name === 'teambit.pipelines/builder');
    if (!builderExt) throw new Error(`unable to find builder data for ${id}`);
    const artifacts = builderExt.data.artifacts;
    if (!artifacts) throw new Error(`unable to find artifacts data for ${id}`);
    return artifacts;
  }
  untag(id, head = false, flag = '') {
    return this.runCmd(`bit reset ${id} ${head ? '--head' : ''} ${flag}`);
  }
  untagAll(options = '') {
    return this.runCmd(`bit reset ${options} --all`);
  }
  untagSoft(id) {
    return this.runCmd(`bit reset ${id} --soft`);
  }
  exportIds(ids, flags = '', assert = true) {
    const result = this.runCmd(`bit export ${ids} ${flags}`);
    if (assert) (0, _chai().expect)(result).to.not.have.string('nothing to export');
    return result;
  }
  exportLane(assert = true) {
    const result = this.export();
    if (assert) (0, _chai().expect)(result).to.not.have.string('nothing to export');
    return result;
  }
  export(options = '') {
    return this.runCmd(`bit export ${options}`);
  }
  resumeExport(exportId, remotes) {
    return this.runCmd(`bit resume-export ${exportId} ${remotes.join(' ')}`);
  }
  ejectComponents(ids, flags) {
    return this.runCmd(`bit eject ${ids} ${flags || ''}`);
  }
  ejectComponentsParsed(ids, flags) {
    const result = this.runCmd(`bit eject ${ids} ${flags || ''} --json`);
    const jsonStart = result.indexOf('{');
    const jsonResult = result.substring(jsonStart);
    return JSON.parse(jsonResult);
  }
  importComponent(id, flags = '') {
    return this.runCmd(`bit import ${this.scopes.remote}/${id} ${flags}`);
  }
  import(value = '') {
    return this.runCmd(`bit import ${value}`);
  }
  importLane(laneName, flags = '') {
    return this.runCmd(`bit lane import ${this.scopes.remote}/${laneName} ${flags}`);
  }
  fetchLane(id) {
    return this.runCmd(`bit fetch ${id} --lanes`);
  }
  fetchRemoteLane(id) {
    return this.runCmd(`bit fetch ${this.scopes.remote}${_laneId().LANE_REMOTE_DELIMITER}${id} --lanes`);
  }
  fetchAllLanes() {
    return this.runCmd(`bit fetch --lanes`);
  }
  fetchAllComponents() {
    return this.runCmd(`bit fetch --components`);
  }
  renameLane(oldName, newName) {
    return this.runCmd(`bit lane rename ${oldName} ${newName}`);
  }
  importManyComponents(ids) {
    const idsWithRemote = ids.map(id => `${this.scopes.remote}/${id}`);
    return this.runCmd(`bit import ${idsWithRemote.join(' ')}`);
  }
  importComponentWithOptions(id = 'bar/foo.js', options) {
    const value = Object.keys(options).map(key => `-${key} ${options[key]}`).join(' ');
    return this.runCmd(`bit import ${this.scopes.remote}/${id} ${value}`);
  }
  importAllComponents(writeToFileSystem = false) {
    return this.runCmd(`bit import ${writeToFileSystem ? '--merge' : ''}`);
  }

  /**
   * returns the capsule dir in case there is --json flag
   */
  createCapsuleHarmony(id, options) {
    const parsedOpts = this.parseOptions(options);
    const output = this.runCmd(`bit capsule create ${id} ${parsedOpts}`);
    if (options !== null && options !== void 0 && options.json || options !== null && options !== void 0 && options.j) {
      const capsules = JSON.parse(output);
      const capsule = capsules.find(c => c.id.includes(id));
      if (!capsule) throw new Error(`createCapsuleHarmony unable to find capsule for ${id}, inside ${capsules.map(c => c.id).join(', ')}`);
      return capsule.path;
    }
    return output;
  }
  capsuleListParsed() {
    const capsulesJson = this.runCmd('bit capsule list -j');
    return JSON.parse(capsulesJson);
  }
  getCapsuleOfComponent(id) {
    const capsules = this.capsuleListParsed();
    const idWithUnderScore = id.replace(/\//, '_');
    const capsulePath = capsules.capsules.find(c => c.endsWith(idWithUnderScore));
    if (!capsulePath) throw new Error(`unable to find the capsule for ${id}`);
    return capsulePath;
  }
  importExtension(id) {
    return this.runCmd(`bit import ${id} --extension`);
  }
  build(id = '', flags = '', getStderrAsPartOfTheOutput = false) {
    return this.runCmd(`bit build ${id} ${flags}`, undefined, undefined, undefined, getStderrAsPartOfTheOutput);
  }
  test(flags = '', getStderrAsPartOfTheOutput = false) {
    return this.runCmd(`bit test ${flags}`, undefined, undefined, undefined, getStderrAsPartOfTheOutput);
  }
  testComponent(id = '', flags = '') {
    return this.runCmd(`bit test ${id} ${flags}`);
  }
  testAllWithJunit() {
    return this.testComponent(undefined, '--junit junit.xml');
  }
  status(flags = '') {
    return this.runCmd(`bit status ${flags}`);
  }
  statusJson(cwd = this.scopes.localPath) {
    const status = this.runCmd('bit status --json', cwd);
    return JSON.parse(status);
  }
  isDeprecated(compName) {
    const deprecationData = this.showAspectConfig(compName, _constants().Extensions.deprecation);
    return deprecationData.config.deprecate;
  }
  getStagedIdsFromStatus(stripScopeName = true) {
    const status = this.statusJson();
    return status.stagedComponents.map(s => s.id).map(id => stripScopeName ? id.replace(`${this.scopes.remote}/`, '') : id);
  }
  expectStatusToBeClean(exclude = []) {
    const statusJson = this.statusJson();
    Object.keys(statusJson).forEach(key => {
      if (exclude.includes(key)) return;
      if (key === 'currentLaneId' || key === 'forkedLaneId') return;
      (0, _chai().expect)(statusJson[key], `status.${key} should be empty`).to.have.lengthOf(0);
    });
  }
  expectStatusToHaveIssue(issueName) {
    const allIssues = this.getAllIssuesFromStatus();
    (0, _chai().expect)(allIssues).to.include(issueName);
  }
  expectStatusToNotHaveIssue(issueName) {
    const allIssues = this.getAllIssuesFromStatus();
    (0, _chai().expect)(allIssues).to.not.include(issueName);
  }
  getAllIssuesFromStatus() {
    const statusJson = this.statusJson();
    return statusJson.componentsWithIssues.map(comp => comp.issues.map(issue => issue.type)).flat();
  }
  expectStatusToNotHaveIssues(cwd = this.scopes.localPath) {
    const statusJson = this.statusJson(cwd);
    ['componentsWithIssues', 'invalidComponents'].forEach(key => {
      (0, _chai().expect)(statusJson[key], `status.${key} should be empty`).to.have.lengthOf(0);
    });
  }
  statusComponentIsModified(fullIdWithVersion) {
    const status = this.statusJson();
    return status.modifiedComponents.includes(fullIdWithVersion);
  }
  statusComponentIsStaged(id) {
    const status = this.statusJson();
    const stagedIds = status.stagedComponents.map(s => s.id);
    return stagedIds.includes(id);
  }
  statusComponentHasIssues(id) {
    const status = this.statusJson();
    return status.componentsWithIssues.includes(`${this.scopes.remote}/${id}`);
  }
  showComponent(id = 'bar/foo') {
    return this.runCmd(`bit show ${id}`);
  }
  showComponentParsed(id = 'bar/foo') {
    const output = this.runCmd(`bit show ${id} --json --legacy`);
    return JSON.parse(output);
  }
  showComponentParsedHarmony(id = 'bar/foo') {
    const output = this.runCmd(`bit show ${id} --json`);
    return JSON.parse(output);
  }
  showAspectConfig(compId, aspectId) {
    const show = this.showComponentParsedHarmony(compId);
    return show.find(_ => _.title === 'configuration').json.find(_ => _.id === aspectId);
  }
  getComponentFiles(id) {
    const output = this.runCmd(`bit show ${id} --json`);
    const comp = JSON.parse(output);
    return comp.find(c => c.title === 'files').json;
  }
  showComponentWithOptions(id = 'bar/foo', options) {
    const value = Object.keys(options).map(key => `-${key} ${options[key]}`).join(' ');
    return this.runCmd(`bit show ${id} ${value}`);
  }
  checkoutVersion(version, ids, flags, cwd) {
    return this.runCmd(`bit checkout ${version} ${ids} ${flags || ''}`, cwd);
  }
  checkout(values) {
    return this.runCmd(`bit checkout ${values}`);
  }
  checkoutHead(values = '') {
    return this.runCmd(`bit checkout head ${values}`);
  }
  checkoutReset(values = '') {
    return this.runCmd(`bit checkout reset ${values}`);
  }
  switchLocalLane(lane, flags) {
    return this.runCmd(`bit switch ${lane} ${flags || ''}`);
  }
  switchRemoteLane(lane, flags, getAll = true) {
    const getAllFlag = getAll ? '--get-all' : '';
    return this.runCmd(`bit switch ${this.scopes.remote}/${lane} ${getAllFlag} ${flags || ''}`);
  }
  mergeVersion(version, ids, flags) {
    return this.runCmd(`bit merge ${version} ${ids} ${flags || ''}`);
  }
  merge(values) {
    return this.runCmd(`bit merge ${values}`);
  }
  mergeLane(laneName, options = '') {
    return this.runCmd(`bit lane merge ${laneName} ${options}`);
  }
  mergeLaneFromScope(cwd, laneName, options = '') {
    return this.runCmd(`bit _merge-lane ${laneName} ${options}`, cwd);
  }
  tagFromScope(cwd, ids, options = '') {
    return this.runCmd(`bit _tag ${ids} ${options} -m msg`, cwd);
  }
  diff(id = '') {
    const output = this.runCmd(`bit diff ${id}`);
    return (0, _utils().removeChalkCharacters)(output);
  }
  log(id, flags = '') {
    return this.runCmd(`bit log ${id} ${flags}`);
  }
  logParsed(id, flags = '') {
    const log = this.runCmd(`bit log ${id} ${flags} --json`);
    return JSON.parse(log);
  }
  move(from, to) {
    return this.runCmd(`bit move ${path().normalize(from)} ${path().normalize(to)}`);
  }
  runTask(taskName) {
    return this.runCmd(`bit run ${taskName}`);
  }
  create(templateName, componentName, flags = '', cwd = this.scopes.localPath) {
    return this.runCmd(`bit create ${templateName} ${componentName} ${flags}`, cwd);
  }
  new(templateName, flags = '', workspaceName = 'my-workspace', cwd = this.scopes.localPath) {
    return this.runCmd(`bit new ${templateName} ${workspaceName} ${flags}`, cwd);
  }
  runApp(name) {
    return this.runCmd(`bit app run ${name}`);
  }
  link(flags) {
    return this.runCmd(`bit link ${flags || ''}`);
  }
  install(packages = '', options, cwd = this.scopes.localPath) {
    const parsedOpts = this.parseOptions(options);
    return this.runCmd(`bit install ${packages} ${parsedOpts}`, cwd);
  }
  update(flags) {
    return this.runCmd(`bit update ${flags || ''}`);
  }
  uninstall(flags) {
    return this.runCmd(`bit uninstall ${flags || ''}`);
  }
  linkAndRewire(ids = '') {
    return this.runCmd(`bit link ${ids} --rewire`);
  }
  linkAndCompile(linkFlags, compileId, compileFlags) {
    this.link(linkFlags);
    return this.compile(compileId, compileFlags);
  }
  packComponent(id, options, extract = false) {
    const defaultOptions = {
      o: '',
      p: '',
      k: '',
      j: ''
    };
    options = _objectSpread(_objectSpread({}, defaultOptions), options);
    const value = Object.keys(options).map(key => `-${key} ${options[key]}`).join(' ');
    const result = this.runCmd(`bit pack ${id} ${value}`);
    if (extract) {
      if (!options ||
      // We don't just check that it's falsy because usually it's an empty string.
      // eslint-disable-next-line no-prototype-builtins
      !options.hasOwnProperty('-json') && !options.hasOwnProperty('j') || !options['-out-dir'] && !options.d) {
        throw new Error('extracting supporting only when packing with json and out-dir');
      }
      let resultParsed;
      try {
        resultParsed = JSON.parse(result);
      } catch (e) {
        // TODO: this is a temp hack to remove the pnpm install line which looks something like
        // ...5c35e2f15af94460bf455f4c4e82b67991042 | Progress: resolved 19, reused 18, downloaded 0, added 0, doned 0
        // it should be resolved by controlling the pnpm output correctly and don't print it in json mode
        const firstCBracket = result.indexOf('{');
        const newResult = result.substring(firstCBracket);
        resultParsed = JSON.parse(newResult);
      }
      if (!resultParsed || !resultParsed.metadata.tarPath) {
        throw new Error('npm pack results are invalid');
      }
      const tarballFilePath = resultParsed.metadata.tarPath;
      // const dir = options.d || options['-out-dir'];
      const dir = path().dirname(tarballFilePath);
      if (this.debugMode) {
        console.log(`untaring the file ${tarballFilePath} into ${dir}`); // eslint-disable-line no-console
      }

      _tar().default.x({
        file: tarballFilePath,
        C: dir,
        sync: true
      });
    }
    return result;
  }
  publish(id, flags = '') {
    return this.runCmd(`bit publish ${id} ${flags}`);
  }
  ejectConf(id = 'bar/foo', options) {
    const parsedOpts = this.parseOptions(options);
    return this.runCmd(`bit eject-conf ${id} ${parsedOpts}`);
  }
  runAction(actionName, remote, options) {
    return this.runCmd(`bit run-action ${actionName} ${remote} '${JSON.stringify(options)}'`);
  }
  compile(id = '', options) {
    const parsedOpts = this.parseOptions(options);
    return this.runCmd(`bit compile ${id} ${parsedOpts}`);
  }
  doctor(options) {
    const parsedOpts = this.parseOptions(options);
    return this.runCmd(`bit doctor ${parsedOpts}`);
  }
  doctorOne(diagnosisName, options, cwd) {
    const parsedOpts = this.parseOptions(options);
    return this.runCmd(`bit doctor "${diagnosisName}" ${parsedOpts}`, cwd);
  }
  doctorList(options) {
    const parsedOpts = this.parseOptions(options);
    return this.runCmd(`bit doctor --list ${parsedOpts}`);
  }
  doctorJsonParsed() {
    const result = this.runCmd('bit doctor --json');
    return JSON.parse(result);
  }
  parseOptions(options) {
    if (!options) return ' ';
    const value = Object.keys(options).map(key => {
      const keyStr = key.length === 1 ? `-${key}` : `--${key}`;
      return `${keyStr} ${options[key]}`;
    }).join(' ');
    return value;
  }
  init(options = '') {
    return this.runCmd(`bit init ${options}`);
  }
  async runInteractiveCmd({
    args = [],
    inputs = [],
    // Options for the process (execa)
    processOpts = {
      cwd: this.scopes.localPath
    },
    // opts for interactive
    opts = {
      defaultIntervalBetweenInputs: DEFAULT_DEFAULT_INTERVAL_BETWEEN_INPUTS,
      verbose: false
    }
  }) {
    const processName = this.bitBin || 'bit';
    opts.verbose = !!this.debugMode;
    const {
      stdout
    } = await (0, _runInteractiveCmd().default)({
      processName,
      args,
      inputs,
      processOpts,
      opts
    });
    if (this.debugMode) {
      console.log((0, _padRight().default)(_chalk().default.green('output: \n'), 20, ' ')); // eslint-disable-line no-console
      console.log(_chalk().default.cyan(stdout)); // eslint-disable-line no-console
    }

    return stdout;
  }
}
exports.default = CommandHelper;