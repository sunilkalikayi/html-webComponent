"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _glob() {
  const data = _interopRequireDefault(require("glob"));
  _glob = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _componentsList() {
  const data = _interopRequireDefault(require("../consumer/component/components-list"));
  _componentsList = function () {
    return data;
  };
  return data;
}
function _packageJsonFile() {
  const data = _interopRequireDefault(require("../consumer/component/package-json-file"));
  _packageJsonFile = function () {
    return data;
  };
  return data;
}
function _packageJsonTransformer() {
  const data = require("../consumer/component/package-json-transformer");
  _packageJsonTransformer = function () {
    return data;
  };
  return data;
}
function _dataToPersist() {
  const data = _interopRequireDefault(require("../consumer/component/sources/data-to-persist"));
  _dataToPersist = function () {
    return data;
  };
  return data;
}
function _removePath() {
  const data = _interopRequireDefault(require("../consumer/component/sources/remove-path"));
  _removePath = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _componentNodeModulesPath() {
  const data = _interopRequireDefault(require("../utils/bit/component-node-modules-path"));
  _componentNodeModulesPath = function () {
    return data;
  };
  return data;
}
function _symlink() {
  const data = _interopRequireDefault(require("./symlink"));
  _symlink = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * link given components to node_modules, so it's possible to use absolute link instead of relative
 * for example, require('@bit/remote-scope.bar.foo)
 */
class NodeModuleLinker {
  // preparation for the capsule, which is going to have only BitMap with no Consumer

  constructor(components, consumer, bitMap) {
    (0, _defineProperty2().default)(this, "components", void 0);
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "bitMap", void 0);
    (0, _defineProperty2().default)(this, "dataToPersist", void 0);
    this.components = _componentsList().default.getUniqueComponents(components);
    this.consumer = consumer;
    this.bitMap = bitMap;
    this.dataToPersist = new (_dataToPersist().default)();
  }
  async link() {
    var _this$consumer;
    const links = await this.getLinks();
    const linksResults = this.getLinksResults();
    if (this.consumer) links.addBasePath(this.consumer.getPath());
    await links.persistAllToFS();
    await ((_this$consumer = this.consumer) === null || _this$consumer === void 0 ? void 0 : _this$consumer.componentFsCache.deleteAllDependenciesDataCache());
    return linksResults;
  }
  async getLinks() {
    this.dataToPersist = new (_dataToPersist().default)();
    await this._populateShouldDependenciesSavedAsComponentsData();
    // don't use Promise.all because down the road it calls transformPackageJson of pkg aspect, which loads components
    await (0, _pMapSeries().default)(this.components, component => {
      const componentId = component.id.toString();
      _logger().default.debug(`linking component to node_modules: ${componentId}`);
      const componentMap = this.bitMap.getComponent(component.id);
      component.componentMap = componentMap;
      return this._populateAuthoredComponentsLinks(component);
    });
    return this.dataToPersist;
  }
  getLinksResults() {
    const linksResults = [];
    const getExistingLinkResult = id => linksResults.find(linkResult => linkResult.id.isEqual(id));
    const addLinkResult = (id, from, to) => {
      if (!id) return;
      const existingLinkResult = getExistingLinkResult(id);
      if (existingLinkResult) {
        existingLinkResult.bound.push({
          from,
          to
        });
      } else {
        linksResults.push({
          id,
          bound: [{
            from,
            to
          }]
        });
      }
    };
    this.dataToPersist.symlinks.forEach(symlink => {
      addLinkResult(symlink.componentId, symlink.src, symlink.dest);
    });
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    this.dataToPersist.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      addLinkResult(file.componentId, file.srcPath, file.path);
    });
    this.components.forEach(component => {
      const existingLinkResult = getExistingLinkResult(component.id);
      if (!existingLinkResult) {
        linksResults.push({
          id: component.id,
          bound: []
        });
      }
    });
    return linksResults;
  }
  _getDefaultScope(component) {
    if (component) {
      return component.defaultScope;
    }
    return this.consumer ? this.consumer.config.defaultScope : null;
  }

  /**
   * even when an authored component has rootDir, we can't just symlink that rootDir to
   * node_modules/rootDir. it could work only when the main-file is index.js, not for other cases.
   * node expects the module inside node_modules to have either package.json with valid "main"
   * property or an index.js file. this main property can't be relative.
   */
  async _populateAuthoredComponentsLinks(component) {
    const componentId = component.id;
    const linkPath = (0, _componentNodeModulesPath().default)({
      bindingPrefix: component.bindingPrefix,
      id: componentId,
      allowNonScope: true,
      defaultScope: this._getDefaultScope(component),
      extensions: component.extensions
    });
    this.symlinkDirAuthorHarmony(component, linkPath);
    this._deleteExistingLinksRootIfSymlink(linkPath);
    await this._createPackageJsonForAuthor(component);
  }

  /**
   * on Harmony, just symlink the entire source directory into "src" in node-modules.
   */
  symlinkDirAuthorHarmony(component, linkPath) {
    const componentMap = component.componentMap;
    const filesToBind = componentMap.getAllFilesPaths();
    filesToBind.forEach(file => {
      const fileWithRootDir = path().join(componentMap.rootDir, file);
      const dest = path().join(linkPath, file);
      this.dataToPersist.addSymlink(_symlink().default.makeInstance(fileWithRootDir, dest, component.id, true));
    });
    if (_constants().IS_WINDOWS) {
      this.dataToPersist.addSymlink(_symlink().default.makeInstance(componentMap.rootDir, path().join(linkPath, _constants().SOURCE_DIR_SYMLINK_TO_NM), component.id));
    }
  }

  /**
   * Removing existing links root (the package path) - to handle cases it was linked by package manager for example
   * this makes sure we are not affecting other places (like package manager cache) we shouldn't touch
   * If you have a case when this deletes something created by the package manager and it's not the desired behavior,
   * do not delete this code, but make sure the package manger nest the installed version into it's dependent
   * @param component
   */
  _deleteExistingLinksRootIfSymlink(linkPath) {
    try {
      const stat = _fsExtra().default.lstatSync(linkPath);
      if (stat.isSymbolicLink()) {
        this.dataToPersist.removePath(new (_removePath().default)(linkPath));
      }
      return undefined;
    } catch (err) {
      return undefined; // probably file does not exist
    }
  }

  /**
   * When the dists is outside the components directory, it doesn't have access to the node_modules of the component's
   * root-dir. The solution is to go through the node_modules packages one by one and symlink them.
   */
  _getSymlinkPackages(from, to, component) {
    if (!this.consumer) throw new Error('getSymlinkPackages expects the Consumer to be defined');
    const dependenciesSavedAsComponents = component.dependenciesSavedAsComponents;
    const fromNodeModules = path().join(from, 'node_modules');
    const toNodeModules = path().join(to, 'node_modules');
    _logger().default.debug(`symlinkPackages for dists outside the component directory from ${fromNodeModules} to ${toNodeModules}`);
    const unfilteredDirs = _glob().default.sync('*', {
      cwd: fromNodeModules
    });
    // when dependenciesSavedAsComponents the node_modules/@bit has real link files, we don't want to touch them
    // otherwise, node_modules/@bit has packages as any other directory in node_modules
    const dirsToFilter = dependenciesSavedAsComponents ? [this.consumer.config._bindingPrefix] : [];
    const customResolvedData = component.dependencies.getCustomResolvedData();
    if (!(0, _isEmpty2().default)(customResolvedData)) {
      // filter out packages that are actually symlinks to dependencies
      Object.keys(customResolvedData).forEach(importSource => dirsToFilter.push((0, _utils().first)(importSource.split('/'))));
    }
    const dirs = dirsToFilter.length ? unfilteredDirs.filter(dir => !dirsToFilter.includes(dir)) : unfilteredDirs;
    if (!dirs.length) return [];
    return dirs.map(dir => {
      const fromDir = path().join(fromNodeModules, dir);
      const toDir = path().join(toNodeModules, dir);
      return _symlink().default.makeInstance(fromDir, toDir);
    });
  }
  _getDependencyLink(parentRootDir, bitId, rootDir, bindingPrefix, component) {
    const relativeDestPath = (0, _componentNodeModulesPath().default)(_objectSpread(_objectSpread({}, component), {}, {
      id: bitId,
      allowNonScope: true,
      bindingPrefix,
      isDependency: true
    }));
    const destPathInsideParent = path().join(parentRootDir, relativeDestPath);
    return _symlink().default.makeInstance(rootDir, destPathInsideParent, bitId);
  }

  /**
   * create package.json on node_modules/@bit/component-name/package.json with a property 'main'
   * pointing to the component's main file.
   * It is needed for Authored components only.
   * Since an authored component doesn't have rootDir, it's impossible to symlink to the component directory.
   * It makes it easier for Author to use absolute syntax between their own components.
   */
  async _createPackageJsonForAuthor(component) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const hasPackageJsonAsComponentFile = component.files.some(file => file.relative === _constants().PACKAGE_JSON);
    if (hasPackageJsonAsComponentFile) return; // don't generate package.json on top of the user package.json
    const dest = path().join((0, _componentNodeModulesPath().default)(_objectSpread(_objectSpread({}, component), {}, {
      id: component.id,
      allowNonScope: true
    })));
    const packageJson = _packageJsonFile().default.createFromComponent(dest, component, true, true);
    await this._applyTransformers(component, packageJson);
    if (_constants().IS_WINDOWS) {
      // in the workspace, override the "types" and add the "src" prefix.
      // otherwise, the navigation and auto-complete won't work on the IDE.
      // this is for Windows only. For Linux, we use symlinks for the files.
      packageJson.addOrUpdateProperty('types', `${_constants().SOURCE_DIR_SYMLINK_TO_NM}/${component.mainFile}`);
    }
    if (packageJson.packageJsonObject.version === 'latest') {
      packageJson.packageJsonObject.version = '0.0.1-new';
    }

    // packageJson.mergePropsFromExtensions(component);
    // TODO: we need to have an hook here to get the transformer from the pkg extension

    // delete the version, otherwise, we have to maintains it. such as, when tagging, it should be
    // changed to the new tagged version.
    delete packageJson.packageJsonObject.version;
    this.dataToPersist.addFile(packageJson.toVinylFile());
  }

  /**
   * links are normally generated by `bit import`, `bit link` and `bit install`.
   * for `bit import` the data about whether dependenciesSavedAsComponents is already populated
   * for the rest, it's not.
   * @todo: avoid repopulating for imported. (not easy because by default, all components get "true").
   */
  async _populateShouldDependenciesSavedAsComponentsData() {
    if (!this.components.length || !this.consumer) return;
    const bitIds = this.components.map(c => c.id);
    const shouldDependenciesSavedAsComponents = await this.consumer.shouldDependenciesSavedAsComponents(bitIds);
    this.components.forEach(component => {
      const shouldSavedAsComponents = shouldDependenciesSavedAsComponents.find(c => c.id.isEqual(component.id));
      if (!shouldSavedAsComponents) {
        throw new Error(`_populateShouldDependenciesSavedAsComponentsData, saveDependenciesAsComponents is missing for ${component.id.toString()}`);
      }
      component.dependenciesSavedAsComponents = shouldSavedAsComponents.saveDependenciesAsComponents;
    });
  }

  /**
   * these are changes made by aspects
   */
  async _applyTransformers(component, packageJson) {
    return _packageJsonTransformer().PackageJsonTransformer.applyTransformers(component, packageJson);
  }
}
exports.default = NodeModuleLinker;