"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _showDoctorError() {
  const data = _interopRequireDefault(require("../error/show-doctor-error"));
  _showDoctorError = function () {
    return data;
  };
  return data;
}
function _createSymlinkOrCopy() {
  const data = _interopRequireDefault(require("../utils/fs/create-symlink-or-copy"));
  _createSymlinkOrCopy = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class Symlink {
  // current existing path
  // new symlink path

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  constructor(src, dest, componentId, forDistOutsideComponentsDir = false, avoidHardLink = false) {
    this.avoidHardLink = avoidHardLink;
    (0, _defineProperty2().default)(this, "src", void 0);
    (0, _defineProperty2().default)(this, "dest", void 0);
    (0, _defineProperty2().default)(this, "componentId", void 0);
    (0, _defineProperty2().default)(this, "forDistOutsideComponentsDir", void 0);
    this.src = src;
    this.dest = dest;
    this.componentId = componentId;
    this.forDistOutsideComponentsDir = forDistOutsideComponentsDir;
  }
  write() {
    this._throwForMissingDistOutsideComponent();
    return (0, _createSymlinkOrCopy().default)(this.src, this.dest, this.componentId ? this.componentId.toString() : null, this.avoidHardLink);
  }

  /**
   * @deprecated use write() instead, it was fixed to use the native fs.symlinkSync for non-windows
   */
  writeWithNativeFS() {
    const dest = this.dest;
    this._throwForMissingDistOutsideComponent();
    // TODO: change to fs.lstatSync(dest, {throwIfNoEntry: false});
    // TODO: this requires to upgrade node to v15.3.0 to have the throwIfNoEntry property (maybe upgrade fs-extra will work as well)
    // TODO: we don't use fs.pathExistsSync since it will return false in case the dest is a symlink which will result error on write
    // const exists = fs.pathExistsSync(dest);
    let exists;
    try {
      exists = _fsExtra().default.lstatSync(dest);
      // eslint-disable-next-line no-empty
    } catch (e) {}
    if (exists) {
      _fsExtra().default.removeSync(dest);
    }
    const dir = path().dirname(dest);
    _fsExtra().default.ensureDirSync(dir);
    return _fsExtra().default.symlinkSync(this.src, dest);
  }
  static makeInstance(src, dest, componentId, avoidHardLink) {
    return new Symlink(src, dest, componentId, undefined, avoidHardLink);
  }
  _throwForMissingDistOutsideComponent() {
    if (!this.forDistOutsideComponentsDir) return;
    const srcExists = _fsExtra().default.existsSync(this.src);
    if (!srcExists) {
      const componentId = this.componentId ? this.componentId.toString() : '';
      throw new (_showDoctorError().default)(`unable to link ${componentId}, the file ${this.src} is missing from the filesystem.
it happens when the "dist" directory is set to be outside the components directory, either by changing this settings later or by cloning the project without the dist directory
to rebuild the "dist" directory for all components, please run "bit import --merge".`);
    }
  }
}
exports.default = Symlink;