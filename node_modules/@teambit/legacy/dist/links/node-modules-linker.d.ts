import { BitId } from '../bit-id';
import BitMap from '../consumer/bit-map/bit-map';
import Component from '../consumer/component/consumer-component';
import PackageJsonFile from '../consumer/component/package-json-file';
import DataToPersist from '../consumer/component/sources/data-to-persist';
import Consumer from '../consumer/consumer';
import { PathOsBasedRelative } from '../utils/path';
import Symlink from './symlink';
declare type LinkDetail = {
    from: string;
    to: string;
};
export declare type LinksResult = {
    id: BitId;
    bound: LinkDetail[];
};
/**
 * link given components to node_modules, so it's possible to use absolute link instead of relative
 * for example, require('@bit/remote-scope.bar.foo)
 */
export default class NodeModuleLinker {
    components: Component[];
    consumer: Consumer | null | undefined;
    bitMap: BitMap;
    dataToPersist: DataToPersist;
    constructor(components: Component[], consumer: Consumer | null | undefined, bitMap: BitMap);
    link(): Promise<LinksResult[]>;
    getLinks(): Promise<DataToPersist>;
    getLinksResults(): LinksResult[];
    _getDefaultScope(component?: Component): string | undefined | null;
    /**
     * even when an authored component has rootDir, we can't just symlink that rootDir to
     * node_modules/rootDir. it could work only when the main-file is index.js, not for other cases.
     * node expects the module inside node_modules to have either package.json with valid "main"
     * property or an index.js file. this main property can't be relative.
     */
    _populateAuthoredComponentsLinks(component: Component): Promise<void>;
    /**
     * on Harmony, just symlink the entire source directory into "src" in node-modules.
     */
    private symlinkDirAuthorHarmony;
    /**
     * Removing existing links root (the package path) - to handle cases it was linked by package manager for example
     * this makes sure we are not affecting other places (like package manager cache) we shouldn't touch
     * If you have a case when this deletes something created by the package manager and it's not the desired behavior,
     * do not delete this code, but make sure the package manger nest the installed version into it's dependent
     * @param component
     */
    _deleteExistingLinksRootIfSymlink(linkPath: string): undefined;
    /**
     * When the dists is outside the components directory, it doesn't have access to the node_modules of the component's
     * root-dir. The solution is to go through the node_modules packages one by one and symlink them.
     */
    _getSymlinkPackages(from: string, to: string, component: Component): Symlink[];
    _getDependencyLink(parentRootDir: PathOsBasedRelative, bitId: BitId, rootDir: PathOsBasedRelative, bindingPrefix: string, component: Component): Symlink;
    /**
     * create package.json on node_modules/@bit/component-name/package.json with a property 'main'
     * pointing to the component's main file.
     * It is needed for Authored components only.
     * Since an authored component doesn't have rootDir, it's impossible to symlink to the component directory.
     * It makes it easier for Author to use absolute syntax between their own components.
     */
    _createPackageJsonForAuthor(component: Component): Promise<void>;
    /**
     * links are normally generated by `bit import`, `bit link` and `bit install`.
     * for `bit import` the data about whether dependenciesSavedAsComponents is already populated
     * for the rest, it's not.
     * @todo: avoid repopulating for imported. (not easy because by default, all components get "true").
     */
    _populateShouldDependenciesSavedAsComponentsData(): Promise<void>;
    /**
     * these are changes made by aspects
     */
    _applyTransformers(component: Component, packageJson: PackageJsonFile): Promise<void>;
}
export {};
