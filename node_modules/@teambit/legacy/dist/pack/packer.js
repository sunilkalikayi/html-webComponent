"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.string.trim.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Packer = void 0;
function _execa() {
  const data = _interopRequireDefault(require("execa"));
  _execa = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _componentVersion() {
  const data = require("@teambit/component-version");
  _componentVersion = function () {
    return data;
  };
  return data;
}
function _isRelativePath() {
  const data = _interopRequireDefault(require("is-relative-path"));
  _isRelativePath = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
class Packer {
  constructor(logger = _logger().default) {
    this.logger = logger;
  }
  async npmPack(cwd, outputPath, override = false, dryRun = false, logger = this.logger) {
    const startTime = Date.now();
    const errors = [];
    const warnings = [];
    const packageManager = 'npm';
    const args = ['pack'];
    if (dryRun) {
      args.push('--dry-run');
    }
    try {
      const pkgJson = readPackageJson(cwd);
      if ((0, _componentVersion().isSnap)(pkgJson.version)) {
        warnings.push(`"package.json at ${cwd}" contain a snap version which is not a valid semver, can't pack it`);
        return {
          warnings,
          startTime,
          endTime: Date.now()
        };
      }
      // @todo: once capsule.exec works properly, replace this
      const {
        stdout,
        stderr
      } = await (0, _execa().default)(packageManager, args, {
        cwd
      });
      logger.debug(`successfully ran ${packageManager} ${args} at ${cwd}`);
      logger.debug(`stdout: ${stdout}`);
      logger.debug(`stderr: ${stderr}`);
      const tgzName = stdout.trim();
      const tgzOriginPath = _path().default.join(cwd, tgzName);
      let tarPath = _path().default.join(outputPath, tgzName);
      if ((0, _isRelativePath().default)(tarPath)) {
        tarPath = _path().default.join(cwd, tarPath);
      }
      const metadata = {
        pkgJson,
        tarPath,
        tarName: tgzName
      };
      if (tgzOriginPath !== tarPath && _fsExtra().default.pathExistsSync(tarPath)) {
        if (override) {
          warnings.push(`"${tarPath}" already exists, override it`);
          _fsExtra().default.removeSync(tarPath);
        } else {
          errors.push(`"${tarPath}" already exists, use --override flag to override`);
          return {
            metadata,
            errors,
            startTime,
            endTime: Date.now()
          };
        }
      }
      if (tgzOriginPath !== tarPath && !dryRun) {
        await _fsExtra().default.move(tgzOriginPath, tarPath);
      }
      if (!dryRun) {
        const checksum = await (0, _utils().checksumFile)(tarPath);
        metadata.checksum = checksum;
      }
      return {
        metadata,
        warnings,
        errors,
        startTime,
        endTime: Date.now()
      };
    } catch (err) {
      const errorMsg = `failed running ${packageManager} ${args} at ${cwd}`;
      logger.error(`${errorMsg}`);
      if (err.stderr) logger.error(`${err.stderr}`);
      errors.push(`${errorMsg}\n${err.stderr}`);
      return {
        errors,
        startTime,
        endTime: Date.now()
      };
    }
  }
}
exports.Packer = Packer;
function readPackageJson(dir) {
  const pkgJson = _fsExtra().default.readJsonSync(_path().default.join(dir, 'package.json'));
  return pkgJson;
}