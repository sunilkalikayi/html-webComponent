"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleErrorAndExit = handleErrorAndExit;
exports.handleUnhandledRejection = handleUnhandledRejection;
exports.logErrAndExit = logErrAndExit;
function _serializeError() {
  const data = require("serialize-error");
  _serializeError = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("../utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _defaultErrorHandler() {
  const data = _interopRequireDefault(require("./default-error-handler"));
  _defaultErrorHandler = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("./loader"));
  _loader = function () {
    return data;
  };
  return data;
}
async function handleErrorAndExit(err, commandName, shouldSerialize = false) {
  try {
    _loader().default.off();
    _logger().default.error(`got an error from command ${commandName}: ${err}`);
    _logger().default.error(err.stack || '<no error stack was found>');
    const {
      message,
      error
    } = (0, _defaultErrorHandler().default)(err);
    if (shouldSerialize) serializeErrAndExit(error, commandName);else await logErrAndExit(message, commandName);
  } catch (e) {
    // eslint-disable-next-line no-console
    console.error('failed to log the error properly, failure error', e);
    // eslint-disable-next-line no-console
    console.error('failed to log the error properly, original error', err);
    process.exit(1);
  }
}
async function handleUnhandledRejection(err) {
  // eslint-disable-next-line no-console
  console.error('** unhandled rejection found, please make sure the promise is resolved/rejected correctly! **');
  if (err instanceof Error) {
    return handleErrorAndExit(err, process.argv[2]);
  }
  console.error(err); // eslint-disable-line
  return handleErrorAndExit(new Error(`unhandledRejections found. err ${err}`), process.argv[2]);
}
async function logErrAndExit(err, commandName) {
  if (!err) throw new Error(`logErrAndExit expects to get either an Error or a string, got nothing`);
  console.error(err); // eslint-disable-line
  await _logger().default.exitAfterFlush(1, commandName, err.toString());
}
function serializeErrAndExit(err, commandName) {
  const data = (0, _utils().packCommand)((0, _utils().buildCommandMessage)((0, _serializeError().serializeError)(err), undefined, false), false, false);
  const code = err.code && (0, _utils().isNumeric)(err.code) ? err.code : 1;
  // eslint-disable-next-line @typescript-eslint/no-misused-promises
  return process.stderr.write(data, () => _logger().default.exitAfterFlush(code, commandName));
}