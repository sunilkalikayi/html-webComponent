"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _omit2() {
  const data = _interopRequireDefault(require("ramda/src/omit"));
  _omit2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function pathlib() {
  const data = _interopRequireWildcard(require("path"));
  pathlib = function () {
    return data;
  };
  return data;
}
function _consumer() {
  const data = require("../../../api/consumer");
  _consumer = function () {
    return data;
  };
  return data;
}
function _globalConfig() {
  const data = require("../../../api/consumer/lib/global-config");
  _globalConfig = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = require("../../../api/scope");
  _scope = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _interactive() {
  const data = require("../../../interactive");
  _interactive = function () {
    return data;
  };
  return data;
}
function _shouldShowInteractive() {
  const data = _interopRequireDefault(require("../../../interactive/utils/should-show-interactive"));
  _shouldShowInteractive = function () {
    return data;
  };
  return data;
}
function _objectClean() {
  const data = _interopRequireDefault(require("../../../utils/object-clean"));
  _objectClean = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class Init {
  constructor() {
    (0, _defineProperty2().default)(this, "name", 'init [path]');
    (0, _defineProperty2().default)(this, "skipWorkspace", true);
    (0, _defineProperty2().default)(this, "description", 'create or reinitialize an empty workspace');
    (0, _defineProperty2().default)(this, "group", 'start');
    (0, _defineProperty2().default)(this, "extendedDescription", `https://${_constants().BASE_DOCS_DOMAIN}/workspace/creating-workspaces#initialize-a-workspace-on-an-existing-project`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "opts", [['b', 'bare [name]', 'initialize an empty bit bare scope'], ['s', 'shared <groupname>', 'add group write permissions to a scope properly'], ['T', 'standalone', 'do not nest component store within .git directory and do not write config data inside package.json'], ['r', 'reset', 'write missing or damaged Bit files'], ['', 'reset-new', 'reset .bitmap file as if the components were newly added and remove all model data (objects)'], ['', 'reset-hard', 'delete all Bit files and directories, including Bit configuration, tracking and model data. Useful for re-start using Bit from scratch'], ['', 'reset-scope', 'removes local scope (.bit or .git/bit). snaps that were not exported will be lost. workspace left intact'], ['d', 'default-directory <default-directory>', 'set up default directory to import components into'], ['', 'default-scope <default-scope>', 'set up default scope for all components in the workspace'], ['p', 'package-manager <package-manager>', 'set up package manager (npm or yarn)'], ['f', 'force', 'force workspace initialization without clearing local objects'], ['', 'harmony', 'DEPRECATED. no need for this flag. Harmony is the default now'], ['I', 'interactive', 'EXPERIMENTAL. start an interactive process']]);
  }
  action([path], flags) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (!_isAnyNotInteractiveFlagUsed(flags) && (flags.interactive || (0, _shouldShowInteractive().default)(_constants().CFG_INIT_INTERACTIVE))) {
      return (0, _interactive().initInteractive)();
    }
    const {
      bare,
      shared,
      standalone,
      reset,
      resetNew,
      resetHard,
      resetScope,
      force,
      defaultDirectory,
      defaultScope,
      packageManager
    } = flags;
    if (path) path = pathlib().resolve(path);
    if (bare) {
      if (reset || resetHard) throw new (_generalError().default)('--reset and --reset-hard flags are not available for bare scope');
      // Handle both cases init --bare and init --bare [scopeName]
      const bareVal = bare === true ? '' : bare;
      return (0, _scope().initScope)(path, bareVal, shared).then(({
        created
      }) => {
        return {
          created,
          bare: true
        };
      });
    }
    if (reset && resetHard) throw new (_generalError().default)('please use --reset or --reset-hard. not both');
    const workspaceConfigFileProps = {
      componentsDefaultDirectory: defaultDirectory !== null && defaultDirectory !== void 0 ? defaultDirectory : (0, _globalConfig().getSync)(_constants().CFG_INIT_DEFAULT_DIRECTORY),
      defaultScope: defaultScope !== null && defaultScope !== void 0 ? defaultScope : (0, _globalConfig().getSync)(_constants().CFG_INIT_DEFAULT_SCOPE),
      packageManager
    };
    return (0, _consumer().init)(path, standalone, reset, resetNew, resetHard, resetScope, force, workspaceConfigFileProps).then(({
      created,
      addedGitHooks,
      existingGitHooks
    }) => {
      return {
        created,
        addedGitHooks,
        existingGitHooks,
        reset,
        resetHard,
        resetScope
      };
    });
  }
  report({
    created,
    bare,
    reset,
    resetHard,
    resetScope
  }) {
    if (bare) {
      // if (!created) return `${chalk.grey('successfully reinitialized a bare bit scope.')}`;
      // @TODO - a case that you already have a bit scope
      return `${_chalk().default.green('successfully initialized an empty bare bit scope.')}`;
    }
    let initMessage = `${_chalk().default.green('successfully initialized a bit workspace.')}`;
    if (!created) initMessage = `${_chalk().default.grey('successfully reinitialized a bit workspace.')}`;
    if (reset) initMessage = `${_chalk().default.grey('your bit workspace has been reset successfully.')}`;
    if (resetHard) initMessage = `${_chalk().default.grey('your bit workspace has been hard-reset successfully.')}`;
    if (resetScope) initMessage = `${_chalk().default.grey('your local scope has been reset successfully.')}`;
    // const addedGitHooksTemplate = _generateAddedGitHooksTemplate(addedGitHooks);
    // const existingGitHooksTemplate = _generateExistingGitHooksTemplate(existingGitHooks);
    // return `${initMessage}\n${addedGitHooksTemplate}\n${existingGitHooksTemplate}`;
    return initMessage;
  }
}
exports.default = Init;
function _isAnyNotInteractiveFlagUsed(flags) {
  const withoutInteractive = (0, _omit2().default)(['interactive'], flags);
  const cleaned = (0, _objectClean().default)(withoutInteractive);
  return !(0, _isEmpty2().default)(cleaned);
}

// function _generateAddedGitHooksTemplate(addedGitHooks) {
//   if (addedGitHooks && addedGitHooks.length > 0) {
//     return chalk.green(`the following git hooks were added: ${addedGitHooks.join(', ')}`);
//   }
//   return '';
// }

// function _generateExistingGitHooksTemplate(existingGitHooks) {
//   if (existingGitHooks && existingGitHooks.length > 0) {
//     return chalk.yellow(
//       `warning: the following git hooks are already existing: ${existingGitHooks.join(
//         ', '
//       )}\nplease add the following code to your hooks: \`bit import\``
//     );
//   }
//   return '';
// }