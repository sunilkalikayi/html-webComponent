"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));
  _flatten2 = function () {
    return data;
  };
  return data;
}
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function path() {
  const data = _interopRequireWildcard(require("path"));
  path = function () {
    return data;
  };
  return data;
}
function _consumer() {
  const data = require("../../../api/consumer");
  _consumer = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("../../../constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class Add {
  constructor() {
    (0, _defineProperty2().default)(this, "name", 'add [path...]');
    (0, _defineProperty2().default)(this, "description", 'Add any subset of files to be tracked as a component(s).');
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "extendedDescription", `all flags support glob patterns and {PARENT} {FILE_NAME} annotations
  https://${_constants().BASE_DOCS_DOMAIN}/components/adding-components`);
    (0, _defineProperty2().default)(this, "alias", 'a');
    (0, _defineProperty2().default)(this, "opts", [['i', 'id <name>', 'manually set component id'], ['m', 'main <file>', 'define entry point for the components'], ['n', 'namespace <namespace>', 'organize component in a namespace'], ['o', 'override <boolean>', 'override existing component if exists (default = false)'], ['s', 'scope <string>', `sets the component's scope-name. if not entered, the default-scope will be used`]]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "migration", true);
  }
  action([paths = []], {
    id,
    main,
    namespace,
    scope,
    override = false
  }) {
    if (namespace && id) {
      throw new (_generalError().default)('please use either [id] or [namespace] to add a particular component');
    }
    const normalizedPaths = paths.map(p => path().normalize(p));
    return (0, _consumer().add)({
      componentPaths: normalizedPaths,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      id,
      main: main ? path().normalize(main) : undefined,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      namespace,
      defaultScope: scope,
      override
    });
  }
  splitList(val) {
    return val.split(',');
  }
  report({
    addedComponents,
    warnings
  }) {
    const paintWarning = () => {
      const alreadyUsedOutput = () => {
        const alreadyUsedWarning = Object.keys(warnings.alreadyUsed).map(key => _chalk().default.yellow(`warning: files ${_chalk().default.bold(warnings.alreadyUsed[key].join(', '))} already used by component: ${key}`)).filter(x => x).join('\n');
        return (0, _isEmpty2().default)(alreadyUsedWarning) ? '' : `${alreadyUsedWarning}\n`;
      };
      const emptyDirectoryOutput = () => {
        if (!warnings.emptyDirectory.length) return '';
        return _chalk().default.yellow(`warning: the following directories are empty or all their files were excluded\n${_chalk().default.bold(warnings.emptyDirectory.join('\n'))}\n`);
      };
      return alreadyUsedOutput() + emptyDirectoryOutput();
    };
    if (addedComponents.length > 1) {
      return paintWarning() + _chalk().default.green(`tracking ${addedComponents.length} new components`);
    }
    return paintWarning() + (0, _flatten2().default)(addedComponents.map(result => {
      if (result.files.length === 0) {
        return _chalk().default.underline.red(`could not track component ${_chalk().default.bold(result.id.toString())}: no files to track`);
      }
      const title = _chalk().default.underline(`tracking component ${_chalk().default.bold(result.id.toString())}:\n`);
      const files = result.files.map(file => _chalk().default.green(`added ${file.relativePath}`));
      return title + files.join('\n');
    })).join('\n\n');
  }
}
exports.default = Add;