"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));
  _isEmpty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("../../bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
var _default = ({
  dependentBits,
  modifiedComponents = [],
  removedComponentIds,
  missingComponents,
  removedFromLane
}, isRemote) => {
  const paintMissingComponents = () => {
    if ((0, _isEmpty2().default)(missingComponents)) return '';
    return _chalk().default.red('missing components:') + (0, _chalk().default)(` ${missingComponents.map(id => {
      if (!(id instanceof _bitId().BitId)) id = new (_bitId().BitId)(id); // when the id was received from a remote it's not an instance of BitId
      return id.version === 'latest' ? id.toStringWithoutVersion() : id.toString();
    })}\n`);
  };
  const paintRemoved = () => {
    if ((0, _isEmpty2().default)(removedComponentIds) && (0, _isEmpty2().default)(removedFromLane)) return '';
    const compToStr = comps => (0, _chalk().default)(` ${comps.map(id => id.version === 'latest' ? id.toStringWithoutVersion() : id.toString())}\n`);
    const getMsg = (isLane = false) => {
      const removedFrom = isLane ? 'lane' : 'scope';
      const msg = isRemote ? `successfully removed components from the remote ${removedFrom}:` : `successfully removed components from the local ${removedFrom}:`;
      return _chalk().default.green(msg);
    };
    const newLine = '\n';
    const compOutput = (0, _isEmpty2().default)(removedComponentIds) ? '' : getMsg(false) + compToStr(removedComponentIds) + newLine;
    const laneOutput = (0, _isEmpty2().default)(removedFromLane) ? '' : getMsg(true) + compToStr(removedFromLane);
    return `${compOutput}${laneOutput}`;
  };
  const paintUnRemovedComponents = () => {
    if ((0, _isEmpty2().default)(dependentBits)) return '';
    return Object.keys(dependentBits).map(key => {
      const header = _chalk().default.underline.red(`error: unable to delete ${key}, because the following components depend on it:`);
      const body = dependentBits[key].join('\n');
      return `${header}\n${body}`;
    }).join('\n\n');
  };
  const paintModifiedComponents = () => {
    if ((0, _isEmpty2().default)(modifiedComponents)) return '';
    const modifiedStr = modifiedComponents.map(id => id.version === 'latest' ? id.toStringWithoutVersion() : id.toString());
    return `${_chalk().default.red('error: unable to remove modified components (please use --force to remove modified components)\n') + (0, _chalk().default)(`- ${modifiedStr}`)}`;
  };
  return (
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    paintUnRemovedComponents(dependentBits) +
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    paintRemoved(removedComponentIds) +
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    paintMissingComponents(missingComponents) +
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    paintModifiedComponents(modifiedComponents)
  );
};
exports.default = _default;