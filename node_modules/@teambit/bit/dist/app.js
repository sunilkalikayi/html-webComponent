"use strict";

require("core-js/modules/es.promise.js");
function _toolboxPerformance() {
  const data = require("@teambit/toolbox.performance.v8-cache");
  _toolboxPerformance = function () {
    return data;
  };
  return data;
}
require("./hook-require");
function _bootstrap() {
  const data = require("@teambit/legacy/dist/bootstrap");
  _bootstrap = function () {
    return data;
  };
  return data;
}
function _handleErrors() {
  const data = require("@teambit/legacy/dist/cli/handle-errors");
  _handleErrors = function () {
    return data;
  };
  return data;
}
function _loadBit() {
  const data = require("./load-bit");
  _loadBit = function () {
    return data;
  };
  return data;
}
/* eslint-disable import/no-dynamic-require */
/* eslint-disable import/first */
process.on('uncaughtException', err => {
  // eslint-disable-next-line no-console
  console.error('uncaughtException', err);
  process.exit(1);
});
// Enable v8 compile cache, keep this before other imports
_toolboxPerformance().nativeCompileCache === null || _toolboxPerformance().nativeCompileCache === void 0 ? void 0 : _toolboxPerformance().nativeCompileCache.install();
// eslint-disable-next-line @typescript-eslint/no-floating-promises
initApp();
async function initApp() {
  try {
    await (0, _bootstrap().bootstrap)();
    // registerCoreExtensions();
    // const harmony = await Harmony.load([ConfigExt], {});
    await (0, _loadBit().runCLI)();
  } catch (err) {
    const originalError = err.originalError || err;
    await (0, _handleErrors().handleErrorAndExit)(originalError, process.argv[2]);
  }
}

//# sourceMappingURL=app.js.map