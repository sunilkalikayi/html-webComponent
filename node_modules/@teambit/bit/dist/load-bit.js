"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadBit = loadBit;
exports.requireAspects = requireAspects;
exports.runCLI = runCLI;
function _toolboxPerformance() {
  const data = require("@teambit/toolbox.performance.v8-cache");
  _toolboxPerformance = function () {
    return data;
  };
  return data;
}
require("reflect-metadata");
require("./hook-require");
function _aspectLoader() {
  const data = require("@teambit/aspect-loader");
  _aspectLoader = function () {
    return data;
  };
  return data;
}
function _commentJson() {
  const data = _interopRequireDefault(require("comment-json"));
  _commentJson = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _config() {
  const data = require("@teambit/config");
  _config = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _harmonyConfig() {
  const data = require("@teambit/harmony/dist/harmony-config");
  _harmonyConfig = function () {
    return data;
  };
  return data;
}
function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");
  _legacyBitId = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/legacy/dist/consumer/component/dependencies/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _consumer() {
  const data = require("@teambit/legacy/dist/consumer");
  _consumer = function () {
    return data;
  };
  return data;
}
function _bitMap() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/bit-map"));
  _bitMap = function () {
    return data;
  };
  return data;
}
function _componentLoader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/component-loader"));
  _componentLoader = function () {
    return data;
  };
  return data;
}
function _componentConfig() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/config/component-config"));
  _componentConfig = function () {
    return data;
  };
  return data;
}
function _componentOverrides() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/config/component-overrides"));
  _componentOverrides = function () {
    return data;
  };
  return data;
}
function _packageJsonTransformer() {
  const data = require("@teambit/legacy/dist/consumer/component/package-json-transformer");
  _packageJsonTransformer = function () {
    return data;
  };
  return data;
}
function _semver() {
  const data = require("semver");
  _semver = function () {
    return data;
  };
  return data;
}
function _manyComponentsWriter() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/many-components-writer"));
  _manyComponentsWriter = function () {
    return data;
  };
  return data;
}
function _bootstrap() {
  const data = require("@teambit/legacy/dist/bootstrap");
  _bootstrap = function () {
    return data;
  };
  return data;
}
function _config2() {
  const data = require("@teambit/legacy/dist/consumer/config");
  _config2 = function () {
    return data;
  };
  return data;
}
function _workspaceConfig() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/config/workspace-config"));
  _workspaceConfig = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@teambit/legacy/dist/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _action() {
  const data = require("@teambit/legacy/dist/api/scope/lib/action");
  _action = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = require("fs-extra");
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _manifests() {
  const data = require("./manifests");
  _manifests = function () {
    return data;
  };
  return data;
}
function _bit() {
  const data = require("./bit.aspect");
  _bit = function () {
    return data;
  };
  return data;
}
function _bitMain() {
  const data = require("./bit.main.runtime");
  _bitMain = function () {
    return data;
  };
  return data;
}
/* eslint-disable import/no-dynamic-require */
/* eslint-disable import/first */
process.on('uncaughtException', err => {
  // eslint-disable-next-line no-console
  console.error('uncaughtException', err);
  process.exit(1);
});
// Enable v8 compile cache, keep this before other imports
_toolboxPerformance().nativeCompileCache === null || _toolboxPerformance().nativeCompileCache === void 0 ? void 0 : _toolboxPerformance().nativeCompileCache.install();

// needed for class-transformer package

async function loadLegacyConfig(config) {
  const harmony = await _harmony().Harmony.load([_config().ConfigAspect], _config().ConfigRuntime.name, config.toObject());
  await harmony.run(async (aspect, runtime) => requireAspects(aspect, runtime));
}
async function getConfig(cwd = process.cwd()) {
  const consumerInfo = await (0, _consumer().getConsumerInfo)(cwd);
  const scopePath = (0, _utils().propogateUntil)(cwd);
  const globalConfigOpts = {
    name: '.bitrc.jsonc'
  };
  const configOpts = {
    global: globalConfigOpts,
    shouldThrow: false,
    cwd: (consumerInfo === null || consumerInfo === void 0 ? void 0 : consumerInfo.path) || scopePath
  };
  if (consumerInfo) {
    const config = _harmonyConfig().Config.load('workspace.jsonc', configOpts);
    return attachVersionsFromBitmap(config, consumerInfo);
  }
  if (scopePath && !consumerInfo) {
    return _harmonyConfig().Config.load('scope.jsonc', configOpts);
  }
  return _harmonyConfig().Config.loadGlobal(globalConfigOpts);
}

/**
 * This will attach versions of aspects configured in the config without version by resolves them from the bitmap file
 * It's required in order to support a usecase which you develop a local aspect and configure it in your workspace.jsonc
 * in that case you always want the workspace.jsonc config to be linked to your local aspect
 * but you don't want to change your workspace.jsonc version after each tag of the aspect
 * @param config
 */
function attachVersionsFromBitmap(config, consumerInfo) {
  if (!consumerInfo || !consumerInfo.hasBitMap) {
    return config;
  }
  const rawConfig = config.toObject();
  const rawBitmap = _bitMap().default.loadRawSync(consumerInfo.path);
  let parsedBitMap = {};
  try {
    var _parsedBitMap, _parsedBitMap$_bit_la;
    parsedBitMap = rawBitmap ? _commentJson().default.parse(rawBitmap === null || rawBitmap === void 0 ? void 0 : rawBitmap.toString('utf8'), undefined, true) : {};
    // @todo: remove this if statement once we don't need the migration of the bitmap file for lanes
    // @ts-ignore
    if ((_parsedBitMap = parsedBitMap) !== null && _parsedBitMap !== void 0 && (_parsedBitMap$_bit_la = _parsedBitMap._bit_lane) !== null && _parsedBitMap$_bit_la !== void 0 && _parsedBitMap$_bit_la.name) {
      // backward compatibility. if "_bit_land" has the old format, then, later, when the bitmap is loaded again,
      // it'll take care of the migration.
      parsedBitMap = {};
    }
    _bitMap().default.removeNonComponentFields(parsedBitMap);
    // Do nothing here, invalid bitmaps will be handled later
    // eslint-disable-next-line no-empty
  } catch (e) {}
  const allBitmapIds = Object.keys(parsedBitMap).map(id => _bitMap().default.getBitIdFromComponentJson(id, parsedBitMap[id]));
  const bitMapBitIds = _bitId().BitIds.fromArray(allBitmapIds);
  const result = Object.entries(rawConfig).reduce((acc, [aspectId, aspectConfig]) => {
    let newAspectEntry = aspectId;
    // In case the id already has a version we don't want to get it from the bitmap
    // We also don't want to add versions for core aspects
    if (!aspectId.includes(_legacyBitId().VERSION_DELIMITER) && !_manifests().manifestsMap[aspectId]) {
      const versionFromBitmap = getVersionFromBitMapIds(bitMapBitIds, aspectId);
      if (versionFromBitmap) {
        newAspectEntry = `${aspectId}${_legacyBitId().VERSION_DELIMITER}${versionFromBitmap}`;
      }
    }
    acc[newAspectEntry] = aspectConfig;
    return acc;
  }, {});
  return new (_harmonyConfig().Config)(result);
}
function getVersionFromBitMapIds(allBitmapIds, aspectId) {
  let aspectBitId;
  try {
    aspectBitId = _legacyBitId().BitId.parse(aspectId, true);
  } catch (err) {
    throw new Error(`unable to parse the component-id "${aspectId}" from the workspace.jsonc file, make sure this is a component id`);
  }
  // start by searching id in the bitmap with exact match (including scope name)
  // in case the aspect is not exported yet, it will be in the bitmap without a scope,
  // while in the aspect id it will have the default scope
  const found = allBitmapIds.searchWithoutVersion(aspectBitId) || allBitmapIds.searchWithoutScopeAndVersion(aspectBitId);
  return found && found.hasVersion() ? found.version : undefined;
}
async function requireAspects(aspect, runtime) {
  const id = aspect.name;
  if (!id) throw new Error('could not retrieve aspect id');
  const dirPath = (0, _aspectLoader().getAspectDistDir)(id);
  const files = await (0, _fsExtra().readdir)(dirPath);
  const runtimeFile = files.find(file => file.includes(`.${runtime.name}.runtime.js`));
  if (!runtimeFile) return;
  // eslint-disable-next-line
  require((0, _path().resolve)(`${dirPath}/${runtimeFile}`));
}
function getMainAspect() {
  const mainAspectDir = (0, _aspectLoader().getAspectDir)(_bit().BitAspect.id);
  let version;
  const packageName = (0, _aspectLoader().getCoreAspectPackageName)(_bit().BitAspect.id);
  try {
    // eslint-disable-next-line global-require
    const packageJson = require(`${mainAspectDir}/package.json`);
    version = packageJson.version;
  } catch (err) {
    version = undefined;
  }
  return {
    path: mainAspectDir,
    version,
    packageName,
    aspect: _bit().BitAspect,
    name: (0, _aspectLoader().getCoreAspectName)(_bit().BitAspect.id),
    id: _bit().BitAspect.id
  };
}

/**
 * Bit may crush during the aspect loading phase or workspace/consumer initialization.
 * normally, this is the desired behavior, however, some commands are there to help overcome these
 * errors, such as "bit clear-cache". for these commands we're better off loading the bare minimum,
 * which is only the CLI aspect.
 *
 * at this stage we don't have the commands objects, so we can't check the command/flags from there
 * instead, we have to check the `process.argv.` directly instead, which is not 100% accurate.
 */
function shouldLoadInSafeMode() {
  const currentCommand = process.argv[2];
  const safeModeCommands = ['init', 'cat-scope', 'cat-object', 'cat-component', 'cmp', 'cat-lane', 'login', 'logout', 'config', 'remote'];
  const hasSafeModeFlag = process.argv.includes('--safe-mode');
  const isSafeModeCommand = safeModeCommands.includes(currentCommand);
  return isSafeModeCommand || hasSafeModeFlag;
}
async function loadBit(path = process.cwd()) {
  var _BitAspect$id;
  clearGlobalsIfNeeded();
  _logger().default.info(`*** Loading Bit *** argv:\n${process.argv.join('\n')}`);
  const config = await getConfig(path);
  (0, _bitMain().registerCoreExtensions)();
  await loadLegacyConfig(config);
  const configMap = config.toObject();
  configMap[_BitAspect$id = _bit().BitAspect.id] || (configMap[_BitAspect$id] = {});
  configMap[_bit().BitAspect.id].cwd = path;
  verifyEngine(configMap[_bit().BitAspect.id]);
  const aspectsToLoad = [_cli().CLIAspect];
  const loadCLIOnly = shouldLoadInSafeMode();
  if (!loadCLIOnly) {
    aspectsToLoad.push(_bit().BitAspect);
  }
  const harmony = await _harmony().Harmony.load(aspectsToLoad, _cli().MainRuntime.name, configMap);
  await harmony.run(async (aspect, runtime) => requireAspects(aspect, runtime));
  if (loadCLIOnly) return harmony;
  _loader().default.start('loading aspects...');
  const aspectLoader = harmony.get('teambit.harmony/aspect-loader');
  aspectLoader.setCoreAspects(Object.values(_manifests().manifestsMap));
  aspectLoader.setMainAspect(getMainAspect());
  registerCoreAspectsToLegacyDepResolver(aspectLoader);
  return harmony;
}
function verifyEngine(bitConfig) {
  if (!bitConfig.engine) {
    return;
  }
  const bitVersion = (0, _bootstrap().getHarmonyVersion)(true);
  if ((0, _semver().satisfies)(bitVersion, bitConfig.engine)) {
    return;
  }
  const msg = `your bit version "${bitVersion}" doesn't satisfies the required "${bitConfig.engine}" version`;
  if (bitConfig.engineStrict) {
    throw new Error(`error: ${msg}`);
  }
  _logger().default.console(msg, 'warn', 'yellow');
}
async function runCLI() {
  const harmony = await loadBit();
  const cli = harmony.get('teambit.harmony/cli');
  let hasWorkspace = true;
  try {
    harmony.get('teambit.workspace/workspace');
  } catch (err) {
    hasWorkspace = false;
  }
  await cli.run(hasWorkspace);
}
function registerCoreAspectsToLegacyDepResolver(aspectLoader) {
  const allCoreAspectsIds = aspectLoader.getCoreAspectIds();
  const coreAspectsPackagesAndIds = {};
  allCoreAspectsIds.forEach(id => {
    const packageName = (0, _aspectLoader().getCoreAspectPackageName)(id);
    coreAspectsPackagesAndIds[packageName] = id;
  });
  // @ts-ignore
  _dependencyResolver().DependencyResolver.getCoreAspectsPackagesAndIds = () => coreAspectsPackagesAndIds;
}

/**
 * loadBit may gets called multiple times (currently, it's happening during e2e-tests that call loadBit).
 * when it happens, the static methods in this function still have the callbacks that were added in
 * the previous loadBit call. this callbacks have the old data such as workspace/bitmap/consumer
 * of the previous workspace, which leads to hard-to-debug issues.
 */
function clearGlobalsIfNeeded() {
  if (!_consumer().loadConsumer.cache && !_packageJsonTransformer().PackageJsonTransformer.packageJsonTransformersRegistry.length) {
    return;
  }
  delete _consumer().loadConsumer.cache;
  _componentLoader().default.onComponentLoadSubscribers = [];
  _componentOverrides().default.componentOverridesLoadingRegistry = {};
  _componentConfig().default.componentConfigLegacyLoadingRegistry = {};
  _componentConfig().default.componentConfigLoadingRegistry = {};
  _packageJsonTransformer().PackageJsonTransformer.packageJsonTransformersRegistry = [];
  // @ts-ignore
  _dependencyResolver().DependencyResolver.getWorkspacePolicy = undefined;
  // @ts-ignore
  _manyComponentsWriter().default.externalInstaller = {};
  _config2().ExtensionDataList.coreExtensionsNames = new Map();
  // @ts-ignore
  _workspaceConfig().default.workspaceConfigEnsuringRegistry = undefined;
  // @ts-ignore
  _workspaceConfig().default.workspaceConfigIsExistRegistry = undefined;
  // @ts-ignore
  _workspaceConfig().default.workspaceConfigLoadingRegistry = undefined;
  _action().ExternalActions.externalActions = [];
}

//# sourceMappingURL=load-bit.js.map