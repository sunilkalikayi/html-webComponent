"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.constructor.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypescriptCompiler = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _packageJsonFile() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/package-json-file"));
  _packageJsonFile = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class TypescriptCompiler {
  constructor(id, logger, options, tsModule) {
    var _this$options, _this$options$tsconfi;
    this.id = id;
    this.logger = logger;
    this.options = options;
    this.tsModule = tsModule;
    (0, _defineProperty2().default)(this, "distDir", void 0);
    (0, _defineProperty2().default)(this, "distGlobPatterns", void 0);
    (0, _defineProperty2().default)(this, "shouldCopyNonSupportedFiles", void 0);
    (0, _defineProperty2().default)(this, "artifactName", void 0);
    (0, _defineProperty2().default)(this, "displayName", 'TypeScript');
    (0, _defineProperty2().default)(this, "deleteDistDir", false);
    this.distDir = options.distDir || 'dist';
    this.distGlobPatterns = options.distGlobPatterns || [`${this.distDir}/**`, `!${this.distDir}/tsconfig.tsbuildinfo`];
    this.shouldCopyNonSupportedFiles = typeof options.shouldCopyNonSupportedFiles === 'boolean' ? options.shouldCopyNonSupportedFiles : true;
    this.artifactName = options.artifactName || 'dist';
    (_this$options = this.options).tsconfig || (_this$options.tsconfig = {});
    (_this$options$tsconfi = this.options.tsconfig).compilerOptions || (_this$options$tsconfi.compilerOptions = {});
    // mutate the outDir, otherwise, on capsules, the dists might be written to a different directory and make confusion
    this.options.tsconfig.compilerOptions.outDir = this.distDir;
  }
  displayConfig() {
    return this.stringifyTsconfig(this.options.tsconfig);
  }
  getDistDir() {
    return this.distDir;
  }

  /**
   * compile one file on the workspace
   */
  transpileFile(fileContent, options) {
    if (!this.isFileSupported(options.filePath)) {
      return null; // file is not supported
    }

    const compilerOptionsFromTsconfig = this.tsModule.convertCompilerOptionsFromJson(this.options.tsconfig.compilerOptions, '.');
    if (compilerOptionsFromTsconfig.errors.length) {
      // :TODO @david replace to a more concrete error type and put in 'exceptions' directory here.
      const formattedErrors = this.tsModule.formatDiagnosticsWithColorAndContext(compilerOptionsFromTsconfig.errors, this.getFormatDiagnosticsHost());
      throw new Error(`failed parsing the tsconfig.json.\n${formattedErrors}`);
    }
    const compilerOptions = compilerOptionsFromTsconfig.options;
    compilerOptions.sourceRoot = options.componentDir;
    compilerOptions.rootDir = '.';
    const result = this.tsModule.transpileModule(fileContent, {
      compilerOptions,
      fileName: options.filePath,
      reportDiagnostics: true
    });
    if (result.diagnostics && result.diagnostics.length) {
      const formatHost = this.getFormatDiagnosticsHost();
      const error = this.tsModule.formatDiagnosticsWithColorAndContext(result.diagnostics, formatHost);

      // :TODO @david please replace to a more concrete error type and put in 'exceptions' directory here.
      throw new Error(error);
    }
    const outputPath = this.replaceFileExtToJs(options.filePath);
    const outputFiles = [{
      outputText: result.outputText,
      outputPath
    }];
    if (result.sourceMapText) {
      outputFiles.push({
        outputText: result.sourceMapText,
        outputPath: `${outputPath}.map`
      });
    }
    return outputFiles;
  }
  async preBuild(context) {
    const capsules = context.capsuleNetwork.seedersCapsules;
    const capsuleDirs = capsules.map(capsule => capsule.path);
    await this.writeTsConfig(capsuleDirs);
    await this.writeTypes(capsuleDirs);
    await this.writeNpmIgnore(capsuleDirs);
  }

  /**
   * compile multiple components on the capsules
   */
  async build(context) {
    const componentsResults = await this.runTscBuild(context.capsuleNetwork);
    return {
      artifacts: this.getArtifactDefinition(),
      componentsResults
    };
  }
  async postBuild(context) {
    await Promise.all(context.capsuleNetwork.seedersCapsules.map(async capsule => {
      const packageJson = _packageJsonFile().default.loadFromCapsuleSync(capsule.path);
      // the types['index.ts'] is needed only during the build to avoid errors when tsc finds the
      // same type once in the d.ts and once in the ts file.
      if (packageJson.packageJsonObject.types) {
        delete packageJson.packageJsonObject.types;
        await packageJson.write();
      }
    }));
  }
  getArtifactDefinition() {
    return [{
      generatedBy: this.id,
      name: this.artifactName,
      globPatterns: this.distGlobPatterns
    }];
  }

  /**
   * given a source file, return its parallel in the dists. e.g. index.ts => dist/index.js
   */
  getDistPathBySrcPath(srcPath) {
    const fileWithJSExtIfNeeded = this.replaceFileExtToJs(srcPath);
    return _path().default.join(this.distDir, fileWithJSExtIfNeeded);
  }

  /**
   * whether typescript is able to compile the given path
   */
  isFileSupported(filePath) {
    const isJsAndCompile = !!this.options.compileJs && filePath.endsWith('.js');
    const isJsxAndCompile = !!this.options.compileJsx && filePath.endsWith('.jsx');
    return (filePath.endsWith('.ts') || filePath.endsWith('.tsx') || isJsAndCompile || isJsxAndCompile) && !filePath.endsWith('.d.ts');
  }

  /**
   * we have two options here:
   * 1. pass all capsules-dir at the second parameter of createSolutionBuilder and then no
   * need to write the main tsconfig.json with all the references.
   * 2. write main tsconfig.json and pass the capsules root-dir.
   * we went with option #2 because it'll be easier for users to go to the capsule-root and run
   * `tsc --build` to debug issues.
   */
  async runTscBuild(network) {
    const rootDir = network.capsulesRootDir;
    const capsules = await network.getCapsulesToCompile();
    if (!capsules.length) {
      return [];
    }
    const capsuleDirs = capsules.getAllCapsuleDirs();
    const formatHost = {
      getCanonicalFileName: p => p,
      getCurrentDirectory: () => '',
      // it helps to get the files with absolute paths
      getNewLine: () => this.tsModule.sys.newLine
    };
    const componentsResults = [];
    let currentComponentResult = {
      errors: []
    };
    const reportDiagnostic = diagnostic => {
      const errorStr = process.stdout.isTTY ? this.tsModule.formatDiagnosticsWithColorAndContext([diagnostic], formatHost) : this.tsModule.formatDiagnostic(diagnostic, formatHost);
      if (!diagnostic.file) {
        // the error is general and not related to a specific file. e.g. tsconfig is missing.
        throw new (_bitError().BitError)(errorStr);
      }
      this.logger.consoleFailure(errorStr);
      if (!currentComponentResult.component || !currentComponentResult.errors) {
        throw new Error(`currentComponentResult is not defined yet for ${diagnostic.file}`);
      }
      currentComponentResult.errors.push(errorStr);
    };
    // this only works when `verbose` is `true` in the `ts.createSolutionBuilder` function.
    const reportSolutionBuilderStatus = diag => {
      const msg = diag.messageText;
      this.logger.debug(msg);
    };
    const errorCounter = errorCount => {
      this.logger.info(`total error found: ${errorCount}`);
    };
    const host = this.tsModule.createSolutionBuilderHost(undefined, undefined, reportDiagnostic, reportSolutionBuilderStatus, errorCounter);
    await this.writeProjectReferencesTsConfig(rootDir, capsuleDirs);
    const solutionBuilder = this.tsModule.createSolutionBuilder(host, [rootDir], {
      verbose: true
    });
    let nextProject;
    const longProcessLogger = this.logger.createLongProcessLogger('compile typescript components', capsules.length);
    // eslint-disable-next-line no-cond-assign
    while (nextProject = solutionBuilder.getNextInvalidatedProject()) {
      // regex to make sure it will work correctly for both linux and windows
      // it replaces both /tsconfig.json and \tsocnfig.json
      const capsulePath = nextProject.project.replace(/[/\\]tsconfig.json/, '');
      const currentComponentId = capsules.getIdByPathInCapsule(capsulePath);
      if (!currentComponentId) throw new Error(`unable to find component for ${capsulePath}`);
      longProcessLogger.logProgress(currentComponentId.toString());
      const capsule = capsules.getCapsule(currentComponentId);
      if (!capsule) throw new Error(`unable to find capsule for ${currentComponentId.toString()}`);
      currentComponentResult.component = capsule.component;
      currentComponentResult.startTime = Date.now();
      nextProject.done();
      currentComponentResult.endTime = Date.now();
      componentsResults.push(_objectSpread({}, currentComponentResult));
      currentComponentResult = {
        errors: []
      };
    }
    longProcessLogger.end();
    return componentsResults;
  }
  getFormatDiagnosticsHost() {
    return {
      getCanonicalFileName: p => p,
      getCurrentDirectory: this.tsModule.sys.getCurrentDirectory,
      getNewLine: () => this.tsModule.sys.newLine
    };
  }
  async writeTypes(dirs) {
    await Promise.all(this.options.types.map(async typePath => {
      const contents = await _fsExtra().default.readFile(typePath, 'utf8');
      const filename = _path().default.basename(typePath);
      await Promise.all(dirs.map(async dir => {
        const filePath = _path().default.join(dir, 'types', filename);
        if (!(await _fsExtra().default.pathExists(filePath))) {
          await _fsExtra().default.outputFile(filePath, contents);
        }
      }));
    }));
  }

  /**
   * when using project-references, typescript adds a file "tsconfig.tsbuildinfo" which is not
   * needed for the package.
   */
  async writeNpmIgnore(dirs) {
    const NPM_IGNORE_FILE = '.npmignore';
    await Promise.all(dirs.map(async dir => {
      const npmIgnorePath = _path().default.join(dir, NPM_IGNORE_FILE);
      const npmIgnoreEntriesStr = `\n${this.distDir}/tsconfig.tsbuildinfo\n`;
      await _fsExtra().default.appendFile(npmIgnorePath, npmIgnoreEntriesStr);
    }));
  }
  async writeProjectReferencesTsConfig(rootDir, projects) {
    const files = [];
    const references = projects.map(project => ({
      path: project
    }));
    const tsconfig = {
      files,
      references
    };
    const tsconfigStr = this.stringifyTsconfig(tsconfig);
    await _fsExtra().default.writeFile(_path().default.join(rootDir, 'tsconfig.json'), tsconfigStr);
  }
  async writeTsConfig(dirs) {
    const tsconfigStr = this.stringifyTsconfig(this.options.tsconfig);
    await Promise.all(dirs.map(dir => _fsExtra().default.writeFile(_path().default.join(dir, 'tsconfig.json'), tsconfigStr)));
  }
  stringifyTsconfig(tsconfig) {
    return JSON.stringify(tsconfig, undefined, 2);
  }
  replaceFileExtToJs(filePath) {
    if (!this.isFileSupported(filePath)) return filePath;
    const fileExtension = _path().default.extname(filePath);
    return filePath.replace(new RegExp(`${fileExtension}$`), '.js'); // makes sure it's the last occurrence
  }

  version() {
    return this.tsModule.version;
  }
}
exports.TypescriptCompiler = TypescriptCompiler;

//# sourceMappingURL=typescript.compiler.js.map