"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypeScriptExtractor = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _typescript() {
  const data = _interopRequireDefault(require("typescript"));
  _typescript = function () {
    return data;
  };
  return data;
}
function _semanticsEntities() {
  const data = require("@teambit/semantics.entities.semantic-schema");
  _semanticsEntities = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _schemaExtractorContext() {
  const data = require("./schema-extractor-context");
  _schemaExtractorContext = function () {
    return data;
  };
  return data;
}
function _exportList() {
  const data = require("./export-list");
  _exportList = function () {
    return data;
  };
  return data;
}
class TypeScriptExtractor {
  constructor(tsconfig, schemaTransformerSlot, tsMain, rootPath, depResolver, workspace) {
    this.tsconfig = tsconfig;
    this.schemaTransformerSlot = schemaTransformerSlot;
    this.tsMain = tsMain;
    this.rootPath = rootPath;
    this.depResolver = depResolver;
    this.workspace = workspace;
    (0, _defineProperty2().default)(this, "tsserver", undefined);
  }
  parseSourceFile(file) {
    const sourceFile = _typescript().default.createSourceFile(file.path, file.contents.toString('utf8'), _typescript().default.ScriptTarget.Latest, true
    /** don't pass the scriptKind, it'll be determined automatically by typescript by the filepath */);
    // leave this commented out, it's helpful when there are issues with ASTs. consider throwing in this case.
    // console.log("sourceFile Errors", file.path, sourceFile.parseDiagnostics);
    return sourceFile;
  }

  /**
   * extract a component schema.
   */
  async extract(component) {
    const tsserver = await this.getTsServer();
    const mainFile = component.mainFile;
    const mainAst = this.parseSourceFile(mainFile);
    const context = await this.createContext(tsserver, component);
    const exportNames = await this.computeExportedIdentifiers(mainAst, context);
    context.setExports(new (_exportList().ExportList)(exportNames));
    const moduleSchema = await this.computeSchema(mainAst, context);
    moduleSchema.flatExportsRecursively();
    const apiScheme = moduleSchema;
    const location = context.getLocation(mainAst);
    return new (_semanticsEntities().APISchema)(location, apiScheme, component.id);
  }
  async computeExportedIdentifiers(node, context) {
    const transformer = this.getTransformer(node, context);
    if (!transformer || !transformer.getIdentifiers) {
      throw new (_exceptions().TransformerNotFound)(node, context.component, context.getLocation(node));
    }
    return transformer.getIdentifiers(node, context);
  }
  async createContext(tsserver, component) {
    const componentDeps = await this.getComponentDeps(component);
    return new (_schemaExtractorContext().SchemaExtractorContext)(tsserver, component, this, componentDeps);
  }
  async getComponentDeps(component) {
    const deps = await this.depResolver.getDependencies(component);
    const componentDeps = deps.getComponentDependencies();
    return componentDeps;
  }
  async getTsServer() {
    if (!this.tsserver) {
      const tsserver = this.tsMain.getTsserverClient();
      if (tsserver) {
        this.tsserver = tsserver;
        return tsserver;
      }
      this.tsserver = await this.tsMain.initTsserverClient(this.rootPath);
      return this.tsserver;
    }
    return this.tsserver;
  }
  async computeSchema(node, context) {
    const transformer = this.getTransformer(node, context);
    // leave the next line commented out, it is used for debugging
    // console.log('transformer', transformer.constructor.name, node.getText());
    return transformer.transform(node, context);
  }
  async getComponentIDByPath(file) {
    if (!this.workspace) {
      return null;
    }
    return this.workspace.getComponentIdByPath(file);
  }

  /**
   * select the correct transformer for a node.
   */
  getTransformer(node, context) {
    const transformers = (0, _lodash().flatten)(this.schemaTransformerSlot.values());
    const transformer = transformers.find(singleTransformer => singleTransformer.predicate(node));
    if (!transformer) throw new (_exceptions().TransformerNotFound)(node, context.component, context.getLocation(node));
    return transformer;
  }
}
exports.TypeScriptExtractor = TypeScriptExtractor;

//# sourceMappingURL=typescript.extractor.js.map