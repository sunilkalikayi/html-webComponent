import { ExecutionContext } from '@teambit/envs';
import { Workspace } from '@teambit/workspace';
import { Logger } from '@teambit/logger';
import { TsconfigWriterOptions } from './typescript.main.runtime';
export declare type TsconfigPathsPerEnv = {
    envIds: string[];
    tsconfig: Record<string, any>;
    paths: string[];
};
export declare class TsconfigWriter {
    private workspace;
    private logger;
    constructor(workspace: Workspace, logger: Logger);
    write(envsExecutionContext: ExecutionContext[], options: TsconfigWriterOptions): Promise<TsconfigPathsPerEnv[]>;
    clean(envsExecutionContext: ExecutionContext[], { dryRun, silent }: TsconfigWriterOptions): Promise<string[]>;
    private promptForWriting;
    private promptForCleaning;
    private deleteFiles;
    private writeFiles;
    private getPathsPerEnv;
}
declare type PathsPerEnvIds = {
    ids: string[];
    paths: string[];
};
/**
 * easier to understand by an example:
 * input:
 * [
 *   { id: react, paths: [ui/button, ui/form] },
 *   { id: aspect, paths: [p/a1, p/a2] },
 *   { id: node, paths: [p/n1] },
 * ]
 *
 * output:
 * [
 *   { id: react, paths: [ui] },
 *   { id: aspect, paths: [p] },
 *   { id: node, paths: [p/n1] },
 * ]
 *
 * the goal is to minimize the amount of files to write per env if possible.
 * when multiple components of the same env share a root-dir, then, it's enough to write a file in that shared dir.
 * if in a shared-dir, some components using env1 and some env2, it finds the env that has the max number of
 * components, this env will be optimized. other components, will have the files written inside their dirs.
 */
export declare function dedupePaths(pathsPerEnvId: PathsPerEnvIds[]): PathsPerEnvIds[];
export {};
