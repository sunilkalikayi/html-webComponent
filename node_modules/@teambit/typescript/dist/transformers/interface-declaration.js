"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InterfaceDeclarationTransformer = void 0;
function _typescript() {
  const data = require("typescript");
  _typescript = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _semanticsEntities() {
  const data = require("@teambit/semantics.entities.semantic-schema");
  _semanticsEntities = function () {
    return data;
  };
  return data;
}
function _exportIdentifier() {
  const data = require("../export-identifier");
  _exportIdentifier = function () {
    return data;
  };
  return data;
}
function _typeElementToSchema() {
  const data = require("./utils/type-element-to-schema");
  _typeElementToSchema = function () {
    return data;
  };
  return data;
}
function _jsdocToDocSchema() {
  const data = require("./utils/jsdoc-to-doc-schema");
  _jsdocToDocSchema = function () {
    return data;
  };
  return data;
}
class InterfaceDeclarationTransformer {
  predicate(node) {
    return node.kind === _typescript().SyntaxKind.InterfaceDeclaration;
  }
  async getIdentifiers(node) {
    return [new (_exportIdentifier().ExportIdentifier)(node.name.getText(), node.getSourceFile().fileName)];
  }
  async transform(interfaceDec, context) {
    const members = await (0, _pMapSeries().default)(interfaceDec.members, member => (0, _typeElementToSchema().typeElementToSchema)(member, context));
    const doc = await (0, _jsdocToDocSchema().jsDocToDocSchema)(interfaceDec, context);
    return new (_semanticsEntities().InterfaceSchema)(context.getLocation(interfaceDec), interfaceDec.name.getText(), members, doc);
  }
}
exports.InterfaceDeclarationTransformer = InterfaceDeclarationTransformer;

//# sourceMappingURL=interface-declaration.js.map