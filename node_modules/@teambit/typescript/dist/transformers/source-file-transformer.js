"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SourceFileTransformer = void 0;
function _typescript() {
  const data = _interopRequireDefault(require("typescript"));
  _typescript = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _semanticsEntities() {
  const data = require("@teambit/semantics.entities.semantic-schema");
  _semanticsEntities = function () {
    return data;
  };
  return data;
}
class SourceFileTransformer {
  predicate(node) {
    return node.kind === _typescript().default.SyntaxKind.SourceFile;
  }
  async getIdentifiers(sourceFile, context) {
    const exports = this.listExports(sourceFile);
    const exportNames = await Promise.all(exports.map(node => {
      return context.getExportedIdentifiers(node);
    }));
    const exportIds = (0, _lodash().flatten)(exportNames).reduce((acc, current) => {
      const item = acc.find(exportName => exportName.id === current.id);
      if (!item) acc.push(current);
      return acc;
    }, []);
    return exportIds;
  }
  async transform(node, context) {
    const exports = this.listExports(node);
    const schemas = await (0, _pMapSeries().default)(exports, exportNode => {
      return context.computeSchema(exportNode);
    });
    return new (_semanticsEntities().Module)(context.getLocation(node), schemas);
  }

  /**
   * list all exports of a source file.
   */
  listExports(ast) {
    return (0, _lodash().compact)(ast.statements.map(statement => {
      var _statement$modifiers;
      if (statement.kind === _typescript().default.SyntaxKind.ExportDeclaration) return statement;
      const isExport = Boolean((_statement$modifiers = statement.modifiers) === null || _statement$modifiers === void 0 ? void 0 : _statement$modifiers.find(modifier => {
        return modifier.kind === _typescript().default.SyntaxKind.ExportKeyword;
      }));

      // eslint-disable-next-line consistent-return
      if (!isExport) return;
      return statement;
    }));
  }
}
exports.SourceFileTransformer = SourceFileTransformer;

//# sourceMappingURL=source-file-transformer.js.map