"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.jsDocToDocSchema = jsDocToDocSchema;
function _typescript() {
  const data = require("typescript");
  _typescript = function () {
    return data;
  };
  return data;
}
function _tsutils() {
  const data = require("tsutils");
  _tsutils = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _semanticsEntities() {
  const data = require("@teambit/semantics.entities.semantic-schema");
  _semanticsEntities = function () {
    return data;
  };
  return data;
}
function _typeNodeToSchema() {
  const data = require("./type-node-to-schema");
  _typeNodeToSchema = function () {
    return data;
  };
  return data;
}
/* eslint-disable no-fallthrough */

async function jsDocToDocSchema(node, context) {
  if (!(0, _tsutils().canHaveJsDoc)(node)) {
    return undefined;
  }
  const jsDocs = (0, _tsutils().getJsDoc)(node);
  if (!jsDocs.length) {
    return undefined;
  }
  // not sure how common it is to have multiple JSDocs. never seen it before.
  // regardless, in typescript implementation of methods like `getJSDocDeprecatedTag()`, they use the first one. (`getFirstJSDocTag()`)
  const jsDoc = jsDocs[0];
  const location = context.getLocation(jsDoc);
  const comment = (0, _typescript().getTextOfJSDocComment)(jsDoc.comment);
  const tags = jsDoc.tags ? await (0, _pMapSeries().default)(jsDoc.tags, tag => tagParser(tag, context)) : undefined;
  return new (_semanticsEntities().DocSchema)(location, jsDoc.getText(), comment, tags);
}
async function tagParser(tag, context) {
  // for some reason, in some cases, if `tag.getSourceFile()` is not provided to the `getText()`, it throws "Cannot read property 'text' of undefined"

  switch (tag.kind) {
    case _typescript().SyntaxKind.JSDocReturnTag:
      return returnTag(tag, context);
    case _typescript().SyntaxKind.JSDocPropertyTag:
      return propertyLikeTag(tag, context);
    case _typescript().SyntaxKind.JSDocParameterTag:
      return propertyLikeTag(tag, context);
    case _typescript().SyntaxKind.JSDocAugmentsTag:
      return simpleTag(tag, _semanticsEntities().TagName.augments, context);
    case _typescript().SyntaxKind.JSDocAuthorTag:
      return simpleTag(tag, _semanticsEntities().TagName.author, context);
    case _typescript().SyntaxKind.JSDocClassTag:
      return simpleTag(tag, _semanticsEntities().TagName.class, context);
    case _typescript().SyntaxKind.JSDocCallbackTag:
      return simpleTag(tag, _semanticsEntities().TagName.callback, context);
    case _typescript().SyntaxKind.JSDocPublicTag:
      return simpleTag(tag, _semanticsEntities().TagName.public, context);
    case _typescript().SyntaxKind.JSDocPrivateTag:
      return simpleTag(tag, _semanticsEntities().TagName.private, context);
    case _typescript().SyntaxKind.JSDocProtectedTag:
      return simpleTag(tag, _semanticsEntities().TagName.protected, context);
    case _typescript().SyntaxKind.JSDocReadonlyTag:
      return simpleTag(tag, _semanticsEntities().TagName.readonly, context);
    case _typescript().SyntaxKind.JSDocOverrideTag:
      return simpleTag(tag, _semanticsEntities().TagName.override, context);
    case _typescript().SyntaxKind.JSDocDeprecatedTag:
      return simpleTag(tag, _semanticsEntities().TagName.deprecated, context);
    case _typescript().SyntaxKind.JSDocSeeTag:
      return simpleTag(tag, _semanticsEntities().TagName.see, context);
    case _typescript().SyntaxKind.JSDocEnumTag:
      return simpleTag(tag, _semanticsEntities().TagName.enum, context);
    case _typescript().SyntaxKind.JSDocThisTag:
      return simpleTag(tag, _semanticsEntities().TagName.this, context);
    case _typescript().SyntaxKind.JSDocTypeTag:
      return simpleTag(tag, _semanticsEntities().TagName.type, context);
    case _typescript().SyntaxKind.JSDocTemplateTag:
      return simpleTag(tag, _semanticsEntities().TagName.template, context);
    case _typescript().SyntaxKind.JSDocTypedefTag:
      return simpleTag(tag, _semanticsEntities().TagName.typedef, context);
    case _typescript().SyntaxKind.JSDocImplementsTag:
      return simpleTag(tag, _semanticsEntities().TagName.implements, context);
    default:
      {
        const tagName = tag.tagName.getText(tag.getSourceFile());
        return simpleTag(tag, tagName, context);
      }
  }
}
function simpleTag(tag, tagName, context) {
  return new (_semanticsEntities().TagSchema)(context.getLocation(tag), tagName, (0, _typescript().getTextOfJSDocComment)(tag.comment));
}
async function returnTag(tag, context) {
  var _tag$typeExpression, _tag$typeExpression2;
  const type = (_tag$typeExpression = tag.typeExpression) !== null && _tag$typeExpression !== void 0 && _tag$typeExpression.type ? await (0, _typeNodeToSchema().typeNodeToSchema)((_tag$typeExpression2 = tag.typeExpression) === null || _tag$typeExpression2 === void 0 ? void 0 : _tag$typeExpression2.type, context) : undefined;
  return new (_semanticsEntities().ReturnTagSchema)(context.getLocation(tag), (0, _typescript().getTextOfJSDocComment)(tag.comment), type);
}
async function propertyLikeTag(tag, context) {
  var _tag$typeExpression3, _tag$typeExpression4;
  const type = (_tag$typeExpression3 = tag.typeExpression) !== null && _tag$typeExpression3 !== void 0 && _tag$typeExpression3.type ? await (0, _typeNodeToSchema().typeNodeToSchema)((_tag$typeExpression4 = tag.typeExpression) === null || _tag$typeExpression4 === void 0 ? void 0 : _tag$typeExpression4.type, context) : undefined;
  return new (_semanticsEntities().PropertyLikeTagSchema)(context.getLocation(tag), tag.name.getText(), (0, _typescript().getTextOfJSDocComment)(tag.comment), type);
}

//# sourceMappingURL=jsdoc-to-doc-schema.js.map