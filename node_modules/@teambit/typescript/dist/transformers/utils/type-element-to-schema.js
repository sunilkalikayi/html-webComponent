"use strict";

require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAccessor = getAccessor;
exports.indexSignature = indexSignature;
exports.setAccessor = setAccessor;
exports.typeElementToSchema = typeElementToSchema;
function _typescript() {
  const data = require("typescript");
  _typescript = function () {
    return data;
  };
  return data;
}
function _semanticsEntities() {
  const data = require("@teambit/semantics.entities.semantic-schema");
  _semanticsEntities = function () {
    return data;
  };
  return data;
}
function _toFunctionLikeSchema() {
  const data = require("./to-function-like-schema");
  _toFunctionLikeSchema = function () {
    return data;
  };
  return data;
}
function _parseTypeFromQuickInfo() {
  const data = require("./parse-type-from-quick-info");
  _parseTypeFromQuickInfo = function () {
    return data;
  };
  return data;
}
function _typeNodeToSchema() {
  const data = require("./type-node-to-schema");
  _typeNodeToSchema = function () {
    return data;
  };
  return data;
}
function _getParams() {
  const data = require("./get-params");
  _getParams = function () {
    return data;
  };
  return data;
}
function _jsdocToDocSchema() {
  const data = require("./jsdoc-to-doc-schema");
  _jsdocToDocSchema = function () {
    return data;
  };
  return data;
}
async function typeElementToSchema(node, context) {
  switch (node.kind) {
    case _typescript().SyntaxKind.MethodSignature:
      return (0, _toFunctionLikeSchema().toFunctionLikeSchema)(node, context);
    case _typescript().SyntaxKind.ConstructSignature:
      return (0, _toFunctionLikeSchema().toFunctionLikeSchema)(node, context, 'new');
    case _typescript().SyntaxKind.CallSignature:
      return callSignature(node, context);
    case _typescript().SyntaxKind.PropertySignature:
      return propertySignature(node, context);
    case _typescript().SyntaxKind.IndexSignature:
      return indexSignature(node, context);
    case _typescript().SyntaxKind.GetAccessor:
      return getAccessor(node, context);
    case _typescript().SyntaxKind.SetAccessor:
      return setAccessor(node, context);
    default:
      throw new Error(`typeElementToSchema expect type-element node. got ${node.kind}`);
  }
}
async function propertySignature(node, context) {
  var _info$body;
  const name = node.name.getText();
  const info = (0, _typescript().isComputedPropertyName)(node.name) ? undefined : await context.getQuickInfo(node.name);
  const displaySig = (info === null || info === void 0 ? void 0 : (_info$body = info.body) === null || _info$body === void 0 ? void 0 : _info$body.displayString) || '';
  const typeStr = (0, _parseTypeFromQuickInfo().parseTypeFromQuickInfo)(info);
  const type = await context.resolveType(node, typeStr);
  const isOptional = Boolean(node.questionToken);
  const doc = await (0, _jsdocToDocSchema().jsDocToDocSchema)(node, context);
  return new (_semanticsEntities().VariableLikeSchema)(context.getLocation(node), name, displaySig, type, isOptional, doc);
}
async function indexSignature(node, context) {
  const params = await (0, _getParams().getParams)(node.parameters, context);
  const type = await (0, _typeNodeToSchema().typeNodeToSchema)(node.type, context);
  return new (_semanticsEntities().IndexSignatureSchema)(context.getLocation(node), params, type);
}
async function getAccessor(node, context) {
  var _info$body2;
  const info = await context.getQuickInfo(node.name);
  const displaySig = (info === null || info === void 0 ? void 0 : (_info$body2 = info.body) === null || _info$body2 === void 0 ? void 0 : _info$body2.displayString) || '';
  const typeStr = (0, _parseTypeFromQuickInfo().parseTypeFromQuickInfo)(info);
  const type = await context.resolveType(node, typeStr);
  return new (_semanticsEntities().GetAccessorSchema)(context.getLocation(node), node.name.getText(), type, displaySig);
}
async function setAccessor(node, context) {
  const params = await (0, _getParams().getParams)(node.parameters, context);
  const displaySig = await context.getQuickInfoDisplayString(node.name);
  return new (_semanticsEntities().SetAccessorSchema)(context.getLocation(node), node.name.getText(), params[0], displaySig);
}
async function callSignature(node, context) {
  return (0, _toFunctionLikeSchema().toFunctionLikeSchema)(node, context);
}

//# sourceMappingURL=type-element-to-schema.js.map