"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typeNodeToSchema = typeNodeToSchema;
function _typescript() {
  const data = require("typescript");
  _typescript = function () {
    return data;
  };
  return data;
}
function _semanticsEntities() {
  const data = require("@teambit/semantics.entities.semantic-schema");
  _semanticsEntities = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _getParams() {
  const data = require("./get-params");
  _getParams = function () {
    return data;
  };
  return data;
}
function _typeElementToSchema() {
  const data = require("./type-element-to-schema");
  _typeElementToSchema = function () {
    return data;
  };
  return data;
}
function _jsdocToDocSchema() {
  const data = require("./jsdoc-to-doc-schema");
  _jsdocToDocSchema = function () {
    return data;
  };
  return data;
}
// eslint-disable-next-line complexity
async function typeNodeToSchema(node, context) {
  const location = context.getLocation(node);
  if (isKeywordType(node)) {
    return new (_semanticsEntities().KeywordTypeSchema)(location, node.getText());
  }
  switch (node.kind) {
    case _typescript().SyntaxKind.IntersectionType:
      return intersectionType(node, context);
    case _typescript().SyntaxKind.UnionType:
      return unionType(node, context);
    case _typescript().SyntaxKind.TypeReference:
      return typeReference(node, context);
    case _typescript().SyntaxKind.TypeLiteral:
      return typeLiteral(node, context);
    case _typescript().SyntaxKind.LiteralType:
      // e.g. string/boolean
      return new (_semanticsEntities().LiteralTypeSchema)(location, node.getText());
    case _typescript().SyntaxKind.FunctionType:
      return functionType(node, context);
    case _typescript().SyntaxKind.TypeQuery:
      return typeQuery(node, context);
    case _typescript().SyntaxKind.ArrayType:
      return arrayType(node, context);
    case _typescript().SyntaxKind.TypeOperator:
      return typeOperator(node, context);
    case _typescript().SyntaxKind.TupleType:
      return tupleType(node, context);
    case _typescript().SyntaxKind.ParenthesizedType:
      return parenthesizedType(node, context);
    case _typescript().SyntaxKind.TypePredicate:
      return typePredicate(node, context);
    case _typescript().SyntaxKind.IndexedAccessType:
      return indexedAccessType(node, context);
    case _typescript().SyntaxKind.TemplateLiteralTypeSpan:
      return templateLiteralTypeSpan(node, context);
    case _typescript().SyntaxKind.TemplateLiteralType:
      return templateLiteralType(node, context);
    case _typescript().SyntaxKind.ThisType:
      return thisType(node, context);
    case _typescript().SyntaxKind.ConditionalType:
      return conditionalType(node, context);
    case _typescript().SyntaxKind.ConstructorType:
    case _typescript().SyntaxKind.NamedTupleMember:
    case _typescript().SyntaxKind.OptionalType:
    case _typescript().SyntaxKind.RestType:
    case _typescript().SyntaxKind.InferType:
    case _typescript().SyntaxKind.MappedType:
    case _typescript().SyntaxKind.ImportType:
    case _typescript().SyntaxKind.ExpressionWithTypeArguments:
    case _typescript().SyntaxKind.JSDocTypeExpression:
    case _typescript().SyntaxKind.JSDocAllType:
    case _typescript().SyntaxKind.JSDocUnknownType:
    case _typescript().SyntaxKind.JSDocNonNullableType:
    case _typescript().SyntaxKind.JSDocNullableType:
    case _typescript().SyntaxKind.JSDocOptionalType:
    case _typescript().SyntaxKind.JSDocFunctionType:
    case _typescript().SyntaxKind.JSDocVariadicType:
    case _typescript().SyntaxKind.JSDocNamepathType:
    case _typescript().SyntaxKind.JSDocSignature:
    case _typescript().SyntaxKind.JSDocTypeLiteral:
      throw new Error(`TypeNode ${node.kind} (probably ${_typescript().SyntaxKind[node.kind]}) was not implemented yet.
context: ${node.getText()}`);
    default:
      throw new Error(`Node ${node.kind} (probably ${_typescript().SyntaxKind[node.kind]}) is not a TypeNode.
context: ${node.getText()}`);
  }
}

/**
 * whether it's kind of `ts.KeywordTypeSyntaxKind`
 */
function isKeywordType(node) {
  switch (node.kind) {
    case _typescript().SyntaxKind.AnyKeyword:
    case _typescript().SyntaxKind.BigIntKeyword:
    case _typescript().SyntaxKind.BooleanKeyword:
    case _typescript().SyntaxKind.IntrinsicKeyword:
    case _typescript().SyntaxKind.NeverKeyword:
    case _typescript().SyntaxKind.NumberKeyword:
    case _typescript().SyntaxKind.ObjectKeyword:
    case _typescript().SyntaxKind.StringKeyword:
    case _typescript().SyntaxKind.SymbolKeyword:
    case _typescript().SyntaxKind.UndefinedKeyword:
    case _typescript().SyntaxKind.UnknownKeyword:
    case _typescript().SyntaxKind.VoidKeyword:
      return true;
    default:
      return false;
  }
}
async function intersectionType(node, context) {
  const types = await (0, _pMapSeries().default)(node.types, async type => {
    const typeSchema = await typeNodeToSchema(type, context);
    return typeSchema;
  });
  const location = context.getLocation(node);
  return new (_semanticsEntities().TypeIntersectionSchema)(location, types);
}
async function unionType(node, context) {
  const types = await (0, _pMapSeries().default)(node.types, async type => {
    const typeSchema = await typeNodeToSchema(type, context);
    return typeSchema;
  });
  const location = context.getLocation(node);
  return new (_semanticsEntities().TypeUnionSchema)(location, types);
}

/**
 * not to be confused with "LiteralType", which is string/boolean/null.
 * this "TypeLiteral" is an object with properties, such as: `{ a: string; b: number }`, similar to Interface.
 */
async function typeLiteral(node, context) {
  const members = await (0, _pMapSeries().default)(node.members, member => (0, _typeElementToSchema().typeElementToSchema)(member, context));
  const location = context.getLocation(node);
  return new (_semanticsEntities().TypeLiteralSchema)(location, members);
}

/**
 * In the following example, `AriaButtonProps` is a type reference
 * ```ts
 * import type { AriaButtonProps } from '@react-types/button';
 * export type ButtonProps = AriaButtonProps & { a: string };
 * ```
 */
async function typeReference(node, context) {
  const name = node.typeName.getText();
  const type = await context.resolveType(node, name, false);
  if (node.typeArguments && type instanceof _semanticsEntities().TypeRefSchema) {
    const args = await (0, _pMapSeries().default)(node.typeArguments, arg => typeNodeToSchema(arg, context));
    type.typeArgs = args;
  }
  return type;
}
async function functionType(node, context) {
  var _node$name, _node$modifiers;
  const name = ((_node$name = node.name) === null || _node$name === void 0 ? void 0 : _node$name.getText()) || '';
  const params = await (0, _getParams().getParams)(node.parameters, context);
  const returnType = await typeNodeToSchema(node.type, context);
  const location = context.getLocation(node);
  const modifiers = ((_node$modifiers = node.modifiers) === null || _node$modifiers === void 0 ? void 0 : _node$modifiers.map(modifier => modifier.getText())) || [];
  const doc = await (0, _jsdocToDocSchema().jsDocToDocSchema)(node, context);
  return new (_semanticsEntities().FunctionLikeSchema)(location, name, params, returnType, '', modifiers, doc);
}

/**
 * e.g. `typeof Foo`
 */
async function typeQuery(node, context) {
  const displaySig = await context.getQuickInfoDisplayString(node.exprName);
  const type = await context.resolveType(node.exprName, node.exprName.getText(), false);
  const location = context.getLocation(node);
  return new (_semanticsEntities().TypeQuerySchema)(location, type, displaySig);
}
async function arrayType(node, context) {
  const type = await typeNodeToSchema(node.elementType, context);
  const location = context.getLocation(node);
  return new (_semanticsEntities().TypeArraySchema)(location, type);
}

/**
 * e.g. keyof typeof Foo
 */
async function typeOperator(node, context) {
  const operatorName = getOperatorName(node.operator);
  const type = await typeNodeToSchema(node.type, context);
  return new (_semanticsEntities().TypeOperatorSchema)(context.getLocation(node), operatorName, type);
}
function getOperatorName(operator) {
  switch (operator) {
    case _typescript().SyntaxKind.KeyOfKeyword:
      return 'keyof';
    case _typescript().SyntaxKind.UniqueKeyword:
      return 'unique';
    case _typescript().SyntaxKind.ReadonlyKeyword:
      return 'readonly';
    default:
      throw new Error(`getOperatorName: unable to find operator name for ${operator}`);
  }
}
async function tupleType(node, context) {
  const elements = await (0, _pMapSeries().default)(node.elements, async elem => {
    const typeSchema = await typeNodeToSchema(elem, context);
    return typeSchema;
  });
  return new (_semanticsEntities().TupleTypeSchema)(context.getLocation(node), elements);
}
async function parenthesizedType(node, context) {
  const type = await typeNodeToSchema(node.type, context);
  return new (_semanticsEntities().ParenthesizedTypeSchema)(context.getLocation(node), type);
}
async function typePredicate(node, context) {
  const parameterName = (0, _typescript().isIdentifier)(node.parameterName) ? node.parameterName.getText() : 'this';
  const type = node.type ? await typeNodeToSchema(node.type, context) : undefined;
  const hasAssertsModifier = Boolean(node.assertsModifier);
  return new (_semanticsEntities().TypePredicateSchema)(context.getLocation(node), parameterName, type, hasAssertsModifier);
}
async function indexedAccessType(node, context) {
  const objectType = await typeNodeToSchema(node.objectType, context);
  const indexType = await typeNodeToSchema(node.indexType, context);
  return new (_semanticsEntities().IndexedAccessSchema)(context.getLocation(node), objectType, indexType);
}
async function templateLiteralType(node, context) {
  const templateSpans = await (0, _pMapSeries().default)(node.templateSpans, span => templateLiteralTypeSpan(span, context));
  const head = node.head.text;
  return new (_semanticsEntities().TemplateLiteralTypeSchema)(context.getLocation(node), head, templateSpans);
}
async function templateLiteralTypeSpan(node, context) {
  const type = await typeNodeToSchema(node.type, context);
  const literal = node.literal.text;
  return new (_semanticsEntities().TemplateLiteralTypeSpanSchema)(context.getLocation(node), literal, type);
}
async function thisType(node, context) {
  return new (_semanticsEntities().ThisTypeSchema)(context.getLocation(node));
}
async function conditionalType(node, context) {
  const checkType = await typeNodeToSchema(node.checkType, context);
  const extendsType = await typeNodeToSchema(node.extendsType, context);
  const trueType = await typeNodeToSchema(node.trueType, context);
  const falseType = await typeNodeToSchema(node.falseType, context);
  return new (_semanticsEntities().ConditionalTypeSchema)(context.getLocation(node), checkType, extendsType, trueType, falseType);
}

//# sourceMappingURL=type-node-to-schema.js.map