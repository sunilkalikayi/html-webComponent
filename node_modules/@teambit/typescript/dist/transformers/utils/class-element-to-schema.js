"use strict";

require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.classElementToSchema = classElementToSchema;
function _typescript() {
  const data = require("typescript");
  _typescript = function () {
    return data;
  };
  return data;
}
function _semanticsEntities() {
  const data = require("@teambit/semantics.entities.semantic-schema");
  _semanticsEntities = function () {
    return data;
  };
  return data;
}
function _getParams() {
  const data = require("./get-params");
  _getParams = function () {
    return data;
  };
  return data;
}
function _typeElementToSchema() {
  const data = require("./type-element-to-schema");
  _typeElementToSchema = function () {
    return data;
  };
  return data;
}
function _parseTypeFromQuickInfo() {
  const data = require("./parse-type-from-quick-info");
  _parseTypeFromQuickInfo = function () {
    return data;
  };
  return data;
}
function _toFunctionLikeSchema() {
  const data = require("./to-function-like-schema");
  _toFunctionLikeSchema = function () {
    return data;
  };
  return data;
}
function _jsdocToDocSchema() {
  const data = require("./jsdoc-to-doc-schema");
  _jsdocToDocSchema = function () {
    return data;
  };
  return data;
}
async function classElementToSchema(node, context) {
  switch (node.kind) {
    case _typescript().SyntaxKind.Constructor:
      return constructor(node, context);
    case _typescript().SyntaxKind.PropertyDeclaration:
      return propertyDeclaration(node, context);
    case _typescript().SyntaxKind.MethodDeclaration:
      return methodDeclaration(node, context);
    case _typescript().SyntaxKind.GetAccessor:
      return (0, _typeElementToSchema().getAccessor)(node, context);
    case _typescript().SyntaxKind.SetAccessor:
      return (0, _typeElementToSchema().setAccessor)(node, context);
    case _typescript().SyntaxKind.IndexSignature:
      return (0, _typeElementToSchema().indexSignature)(node, context);
    case _typescript().SyntaxKind.ClassStaticBlockDeclaration: // not sure what is it, but the name sounds like not something we need
    case _typescript().SyntaxKind.SemicolonClassElement:
      // seems to be just a semicolon
      return null;
    default:
      // should never be here unless typescript added new class elements
      throw new Error(`unrecognized ClassElement type. got ${node.kind}`);
  }
}
async function constructor(node, context) {
  const args = await (0, _getParams().getParams)(node.parameters, context);
  return new (_semanticsEntities().ConstructorSchema)(context.getLocation(node), args);
}
async function propertyDeclaration(node, context) {
  var _info$body;
  const name = node.name.getText();
  const info = await context.getQuickInfo(node.name);
  const displaySig = info === null || info === void 0 ? void 0 : (_info$body = info.body) === null || _info$body === void 0 ? void 0 : _info$body.displayString;
  const typeStr = (0, _parseTypeFromQuickInfo().parseTypeFromQuickInfo)(info);
  const type = await context.resolveType(node, typeStr);
  const isOptional = Boolean(node.questionToken);
  const doc = await (0, _jsdocToDocSchema().jsDocToDocSchema)(node, context);
  return new (_semanticsEntities().VariableLikeSchema)(context.getLocation(node), name, displaySig || '', type, isOptional, doc);
}
async function methodDeclaration(node, context) {
  return (0, _toFunctionLikeSchema().toFunctionLikeSchema)(node, context);
}

//# sourceMappingURL=class-element-to-schema.js.map