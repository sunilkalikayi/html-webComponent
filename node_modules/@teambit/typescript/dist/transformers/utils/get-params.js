"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParams = getParams;
function _semanticsEntities() {
  const data = require("@teambit/semantics.entities.semantic-schema");
  _semanticsEntities = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _typescript() {
  const data = require("typescript");
  _typescript = function () {
    return data;
  };
  return data;
}
function _parseTypeFromQuickInfo() {
  const data = require("./parse-type-from-quick-info");
  _parseTypeFromQuickInfo = function () {
    return data;
  };
  return data;
}
function _typeNodeToSchema() {
  const data = require("./type-node-to-schema");
  _typeNodeToSchema = function () {
    return data;
  };
  return data;
}
async function getParams(parameterNodes, context) {
  return (0, _pMapSeries().default)(parameterNodes, async param => {
    return new (_semanticsEntities().ParameterSchema)(context.getLocation(param), getParamName(param), await getParamType(param, context), Boolean(param.questionToken), param.initializer ? param.initializer.getText() : undefined);
  });
}
function getParamName(param) {
  if ((0, _typescript().isIdentifier)(param.name)) {
    return param.name.getText();
  }
  // it's binding pattern, either an array or an object
  const elements = param.name.elements.map(elem => elem.getText());
  const elementsStr = elements.join(', ');
  if (param.name.kind === _typescript().SyntaxKind.ArrayBindingPattern) {
    return `[ ${elementsStr} ]`;
  }
  // it's an object binding
  return `{ ${elementsStr} }`;
}
async function getParamType(param, context) {
  if (param.type) {
    const type = param.type;
    return (0, _typeNodeToSchema().typeNodeToSchema)(type, context);
  }
  if ((0, _typescript().isIdentifier)(param.name)) {
    const info = await context.getQuickInfo(param.name);
    const parsed = (0, _parseTypeFromQuickInfo().parseTypeFromQuickInfo)(info);
    return new (_semanticsEntities().InferenceTypeSchema)(context.getLocation(param), parsed);
  }
  // it's binding pattern, either an array or an object
  if (param.name.kind === _typescript().SyntaxKind.ArrayBindingPattern) {
    const elements = await (0, _pMapSeries().default)(param.name.elements, async elem => {
      const info = await context.getQuickInfo(elem);
      const parsed = (0, _parseTypeFromQuickInfo().parseTypeFromQuickInfo)(info);
      return new (_semanticsEntities().InferenceTypeSchema)(context.getLocation(param), parsed);
    });
    return new (_semanticsEntities().TupleTypeSchema)(context.getLocation(param), elements);
  }
  if (param.name.kind === _typescript().SyntaxKind.ObjectBindingPattern) {
    const elements = await (0, _pMapSeries().default)(param.name.elements, async elem => {
      const info = await context.getQuickInfo(elem.name);
      const parsed = (0, _parseTypeFromQuickInfo().parseTypeFromQuickInfo)(info);
      return new (_semanticsEntities().InferenceTypeSchema)(context.getLocation(param), parsed, elem.name.getText());
    });
    return new (_semanticsEntities().TypeLiteralSchema)(context.getLocation(param), elements);
  }
  throw new Error(`unknown param type`);
}

//# sourceMappingURL=get-params.js.map