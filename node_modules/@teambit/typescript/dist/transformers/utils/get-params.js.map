{"version":3,"names":["getParams","parameterNodes","context","pMapSeries","param","ParameterSchema","getLocation","getParamName","getParamType","Boolean","questionToken","initializer","getText","undefined","isIdentifier","name","elements","map","elem","elementsStr","join","kind","SyntaxKind","ArrayBindingPattern","type","typeNodeToSchema","info","getQuickInfo","parsed","parseTypeFromQuickInfo","InferenceTypeSchema","TupleTypeSchema","ObjectBindingPattern","TypeLiteralSchema","Error"],"sources":["get-params.ts"],"sourcesContent":["import {\n  InferenceTypeSchema,\n  ParameterSchema,\n  TupleTypeSchema,\n  TypeLiteralSchema,\n  SchemaNode,\n} from '@teambit/semantics.entities.semantic-schema';\nimport pMapSeries from 'p-map-series';\nimport {\n  SyntaxKind,\n  ParameterDeclaration,\n  NodeArray,\n  isIdentifier,\n  BindingElement,\n  ArrayBindingElement,\n} from 'typescript';\nimport { SchemaExtractorContext } from '../../schema-extractor-context';\nimport { parseTypeFromQuickInfo } from './parse-type-from-quick-info';\nimport { typeNodeToSchema } from './type-node-to-schema';\n\nexport async function getParams(\n  parameterNodes: NodeArray<ParameterDeclaration>,\n  context: SchemaExtractorContext\n): Promise<ParameterSchema[]> {\n  return pMapSeries(parameterNodes, async (param) => {\n    return new ParameterSchema(\n      context.getLocation(param),\n      getParamName(param),\n      await getParamType(param, context),\n      Boolean(param.questionToken),\n      param.initializer ? param.initializer.getText() : undefined\n    );\n  });\n}\n\nfunction getParamName(param: ParameterDeclaration): string {\n  if (isIdentifier(param.name)) {\n    return param.name.getText();\n  }\n  // it's binding pattern, either an array or an object\n  const elements = param.name.elements.map((elem) => elem.getText());\n  const elementsStr = elements.join(', ');\n  if (param.name.kind === SyntaxKind.ArrayBindingPattern) {\n    return `[ ${elementsStr} ]`;\n  }\n  // it's an object binding\n  return `{ ${elementsStr} }`;\n}\n\nasync function getParamType(param: ParameterDeclaration, context: SchemaExtractorContext): Promise<SchemaNode> {\n  if (param.type) {\n    const type = param.type;\n    return typeNodeToSchema(type, context);\n  }\n  if (isIdentifier(param.name)) {\n    const info = await context.getQuickInfo(param.name);\n    const parsed = parseTypeFromQuickInfo(info);\n    return new InferenceTypeSchema(context.getLocation(param), parsed);\n  }\n  // it's binding pattern, either an array or an object\n  if (param.name.kind === SyntaxKind.ArrayBindingPattern) {\n    const elements = await pMapSeries(param.name.elements, async (elem: ArrayBindingElement) => {\n      const info = await context.getQuickInfo(elem);\n      const parsed = parseTypeFromQuickInfo(info);\n      return new InferenceTypeSchema(context.getLocation(param), parsed);\n    });\n    return new TupleTypeSchema(context.getLocation(param), elements);\n  }\n  if (param.name.kind === SyntaxKind.ObjectBindingPattern) {\n    const elements = await pMapSeries(param.name.elements, async (elem: BindingElement) => {\n      const info = await context.getQuickInfo(elem.name);\n      const parsed = parseTypeFromQuickInfo(info);\n      return new InferenceTypeSchema(context.getLocation(param), parsed, elem.name.getText());\n    });\n    return new TypeLiteralSchema(context.getLocation(param), elements);\n  }\n  throw new Error(`unknown param type`);\n}\n"],"mappings":"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"}