{"version":3,"names":["ExportDeclaration","predicate","node","kind","SyntaxKind","getIdentifiers","exportDec","context","exportClause","ts","NamedExports","elements","map","elm","ExportIdentifier","name","getText","getSourceFile","fileName","NamespaceExport","moduleSpecifier","getFileExports","transform","specifier","Error","sourceFile","getSourceFileFromNode","computeSchema","schemas","namedExport","Module","getLocation","namespaceExport","isSameNode","nodeA","nodeB","pos","end","Promise","all","element","exportSpecifierToSchemaNode","definitionInfo","UnresolvedSchema","definitionNode","definition","getTypeRefForExternalNode","parent","getLocationAsString","ExportSpecifier","namespace","filePath","getFilePathByNode","getSourceFileInsideComponent","getTypeRefForExternalPath","result"],"sources":["export-declaration.ts"],"sourcesContent":["import { SchemaNode, Module, UnresolvedSchema } from '@teambit/semantics.entities.semantic-schema';\nimport ts, {\n  Node,\n  SyntaxKind,\n  ExportDeclaration as ExportDeclarationNode,\n  NamedExports,\n  NamespaceExport,\n  ExportSpecifier,\n} from 'typescript';\nimport { SchemaExtractorContext } from '../schema-extractor-context';\nimport { SchemaTransformer } from '../schema-transformer';\nimport { ExportIdentifier } from '../export-identifier';\n\nexport class ExportDeclaration implements SchemaTransformer {\n  predicate(node: Node) {\n    return node.kind === SyntaxKind.ExportDeclaration;\n  }\n\n  async getIdentifiers(exportDec: ExportDeclarationNode, context: SchemaExtractorContext) {\n    if (exportDec.exportClause?.kind === ts.SyntaxKind.NamedExports) {\n      exportDec.exportClause as NamedExports;\n      return exportDec.exportClause.elements.map((elm) => {\n        return new ExportIdentifier(elm.name.getText(), elm.getSourceFile().fileName);\n      });\n    }\n\n    if (exportDec.exportClause?.kind === ts.SyntaxKind.NamespaceExport) {\n      return [new ExportIdentifier(exportDec.exportClause.name.getText(), exportDec.getSourceFile().fileName)];\n    }\n\n    if (exportDec.moduleSpecifier) {\n      return context.getFileExports(exportDec);\n    }\n\n    return [];\n  }\n\n  async transform(exportDec: ExportDeclarationNode, context: SchemaExtractorContext): Promise<SchemaNode> {\n    const exportClause = exportDec.exportClause;\n\n    // it's export-all, e.g. `export * from './button'`;\n    if (!exportClause) {\n      const specifier = exportDec.moduleSpecifier;\n      if (!specifier) {\n        throw new Error(`fatal: no specifier`);\n      }\n      const sourceFile = await context.getSourceFileFromNode(specifier);\n      if (!sourceFile) {\n        throw new Error(`unable to find the source-file`);\n      }\n      return context.computeSchema(sourceFile);\n    }\n\n    // e.g. `export { button1, button2 } as Composition from './button';\n    if (exportClause.kind === SyntaxKind.NamedExports) {\n      const schemas = await namedExport(exportClause, context);\n      return new Module(context.getLocation(exportDec), schemas);\n    }\n    // e.g. `export * as Composition from './button';\n    if (exportClause.kind === SyntaxKind.NamespaceExport) {\n      return namespaceExport(exportClause, exportDec, context);\n    }\n\n    // should never reach here. exportClause can be either NamespaceExport or NamedExports\n    throw new Error(`unrecognized exportClause type`);\n  }\n}\n\nfunction isSameNode(nodeA: Node, nodeB: Node): boolean {\n  return nodeA.kind === nodeB.kind && nodeA.pos === nodeB.pos && nodeA.end === nodeB.end;\n}\n\nasync function namedExport(exportClause: NamedExports, context: SchemaExtractorContext): Promise<SchemaNode[]> {\n  const schemas = await Promise.all(\n    exportClause.elements.map(async (element) => {\n      return exportSpecifierToSchemaNode(element, context);\n    })\n  );\n\n  return schemas;\n}\n\nasync function exportSpecifierToSchemaNode(element: ExportSpecifier, context: SchemaExtractorContext) {\n  const definitionInfo = await context.definitionInfo(element);\n\n  if (!definitionInfo) {\n    // happens for example when the main index.ts file exports variable from an mdx file.\n    // tsserver is unable to get the definition node because it doesn't know to parse mdx files.\n    return new UnresolvedSchema(context.getLocation(element.name), element.name.getText());\n  }\n\n  const definitionNode = await context.definition(definitionInfo);\n\n  if (!definitionNode) {\n    return context.getTypeRefForExternalNode(element);\n  }\n\n  // if it is reexported from another export\n  if (isSameNode(element, definitionNode.parent)) {\n    // the definition node is the same node as element.name. tsserver wasn't able to find the source for it\n    // normally, \"bit install\" should fix it. another option is to open vscode and look for errors.\n    throw new Error(`error: tsserver is unable to locate the identifier \"${element.name.getText()}\" at ${context.getLocationAsString(\n      element.name\n    )}.\nmake sure \"bit status\" is clean and there are no errors about missing packages/links.\nalso, make sure the tsconfig.json in the root has the \"jsx\" setting defined.`);\n  }\n\n  if (definitionNode.parent.kind === SyntaxKind.ExportSpecifier)\n    return exportSpecifierToSchemaNode(definitionNode.parent as ExportSpecifier, context);\n\n  return context.computeSchema(definitionNode.parent);\n}\n\nasync function namespaceExport(\n  exportClause: NamespaceExport,\n  exportDec: ExportDeclarationNode,\n  context: SchemaExtractorContext\n) {\n  const namespace = exportClause.name.getText();\n  const filePath = await context.getFilePathByNode(exportClause.name);\n  if (!filePath) {\n    throw new Error(`unable to find the file-path for \"${namespace}\"`);\n  }\n  const sourceFile = context.getSourceFileInsideComponent(filePath);\n  if (!sourceFile) {\n    // it's a namespace from another component or an external package.\n    return context.getTypeRefForExternalPath(namespace, filePath, context.getLocation(exportDec));\n  }\n  const result = await context.computeSchema(sourceFile);\n  if (!(result instanceof Module)) {\n    throw new Error(`expect result to be instance of Module`);\n  }\n  result.namespace = namespace;\n  return result;\n}\n"],"mappings":"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"}