{"version":3,"names":["SchemaExtractorContext","constructor","tsserver","component","extractor","componentDeps","undefined","computeSchema","node","getLocation","targetSourceFile","absolutePath","sourceFile","getSourceFile","position","getLineAndCharacterOfPosition","getStart","line","character","filePath","fileName","getPathRelativeToComponent","pathNormalizeToLinux","getLocationAsString","location","basePath","filesystem","files","base","relative","getSignature","getSignatureHelp","getPath","getPosition","offset","getPositionOfLineAndCharacter","getQuickInfo","err","message","Error","getQuickInfoDisplayString","quickInfo","body","displayString","typeDefinition","getTypeDefinition","visitTypeDefinition","findFileInComponent","find","file","path","includes","strings","map","format","endsWith","string","parsePackageNameFromPath","parts","split","length","lastPart","replace","sep","pkgParts","startsWith","pkgName","getSourceFileInsideComponent","parseSourceFile","getSourceFileFromNode","getFilePathByNode","def","getDefinition","firstDef","head","definitionInfo","definition","definitonInfo","startPosition","start","pos","nodeAtPos","getTokenAtPosition","visitDefinition","getTypeRefForExternalNode","visit","parent","references","isExported","isFromComponent","getFileExports","exportDec","specifierPathStr","moduleSpecifier","getText","specifierPath","substring","absPath","resolve","computeExportedIdentifiers","setExports","exports","_exports","getExportedIdentifiers","jump","TransformerNotFound","resolveType","typeStr","isTypeStrFromQuickInfo","TypeRefSchema","type","ts","isTypeNode","typeNodeToSchema","getDef","headTypeDefinition","unknownExactType","InferenceTypeSchema","info","parseTypeFromQuickInfo","isDefInSameLocation","loc","schemaNode","getTypeRefForExternalPath","getCompIdByPkgName","dep","packageName","componentId","compIdByPath","getComponentIDByPath","compIdByPkg"],"sources":["schema-extractor-context.ts"],"sourcesContent":["import { TsserverClient } from '@teambit/ts-server';\nimport ts, { ExportDeclaration, Node, TypeNode } from 'typescript';\nimport { getTokenAtPosition } from 'tsutils';\nimport { head } from 'lodash';\n// eslint-disable-next-line import/no-unresolved\nimport protocol from 'typescript/lib/protocol';\n// @ts-ignore david we should figure fix this.\nimport type { AbstractVinyl } from '@teambit/legacy/dist/consumer/component/sources';\nimport { pathNormalizeToLinux } from '@teambit/legacy/dist/utils';\nimport { resolve, sep, relative } from 'path';\nimport { Component, ComponentID } from '@teambit/component';\nimport { TypeRefSchema, SchemaNode, InferenceTypeSchema, Location } from '@teambit/semantics.entities.semantic-schema';\nimport { ComponentDependency } from '@teambit/dependency-resolver';\nimport { TypeScriptExtractor } from './typescript.extractor';\nimport { ExportList } from './export-list';\nimport { typeNodeToSchema } from './transformers/utils/type-node-to-schema';\nimport { TransformerNotFound } from './exceptions';\nimport { parseTypeFromQuickInfo } from './transformers/utils/parse-type-from-quick-info';\n\nexport class SchemaExtractorContext {\n  constructor(\n    readonly tsserver: TsserverClient,\n    readonly component: Component,\n    readonly extractor: TypeScriptExtractor,\n    readonly componentDeps: ComponentDependency[]\n  ) {}\n\n  computeSchema(node: Node) {\n    return this.extractor.computeSchema(node, this);\n  }\n\n  /**\n   * returns the location of a node in a source file.\n   */\n  getLocation(node: Node, targetSourceFile?: ts.SourceFile, absolutePath = false): Location {\n    const sourceFile = targetSourceFile || node.getSourceFile();\n    const position = sourceFile.getLineAndCharacterOfPosition(node.getStart());\n    const line = position.line + 1;\n    const character = position.character + 1;\n    const filePath = absolutePath ? sourceFile.fileName : this.getPathRelativeToComponent(sourceFile.fileName);\n\n    return {\n      filePath: pathNormalizeToLinux(filePath),\n      line,\n      character,\n    };\n  }\n\n  getLocationAsString(node: Node): string {\n    const location = this.getLocation(node);\n    return `${node.getSourceFile().fileName}, line: ${location.line}, character: ${location.character}`;\n  }\n\n  getPathRelativeToComponent(filePath: string): string {\n    const basePath = this.component.filesystem.files[0].base;\n    return relative(basePath, filePath);\n  }\n\n  /**\n   * returns a signature for a node.\n   */\n  async getSignature(node: Node) {\n    return this.tsserver.getSignatureHelp(this.getPath(node), this.getLocation(node));\n  }\n\n  /**\n   * get the position for the tsserver.\n   */\n  getPosition(sourceFile: ts.SourceFile, line: number, offset: number): number {\n    return sourceFile.getPositionOfLineAndCharacter(line - 1, offset - 1);\n  }\n\n  /**\n   * get the path for a source file.\n   */\n  getPath(node: Node) {\n    const sourceFile = node.getSourceFile();\n    return sourceFile.fileName;\n  }\n\n  async getQuickInfo(node: Node) {\n    const location = this.getLocation(node);\n    try {\n      return await this.tsserver.getQuickInfo(this.getPath(node), location);\n    } catch (err: any) {\n      if (err.message === 'No content available.') {\n        throw new Error(\n          `unable to get quickinfo data from tsserver at ${this.getPath(node)}, Ln ${location.line}, Col ${\n            location.character\n          }`\n        );\n      }\n      throw err;\n    }\n  }\n\n  async getQuickInfoDisplayString(node: Node): Promise<string> {\n    const quickInfo = await this.getQuickInfo(node);\n    return quickInfo?.body?.displayString || '';\n  }\n\n  /**\n   * returns the type definition for a type.\n   */\n  typeDefinition(node: Node) {\n    return this.tsserver.getTypeDefinition(this.getPath(node), this.getLocation(node));\n  }\n\n  visitTypeDefinition() {}\n\n  private findFileInComponent(filePath: string) {\n    return this.component.filesystem.files.find((file) => {\n      // TODO: fix this line to support further extensions.\n      if (file.path.includes(filePath)) {\n        const strings = ['ts', 'tsx', 'js', 'jsx'].map((format) => {\n          if (filePath.endsWith(format)) return filePath;\n          return `${filePath}.${format}`;\n        });\n\n        return strings.find((string) => string === file.path);\n      }\n\n      return false;\n    });\n  }\n\n  private parsePackageNameFromPath(path: string) {\n    const parts = path.split('node_modules');\n    if (parts.length === 1) return '';\n    const lastPart = parts[parts.length - 1].replace(sep, '');\n    const pkgParts = lastPart.split('/');\n    if (lastPart.startsWith('@')) {\n      // scoped package\n      return `${pkgParts[0]}/${pkgParts[1]}`;\n    }\n    const pkgName = pkgParts[0];\n    if (pkgName === 'typescript') {\n      // it's a built-in type, such as \"string\".\n      return '';\n    }\n    return pkgName;\n  }\n\n  /**\n   * return the file if part of the component.\n   * otherwise, a reference to the target package and the type name.\n   */\n  getSourceFileInsideComponent(filePath: string) {\n    const file = this.findFileInComponent(filePath);\n    if (!file) return undefined;\n    return this.extractor.parseSourceFile(file);\n  }\n\n  async getSourceFileFromNode(node: Node) {\n    const filePath = await this.getFilePathByNode(node);\n    if (!filePath) {\n      return undefined;\n    }\n    return this.getSourceFileInsideComponent(filePath);\n  }\n\n  async getFilePathByNode(node: Node) {\n    const def = await this.tsserver.getDefinition(this.getPath(node), this.getLocation(node));\n\n    const firstDef = head(def.body);\n    return firstDef?.file;\n  }\n\n  async definitionInfo(node: Node): Promise<protocol.DefinitionInfo | undefined> {\n    const location = this.getLocation(node);\n    const filePath = this.getPath(node);\n\n    const def = await this.tsserver.getDefinition(filePath, location);\n\n    const firstDef = head(def.body);\n\n    return firstDef;\n  }\n\n  /**\n   * get a definition for a given node.\n   */\n  async definition(definitonInfo: protocol.DefinitionInfo): Promise<Node | undefined> {\n    const startPosition = definitonInfo.start;\n    const sourceFile = this.getSourceFileInsideComponent(definitonInfo.file);\n    if (!sourceFile) {\n      // it might be an external reference, cant get the node\n      return undefined;\n    }\n    const pos = this.getPosition(sourceFile, startPosition.line, startPosition.offset);\n    const nodeAtPos = getTokenAtPosition(sourceFile, pos);\n    return nodeAtPos;\n  }\n\n  /**\n   * visit a definition for node - e.g. return it's schema.\n   */\n  async visitDefinition(node: Node): Promise<SchemaNode | undefined> {\n    const definitionInfo = await this.definitionInfo(node);\n    if (!definitionInfo) {\n      return undefined;\n    }\n\n    const definition = await this.definition(definitionInfo);\n    if (!definition) {\n      return this.getTypeRefForExternalNode(node);\n    }\n\n    return this.visit(definition.parent);\n  }\n\n  async visit(node: Node): Promise<SchemaNode> {\n    return this.extractor.computeSchema(node, this);\n  }\n\n  references() {}\n\n  isExported() {}\n\n  isFromComponent() {}\n\n  async getFileExports(exportDec: ExportDeclaration) {\n    const file = exportDec.getSourceFile().fileName;\n    const specifierPathStr = exportDec.moduleSpecifier?.getText() || '';\n    const specifierPath = specifierPathStr.substring(1, specifierPathStr.length - 1);\n    const absPath = resolve(file, '..', specifierPath);\n    const sourceFile = this.getSourceFileInsideComponent(absPath);\n    if (!sourceFile) return [];\n    return this.extractor.computeExportedIdentifiers(sourceFile, this);\n  }\n\n  _exports: ExportList | undefined = undefined;\n\n  setExports(exports: ExportList) {\n    this._exports = exports;\n    return this;\n  }\n\n  getExportedIdentifiers(node: Node) {\n    return this.extractor.computeExportedIdentifiers(node, this);\n  }\n\n  async jump(file: AbstractVinyl, start: any): Promise<SchemaNode | undefined> {\n    const sourceFile = this.extractor.parseSourceFile(file);\n    const pos = this.getPosition(sourceFile, start.line, start.offset);\n    const nodeAtPos = getTokenAtPosition(sourceFile, pos);\n    if (!nodeAtPos) return undefined;\n\n    // this causes some infinite loops. it's helpful for getting more data from types that are not exported.\n    // e.g.\n    // ```ts\n    // class Bar {}\n    // export const getBar = () => new Bar();\n    // ```\n    // if (nodeAtPos.kind === ts.SyntaxKind.Identifier) {\n    //   // @todo: make sure with Ran that it's fine. Maybe it's better to do: `this.visit(nodeAtPos.parent);`\n    //   return this.visitDefinition(nodeAtPos);\n    // }\n    try {\n      return await this.visit(nodeAtPos);\n    } catch (err) {\n      if (err instanceof TransformerNotFound) {\n        return undefined;\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * resolve a type by a node and its identifier.\n   */\n  async resolveType(\n    node: Node & { type?: TypeNode },\n    typeStr: string,\n    isTypeStrFromQuickInfo = true\n  ): Promise<SchemaNode> {\n    const location = this.getLocation(node);\n    if (this._exports?.includes(typeStr)) {\n      return new TypeRefSchema(location, typeStr);\n    }\n    if (node.type && ts.isTypeNode(node.type)) {\n      // if a node has \"type\" prop, it has the type data of the node. this normally happens when the code has the type\n      // explicitly, e.g. `const str: string` vs implicitly `const str = 'some-string'`, which the node won't have \"type\"\n      return typeNodeToSchema(node.type, this);\n    }\n    /**\n     * tsserver has two different calls: \"definition\" and \"typeDefinition\".\n     * normally, we need the \"typeDefinition\" to get the type data of a node.\n     * sometimes, it has no data, for example when the node is of type TypeReference, and then using \"definition\" is\n     * helpful. (couldn't find a rule when to use each one. e.g. \"VariableDeclaration\" sometimes has data only in\n     * \"definition\" but it's not clear when/why).\n     */\n    const getDef = async () => {\n      const typeDefinition = await this.typeDefinition(node);\n      const headTypeDefinition = head(typeDefinition?.body);\n      if (headTypeDefinition) {\n        return headTypeDefinition;\n      }\n      const definition = await this.tsserver.getDefinition(node.getSourceFile().fileName, this.getLocation(node));\n      return head(definition?.body);\n    };\n    const definition = await getDef();\n\n    // when we can't figure out the component/package/type of this node, we'll use the typeStr as the type.\n    const unknownExactType = async () => {\n      if (isTypeStrFromQuickInfo) {\n        return new InferenceTypeSchema(location, typeStr || 'any');\n      }\n      const info = await this.getQuickInfo(node);\n      const type = parseTypeFromQuickInfo(info);\n      return new InferenceTypeSchema(location, type, typeStr);\n    };\n    if (!definition) {\n      return unknownExactType();\n    }\n\n    // the reason for this check is to avoid infinite loop when calling `this.jump` with the same file+location\n    const isDefInSameLocation = () => {\n      if (definition.file !== node.getSourceFile().fileName) {\n        return false;\n      }\n      const loc = this.getLocation(node);\n      return loc.line === definition.start.line && loc.character === definition.start.offset;\n    };\n\n    const file = this.findFileInComponent(definition.file);\n    if (file) {\n      if (isDefInSameLocation()) {\n        return unknownExactType();\n      }\n      const schemaNode = await this.jump(file, definition.start);\n      return schemaNode || unknownExactType();\n    }\n    return this.getTypeRefForExternalPath(typeStr, definition.file, location);\n  }\n\n  private getCompIdByPkgName(pkgName: string): ComponentID | undefined {\n    return this.componentDeps.find((dep) => dep.packageName === pkgName)?.componentId;\n  }\n\n  async getTypeRefForExternalNode(node: Node): Promise<TypeRefSchema> {\n    const info = await this.getQuickInfo(node);\n    const typeStr = parseTypeFromQuickInfo(info);\n    const location = this.getLocation(node);\n    const filePath = this.getPath(node);\n    return this.getTypeRefForExternalPath(typeStr, filePath, location);\n  }\n\n  async getTypeRefForExternalPath(typeStr: string, filePath: string, location: Location): Promise<TypeRefSchema> {\n    const compIdByPath = await this.extractor.getComponentIDByPath(filePath);\n    if (compIdByPath) {\n      return new TypeRefSchema(location, typeStr, compIdByPath);\n    }\n    const pkgName = this.parsePackageNameFromPath(filePath);\n    const compIdByPkg = this.getCompIdByPkgName(pkgName);\n    if (compIdByPkg) {\n      return new TypeRefSchema(location, typeStr, compIdByPkg);\n    }\n    return new TypeRefSchema(location, typeStr, undefined, pkgName);\n  }\n}\n"],"mappings":"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"}