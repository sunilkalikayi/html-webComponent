"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TsconfigWriter = void 0;
exports.dedupePaths = dedupePaths;
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _yesno() {
  const data = _interopRequireDefault(require("yesno"));
  _yesno = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/prompts/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
class TsconfigWriter {
  constructor(workspace, logger) {
    this.workspace = workspace;
    this.logger = logger;
  }
  async write(envsExecutionContext, options) {
    const pathsPerEnvs = this.getPathsPerEnv(envsExecutionContext, options);
    const tsconfigPathsPerEnv = pathsPerEnvs.map(pathsPerEnv => ({
      envIds: pathsPerEnv.ids,
      tsconfig: pathsPerEnv.env.getTsConfig(),
      paths: pathsPerEnv.paths
    }));
    if (options.dryRun) return tsconfigPathsPerEnv;
    if (!options.silent) await this.promptForWriting(tsconfigPathsPerEnv.map(p => p.paths).flat());
    await this.writeFiles(tsconfigPathsPerEnv);
    return tsconfigPathsPerEnv;
  }
  async clean(envsExecutionContext, {
    dryRun,
    silent
  }) {
    const pathsPerEnvs = this.getPathsPerEnv(envsExecutionContext, {
      dedupe: false
    });
    const componentPaths = pathsPerEnvs.map(p => p.paths).flat();
    const allPossibleDirs = getAllPossibleDirsFromPaths(componentPaths);
    const dirsWithTsconfig = await filterDirsWithTsconfigFile(allPossibleDirs);
    const tsconfigFiles = dirsWithTsconfig.map(dir => _path().default.join(dir, 'tsconfig.json'));
    if (dryRun) return tsconfigFiles;
    if (!dirsWithTsconfig.length) return [];
    if (!silent) await this.promptForCleaning(tsconfigFiles);
    await this.deleteFiles(tsconfigFiles);
    return tsconfigFiles;
  }
  async promptForWriting(dirs) {
    this.logger.clearStatusLine();
    const tsconfigFiles = dirs.map(dir => _path().default.join(dir, 'tsconfig.json'));
    const ok = await (0, _yesno().default)({
      question: `${_chalk().default.underline('The following paths will be written:')}
${tsconfigFiles.join('\n')}
${_chalk().default.bold('Do you want to continue? [yes(y)/no(n)]')}`
    });
    if (!ok) {
      throw new (_exceptions().PromptCanceled)();
    }
  }
  async promptForCleaning(tsconfigFiles) {
    this.logger.clearStatusLine();
    const ok = await (0, _yesno().default)({
      question: `${_chalk().default.underline('The following paths will be deleted:')}
${tsconfigFiles.join('\n')}
${_chalk().default.bold('Do you want to continue? [yes(y)/no(n)]')}`
    });
    if (!ok) {
      throw new (_exceptions().PromptCanceled)();
    }
  }
  async deleteFiles(tsconfigFiles) {
    await Promise.all(tsconfigFiles.map(f => _fsExtra().default.remove(f)));
  }
  async writeFiles(tsconfigPathsPerEnvs) {
    await Promise.all(tsconfigPathsPerEnvs.map(pathsPerEnv => {
      return Promise.all(pathsPerEnv.paths.map(p => _fsExtra().default.writeJSON(_path().default.join(p, 'tsconfig.json'), pathsPerEnv.tsconfig, {
        spaces: 2
      })));
    }));
  }
  getPathsPerEnv(envsExecutionContext, {
    dedupe
  }) {
    const pathsPerEnvs = envsExecutionContext.map(envExecution => {
      return {
        id: envExecution.id,
        env: envExecution.env,
        paths: envExecution.components.map(c => this.workspace.componentDir(c.id, undefined, {
          relative: true
        }))
      };
    });
    if (!dedupe) {
      return pathsPerEnvs.map(({
        id,
        env,
        paths
      }) => ({
        ids: [id],
        env,
        paths
      }));
    }
    const envsWithFiles = envsExecutionContext.map(e => ({
      id: e.id,
      file: e.env.getTsConfig()
    }));
    const envsPerFile = [];
    const isEnvProcessed = envId => envsPerFile.map(e => e.envIds).flat().find(e => e === envId);
    envsWithFiles.forEach(({
      id,
      file
    }) => {
      if (isEnvProcessed(id)) return;
      const foundSameFile = envsWithFiles.filter(e => (0, _lodash().isEqual)(file, e.file));
      envsPerFile.push({
        envIds: foundSameFile.map(f => f.id),
        fileContent: file
      });
    });
    const pathsPerEnvIds = envsPerFile.map(e => ({
      ids: e.envIds,
      paths: (0, _lodash().compact)(e.envIds.map(envId => {
        var _pathsPerEnvs$find;
        return (_pathsPerEnvs$find = pathsPerEnvs.find(p => p.id === envId)) === null || _pathsPerEnvs$find === void 0 ? void 0 : _pathsPerEnvs$find.paths;
      }).flat())
    }));
    // const pathsPerEnvIds = pathsPerEnvs.map((p) => ({ ids: p.ids, paths: p.paths }));
    const envsPerDedupedPaths = dedupePaths(pathsPerEnvIds);
    const dedupedPathsPerEnvs = envsPerDedupedPaths.map(envWithDedupePaths => {
      const found = pathsPerEnvs.find(p => envWithDedupePaths.ids.includes(p.id));
      if (!found) throw new Error(`dedupedPathsPerEnvs, unable to find ${envWithDedupePaths.ids}`);
      return {
        env: found.env,
        ids: envWithDedupePaths.ids,
        paths: envWithDedupePaths.paths
      };
    });
    return dedupedPathsPerEnvs;
  }
}
exports.TsconfigWriter = TsconfigWriter;
async function filterDirsWithTsconfigFile(dirs) {
  const dirsWithTsconfig = await Promise.all(dirs.map(async dir => {
    const hasTsconfig = await _fsExtra().default.pathExists(_path().default.join(dir, 'tsconfig.json'));
    return hasTsconfig ? dir : undefined;
  }));
  return (0, _lodash().compact)(dirsWithTsconfig);
}
function getAllPossibleDirsFromPaths(paths) {
  const dirs = paths.map(p => getAllParentsDirOfPath(p)).flat();
  dirs.push('.'); // add the root dir
  return (0, _lodash().uniq)(dirs);
}
function getAllParentsDirOfPath(p) {
  const all = [];
  let current = p;
  while (current !== '.') {
    all.push(current);
    current = _path().default.dirname(current);
  }
  return all;
}

/**
 * easier to understand by an example:
 * input:
 * [
 *   { id: react, paths: [ui/button, ui/form] },
 *   { id: aspect, paths: [p/a1, p/a2] },
 *   { id: node, paths: [p/n1] },
 * ]
 *
 * output:
 * [
 *   { id: react, paths: [ui] },
 *   { id: aspect, paths: [p] },
 *   { id: node, paths: [p/n1] },
 * ]
 *
 * the goal is to minimize the amount of files to write per env if possible.
 * when multiple components of the same env share a root-dir, then, it's enough to write a file in that shared dir.
 * if in a shared-dir, some components using env1 and some env2, it finds the env that has the max number of
 * components, this env will be optimized. other components, will have the files written inside their dirs.
 */
function dedupePaths(pathsPerEnvId) {
  const rootDir = '.';
  const individualPathPerConcatenatedEnvIds = pathsPerEnvId.reduce((acc, current) => {
    current.paths.forEach(p => {
      acc[p] = current.ids.join(',');
    });
    return acc;
  }, {});
  const allPaths = Object.keys(individualPathPerConcatenatedEnvIds);
  const allPossibleDirs = getAllPossibleDirsFromPaths(allPaths);
  const allPathsPerEnvId = {}; // null when parent-dir has same amount of comps per env.

  const calculateBestEnvForDir = dir => {
    if (individualPathPerConcatenatedEnvIds[dir]) {
      // it's the component dir, so it's the best env
      allPathsPerEnvId[dir] = individualPathPerConcatenatedEnvIds[dir];
      return;
    }
    const allPathsShareSameDir = dir === rootDir ? allPaths : allPaths.filter(p => p.startsWith(`${dir}/`));
    const countPerEnv = {};
    allPathsShareSameDir.forEach(p => {
      const envIdStr = individualPathPerConcatenatedEnvIds[p];
      if (countPerEnv[envIdStr]) countPerEnv[envIdStr] += 1;else countPerEnv[envIdStr] = 1;
    });
    const max = Math.max(...Object.values(countPerEnv));
    const envWithMax = Object.keys(countPerEnv).filter(env => countPerEnv[env] === max);
    if (!envWithMax.length) throw new Error(`must be at least one env related to path "${dir}"`);
    if (envWithMax.length > 1) allPathsPerEnvId[dir] = null;else allPathsPerEnvId[dir] = envWithMax[0];
  };
  allPossibleDirs.forEach(dirPath => {
    calculateBestEnvForDir(dirPath);
  });

  // this is the actual deduping. if found a shorter path with the same env, then no need for this path.
  // in other words, return only the paths that their parent is null or has a different env.
  const dedupedPathsPerEnvIds = Object.keys(allPathsPerEnvId).reduce((acc, current) => {
    if (allPathsPerEnvId[current] && allPathsPerEnvId[_path().default.dirname(current)] !== allPathsPerEnvId[current]) {
      acc[current] = allPathsPerEnvId[current];
    }
    return acc;
  }, {});
  // rootDir parent is always rootDir, so leave it as is.
  if (allPathsPerEnvId[rootDir]) dedupedPathsPerEnvIds[rootDir] = allPathsPerEnvId[rootDir];
  const envIdsPerDedupedPaths = (0, _lodash().invertBy)(dedupedPathsPerEnvIds);
  return Object.keys(envIdsPerDedupedPaths).map(envIdStr => ({
    ids: envIdStr.split(','),
    paths: envIdsPerDedupedPaths[envIdStr]
  }));
}

//# sourceMappingURL=tsconfig-writer.js.map