"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
class WriteTsconfigCmd {
  constructor(tsMain) {
    this.tsMain = tsMain;
    (0, _defineProperty2().default)(this, "name", 'write-tsconfig');
    (0, _defineProperty2().default)(this, "description", 'EXPERIMENTAL. write tsconfig.json files in the component directories');
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "options", [['c', 'clean', 'delete tsconfig files from the workspace. highly recommended to run it with "--dry-run" first'], ['s', 'silent', 'do not prompt for confirmation'], ['', 'no-dedupe', "write tsconfig.json inside each one of the component's dir, avoid deduping"], ['', 'dry-run', 'show the paths that tsconfig will be written per env'], ['', 'dry-run-with-tsconfig', 'use with --json flag. show the tsconfig.json content and the paths it will be written per env'], ['j', 'json', 'json format']]);
  }
  async report(_args, flags) {
    const {
      cleanResults,
      writeResults
    } = await this.json(_args, flags);
    if (flags.dryRunWithTsconfig) {
      throw new Error(`use --json flag along with --dry-run-with-tsconfig`);
    }
    const isDryRun = flags.dryRun;
    const cleanResultsOutput = cleanResults ? `${_chalk().default.green(`the following paths ${isDryRun ? 'will be' : 'were'} deleted`)}\n${cleanResults.join('\n')}\n\n` : '';
    const totalFiles = writeResults.map(r => r.paths.length).reduce((acc, current) => acc + current);
    const writeTitle = isDryRun ? _chalk().default.green(`${totalFiles} files will be written`) : _chalk().default.green(`${totalFiles} files have been written successfully`);
    const writeOutput = writeResults.map(result => {
      const paths = result.paths.map(p => _path().default.join(p, 'tsconfig.json')).map(str => `  ${str}`).join('\n');
      return `The following paths are according to env(s) ${_chalk().default.bold(result.envIds.join(', '))}\n${paths}`;
    }).join('\n\n');
    return `${cleanResultsOutput}${writeTitle}\n${writeOutput}`;
  }
  async json(_args, flags) {
    const {
      clean,
      silent,
      noDedupe,
      dryRunWithTsconfig
    } = flags;
    const dryRun = dryRunWithTsconfig ? true : flags.dryRun;
    const {
      cleanResults,
      writeResults
    } = await this.tsMain.writeTsconfigJson({
      clean,
      dedupe: !noDedupe,
      dryRun,
      dryRunWithTsconfig,
      silent
    });
    if (dryRun) {
      const writeJson = dryRunWithTsconfig ? writeResults : writeResults.map(s => (0, _lodash().omit)(s, ['tsconfig']));
      // return JSON.stringify({ cleanResults, writeResults: writeJson }, undefined, 2);
      return {
        cleanResults,
        writeResults: writeJson
      };
    }
    return {
      cleanResults,
      writeResults
    };
  }
}
exports.default = WriteTsconfigCmd;

//# sourceMappingURL=write-tsconfig.cmd.js.map