"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TypescriptMain = void 0;
exports.runTransformersWithContext = runTransformersWithContext;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _typescript() {
  const data = _interopRequireDefault(require("typescript"));
  _typescript = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _schema() {
  const data = require("@teambit/schema");
  _schema = function () {
    return data;
  };
  return data;
}
function _typescriptModules() {
  const data = require("@teambit/typescript.modules.ts-config-mutator");
  _typescriptModules = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = require("@teambit/workspace");
  _workspace = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _tsServer() {
  const data = require("@teambit/ts-server");
  _tsServer = function () {
    return data;
  };
  return data;
}
function _aspectLoader() {
  const data = _interopRequireDefault(require("@teambit/aspect-loader"));
  _aspectLoader = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = _interopRequireDefault(require("@teambit/envs"));
  _envs = function () {
    return data;
  };
  return data;
}
function _typescript2() {
  const data = require("./typescript.extractor");
  _typescript2 = function () {
    return data;
  };
  return data;
}
function _typescript3() {
  const data = require("./typescript.aspect");
  _typescript3 = function () {
    return data;
  };
  return data;
}
function _typescript4() {
  const data = require("./typescript.compiler");
  _typescript4 = function () {
    return data;
  };
  return data;
}
function _typescript5() {
  const data = require("./typescript.parser");
  _typescript5 = function () {
    return data;
  };
  return data;
}
function _schemaTransformer() {
  const data = require("./schema-transformer.plugin");
  _schemaTransformer = function () {
    return data;
  };
  return data;
}
function _transformers() {
  const data = require("./transformers");
  _transformers = function () {
    return data;
  };
  return data;
}
function _checkTypes() {
  const data = require("./cmds/check-types.cmd");
  _checkTypes = function () {
    return data;
  };
  return data;
}
function _tsconfigWriter() {
  const data = require("./tsconfig-writer");
  _tsconfigWriter = function () {
    return data;
  };
  return data;
}
function _writeTsconfig() {
  const data = _interopRequireDefault(require("./cmds/write-tsconfig.cmd"));
  _writeTsconfig = function () {
    return data;
  };
  return data;
}
class TypescriptMain {
  constructor(logger, schemaTransformerSlot, workspace, depResolver, envs, tsConfigWriter) {
    this.logger = logger;
    this.schemaTransformerSlot = schemaTransformerSlot;
    this.workspace = workspace;
    this.depResolver = depResolver;
    this.envs = envs;
    this.tsConfigWriter = tsConfigWriter;
    (0, _defineProperty2().default)(this, "tsServer", void 0);
  }
  /**
   * create a new compiler.
   */
  createCompiler(options, transformers = [], tsModule = _typescript().default) {
    const configMutator = new (_typescriptModules().TypescriptConfigMutator)(options);
    const transformerContext = {};
    const afterMutation = runTransformersWithContext(configMutator.clone(), transformers, transformerContext);
    return new (_typescript4().TypescriptCompiler)(_typescript3().TypescriptAspect.id, this.logger, afterMutation.raw, tsModule);
  }

  /**
   * get TsserverClient instance if initiated already, otherwise, return undefined.
   */
  getTsserverClient() {
    return this.tsServer;
  }

  /**
   * starts a tsserver process to communicate with its API.
   * @param projectPath absolute path of the project root directory
   * @param options TsserverClientOpts
   * @param files optionally, if check-types is enabled, provide files to open and type check.
   * @returns TsserverClient
   */
  async initTsserverClient(projectPath, options = {}, files = []) {
    this.tsServer = new (_tsServer().TsserverClient)(projectPath, this.logger, options, files);
    this.tsServer.init();
    return this.tsServer;
  }

  /**
   * starts a tsserver process to communicate with its API. use only when running on the workspace.
   * @param options TsserverClientOpts
   * @param files optionally, if check-types is enabled, provide files to open and type check.
   * @returns TsserverClient
   */
  async initTsserverClientFromWorkspace(options = {}, files = []) {
    if (!this.workspace) {
      throw new Error(`initTsserverClientFromWorkspace: workspace was not found`);
    }
    return this.initTsserverClient(this.workspace.path, options, files);
  }

  /**
   * Create a compiler instance and run the cjs transformer for it
   * @param options
   * @param transformers
   * @param tsModule
   * @returns
   */
  createCjsCompiler(options, transformers = [], tsModule = _typescript().default) {
    return this.createCompiler(options, [this.getCjsTransformer(), ...transformers], tsModule);
  }

  /**
   * Create a compiler instance and run the esm transformer for it
   * @param options
   * @param transformers
   * @param tsModule
   * @returns
   */
  createEsmCompiler(options, transformers = [], tsModule = _typescript().default) {
    return this.createCompiler(options, [this.getEsmTransformer(), ...transformers], tsModule);
  }

  /**
   * Create a transformer that change the ts module to CommonJS
   * @returns
   */
  getCjsTransformer() {
    const cjsTransformer = config => {
      config.setModule('CommonJS');
      return config;
    };
    return cjsTransformer;
  }

  /**
   * Create a transformer that change the ts module to ES2020
   * @returns
   */
  getEsmTransformer() {
    const esmTransformer = config => {
      config.setModule('ES2020');
      return config;
    };
    return esmTransformer;
  }

  /**
   * create an instance of a typescript semantic schema extractor.
   */
  createSchemaExtractor(tsconfig, path) {
    return new (_typescript2().TypeScriptExtractor)(tsconfig, this.schemaTransformerSlot, this, path || this.workspace.path, this.depResolver, this.workspace);
  }

  /**
   * add the default package json properties to the component
   * :TODO @gilad why do we need this DSL? can't I just get the args here.
   */
  getCjsPackageJsonProps() {
    return {
      main: 'dist/{main}.js',
      types: '{main}.ts'
    };
  }

  /**
   * add type: module to the package.json props and the default props
   * :TODO @gilad why do we need this DSL? can't I just get the args here.
   */
  getEsmPackageJsonProps() {
    return {
      // main: 'dist-esm/{main}.js',
      main: 'dist/{main}.js',
      type: 'module',
      types: '{main}.ts'
    };
  }
  getSupportedFilesForTsserver(components) {
    const files = components.map(c => c.filesystem.files).flat().map(f => f.path);
    return files.filter(f => f.endsWith('.ts') || f.endsWith('.tsx'));
  }
  async cleanTsconfigJson(options = {}) {
    const components = await this.workspace.list();
    const runtime = await this.envs.createEnvironment(components);
    const execContext = runtime.getEnvExecutionContext();
    const results = await new (_tsconfigWriter().TsconfigWriter)(this.workspace, this.logger).clean(execContext, options);
    return results;
  }
  async writeTsconfigJson(options = {}) {
    const components = await this.workspace.list();
    const runtime = await this.envs.createEnvironment(components);
    const execContext = runtime.getEnvExecutionContext();
    let cleanResults;
    if (options.clean) {
      cleanResults = await this.tsConfigWriter.clean(execContext, options);
    }
    const writeResults = await this.tsConfigWriter.write(execContext, options);
    return {
      writeResults,
      cleanResults
    };
  }
  async onPreWatch(components, watchOpts) {
    const workspace = this.workspace;
    if (!workspace || !watchOpts.spawnTSServer) {
      return;
    }
    const {
      verbose,
      checkTypes
    } = watchOpts;
    const files = checkTypes ? this.getSupportedFilesForTsserver(components) : [];
    const printTypeErrors = Boolean(checkTypes);
    await this.initTsserverClientFromWorkspace({
      verbose,
      checkTypes,
      printTypeErrors
    }, files);
  }
  async onComponentChange(component, files) {
    if (!this.tsServer) {
      return {
        results: 'N/A'
      };
    }
    await (0, _pMapSeries().default)(files, file => this.tsServer.onFileChange(file));
    return {
      results: 'succeed'
    };
  }
  static async provider([schema, loggerExt, aspectLoader, workspace, cli, depResolver, envs], config, [schemaTransformerSlot]) {
    schema.registerParser(new (_typescript5().TypeScriptParser)());
    const logger = loggerExt.createLogger(_typescript3().TypescriptAspect.id);
    aspectLoader.registerPlugins([new (_schemaTransformer().SchemaTransformerPlugin)(schemaTransformerSlot)]);
    const tsconfigWriter = new (_tsconfigWriter().TsconfigWriter)(workspace, logger);
    const tsMain = new TypescriptMain(logger, schemaTransformerSlot, workspace, depResolver, envs, tsconfigWriter);
    schemaTransformerSlot.register([new (_transformers().ExportDeclaration)(), new (_transformers().FunctionDeclaration)(), new (_transformers().VariableStatementTransformer)(), new (_transformers().VariableDeclaration)(), new (_transformers().SourceFileTransformer)(), new (_transformers().TypeAliasTransformer)(), new (_transformers().ClassDecelerationTransformer)(), new (_transformers().InterfaceDeclarationTransformer)(), new (_transformers().EnumDeclarationTransformer)(), new (_transformers().BindingElementTransformer)()]);
    if (workspace) {
      workspace.registerOnPreWatch(tsMain.onPreWatch.bind(this));
      workspace.registerOnComponentChange(tsMain.onComponentChange.bind(this));
      workspace.registerOnComponentAdd(tsMain.onComponentChange.bind(this));
    }
    const checkTypesCmd = new (_checkTypes().CheckTypesCmd)(tsMain, workspace, logger);
    const writeTsconfigCmd = new (_writeTsconfig().default)(tsMain);
    cli.register(checkTypesCmd, writeTsconfigCmd);
    return tsMain;
  }
}
exports.TypescriptMain = TypescriptMain;
(0, _defineProperty2().default)(TypescriptMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(TypescriptMain, "dependencies", [_schema().SchemaAspect, _logger().LoggerAspect, _aspectLoader().default, _workspace().WorkspaceAspect, _cli().CLIAspect, _dependencyResolver().DependencyResolverAspect, _envs().default]);
(0, _defineProperty2().default)(TypescriptMain, "slots", [_harmony().Slot.withType()]);
_typescript3().TypescriptAspect.addRuntime(TypescriptMain);
function runTransformersWithContext(config, transformers = [], context) {
  if (!Array.isArray(transformers)) return config;
  const newConfig = transformers.reduce((acc, transformer) => {
    return transformer(acc, context);
  }, config);
  return newConfig;
}
var _default = TypescriptMain;
exports.default = _default;

//# sourceMappingURL=typescript.main.runtime.js.map