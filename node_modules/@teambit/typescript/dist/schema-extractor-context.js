"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SchemaExtractorContext = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _typescript() {
  const data = _interopRequireDefault(require("typescript"));
  _typescript = function () {
    return data;
  };
  return data;
}
function _tsutils() {
  const data = require("tsutils");
  _tsutils = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@teambit/legacy/dist/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _semanticsEntities() {
  const data = require("@teambit/semantics.entities.semantic-schema");
  _semanticsEntities = function () {
    return data;
  };
  return data;
}
function _typeNodeToSchema() {
  const data = require("./transformers/utils/type-node-to-schema");
  _typeNodeToSchema = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _parseTypeFromQuickInfo() {
  const data = require("./transformers/utils/parse-type-from-quick-info");
  _parseTypeFromQuickInfo = function () {
    return data;
  };
  return data;
}
class SchemaExtractorContext {
  constructor(tsserver, component, extractor, componentDeps) {
    this.tsserver = tsserver;
    this.component = component;
    this.extractor = extractor;
    this.componentDeps = componentDeps;
    (0, _defineProperty2().default)(this, "_exports", undefined);
  }
  computeSchema(node) {
    return this.extractor.computeSchema(node, this);
  }

  /**
   * returns the location of a node in a source file.
   */
  getLocation(node, targetSourceFile, absolutePath = false) {
    const sourceFile = targetSourceFile || node.getSourceFile();
    const position = sourceFile.getLineAndCharacterOfPosition(node.getStart());
    const line = position.line + 1;
    const character = position.character + 1;
    const filePath = absolutePath ? sourceFile.fileName : this.getPathRelativeToComponent(sourceFile.fileName);
    return {
      filePath: (0, _utils().pathNormalizeToLinux)(filePath),
      line,
      character
    };
  }
  getLocationAsString(node) {
    const location = this.getLocation(node);
    return `${node.getSourceFile().fileName}, line: ${location.line}, character: ${location.character}`;
  }
  getPathRelativeToComponent(filePath) {
    const basePath = this.component.filesystem.files[0].base;
    return (0, _path().relative)(basePath, filePath);
  }

  /**
   * returns a signature for a node.
   */
  async getSignature(node) {
    return this.tsserver.getSignatureHelp(this.getPath(node), this.getLocation(node));
  }

  /**
   * get the position for the tsserver.
   */
  getPosition(sourceFile, line, offset) {
    return sourceFile.getPositionOfLineAndCharacter(line - 1, offset - 1);
  }

  /**
   * get the path for a source file.
   */
  getPath(node) {
    const sourceFile = node.getSourceFile();
    return sourceFile.fileName;
  }
  async getQuickInfo(node) {
    const location = this.getLocation(node);
    try {
      return await this.tsserver.getQuickInfo(this.getPath(node), location);
    } catch (err) {
      if (err.message === 'No content available.') {
        throw new Error(`unable to get quickinfo data from tsserver at ${this.getPath(node)}, Ln ${location.line}, Col ${location.character}`);
      }
      throw err;
    }
  }
  async getQuickInfoDisplayString(node) {
    var _quickInfo$body;
    const quickInfo = await this.getQuickInfo(node);
    return (quickInfo === null || quickInfo === void 0 ? void 0 : (_quickInfo$body = quickInfo.body) === null || _quickInfo$body === void 0 ? void 0 : _quickInfo$body.displayString) || '';
  }

  /**
   * returns the type definition for a type.
   */
  typeDefinition(node) {
    return this.tsserver.getTypeDefinition(this.getPath(node), this.getLocation(node));
  }
  visitTypeDefinition() {}
  findFileInComponent(filePath) {
    return this.component.filesystem.files.find(file => {
      // TODO: fix this line to support further extensions.
      if (file.path.includes(filePath)) {
        const strings = ['ts', 'tsx', 'js', 'jsx'].map(format => {
          if (filePath.endsWith(format)) return filePath;
          return `${filePath}.${format}`;
        });
        return strings.find(string => string === file.path);
      }
      return false;
    });
  }
  parsePackageNameFromPath(path) {
    const parts = path.split('node_modules');
    if (parts.length === 1) return '';
    const lastPart = parts[parts.length - 1].replace(_path().sep, '');
    const pkgParts = lastPart.split('/');
    if (lastPart.startsWith('@')) {
      // scoped package
      return `${pkgParts[0]}/${pkgParts[1]}`;
    }
    const pkgName = pkgParts[0];
    if (pkgName === 'typescript') {
      // it's a built-in type, such as "string".
      return '';
    }
    return pkgName;
  }

  /**
   * return the file if part of the component.
   * otherwise, a reference to the target package and the type name.
   */
  getSourceFileInsideComponent(filePath) {
    const file = this.findFileInComponent(filePath);
    if (!file) return undefined;
    return this.extractor.parseSourceFile(file);
  }
  async getSourceFileFromNode(node) {
    const filePath = await this.getFilePathByNode(node);
    if (!filePath) {
      return undefined;
    }
    return this.getSourceFileInsideComponent(filePath);
  }
  async getFilePathByNode(node) {
    const def = await this.tsserver.getDefinition(this.getPath(node), this.getLocation(node));
    const firstDef = (0, _lodash().head)(def.body);
    return firstDef === null || firstDef === void 0 ? void 0 : firstDef.file;
  }
  async definitionInfo(node) {
    const location = this.getLocation(node);
    const filePath = this.getPath(node);
    const def = await this.tsserver.getDefinition(filePath, location);
    const firstDef = (0, _lodash().head)(def.body);
    return firstDef;
  }

  /**
   * get a definition for a given node.
   */
  async definition(definitonInfo) {
    const startPosition = definitonInfo.start;
    const sourceFile = this.getSourceFileInsideComponent(definitonInfo.file);
    if (!sourceFile) {
      // it might be an external reference, cant get the node
      return undefined;
    }
    const pos = this.getPosition(sourceFile, startPosition.line, startPosition.offset);
    const nodeAtPos = (0, _tsutils().getTokenAtPosition)(sourceFile, pos);
    return nodeAtPos;
  }

  /**
   * visit a definition for node - e.g. return it's schema.
   */
  async visitDefinition(node) {
    const definitionInfo = await this.definitionInfo(node);
    if (!definitionInfo) {
      return undefined;
    }
    const definition = await this.definition(definitionInfo);
    if (!definition) {
      return this.getTypeRefForExternalNode(node);
    }
    return this.visit(definition.parent);
  }
  async visit(node) {
    return this.extractor.computeSchema(node, this);
  }
  references() {}
  isExported() {}
  isFromComponent() {}
  async getFileExports(exportDec) {
    var _exportDec$moduleSpec;
    const file = exportDec.getSourceFile().fileName;
    const specifierPathStr = ((_exportDec$moduleSpec = exportDec.moduleSpecifier) === null || _exportDec$moduleSpec === void 0 ? void 0 : _exportDec$moduleSpec.getText()) || '';
    const specifierPath = specifierPathStr.substring(1, specifierPathStr.length - 1);
    const absPath = (0, _path().resolve)(file, '..', specifierPath);
    const sourceFile = this.getSourceFileInsideComponent(absPath);
    if (!sourceFile) return [];
    return this.extractor.computeExportedIdentifiers(sourceFile, this);
  }
  setExports(exports) {
    this._exports = exports;
    return this;
  }
  getExportedIdentifiers(node) {
    return this.extractor.computeExportedIdentifiers(node, this);
  }
  async jump(file, start) {
    const sourceFile = this.extractor.parseSourceFile(file);
    const pos = this.getPosition(sourceFile, start.line, start.offset);
    const nodeAtPos = (0, _tsutils().getTokenAtPosition)(sourceFile, pos);
    if (!nodeAtPos) return undefined;

    // this causes some infinite loops. it's helpful for getting more data from types that are not exported.
    // e.g.
    // ```ts
    // class Bar {}
    // export const getBar = () => new Bar();
    // ```
    // if (nodeAtPos.kind === ts.SyntaxKind.Identifier) {
    //   // @todo: make sure with Ran that it's fine. Maybe it's better to do: `this.visit(nodeAtPos.parent);`
    //   return this.visitDefinition(nodeAtPos);
    // }
    try {
      return await this.visit(nodeAtPos);
    } catch (err) {
      if (err instanceof _exceptions().TransformerNotFound) {
        return undefined;
      }
      throw err;
    }
  }

  /**
   * resolve a type by a node and its identifier.
   */
  async resolveType(node, typeStr, isTypeStrFromQuickInfo = true) {
    var _this$_exports;
    const location = this.getLocation(node);
    if ((_this$_exports = this._exports) !== null && _this$_exports !== void 0 && _this$_exports.includes(typeStr)) {
      return new (_semanticsEntities().TypeRefSchema)(location, typeStr);
    }
    if (node.type && _typescript().default.isTypeNode(node.type)) {
      // if a node has "type" prop, it has the type data of the node. this normally happens when the code has the type
      // explicitly, e.g. `const str: string` vs implicitly `const str = 'some-string'`, which the node won't have "type"
      return (0, _typeNodeToSchema().typeNodeToSchema)(node.type, this);
    }
    /**
     * tsserver has two different calls: "definition" and "typeDefinition".
     * normally, we need the "typeDefinition" to get the type data of a node.
     * sometimes, it has no data, for example when the node is of type TypeReference, and then using "definition" is
     * helpful. (couldn't find a rule when to use each one. e.g. "VariableDeclaration" sometimes has data only in
     * "definition" but it's not clear when/why).
     */
    const getDef = async () => {
      const typeDefinition = await this.typeDefinition(node);
      const headTypeDefinition = (0, _lodash().head)(typeDefinition === null || typeDefinition === void 0 ? void 0 : typeDefinition.body);
      if (headTypeDefinition) {
        return headTypeDefinition;
      }
      const definition = await this.tsserver.getDefinition(node.getSourceFile().fileName, this.getLocation(node));
      return (0, _lodash().head)(definition === null || definition === void 0 ? void 0 : definition.body);
    };
    const definition = await getDef();

    // when we can't figure out the component/package/type of this node, we'll use the typeStr as the type.
    const unknownExactType = async () => {
      if (isTypeStrFromQuickInfo) {
        return new (_semanticsEntities().InferenceTypeSchema)(location, typeStr || 'any');
      }
      const info = await this.getQuickInfo(node);
      const type = (0, _parseTypeFromQuickInfo().parseTypeFromQuickInfo)(info);
      return new (_semanticsEntities().InferenceTypeSchema)(location, type, typeStr);
    };
    if (!definition) {
      return unknownExactType();
    }

    // the reason for this check is to avoid infinite loop when calling `this.jump` with the same file+location
    const isDefInSameLocation = () => {
      if (definition.file !== node.getSourceFile().fileName) {
        return false;
      }
      const loc = this.getLocation(node);
      return loc.line === definition.start.line && loc.character === definition.start.offset;
    };
    const file = this.findFileInComponent(definition.file);
    if (file) {
      if (isDefInSameLocation()) {
        return unknownExactType();
      }
      const schemaNode = await this.jump(file, definition.start);
      return schemaNode || unknownExactType();
    }
    return this.getTypeRefForExternalPath(typeStr, definition.file, location);
  }
  getCompIdByPkgName(pkgName) {
    var _this$componentDeps$f;
    return (_this$componentDeps$f = this.componentDeps.find(dep => dep.packageName === pkgName)) === null || _this$componentDeps$f === void 0 ? void 0 : _this$componentDeps$f.componentId;
  }
  async getTypeRefForExternalNode(node) {
    const info = await this.getQuickInfo(node);
    const typeStr = (0, _parseTypeFromQuickInfo().parseTypeFromQuickInfo)(info);
    const location = this.getLocation(node);
    const filePath = this.getPath(node);
    return this.getTypeRefForExternalPath(typeStr, filePath, location);
  }
  async getTypeRefForExternalPath(typeStr, filePath, location) {
    const compIdByPath = await this.extractor.getComponentIDByPath(filePath);
    if (compIdByPath) {
      return new (_semanticsEntities().TypeRefSchema)(location, typeStr, compIdByPath);
    }
    const pkgName = this.parsePackageNameFromPath(filePath);
    const compIdByPkg = this.getCompIdByPkgName(pkgName);
    if (compIdByPkg) {
      return new (_semanticsEntities().TypeRefSchema)(location, typeStr, compIdByPkg);
    }
    return new (_semanticsEntities().TypeRefSchema)(location, typeStr, undefined, pkgName);
  }
}
exports.SchemaExtractorContext = SchemaExtractorContext;

//# sourceMappingURL=schema-extractor-context.js.map