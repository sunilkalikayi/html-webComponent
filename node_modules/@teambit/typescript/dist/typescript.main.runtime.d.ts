import ts from 'typescript';
import { SlotRegistry } from '@teambit/harmony';
import { CLIMain } from '@teambit/cli';
import { Compiler } from '@teambit/compiler';
import { Logger, LoggerMain } from '@teambit/logger';
import { SchemaExtractor, SchemaMain } from '@teambit/schema';
import { PackageJsonProps } from '@teambit/pkg';
import { TypescriptConfigMutator } from '@teambit/typescript.modules.ts-config-mutator';
import type { Workspace } from '@teambit/workspace';
import { DependencyResolverMain } from '@teambit/dependency-resolver';
import { TsserverClient, TsserverClientOpts } from '@teambit/ts-server';
import { AspectLoaderMain } from '@teambit/aspect-loader';
import type { Component } from '@teambit/component';
import { EnvsMain } from '@teambit/envs';
import { TypeScriptCompilerOptions } from './compiler-options';
import { SchemaTransformer } from './schema-transformer';
import { TsconfigPathsPerEnv, TsconfigWriter } from './tsconfig-writer';
export declare type TsMode = 'build' | 'dev';
export declare type SchemaTransformerSlot = SlotRegistry<SchemaTransformer[]>;
export declare type TsConfigTransformContext = {};
export declare type TsconfigWriterOptions = {
    clean?: boolean;
    silent?: boolean;
    dedupe?: boolean;
    dryRun?: boolean;
    dryRunWithTsconfig?: boolean;
};
export declare type TsConfigTransformer = (config: TypescriptConfigMutator, context: TsConfigTransformContext) => TypescriptConfigMutator;
export declare class TypescriptMain {
    private logger;
    private schemaTransformerSlot;
    private workspace;
    private depResolver;
    private envs;
    private tsConfigWriter;
    constructor(logger: Logger, schemaTransformerSlot: SchemaTransformerSlot, workspace: Workspace, depResolver: DependencyResolverMain, envs: EnvsMain, tsConfigWriter: TsconfigWriter);
    private tsServer;
    /**
     * create a new compiler.
     */
    createCompiler(options: TypeScriptCompilerOptions, transformers?: TsConfigTransformer[], tsModule?: typeof ts): Compiler;
    /**
     * get TsserverClient instance if initiated already, otherwise, return undefined.
     */
    getTsserverClient(): TsserverClient | undefined;
    /**
     * starts a tsserver process to communicate with its API.
     * @param projectPath absolute path of the project root directory
     * @param options TsserverClientOpts
     * @param files optionally, if check-types is enabled, provide files to open and type check.
     * @returns TsserverClient
     */
    initTsserverClient(projectPath: string, options?: TsserverClientOpts, files?: string[]): Promise<TsserverClient>;
    /**
     * starts a tsserver process to communicate with its API. use only when running on the workspace.
     * @param options TsserverClientOpts
     * @param files optionally, if check-types is enabled, provide files to open and type check.
     * @returns TsserverClient
     */
    initTsserverClientFromWorkspace(options?: TsserverClientOpts, files?: string[]): Promise<TsserverClient>;
    /**
     * Create a compiler instance and run the cjs transformer for it
     * @param options
     * @param transformers
     * @param tsModule
     * @returns
     */
    createCjsCompiler(options: TypeScriptCompilerOptions, transformers?: TsConfigTransformer[], tsModule?: typeof ts): Compiler;
    /**
     * Create a compiler instance and run the esm transformer for it
     * @param options
     * @param transformers
     * @param tsModule
     * @returns
     */
    createEsmCompiler(options: TypeScriptCompilerOptions, transformers?: TsConfigTransformer[], tsModule?: typeof ts): Compiler;
    /**
     * Create a transformer that change the ts module to CommonJS
     * @returns
     */
    getCjsTransformer(): TsConfigTransformer;
    /**
     * Create a transformer that change the ts module to ES2020
     * @returns
     */
    getEsmTransformer(): TsConfigTransformer;
    /**
     * create an instance of a typescript semantic schema extractor.
     */
    createSchemaExtractor(tsconfig: any, path?: string): SchemaExtractor;
    /**
     * add the default package json properties to the component
     * :TODO @gilad why do we need this DSL? can't I just get the args here.
     */
    getCjsPackageJsonProps(): PackageJsonProps;
    /**
     * add type: module to the package.json props and the default props
     * :TODO @gilad why do we need this DSL? can't I just get the args here.
     */
    getEsmPackageJsonProps(): PackageJsonProps;
    getSupportedFilesForTsserver(components: Component[]): string[];
    cleanTsconfigJson(options?: TsconfigWriterOptions): Promise<string[]>;
    writeTsconfigJson(options?: TsconfigWriterOptions): Promise<{
        cleanResults?: string[];
        writeResults: TsconfigPathsPerEnv[];
    }>;
    private onPreWatch;
    private onComponentChange;
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: import("@teambit/harmony").Aspect[];
    static slots: ((registerFn: () => string) => SlotRegistry<SchemaTransformer[]>)[];
    static provider([schema, loggerExt, aspectLoader, workspace, cli, depResolver, envs]: [
        SchemaMain,
        LoggerMain,
        AspectLoaderMain,
        Workspace,
        CLIMain,
        DependencyResolverMain,
        EnvsMain
    ], config: any, [schemaTransformerSlot]: [SchemaTransformerSlot]): Promise<TypescriptMain>;
}
export declare function runTransformersWithContext(config: TypescriptConfigMutator, transformers: TsConfigTransformer[] | undefined, context: TsConfigTransformContext): TypescriptConfigMutator;
export default TypescriptMain;
