"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PnpmPackageManager = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _modulesYaml() {
  const data = require("@pnpm/modules-yaml");
  _modulesYaml = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _userHome() {
  const data = _interopRequireDefault(require("user-home"));
  _userHome = function () {
    return data;
  };
  return data;
}
function _readConfig() {
  const data = require("./read-config");
  _readConfig = function () {
    return data;
  };
  return data;
}
const defaultStoreDir = (0, _path().join)(_userHome().default, '.pnpm-store');
const defaultCacheDir = (0, _path().join)(_userHome().default, '.pnpm-cache');
class PnpmPackageManager {
  constructor(depResolver, logger) {
    this.depResolver = depResolver;
    this.logger = logger;
    (0, _defineProperty2().default)(this, "readConfig", (0, _lodash().memoize)(_readConfig().readConfig));
  }
  async _getGlobalPnpmDirs(opts = {}) {
    var _config$storeDir, _config$cacheDir;
    const {
      config
    } = await this.readConfig(opts.packageManagerConfigRootDir);
    const storeDir = opts.cacheRootDir ? (0, _path().join)(opts.cacheRootDir, '.pnpm-store') : (_config$storeDir = config.storeDir) !== null && _config$storeDir !== void 0 ? _config$storeDir : defaultStoreDir;
    const cacheDir = opts.cacheRootDir ? (0, _path().join)(opts.cacheRootDir, '.pnpm-cache') : (_config$cacheDir = config.cacheDir) !== null && _config$cacheDir !== void 0 ? _config$cacheDir : defaultCacheDir;
    return {
      storeDir,
      cacheDir
    };
  }
  async install({
    rootDir,
    manifests
  }, installOptions = {}) {
    var _installOptions$engin, _installOptions$nodeV, _installOptions$packa, _installOptions$sideE, _installOptions$sideE2;
    // require it dynamically for performance purpose. the pnpm package require many files - do not move to static import
    // eslint-disable-next-line global-require, import/no-dynamic-require
    const {
      install
    } = require('./lynx');
    this.logger.debug(`running installation in root dir ${rootDir}`);
    this.logger.debug('components manifests for installation', manifests);
    this.logger.setStatusLine('installing dependencies using pnpm');
    // turn off the logger because it interrupts the pnpm output
    this.logger.off();
    const registries = await this.depResolver.getRegistries();
    const proxyConfig = await this.depResolver.getProxyConfig();
    const networkConfig = await this.depResolver.getNetworkConfig();
    const {
      storeDir,
      cacheDir
    } = await this._getGlobalPnpmDirs(installOptions);
    const {
      config
    } = await this.readConfig(installOptions.packageManagerConfigRootDir);
    if (!installOptions.useNesting) {
      manifests = await (0, _dependencyResolver().extendWithComponentsFromDir)(rootDir, manifests);
    }
    await install(rootDir, manifests, storeDir, cacheDir, registries, proxyConfig, networkConfig, {
      engineStrict: (_installOptions$engin = installOptions.engineStrict) !== null && _installOptions$engin !== void 0 ? _installOptions$engin : config.engineStrict,
      nodeLinker: installOptions.nodeLinker,
      nodeVersion: (_installOptions$nodeV = installOptions.nodeVersion) !== null && _installOptions$nodeV !== void 0 ? _installOptions$nodeV : config.nodeVersion,
      overrides: installOptions.overrides,
      hoistPattern: config.hoistPattern,
      publicHoistPattern: ['*eslint*', '@prettier/plugin-*', '*prettier-plugin-*'],
      packageImportMethod: (_installOptions$packa = installOptions.packageImportMethod) !== null && _installOptions$packa !== void 0 ? _installOptions$packa : config.packageImportMethod,
      rootComponents: installOptions.rootComponents,
      rootComponentsForCapsules: installOptions.rootComponentsForCapsules,
      peerDependencyRules: installOptions.peerDependencyRules,
      sideEffectsCacheRead: (_installOptions$sideE = installOptions.sideEffectsCache) !== null && _installOptions$sideE !== void 0 ? _installOptions$sideE : true,
      sideEffectsCacheWrite: (_installOptions$sideE2 = installOptions.sideEffectsCache) !== null && _installOptions$sideE2 !== void 0 ? _installOptions$sideE2 : true
    }, this.logger);
    this.logger.on();
    // Make a divider row to improve output
    this.logger.console('-------------------------');
    this.logger.consoleSuccess('installing dependencies using pnpm');
  }
  async getPeerDependencyIssues(rootDir, manifests, installOptions = {}) {
    var _installOptions$packa2;
    const {
      storeDir,
      cacheDir
    } = await this._getGlobalPnpmDirs(installOptions);
    const proxyConfig = await this.depResolver.getProxyConfig();
    const networkConfig = await this.depResolver.getNetworkConfig();
    const registries = await this.depResolver.getRegistries();
    // require it dynamically for performance purpose. the pnpm package require many files - do not move to static import
    // eslint-disable-next-line global-require, import/no-dynamic-require
    const lynx = require('./lynx');
    const {
      config
    } = await this.readConfig();
    return lynx.getPeerDependencyIssues(manifests, {
      storeDir,
      cacheDir,
      proxyConfig,
      registries,
      rootDir,
      networkConfig,
      overrides: installOptions.overrides,
      packageImportMethod: (_installOptions$packa2 = installOptions.packageImportMethod) !== null && _installOptions$packa2 !== void 0 ? _installOptions$packa2 : config.packageImportMethod
    });
  }
  async resolveRemoteVersion(packageName, options) {
    // require it dynamically for performance purpose. the pnpm package require many files - do not move to static import
    // eslint-disable-next-line global-require, import/no-dynamic-require
    const {
      resolveRemoteVersion
    } = require('./lynx');
    const {
      cacheDir
    } = await this._getGlobalPnpmDirs(options);
    const registries = await this.depResolver.getRegistries();
    const proxyConfig = await this.depResolver.getProxyConfig();
    const networkConfig = await this.depResolver.getNetworkConfig();
    return resolveRemoteVersion(packageName, options.rootDir, cacheDir, registries, proxyConfig, networkConfig);
  }
  async getProxyConfig() {
    // eslint-disable-next-line global-require, import/no-dynamic-require
    const {
      getProxyConfig
    } = require('./get-proxy-config');
    const {
      config
    } = await this.readConfig();
    return getProxyConfig(config);
  }
  async getNetworkConfig() {
    const {
      config
    } = await this.readConfig();
    // We need to use config.rawConfig as it will only contain the settings defined by the user.
    // config contains default values of the settings when they are not defined by the user.
    return {
      maxSockets: config.rawConfig['max-sockets'],
      networkConcurrency: config.rawConfig['network-concurrency'],
      fetchRetries: config.rawConfig['fetch-retries'],
      fetchTimeout: config.rawConfig['fetch-timeout'],
      fetchRetryMaxtimeout: config.rawConfig['fetch-retry-maxtimeout'],
      fetchRetryMintimeout: config.rawConfig['fetch-retry-mintimeout'],
      strictSSL: config.rawConfig['strict-ssl'],
      // These settings don't have default value, so it is safe to read them from config
      // ca is automatically populated from the content of the file specified by cafile.
      ca: config.ca,
      cert: config.cert,
      key: config.key
    };
  }
  async getRegistries() {
    // eslint-disable-next-line global-require, import/no-dynamic-require
    const {
      getRegistries
    } = require('./get-registries');
    const {
      config
    } = await this.readConfig();
    const pnpmRegistry = await getRegistries(config);
    const defaultRegistry = new (_dependencyResolver().Registry)(pnpmRegistry.default.uri, pnpmRegistry.default.alwaysAuth, pnpmRegistry.default.authHeaderValue, pnpmRegistry.default.originalAuthType, pnpmRegistry.default.originalAuthValue);
    const pnpmScoped = (0, _lodash().omit)(pnpmRegistry, ['default']);
    const scopesRegistries = Object.keys(pnpmScoped).reduce((acc, scopedRegName) => {
      const scopedReg = pnpmScoped[scopedRegName];
      const name = scopedRegName.replace('@', '');
      acc[name] = new (_dependencyResolver().Registry)(scopedReg.uri, scopedReg.alwaysAuth, scopedReg.authHeaderValue, scopedReg.originalAuthType, scopedReg.originalAuthValue);
      return acc;
    }, {});

    // Add bit registry server if not exist
    if (!scopesRegistries.bit) {
      scopesRegistries.bit = new (_dependencyResolver().Registry)(_dependencyResolver().BIT_DEV_REGISTRY, true);
    }
    return new (_dependencyResolver().Registries)(defaultRegistry, scopesRegistries);
  }
  async getInjectedDirs(rootDir, componentDir) {
    var _modulesState$injecte, _modulesState$injecte2;
    const modulesState = await (0, _modulesYaml().readModulesManifest)((0, _path().join)(rootDir, 'node_modules'));
    return (_modulesState$injecte = modulesState === null || modulesState === void 0 ? void 0 : (_modulesState$injecte2 = modulesState.injectedDeps) === null || _modulesState$injecte2 === void 0 ? void 0 : _modulesState$injecte2[componentDir]) !== null && _modulesState$injecte !== void 0 ? _modulesState$injecte : [];
  }
}
exports.PnpmPackageManager = PnpmPackageManager;

//# sourceMappingURL=pnpm.package-manager.js.map