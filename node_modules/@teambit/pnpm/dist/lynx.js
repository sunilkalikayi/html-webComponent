"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPeerDependencyIssues = getPeerDependencyIssues;
exports.install = install;
exports.resolveRemoteVersion = resolveRemoteVersion;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _gracefulFs() {
  const data = _interopRequireDefault(require("graceful-fs"));
  _gracefulFs = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _semver() {
  const data = _interopRequireDefault(require("semver"));
  _semver = function () {
    return data;
  };
  return data;
}
function _parsePackageName() {
  const data = _interopRequireDefault(require("parse-package-name"));
  _parsePackageName = function () {
    return data;
  };
  return data;
}
function _defaultReporter() {
  const data = require("@pnpm/default-reporter");
  _defaultReporter = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@pnpm/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _modulesYaml() {
  const data = require("@pnpm/modules-yaml");
  _modulesYaml = function () {
    return data;
  };
  return data;
}
function _storeConnectionManager() {
  const data = require("@pnpm/store-connection-manager");
  _storeConnectionManager = function () {
    return data;
  };
  return data;
}
function _sortPackages() {
  const data = require("@pnpm/sort-packages");
  _sortPackages = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function pnpm() {
  const data = _interopRequireWildcard(require("@pnpm/core"));
  pnpm = function () {
    return data;
  };
  return data;
}
function _client() {
  const data = require("@pnpm/client");
  _client = function () {
    return data;
  };
  return data;
}
function _pickRegistryForPackage() {
  const data = require("@pnpm/pick-registry-for-package");
  _pickRegistryForPackage = function () {
    return data;
  };
  return data;
}
function _nerfDart() {
  const data = _interopRequireDefault(require("nerf-dart"));
  _nerfDart = function () {
    return data;
  };
  return data;
}
function _util() {
  const data = require("util");
  _util = function () {
    return data;
  };
  return data;
}
function _pkgsGraph() {
  const data = require("pkgs-graph");
  _pkgsGraph = function () {
    return data;
  };
  return data;
}
function _userHome() {
  const data = _interopRequireDefault(require("user-home"));
  _userHome = function () {
    return data;
  };
  return data;
}
function _pnpmErrorToBitError() {
  const data = require("./pnpm-error-to-bit-error");
  _pnpmErrorToBitError = function () {
    return data;
  };
  return data;
}
function _readConfig() {
  const data = require("./read-config");
  _readConfig = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const link = (0, _util().promisify)(_gracefulFs().default.link);
const installsRunning = {};
const STORE_CACHE = {};
async function createStoreController(options) {
  var _options$proxyConfig, _options$proxyConfig2, _options$networkConfi, _options$networkConfi2, _options$networkConfi3, _options$networkConfi4, _options$proxyConfig3;
  const authConfig = getAuthConfig(options.registries);
  const opts = {
    dir: options.rootDir,
    cacheDir: options.cacheDir,
    storeDir: options.storeDir,
    rawConfig: authConfig,
    verifyStoreIntegrity: true,
    httpProxy: (_options$proxyConfig = options.proxyConfig) === null || _options$proxyConfig === void 0 ? void 0 : _options$proxyConfig.httpProxy,
    httpsProxy: (_options$proxyConfig2 = options.proxyConfig) === null || _options$proxyConfig2 === void 0 ? void 0 : _options$proxyConfig2.httpsProxy,
    ca: (_options$networkConfi = options.networkConfig) === null || _options$networkConfi === void 0 ? void 0 : _options$networkConfi.ca,
    cert: (_options$networkConfi2 = options.networkConfig) === null || _options$networkConfi2 === void 0 ? void 0 : _options$networkConfi2.cert,
    key: (_options$networkConfi3 = options.networkConfig) === null || _options$networkConfi3 === void 0 ? void 0 : _options$networkConfi3.key,
    localAddress: (_options$networkConfi4 = options.networkConfig) === null || _options$networkConfi4 === void 0 ? void 0 : _options$networkConfi4.localAddress,
    noProxy: (_options$proxyConfig3 = options.proxyConfig) === null || _options$proxyConfig3 === void 0 ? void 0 : _options$proxyConfig3.noProxy,
    strictSsl: options.networkConfig.strictSSL,
    maxSockets: options.networkConfig.maxSockets,
    networkConcurrency: options.networkConfig.networkConcurrency,
    packageImportMethod: options.packageImportMethod,
    pnpmHomeDir: _path().default.join(_userHome().default, '.pnpm') // This is not actually used in our case
  };
  // We should avoid the recreation of store.
  // The store holds cache that makes subsequent resolutions faster.
  const cacheKey = JSON.stringify(opts);
  if (!STORE_CACHE[cacheKey]) {
    // Although it would be enough to call createNewStoreController(),
    // that doesn't resolve the store directory location.
    STORE_CACHE[cacheKey] = await (0, _storeConnectionManager().createOrConnectStoreController)(opts);
  }
  return STORE_CACHE[cacheKey];
}
async function generateResolverAndFetcher(cacheDir, registries, proxyConfig = {}, networkConfig = {}) {
  const pnpmConfig = await (0, _readConfig().readConfig)();
  const authConfig = getAuthConfig(registries);
  const opts = {
    authConfig: Object.assign({}, pnpmConfig.config.rawConfig, authConfig),
    cacheDir,
    httpProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.httpProxy,
    httpsProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.httpsProxy,
    ca: networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.ca,
    cert: networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.cert,
    key: networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.key,
    localAddress: networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.localAddress,
    noProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.noProxy,
    strictSsl: networkConfig.strictSSL,
    timeout: networkConfig.fetchTimeout,
    retry: {
      factor: networkConfig.fetchRetryFactor,
      maxTimeout: networkConfig.fetchRetryMaxtimeout,
      minTimeout: networkConfig.fetchRetryMintimeout,
      retries: networkConfig.fetchRetries
    }
  };
  const result = (0, _client().createClient)(opts);
  return result;
}
async function getPeerDependencyIssues(manifestsByPaths, opts) {
  const projects = [];
  const workspacePackages = {};
  for (const [rootDir, manifest] of Object.entries(manifestsByPaths)) {
    projects.push({
      buildIndex: 0,
      // this is not used while searching for peer issues anyway
      manifest,
      rootDir
    });
    workspacePackages[manifest.name] = workspacePackages[manifest.name] || {};
    workspacePackages[manifest.name][manifest.version] = {
      dir: rootDir,
      manifest
    };
  }
  const registriesMap = getRegistriesMap(opts.registries);
  const storeController = await createStoreController(_objectSpread(_objectSpread({}, opts), {}, {
    rootDir: opts.rootDir
  }));
  return pnpm().getPeerDependencyIssues(projects, {
    storeController: storeController.ctrl,
    storeDir: storeController.dir,
    overrides: opts.overrides,
    workspacePackages,
    registries: registriesMap
  });
}
async function install(rootDir, manifestsByPaths, storeDir, cacheDir, registries, proxyConfig = {}, networkConfig = {}, options,
// eslint-disable-next-line @typescript-eslint/no-unused-vars
logger) {
  if (!manifestsByPaths[rootDir].dependenciesMeta) {
    manifestsByPaths = _objectSpread(_objectSpread({}, manifestsByPaths), {}, {
      [rootDir]: _objectSpread(_objectSpread({}, manifestsByPaths[rootDir]), {}, {
        dependenciesMeta: {}
      })
    });
  }
  const readPackage = [];
  let hoistingLimits = new Map();
  if (options !== null && options !== void 0 && options.rootComponents) {
    const {
      rootComponentWrappers,
      rootComponents
    } = createRootComponentWrapperManifests(rootDir, manifestsByPaths);
    manifestsByPaths = _objectSpread(_objectSpread({}, rootComponentWrappers), manifestsByPaths);
    readPackage.push(readPackageHook);
    hoistingLimits = new Map();
    hoistingLimits.set('.@', new Set(rootComponents));
  } else if (options !== null && options !== void 0 && options.rootComponentsForCapsules) {
    readPackage.push(readPackageHookForCapsules);
  }
  const {
    allProjects,
    packagesToBuild,
    workspacePackages
  } = groupPkgs(manifestsByPaths);
  const registriesMap = getRegistriesMap(registries);
  const authConfig = getAuthConfig(registries);
  const storeController = await createStoreController({
    rootDir,
    storeDir,
    cacheDir,
    registries,
    proxyConfig,
    networkConfig,
    packageImportMethod: options === null || options === void 0 ? void 0 : options.packageImportMethod
  });
  const opts = _objectSpread(_objectSpread({
    allProjects,
    storeDir: storeController.dir,
    dir: rootDir,
    storeController: storeController.ctrl,
    workspacePackages,
    preferFrozenLockfile: true,
    pruneLockfileImporters: true,
    modulesCacheMaxAge: 0,
    registries: registriesMap,
    rawConfig: authConfig,
    hooks: {
      readPackage
    },
    hoistingLimits,
    strictPeerDependencies: false
  }, options), {}, {
    peerDependencyRules: _objectSpread({
      allowAny: ['*'],
      ignoreMissing: ['*']
    }, options === null || options === void 0 ? void 0 : options.peerDependencyRules)
  });
  const stopReporting = (0, _defaultReporter().initDefaultReporter)({
    context: {
      argv: []
    },
    reportingOptions: {
      appendOnly: false,
      throttleProgress: 200
    },
    streamParser: _logger().streamParser
  });
  try {
    await installsRunning[rootDir];
    installsRunning[rootDir] = (0, pnpm().mutateModules)(packagesToBuild, opts);
    await installsRunning[rootDir];
    delete installsRunning[rootDir];
  } catch (err) {
    throw (0, _pnpmErrorToBitError().pnpmErrorToBitError)(err);
  } finally {
    stopReporting();
  }
  if (options.rootComponents) {
    const modulesState = await (0, _modulesYaml().readModulesManifest)(_path().default.join(rootDir, 'node_modules'));
    if (modulesState !== null && modulesState !== void 0 && modulesState.injectedDeps) {
      await linkManifestsToInjectedDeps({
        injectedDeps: modulesState.injectedDeps,
        manifestsByPaths,
        rootDir
      });
    }
  }
}

/**
 * This function creates manifests for root component wrappers.
 * Root component wrappers are used to isolated workspace components with their workspace dependencies
 * and peer dependencies.
 * A root component wrapper has the wrapped component in the dependencies and any of its peer dependencies.
 * This way pnpm will install the wrapped component in isolation from other components and their dependencies.
 */
function createRootComponentWrapperManifests(rootDir, manifestsByPaths) {
  const rootComponentWrappers = {};
  const rootComponents = [];
  for (const manifest of Object.values(manifestsByPaths)) {
    const name = manifest.name.toString(); // eslint-disable-line
    const compDir = _path().default.join(rootDir, 'node_modules', name);
    const id = _path().default.relative(rootDir, compDir).replace(/\\/g, '/');
    rootComponents.push(encodeURIComponent(id));
    rootComponentWrappers[compDir] = {
      name: `${name}__root`,
      dependencies: _objectSpread(_objectSpread({
        [name]: `workspace:*`
      }, manifest.peerDependencies), manifest['defaultPeerDependencies']),
      dependenciesMeta: {
        [name]: {
          injected: true
        }
      }
    };
  }
  return {
    rootComponentWrappers,
    rootComponents
  };
}

/**
 * This hook is used when installation is executed inside a capsule.
 * The components in the capsules should get their peer dependencies installed,
 * so this hook converts any peer dependencies into runtime dependencies.
 * Also, any local dependencies are extended with the "injected" option,
 * this tells pnpm to hard link the packages instead of symlinking them.
 */
function readPackageHookForCapsules(pkg, workspaceDir) {
  // workspaceDir is set only for workspace packages
  if (workspaceDir) {
    return readDependencyPackageHook(_objectSpread(_objectSpread({}, pkg), {}, {
      dependencies: _objectSpread(_objectSpread(_objectSpread({}, pkg.dependencies), pkg.peerDependencies), pkg['defaultPeerDependencies'])
    }));
  }
  return readDependencyPackageHook(pkg);
}

/**
 * This hook is used when installation happens in a Bit workspace.
 * We need a different hook for this case because unlike in a capsule, in a workspace,
 * the package manager only links workspace components to subdependencies.
 * For direct dependencies, Bit's linking is used.
 */
function readPackageHook(pkg, workspaceDir) {
  var _pkg$name;
  if (!pkg.dependencies || (_pkg$name = pkg.name) !== null && _pkg$name !== void 0 && _pkg$name.endsWith(`__root`)) {
    return pkg;
  }
  // workspaceDir is set only for workspace packages
  if (workspaceDir) {
    return readWorkspacePackageHook(pkg);
  }
  return readDependencyPackageHook(pkg);
}

/**
 * This hook adds the "injected" option to any workspace dependency.
 * The injected option tell pnpm to hard link the packages instead of symlinking them.
 */
function readDependencyPackageHook(pkg) {
  var _pkg$dependenciesMeta;
  const dependenciesMeta = (_pkg$dependenciesMeta = pkg.dependenciesMeta) !== null && _pkg$dependenciesMeta !== void 0 ? _pkg$dependenciesMeta : {};
  for (const [name, version] of Object.entries((_pkg$dependencies = pkg.dependencies) !== null && _pkg$dependencies !== void 0 ? _pkg$dependencies : {})) {
    var _pkg$dependencies;
    if (version.startsWith('workspace:')) {
      // This instructs pnpm to hard link the component from the workspace, not symlink it.
      dependenciesMeta[name] = {
        injected: true
      };
    }
  }
  return _objectSpread(_objectSpread({}, pkg), {}, {
    dependenciesMeta
  });
}

/**
 * This hook is used when installation happens in a Bit workspace.
 * It is applied on workspace projects, and it removes any references to other workspace projects.
 * This is needed because Bit has its own linking for workspace projects.
 * pnpm should not override the links created by Bit.
 * Otherwise, the IDE would reference workspace projects from inside `node_modules/.pnpm`.
 */
function readWorkspacePackageHook(pkg) {
  const newDeps = {};
  for (const [name, version] of Object.entries((_pkg$dependencies2 = pkg.dependencies) !== null && _pkg$dependencies2 !== void 0 ? _pkg$dependencies2 : {})) {
    var _pkg$dependencies2;
    if (!version.startsWith('workspace:')) {
      newDeps[name] = version;
    }
  }
  return _objectSpread(_objectSpread({}, pkg), {}, {
    dependencies: _objectSpread(_objectSpread(_objectSpread({}, pkg.peerDependencies), pkg['defaultPeerDependencies']), newDeps)
  });
}

/*
 * The package.json files of the components are generated into node_modules/<component pkg name>/package.json
 * This function copies the generated package.json file into all the locations of the component.
 */
async function linkManifestsToInjectedDeps({
  rootDir,
  manifestsByPaths,
  injectedDeps
}) {
  await Promise.all(Object.entries(injectedDeps).map(async ([compDir, targetDirs]) => {
    var _manifestsByPaths$pat;
    const pkgName = (_manifestsByPaths$pat = manifestsByPaths[_path().default.join(rootDir, compDir)]) === null || _manifestsByPaths$pat === void 0 ? void 0 : _manifestsByPaths$pat.name;
    if (!pkgName) return;
    const pkgJsonPath = _path().default.join(rootDir, 'node_modules', pkgName, 'package.json');
    if (_gracefulFs().default.existsSync(pkgJsonPath)) {
      await Promise.all(targetDirs.map(targetDir => link(pkgJsonPath, _path().default.join(targetDir, 'package.json'))));
    }
  }));
}
function groupPkgs(manifestsByPaths) {
  const pkgs = Object.entries(manifestsByPaths).map(([dir, manifest]) => ({
    dir,
    manifest
  }));
  const {
    graph
  } = (0, _pkgsGraph().createPkgGraph)(pkgs);
  const chunks = (0, _sortPackages().sortPackages)(graph);

  // This will create local link by pnpm to a component exists in the ws.
  // it will later deleted by the link process
  // we keep it here to better support case like this:
  // compA@1.0.0 uses compB@1.0.0
  // I have compB@2.0.0 in my workspace
  // now I install compA@1.0.0
  // compA is hoisted to the root and install B@1.0.0 hoisted to the root as well
  // now we will make link to B@2.0.0 and A will break
  // with this we will have a link to the local B by pnpm so it will install B@1.0.0 inside A
  // then when overriding the link, A will still works
  // This is the rational behind not deleting this completely, but need further check that it really works
  const packagesToBuild = []; // @pnpm/core will use this to install the packages
  const allProjects = [];
  const workspacePackages = {}; // @pnpm/core will use this to link packages to each other

  chunks.forEach((dirs, buildIndex) => {
    for (const rootDir of dirs) {
      const manifest = manifestsByPaths[rootDir];
      allProjects.push({
        buildIndex,
        manifest,
        rootDir
      });
      packagesToBuild.push({
        rootDir,
        mutation: 'install'
      });
      if (manifest.name) {
        workspacePackages[manifest.name] = workspacePackages[manifest.name] || {};
        workspacePackages[manifest.name][manifest.version] = {
          dir: rootDir,
          manifest
        };
      }
    }
  });
  return {
    packagesToBuild,
    allProjects,
    workspacePackages
  };
}
async function resolveRemoteVersion(packageName, rootDir, cacheDir, registries, proxyConfig = {}, networkConfig = {}) {
  const {
    resolve
  } = await generateResolverAndFetcher(cacheDir, registries, proxyConfig, networkConfig);
  const resolveOpts = {
    lockfileDir: rootDir,
    preferredVersions: {},
    projectDir: rootDir,
    registry: ''
  };
  try {
    const parsedPackage = (0, _parsePackageName().default)(packageName);
    const registriesMap = getRegistriesMap(registries);
    const registry = (0, _pickRegistryForPackage().pickRegistryForPackage)(registriesMap, parsedPackage.name);
    const wantedDep = {
      alias: parsedPackage.name,
      pref: parsedPackage.version
    };
    const isValidRange = parsedPackage.version ? !!_semver().default.validRange(parsedPackage.version) : false;
    resolveOpts.registry = registry;
    const val = await resolve(wantedDep, resolveOpts);
    if (!val.manifest) {
      throw new (_bitError().BitError)('The resolved package has no manifest');
    }
    const version = isValidRange ? parsedPackage.version : val.manifest.version;
    return {
      packageName: val.manifest.name,
      version,
      isSemver: true,
      resolvedVia: val.resolvedVia
    };
  } catch (e) {
    var _e$message;
    if (!((_e$message = e.message) !== null && _e$message !== void 0 && _e$message.includes('is not a valid string'))) {
      throw (0, _pnpmErrorToBitError().pnpmErrorToBitError)(e);
    }
    // The provided package is probably a git url or path to a folder
    const wantedDep = {
      alias: undefined,
      pref: packageName
    };
    const val = await resolve(wantedDep, resolveOpts);
    if (!val.manifest) {
      throw new (_bitError().BitError)('The resolved package has no manifest');
    }
    if (!val.normalizedPref) {
      throw new (_bitError().BitError)('The resolved package has no version');
    }
    return {
      packageName: val.manifest.name,
      version: val.normalizedPref,
      isSemver: false,
      resolvedVia: val.resolvedVia
    };
  }
}
function getRegistriesMap(registries) {
  const registriesMap = {
    default: registries.defaultRegistry.uri || _dependencyResolver().NPM_REGISTRY
  };
  Object.entries(registries.scopes).forEach(([registryName, registry]) => {
    registriesMap[`@${registryName}`] = registry.uri;
  });
  return registriesMap;
}
function getAuthConfig(registries) {
  const res = {};
  res.registry = registries.defaultRegistry.uri;
  if (registries.defaultRegistry.alwaysAuth) {
    res['always-auth'] = true;
  }
  const defaultAuthTokens = getAuthTokenForRegistry(registries.defaultRegistry, true);
  defaultAuthTokens.forEach(({
    keyName,
    val
  }) => {
    res[keyName] = val;
  });
  Object.entries(registries.scopes).forEach(([, registry]) => {
    const authTokens = getAuthTokenForRegistry(registry);
    authTokens.forEach(({
      keyName,
      val
    }) => {
      res[keyName] = val;
    });
    if (registry.alwaysAuth) {
      const nerfed = (0, _nerfDart().default)(registry.uri);
      const alwaysAuthKeyName = `${nerfed}:always-auth`;
      res[alwaysAuthKeyName] = true;
    }
  });
  return res;
}
function getAuthTokenForRegistry(registry, isDefault = false) {
  const nerfed = (0, _nerfDart().default)(registry.uri);
  if (registry.originalAuthType === 'authToken') {
    return [{
      keyName: `${nerfed}:_authToken`,
      val: registry.originalAuthValue || ''
    }];
  }
  if (registry.originalAuthType === 'auth') {
    return [{
      keyName: isDefault ? '_auth' : `${nerfed}:_auth`,
      val: registry.originalAuthValue || ''
    }];
  }
  if (registry.originalAuthType === 'user-pass') {
    var _registry$originalAut, _registry$originalAut2;
    return [{
      keyName: `${nerfed}:username`,
      val: ((_registry$originalAut = registry.originalAuthValue) === null || _registry$originalAut === void 0 ? void 0 : _registry$originalAut.split(':')[0]) || ''
    }, {
      keyName: `${nerfed}:_password`,
      val: ((_registry$originalAut2 = registry.originalAuthValue) === null || _registry$originalAut2 === void 0 ? void 0 : _registry$originalAut2.split(':')[1]) || ''
    }];
  }
  return [];
}

//# sourceMappingURL=lynx.js.map