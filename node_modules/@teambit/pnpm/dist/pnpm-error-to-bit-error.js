"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BitErrorWithRichMessage = void 0;
exports.pnpmErrorToBitError = pnpmErrorToBitError;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
class BitErrorWithRichMessage extends _bitError().BitError {
  constructor(message, richMessage) {
    super(message);
    (0, _defineProperty2().default)(this, "richMessage", void 0);
    this.richMessage = richMessage;
  }
  report() {
    return this.richMessage;
  }
}
exports.BitErrorWithRichMessage = BitErrorWithRichMessage;
function pnpmErrorToBitError(err) {
  return new BitErrorWithRichMessage(err.message, renderErrorMessage(err));
}
function renderErrorMessage(err) {
  var _err$code;
  if ((_err$code = err.code) !== null && _err$code !== void 0 && _err$code.startsWith('ERR_PNPM_FETCH_')) {
    // On fetching errors, pnpm adds information to the error object about the used auth headers.
    // This information is safe to print as the tokens are obfuscated.
    return `${err.message}

${err.hint}`;
  }
  return err.message;
}

//# sourceMappingURL=pnpm-error-to-bit-error.js.map