"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat-map.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat-map.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExpressMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _express() {
  const data = _interopRequireDefault(require("express"));
  _express = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _bodyParser() {
  const data = _interopRequireDefault(require("body-parser"));
  _bodyParser = function () {
    return data;
  };
  return data;
}
function _express2() {
  const data = require("./express.aspect");
  _express2 = function () {
    return data;
  };
  return data;
}
function _middlewares() {
  const data = require("./middlewares");
  _middlewares = function () {
    return data;
  };
  return data;
}
function _types() {
  const data = require("./types");
  _types = function () {
    return data;
  };
  return data;
}
class ExpressMain {
  constructor(
  /**
   * extension config
   */
  config,
  /**
   * slot for registering graphql modules
   */
  moduleSlot,
  /**
   * logger extension.
   */
  logger, middlewareSlot) {
    this.config = config;
    this.moduleSlot = moduleSlot;
    this.logger = logger;
    this.middlewareSlot = middlewareSlot;
  }

  /**
   * start a express server.
   */
  async listen(port) {
    const serverPort = port || this.config.port;
    const app = this.createApp();
    app.listen(serverPort);
  }

  /**
   * register a new express routes.
   * route will be added as `/api/${route}`
   */
  register(routes) {
    this.moduleSlot.register(routes);
    return this;
  }

  /**
   * register a new middleware into express.
   */
  registerMiddleware(middlewares) {
    this.middlewareSlot.register(middlewares);
    return this;
  }
  createRootRoutes() {
    // TODO: @guy refactor health to service aspect.
    return [{
      namespace: _express2().ExpressAspect.id,
      method: 'get',
      path: '/_health',
      disableNamespace: false,
      middlewares: [async (req, res) => res.send('ok')]
    }];
  }
  createApp(expressApp, options) {
    const internalRoutes = this.createRootRoutes();
    const routes = this.createRoutes();
    const allRoutes = (0, _lodash().concat)(routes, internalRoutes);
    const app = expressApp || (0, _express().default)();
    app.use((req, res, next) => {
      if (this.config.loggerIgnorePath.includes(req.url)) return next();
      this.logger.debug(`express got a request to a URL: ${req.url}', headers:`, req.headers);
      return next();
    });
    if (!(options !== null && options !== void 0 && options.disableBodyParser)) this.bodyParser(app);
    this.middlewareSlot.toArray().flatMap(([, middlewares]) => middlewares.flatMap(middlewareManifest => app.use(middlewareManifest.middleware)));
    allRoutes.forEach(routeInfo => {
      const {
        method,
        path,
        middlewares,
        disableNamespace
      } = routeInfo;
      // TODO: @guy make sure to support single middleware here.
      const namespace = disableNamespace ? '' : `/${this.config.namespace}`;
      app[method](`${namespace}${path}`, this.catchErrorsMiddlewares(middlewares));
    });
    return app;
  }
  createRoutes() {
    const routesSlots = this.moduleSlot.toArray();
    const routeEntries = routesSlots.map(([, routes]) => {
      return routes.map(route => {
        const middlewares = (0, _lodash().flatten)([this.verbValidation(route), route.middlewares]);
        return {
          method: (0, _lodash().lowerCase)(route.method),
          path: route.route,
          disableNamespace: route.disableNamespace,
          middlewares
        };
      });
    });
    return (0, _lodash().flatten)(routeEntries);
  }
  verbValidation(route) {
    return async (req, res, next) => {
      if (!route.verb) return next();
      const verb = req.headers['x-verb'] || _types().Verb.READ;
      if (verb !== route.verb) {
        res.status(403);
        return res.jsonp({
          message: 'You are not authorized',
          error: 'forbidden'
        });
      }
      return next();
    };
  }
  catchErrorsMiddlewares(middlewares) {
    return middlewares.map(middleware => (0, _middlewares().catchErrors)(middleware));
  }
  bodyParser(app) {
    app.use(_bodyParser().default.json({
      limit: '5000mb'
    }));
    app.use(_bodyParser().default.raw({
      type: 'application/octet-stream',
      limit: '5000mb'
    }));
  }
  static async provider([loggerFactory], config, [routeSlot, middlewareSlot]) {
    const logger = loggerFactory.createLogger(_express2().ExpressAspect.id);
    return new ExpressMain(config, routeSlot, logger, middlewareSlot);
  }
}
exports.ExpressMain = ExpressMain;
(0, _defineProperty2().default)(ExpressMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(ExpressMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(ExpressMain, "dependencies", [_logger().LoggerAspect]);
(0, _defineProperty2().default)(ExpressMain, "defaultConfig", {
  port: 4001,
  namespace: 'api',
  loggerIgnorePath: ['/api/_health']
});
_express2().ExpressAspect.addRuntime(ExpressMain);

//# sourceMappingURL=express.main.runtime.js.map