"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SignCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
class SignCmd {
  constructor(signMain) {
    this.signMain = signMain;
    (0, _defineProperty2().default)(this, "name", 'sign [component...]');
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "description", 'complete the build process for components');
    (0, _defineProperty2().default)(this, "extendedDescription", `without --multiple, this will be running on the original scope.
with --multiple, a new bare-scope needs to be created and it will import the components to this scope first`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "options", [['', 'multiple', 'sign components from multiple scopes'], ['', 'always-succeed', 'exit with code 0 even though the build failed'], ['', 'push', 'export the updated objects to the original scopes once done'], ['', 'lane <lane-id>', 'helps to fetch the components from the lane scope (relevant for --multiple)']]);
  }
  async report([components = []], {
    multiple,
    alwaysSucceed,
    push,
    lane
  }) {
    const componentIds = components.map(c => _component().ComponentID.fromString(c));
    this.warnForMissingVersions(componentIds);
    const results = await this.signMain.sign(componentIds, multiple, push, lane);
    if (!results) {
      return _chalk().default.bold('no more components left to sign');
    }
    const status = results.error ? _constants().BuildStatus.Failed : _constants().BuildStatus.Succeed;
    const error = results.error ? `${results.error}\n\n` : '';
    const color = error ? 'red' : 'green';
    const signed = `the following ${results.components.length} component(s) were signed with build-status "${status}"
${results.components.map(c => c.id.toString()).join('\n')}`;
    return {
      data: error + _chalk().default.bold[color](signed),
      code: error && !alwaysSucceed ? 1 : 0
    };
  }
  warnForMissingVersions(compIds) {
    const compIdsWithoutVer = compIds.filter(c => !c.hasVersion());
    if (compIdsWithoutVer.length) {
      const compIdsStr = compIdsWithoutVer.map(c => c.toString()).join(', ');
      // eslint-disable-next-line no-console
      console.warn(_chalk().default.yellow(`the following component-id(s) don't have a version: ${compIdsStr}, as a result, it might sign the wrong version especially when running with lanes`));
    }
  }
}
exports.SignCmd = SignCmd;

//# sourceMappingURL=sign.cmd.js.map