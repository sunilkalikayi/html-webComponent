"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SignMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = require("@teambit/scope");
  _scope = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("@teambit/builder");
  _builder = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _snapping() {
  const data = require("@teambit/snapping");
  _snapping = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _scopeRemotes() {
  const data = require("@teambit/legacy/dist/scope/scope-remotes");
  _scopeRemotes = function () {
    return data;
  };
  return data;
}
function _actions() {
  const data = require("@teambit/legacy/dist/scope/actions");
  _actions = function () {
    return data;
  };
  return data;
}
function _objectList() {
  const data = require("@teambit/legacy/dist/scope/objects/object-list");
  _objectList = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _http() {
  const data = require("@teambit/legacy/dist/scope/network/http");
  _http = function () {
    return data;
  };
  return data;
}
function _lanes() {
  const data = _interopRequireDefault(require("@teambit/lanes"));
  _lanes = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _sign() {
  const data = require("./sign.cmd");
  _sign = function () {
    return data;
  };
  return data;
}
function _sign2() {
  const data = require("./sign.aspect");
  _sign2 = function () {
    return data;
  };
  return data;
}
class SignMain {
  constructor(scope, logger, builder, onPostSignSlot, lanes, snapping) {
    this.scope = scope;
    this.logger = logger;
    this.builder = builder;
    this.onPostSignSlot = onPostSignSlot;
    this.lanes = lanes;
    this.snapping = snapping;
  }

  /**
   * complete the build process of a component.
   * `isMultiple` indicates that this is running on a new bare-scope and not on the original scope.
   * it's recommended to always use it, even when it's a single component and not multiple.
   * (the reason for this name is that for multiple components from multiple scopes, it must be done on a new bare-scope).
   *
   * important! this method mutates the legacyScope. it assigns the currentLaneId according to the `bit sign --lane` flag.
   * if for some reason you're using this API in a long-running-process, make sure to revert it.
   */
  async sign(ids, isMultiple, push, laneIdStr) {
    let lane;
    if (isMultiple) {
      if (laneIdStr) {
        const laneId = _laneId().LaneId.parse(laneIdStr);
        lane = await this.lanes.importLaneObject(laneId);
        // this is critical. otherwise, later on, when loading aspects and isolating capsules, we'll try to fetch dists
        // from the original scope instead of the lane-scope.
        this.scope.legacyScope.setCurrentLaneId(laneId);
      }
      await this.scope.import(ids, {
        lane
      });
    }
    const {
      componentsToSkip,
      componentsToSign
    } = await this.getComponentIdsToSign(ids);
    if (ids.length && componentsToSkip.length) {
      // eslint-disable-next-line no-console
      console.log(`the following component(s) were already signed successfully:
${componentsToSkip.map(c => c.toString()).join('\n')}\n`);
    }
    if (!componentsToSign.length) {
      return null;
    }

    // using `loadMany` instead of `getMany` to make sure component aspects are loaded.
    this.logger.setStatusLine(`loading ${componentsToSign.length} components and their aspects...`);
    const components = await this.scope.loadMany(componentsToSign);
    this.logger.clearStatusLine();
    const {
      builderDataMap,
      pipeResults
    } = await this.builder.tagListener(components, {
      throwOnError: false
    }, {
      seedersOnly: true,
      installOptions: {
        copyPeerToRuntimeOnComponents: true,
        installPeersFromEnvs: true
      }
    });
    const legacyBuildResults = this.scope.builderDataMapToLegacyOnTagResults(builderDataMap);
    const legacyComponents = components.map(c => c.state._consumer);
    this.snapping._updateComponentsByTagResult(legacyComponents, legacyBuildResults);
    const publishedPackages = this.snapping._getPublishedPackages(legacyComponents);
    const pipeWithError = pipeResults.find(pipe => pipe.hasErrors());
    const buildStatus = pipeWithError ? _constants().BuildStatus.Failed : _constants().BuildStatus.Succeed;
    if (push) {
      if (isMultiple) {
        await this.exportExtensionsDataIntoScopes(legacyComponents, buildStatus, lane);
      } else {
        await this.saveExtensionsDataIntoScope(legacyComponents, buildStatus);
      }
      await this.clearScopesCaches(legacyComponents);
    }
    await this.triggerOnPostSign(components);
    return {
      components,
      publishedPackages,
      error: pipeWithError ? pipeWithError.getErrorMessageFormatted() : null
    };
  }
  registerOnPostSign(fn) {
    this.onPostSignSlot.register(fn);
  }
  async triggerOnPostSign(components) {
    await Promise.all(this.onPostSignSlot.values().map(fn => fn(components))).catch(err => {
      this.logger.error('failed running onPostSignSlot', err);
    });
  }
  async clearScopesCaches(components) {
    const bitIds = _bitId().BitIds.fromArray(components.map(c => c.id));
    const idsGroupedByScope = bitIds.toGroupByScopeName(new (_bitId().BitIds)());
    const scopeRemotes = await (0, _scopeRemotes().getScopeRemotes)(this.scope.legacyScope);
    await Promise.all(Object.keys(idsGroupedByScope).map(async scopeName => {
      const remote = await scopeRemotes.resolve(scopeName, this.scope.legacyScope);
      return remote.action(_actions().PostSign.name, {
        ids: idsGroupedByScope[scopeName].map(id => id.toString())
      });
    }));
  }
  async saveExtensionsDataIntoScope(components, buildStatus) {
    await (0, _pMapSeries().default)(components, async component => {
      component.buildStatus = buildStatus;
      await this.snapping._enrichComp(component);
    });
    await this.scope.legacyScope.objects.persist();
  }
  async exportExtensionsDataIntoScopes(components, buildStatus, lane) {
    const objectList = new (_objectList().ObjectList)();
    const signComponents = await (0, _pMapSeries().default)(components, async component => {
      component.buildStatus = buildStatus;
      const objects = await this.snapping._getObjectsToEnrichComp(component);
      const scopeName = component.scope;
      const objectToMerge = await _objectList().ObjectList.fromBitObjects(objects);
      objectToMerge.addScopeName(scopeName);
      objectList.mergeObjectList(objectToMerge);
      return _component().ComponentID.fromLegacy(component.id);
    });
    if (lane) {
      // the components should be exported to the lane-scope, not to their original scope.
      objectList.addScopeName(lane.scope);
    }
    const http = await _http().Http.connect(_constants().CENTRAL_BIT_HUB_URL, _constants().CENTRAL_BIT_HUB_NAME);
    await http.pushToCentralHub(objectList, {
      persist: true,
      sign: true,
      signComponents: signComponents.map(id => id.toString())
    });
  }
  async getComponentIdsToSign(ids) {
    if (!ids.length) {
      ids = await this.scope.listIds();
    }
    this.logger.setStatusLine(`loading ${ids.length} components to determine whether they need to be signed...`);
    const components = await this.scope.getMany(ids);
    this.logger.clearStatusLine();
    const componentsToSign = [];
    const componentsToSkip = [];
    components.forEach(component => {
      if (component.state._consumer.buildStatus === _constants().BuildStatus.Succeed) {
        componentsToSkip.push(component.id);
      } else {
        componentsToSign.push(component.id);
      }
    });
    return {
      componentsToSkip,
      componentsToSign
    };
  }
  static async provider([cli, scope, loggerMain, builder, lanes, snapping], _, [onPostSignSlot]) {
    const logger = loggerMain.createLogger(_sign2().SignAspect.id);
    const signMain = new SignMain(scope, logger, builder, onPostSignSlot, lanes, snapping);
    cli.register(new (_sign().SignCmd)(signMain));
    return signMain;
  }
}
exports.SignMain = SignMain;
(0, _defineProperty2().default)(SignMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(SignMain, "dependencies", [_cli().CLIAspect, _scope().ScopeAspect, _logger().LoggerAspect, _builder().BuilderAspect, _lanes().default, _snapping().SnappingAspect]);
(0, _defineProperty2().default)(SignMain, "slots", [_harmony().Slot.withType()]);
_sign2().SignAspect.addRuntime(SignMain);

//# sourceMappingURL=sign.main.runtime.js.map