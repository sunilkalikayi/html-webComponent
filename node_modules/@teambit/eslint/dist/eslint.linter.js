"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ESLintLinter = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _eslint() {
  const data = require("eslint");
  _eslint = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _objectHash() {
  const data = _interopRequireDefault(require("object-hash"));
  _objectHash = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class ESLintLinter {
  constructor(logger, options,
  /**
   * reference to the eslint module.
   */
  ESLint) {
    this.logger = logger;
    this.options = options;
    this.ESLint = ESLint;
    (0, _defineProperty2().default)(this, "displayName", 'ESlint');
  }
  displayConfig() {
    return JSON.stringify(this.options, null, 2);
  }
  async lint(context) {
    const longProcessLogger = this.logger.createLongProcessLogger('linting components', context.components.length);
    const eslint = this.createEslint(this.options.config, this.ESLint);
    if (this.options.tsConfig && context.rootDir) {
      var _this$options, _this$options$config, _this$options$config$;
      const tsConfigPath = this.createTempTsConfigFile(context.rootDir, context.envRuntime.id, this.options.tsConfig);
      if ((_this$options = this.options) !== null && _this$options !== void 0 && (_this$options$config = _this$options.config) !== null && _this$options$config !== void 0 && (_this$options$config$ = _this$options$config.overrideConfig) !== null && _this$options$config$ !== void 0 && _this$options$config$.parserOptions) {
        this.options.config.overrideConfig.parserOptions.project = tsConfigPath;
      }
    }
    const resultsP = (0, _pMapSeries().default)(context.components, async component => {
      longProcessLogger.logProgress(component.id.toString());
      const filesP = component.filesystem.files.map(async file => {
        var _this$options$extensi;
        // TODO: now that we moved to lint files, maybe it's not required anymore
        // The eslint api will not ignore extensions by default when using lintText, so we do it manually
        if (!((_this$options$extensi = this.options.extensions) !== null && _this$options$extensi !== void 0 && _this$options$extensi.includes(file.extname))) return undefined;
        return file.path;
      });
      const files = (0, _lodash().compact)(await Promise.all(filesP));
      const lintResults = await eslint.lintFiles(files);
      if (eslint && this.options.config.fix && lintResults) {
        await _eslint().ESLint.outputFixes(lintResults);
      }
      const results = (0, _lodash().compact)((0, _lodash().flatten)(lintResults));
      const formatter = await eslint.loadFormatter(this.options.formatter || 'stylish');
      const output = formatter.format(results);
      const {
        totalErrorCount,
        totalFatalErrorCount,
        totalFixableErrorCount,
        totalFixableWarningCount,
        totalWarningCount,
        componentsResults
      } = this.computeComponentResultsWithTotals(results);
      return {
        component,
        output,
        totalErrorCount,
        totalFatalErrorCount,
        totalFixableErrorCount,
        totalFixableWarningCount,
        totalWarningCount,
        results: componentsResults
      };
    });
    const results = await resultsP;
    const {
      totalErrorCount,
      totalFatalErrorCount,
      totalFixableErrorCount,
      totalFixableWarningCount,
      totalWarningCount,
      totalComponentsWithErrorCount,
      totalComponentsWithFatalErrorCount,
      totalComponentsWithFixableErrorCount,
      totalComponentsWithFixableWarningCount,
      totalComponentsWithWarningCount
    } = this.computeManyComponentsTotals(results);
    return {
      totalErrorCount,
      totalFatalErrorCount,
      totalFixableErrorCount,
      totalFixableWarningCount,
      totalWarningCount,
      totalComponentsWithErrorCount,
      totalComponentsWithFatalErrorCount,
      totalComponentsWithFixableErrorCount,
      totalComponentsWithFixableWarningCount,
      totalComponentsWithWarningCount,
      results,
      errors: []
    };
  }
  createTempTsConfigFile(rootDir, envId, tsConfig) {
    const newTsConfig = _objectSpread({}, tsConfig);
    if (tsConfig.include) {
      newTsConfig.include = tsConfig.include.map(includedPath => `../../${includedPath}`);
    }
    if (tsConfig.exclude) {
      newTsConfig.exclude = tsConfig.exclude.map(excludedPath => `../../${excludedPath}`);
    }
    const cacheDir = getCacheDir(rootDir);
    const hash = (0, _objectHash().default)(newTsConfig);
    // We save the tsconfig with hash here to avoid creating unnecessary tsconfig files
    // this is very important as eslint will be able to cache the tsconfig file and will not need to create another program
    // this affects performance dramatically
    const tempTsConfigPath = _path().default.join(cacheDir, `bit.tsconfig.eslint.${hash}.json`);
    if (!_fsExtra().default.existsSync(tempTsConfigPath)) {
      _fsExtra().default.outputJSONSync(tempTsConfigPath, newTsConfig, {
        spaces: 2
      });
    }
    return tempTsConfigPath;
  }
  computeComponentResultsWithTotals(results) {
    let totalErrorCount = 0;
    let totalFatalErrorCount = 0;
    let totalFixableErrorCount = 0;
    let totalFixableWarningCount = 0;
    let totalWarningCount = 0;
    const componentsResults = results.map(result => {
      var _result$errorCount, _result$fatalErrorCou, _result$fixableErrorC, _result$fixableWarnin, _result$warningCount;
      totalErrorCount += (_result$errorCount = result.errorCount) !== null && _result$errorCount !== void 0 ? _result$errorCount : 0;
      // @ts-ignore - missing from the @types/eslint lib
      totalFatalErrorCount += (_result$fatalErrorCou = result.fatalErrorCount) !== null && _result$fatalErrorCou !== void 0 ? _result$fatalErrorCou : 0;
      totalFixableErrorCount += (_result$fixableErrorC = result.fixableErrorCount) !== null && _result$fixableErrorC !== void 0 ? _result$fixableErrorC : 0;
      totalFixableWarningCount += (_result$fixableWarnin = result.fixableWarningCount) !== null && _result$fixableWarnin !== void 0 ? _result$fixableWarnin : 0;
      totalWarningCount += (_result$warningCount = result.warningCount) !== null && _result$warningCount !== void 0 ? _result$warningCount : 0;
      return {
        filePath: result.filePath,
        errorCount: result.errorCount,
        // @ts-ignore - missing from the @types/eslint lib
        fatalErrorCount: result.fatalErrorCount,
        fixableErrorCount: result.fixableErrorCount,
        fixableWarningCount: result.fixableWarningCount,
        warningCount: result.warningCount,
        messages: result.messages,
        raw: result
      };
    });
    return {
      totalErrorCount,
      totalFatalErrorCount,
      totalFixableErrorCount,
      totalFixableWarningCount,
      totalWarningCount,
      componentsResults
    };
  }
  computeManyComponentsTotals(componentsResults) {
    let totalErrorCount = 0;
    let totalFatalErrorCount = 0;
    let totalFixableErrorCount = 0;
    let totalFixableWarningCount = 0;
    let totalWarningCount = 0;
    let totalComponentsWithErrorCount = 0;
    let totalComponentsWithFatalErrorCount = 0;
    let totalComponentsWithFixableErrorCount = 0;
    let totalComponentsWithFixableWarningCount = 0;
    let totalComponentsWithWarningCount = 0;
    componentsResults.forEach(result => {
      if (result.totalErrorCount) {
        totalErrorCount += result.totalErrorCount;
        totalComponentsWithErrorCount += 1;
      }
      // @ts-ignore - missing from the @types/eslint lib
      if (result.totalFatalErrorCount) {
        totalFatalErrorCount += result.totalFatalErrorCount;
        totalComponentsWithFatalErrorCount += 1;
      }
      if (result.totalFixableErrorCount) {
        totalFixableErrorCount += result.totalFixableErrorCount;
        totalComponentsWithFixableErrorCount += 1;
      }
      if (result.totalFixableWarningCount) {
        totalFixableWarningCount += result.totalFixableWarningCount;
        totalComponentsWithFixableWarningCount += 1;
      }
      if (result.totalWarningCount) {
        totalWarningCount += result.totalWarningCount;
        totalComponentsWithWarningCount += 1;
      }
    });
    return {
      totalErrorCount,
      totalFatalErrorCount,
      totalFixableErrorCount,
      totalFixableWarningCount,
      totalWarningCount,
      componentsResults,
      totalComponentsWithErrorCount,
      totalComponentsWithFatalErrorCount,
      totalComponentsWithFixableErrorCount,
      totalComponentsWithFixableWarningCount,
      totalComponentsWithWarningCount
    };
  }

  /**
   * Create the eslint instance by options that was already merged with context
   * @param options
   * @param ESLintModule
   * @returns
   */
  createEslint(options, ESLintModule) {
    // eslint-disable-next-line no-new
    if (ESLintModule) new ESLintModule.ESLint(options);
    return new (_eslint().ESLint)(options);
  }
  version() {
    if (this.ESLint) return this.ESLint.version;
    return _eslint().ESLint.version;
  }
}
exports.ESLintLinter = ESLintLinter;
function getCacheDir(rootDir) {
  return _path().default.join(rootDir, 'node_modules', '.cache');
}

//# sourceMappingURL=eslint.linter.js.map