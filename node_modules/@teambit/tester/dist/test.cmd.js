"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TestCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _timer() {
  const data = require("@teambit/legacy/dist/toolbox/timer");
  _timer = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _ink() {
  const data = require("ink");
  _ink = function () {
    return data;
  };
  return data;
}
function _react() {
  const data = _interopRequireDefault(require("react"));
  _react = function () {
    return data;
  };
  return data;
}
class TestCmd {
  constructor(tester, workspace, logger) {
    this.tester = tester;
    this.workspace = workspace;
    this.logger = logger;
    (0, _defineProperty2().default)(this, "name", 'test [component-pattern]');
    (0, _defineProperty2().default)(this, "description", 'test components in the workspace');
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'component-pattern',
      description: _constants().COMPONENT_PATTERN_HELP
    }]);
    (0, _defineProperty2().default)(this, "alias", 'at');
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "options", [['w', 'watch', 'start the tester in watch mode.'], ['d', 'debug', 'start the tester in debug mode.'], ['a', 'all', 'test all components, not only new and modified'], ['', 'junit <filepath>', 'write tests results as JUnit XML format into the specified file path'], ['', 'coverage', 'show code coverage data'], ['e', 'env <id>', 'test only the given env'], ['s', 'scope <scope-name>', 'DEPRECATED. (use the pattern instead, e.g. "scopeName/**"). name of the scope to test']
    // TODO: we need to reduce this redundant casting every time.
    ]);
  }

  async render([userPattern], {
    watch = false,
    debug = false,
    all = false,
    env,
    scope,
    junit,
    coverage = false
  }) {
    const timer = _timer().Timer.create();
    const scopeName = typeof scope === 'string' ? scope : undefined;
    if (scopeName) {
      this.logger.consoleWarning(`--scope is deprecated, use the pattern argument instead. e.g. "scopeName/**" for the entire scope`);
    }
    timer.start();
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    const getPatternWithScope = () => {
      if (!userPattern && !scope) return undefined;
      const pattern = userPattern || '**';
      return scopeName ? `${scopeName}/${pattern}` : pattern;
    };
    const patternWithScope = getPatternWithScope();
    const components = await this.workspace.getComponentsByUserInput(all, patternWithScope, true);
    if (!components.length) {
      return {
        code: 0,
        data: /*#__PURE__*/_react().default.createElement(_ink().Box, null, /*#__PURE__*/_react().default.createElement(_ink().Text, {
          bold: true
        }, "no components found to test. use \"--all\" flag to test all components or specify the ids to test, otherwise, only new and modified components will be tested", ' '))
      };
    }
    this.logger.console(`testing total of ${components.length} components in workspace '${_chalk().default.cyan(this.workspace.name)}'`);
    let code = 0;
    if (watch && !debug) {
      // avoid turning off the logger for non-watch scenario. otherwise, when this aspect throws errors, they'll be
      // swallowed. (Jest errors are shown regardless via Jest, but if the tester is unable to run Jest in the first
      // place, these errors won't be shown)
      this.logger.off();
      await this.tester.watch(components, {
        watch,
        debug,
        env,
        coverage
      });
    } else {
      const tests = await this.tester.test(components, {
        watch,
        debug,
        env,
        junit,
        coverage
      });
      if (tests.hasErrors()) code = 1;
    }
    const {
      seconds
    } = timer.stop();
    if (watch) return /*#__PURE__*/_react().default.createElement(_ink().Box, null);
    return {
      code,
      data: /*#__PURE__*/_react().default.createElement(_ink().Box, null, /*#__PURE__*/_react().default.createElement(_ink().Text, null, "test has been completed in "), /*#__PURE__*/_react().default.createElement(_ink().Text, {
        color: "cyan"
      }, seconds, " "), /*#__PURE__*/_react().default.createElement(_ink().Text, null, "seconds."))
    };
  }
}
exports.TestCmd = TestCmd;

//# sourceMappingURL=test.cmd.js.map