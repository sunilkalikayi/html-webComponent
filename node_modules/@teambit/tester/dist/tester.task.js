"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TesterTask = void 0;
exports.getArtifactDef = getArtifactDef;
exports.getJUnitArtifactPath = getJUnitArtifactPath;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("@teambit/builder");
  _builder = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _compiler() {
  const data = require("@teambit/compiler");
  _compiler = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("./utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _junitGenerator() {
  const data = require("./utils/junit-generator");
  _junitGenerator = function () {
    return data;
  };
  return data;
}
/**
 * tester build task. Allows to test components during component build.
 */
class TesterTask {
  constructor(aspectId, devFiles) {
    this.aspectId = aspectId;
    this.devFiles = devFiles;
    (0, _defineProperty2().default)(this, "name", 'TestComponents');
    (0, _defineProperty2().default)(this, "dependencies", [_compiler().CompilerAspect.id]);
  }
  async execute(context) {
    const components = context.capsuleNetwork.originalSeedersCapsules.getAllComponents();
    const tester = context.env.getTester();
    const componentsSpecFiles = _component().ComponentMap.as(components, component => {
      return (0, _utils().detectTestFiles)(component, this.devFiles);
    });
    const testCount = componentsSpecFiles.toArray().reduce((acc, [, specs]) => acc + specs.length, 0);
    if (testCount === 0) return {
      artifacts: [],
      componentsResults: []
    };
    const patternsWithCapsule = _component().ComponentMap.as(components, component => {
      const componentSpecFiles = componentsSpecFiles.get(component);
      if (!componentSpecFiles) throw new Error('capsule not found');
      const [, specs] = componentSpecFiles;
      const capsule = context.capsuleNetwork.graphCapsules.getCapsule(component.id);
      if (!capsule) throw new Error('capsule not found');
      const compiler = context.env.getCompiler();
      if (!compiler) {
        throw new Error(`compiler not found for ${component.id.toString()}`);
      }
      // @ts-ignore. not sure why ts complain that compiler might be undefined, when we check it above.
      const distFolder = compiler.getDistDir() || compiler.distDir;
      return {
        componentDir: (0, _path().join)(capsule.path, distFolder),
        paths: specs.map(specFile => {
          const distPath = compiler.getDistPathBySrcPath(specFile.relative);
          // TODO: fix spec type file need to capsule will return files with type AbstractVinyl
          return {
            path: (0, _path().join)(capsule.path, distPath),
            relative: distPath
          };
        })
      };
    });
    const specFilesWithCapsule = _component().ComponentMap.as(components, component => {
      const patternEntry = patternsWithCapsule.get(component);
      // @ts-ignore
      const [, val] = patternEntry;
      return val.paths;
    });
    const testerContext = Object.assign(context, {
      release: true,
      specFiles: specFilesWithCapsule,
      rootPath: context.capsuleNetwork.capsulesRootDir,
      patterns: patternsWithCapsule
    });

    // TODO: remove after fix AbstractVinyl on capsule
    // @ts-ignore
    const testsResults = await tester.test(testerContext);

    // write junit files
    await Promise.all(testsResults.components.map(async compResult => {
      const junit = (0, _junitGenerator().testsResultsToJUnitFormat)([compResult]);
      const capsule = context.capsuleNetwork.graphCapsules.getCapsule(compResult.componentId);
      if (!capsule) {
        throw new Error(`unable to find ${compResult.componentId.toString()} in capsules`);
      }
      await _fsExtra().default.outputFile((0, _path().join)(capsule.path, getJUnitArtifactPath()), junit);
    }));
    return {
      artifacts: getArtifactDef(),
      // @ts-ignore
      componentsResults: testsResults.components.map(componentTests => {
        var _context$capsuleNetwo;
        const componentErrors = componentTests.errors;
        const component = (_context$capsuleNetwo = context.capsuleNetwork.graphCapsules.getCapsule(componentTests.componentId)) === null || _context$capsuleNetwo === void 0 ? void 0 : _context$capsuleNetwo.component;
        if (!component) {
          throw new Error(`unable to find ${componentTests.componentId.toString()} in capsules`);
        }
        return {
          component,
          metadata: {
            tests: componentTests.results
          },
          errors: componentErrors
        };
      })
    };
  }
}
exports.TesterTask = TesterTask;
function getJUnitArtifactPath() {
  return (0, _path().join)(_builder().CAPSULE_ARTIFACTS_DIR, '__bit_junit.xml');
}
function getArtifactDef() {
  return [{
    name: 'junit',
    globPatterns: [getJUnitArtifactPath()],
    rootDir: _builder().CAPSULE_ARTIFACTS_DIR
  }];
}

//# sourceMappingURL=tester.task.js.map