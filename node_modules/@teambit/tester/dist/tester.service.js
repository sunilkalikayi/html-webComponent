"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TesterService = exports.OnTestsChanged = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _react() {
  const data = _interopRequireDefault(require("react"));
  _react = function () {
    return data;
  };
  return data;
}
function _ink() {
  const data = require("ink");
  _ink = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _cliHighlight() {
  const data = _interopRequireDefault(require("cli-highlight"));
  _cliHighlight = function () {
    return data;
  };
  return data;
}
function _tester() {
  const data = require("./tester");
  _tester = function () {
    return data;
  };
  return data;
}
function _tester2() {
  const data = require("./tester.aspect");
  _tester2 = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("./utils");
  _utils = function () {
    return data;
  };
  return data;
}
const chalk = require('chalk');
const OnTestsChanged = 'OnTestsChanged';
exports.OnTestsChanged = OnTestsChanged;
class TesterService {
  constructor(workspace, logger, pubsub, devFiles) {
    this.workspace = workspace;
    this.logger = logger;
    this.pubsub = pubsub;
    this.devFiles = devFiles;
    (0, _defineProperty2().default)(this, "name", 'tester');
    (0, _defineProperty2().default)(this, "_callback", void 0);
  }
  render(env) {
    const descriptor = this.getDescriptor(env);
    return /*#__PURE__*/_react().default.createElement(_ink().Text, {
      key: descriptor === null || descriptor === void 0 ? void 0 : descriptor.id
    }, /*#__PURE__*/_react().default.createElement(_ink().Text, {
      color: "cyan"
    }, "configured tester: "), /*#__PURE__*/_react().default.createElement(_ink().Text, null, descriptor === null || descriptor === void 0 ? void 0 : descriptor.id, " (", descriptor === null || descriptor === void 0 ? void 0 : descriptor.displayName, " @ ", descriptor === null || descriptor === void 0 ? void 0 : descriptor.version, ")"), /*#__PURE__*/_react().default.createElement(_ink().Newline, null), /*#__PURE__*/_react().default.createElement(_ink().Text, {
      underline: true,
      color: "cyan"
    }, "tester config:"), /*#__PURE__*/_react().default.createElement(_ink().Newline, null), /*#__PURE__*/_react().default.createElement(_ink().Text, null, (0, _cliHighlight().default)((descriptor === null || descriptor === void 0 ? void 0 : descriptor.config) || '', {
      language: 'javascript',
      ignoreIllegals: true
    })), /*#__PURE__*/_react().default.createElement(_ink().Newline, null));
  }
  getDescriptor(environment) {
    if (!environment.env.getTester) return undefined;
    const tester = environment.env.getTester();
    return {
      id: tester.id || '',
      displayName: tester.displayName || '',
      icon: tester.icon || '',
      config: tester.displayConfig ? tester.displayConfig() : '',
      version: tester.version ? tester.version() : '?'
    };
  }
  onTestRunComplete(callback) {
    this._callback = callback;
  }
  async run(context, options) {
    const tester = context.env.getTester();
    const specFiles = _component().ComponentMap.as(context.components, component => {
      return (0, _utils().detectTestFiles)(component, this.devFiles);
    });
    const testCount = specFiles.toArray().reduce((acc, [, specs]) => acc + specs.length, 0);
    const componentWithTests = specFiles.toArray().reduce((acc, [, specs]) => {
      if (specs.length > 0) acc += 1;
      return acc;
    }, 0);
    if (testCount === 0 && !options.ui) {
      this.logger.consoleWarning(`no tests found for environment ${chalk.cyan(context.id)}\n`);
      return new (_tester().Tests)([]);
    }
    if (!options.ui) this.logger.console(`testing ${componentWithTests} components with environment ${chalk.cyan(context.id)}\n`);
    const patterns = _component().ComponentMap.as(context.components, component => {
      const componentDir = this.workspace.componentDir(component.id);
      const componentPatterns = this.devFiles.getDevPatterns(component, _tester2().TesterAspect.id);
      return {
        componentDir,
        paths: componentPatterns.map(pattern => ({
          path: (0, _path().resolve)(componentDir, pattern),
          relative: pattern
        })) || []
      };
    });
    let additionalHostDependencies = [];
    if (context.env.getAdditionalTestHostDependencies && typeof context.env.getAdditionalTestHostDependencies === 'function') {
      additionalHostDependencies = await context.env.getAdditionalTestHostDependencies();
    }
    const testerContext = Object.assign(context, {
      release: false,
      specFiles,
      patterns,
      rootPath: this.workspace.path,
      workspace: this.workspace,
      debug: options.debug,
      watch: options.watch,
      ui: options.ui,
      coverage: options.coverage,
      additionalHostDependencies
    });
    if (options.watch && options.ui && tester.watch) {
      if (tester.onTestRunComplete) {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        tester.onTestRunComplete(results => {
          if (this._callback) this._callback(results);
          results.components.forEach(component => {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.pubsub.publish(OnTestsChanged, {
              testsChanged: {
                id: component.componentId.toString(),
                testsResults: component.results,
                loading: component.loading
              }
            });
          });
        });
      }
      return tester.watch(testerContext);
    }
    const results = await tester.test(testerContext);
    return results;
  }
}
exports.TesterService = TesterService;

//# sourceMappingURL=tester.service.js.map