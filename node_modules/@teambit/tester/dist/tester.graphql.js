"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testerSchema = testerSchema;
function _graphqlSubscriptions() {
  const data = require("graphql-subscriptions");
  _graphqlSubscriptions = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _graphqlTag() {
  const data = _interopRequireDefault(require("graphql-tag"));
  _graphqlTag = function () {
    return data;
  };
  return data;
}
function _tester() {
  const data = require("./tester.service");
  _tester = function () {
    return data;
  };
  return data;
}
function testerSchema(tester, graphql) {
  return {
    typeDefs: (0, _graphqlTag().default)`
      extend type ComponentHost {
        getTests(id: String!): Tests
      }

      type Subscription {
        testsChanged(id: String!): Tests
      }

      type Tests {
        loading: Boolean!
        testsResults: TestsResults
      }

      type TestsChanged {
        testsResults: TestsResults
      }

      type TestsResults {
        testFiles: [TestFiles]
        success: Boolean
        start: Int
      }

      type TestFiles {
        file: String
        tests: [Tests]
        pass: Int
        failed: Int
        pending: Int
        duration: Int
        slow: Boolean
        errorStr: String
      }

      type Tests {
        ancestor: [String]
        name: String
        duration: String
        status: String
        error: String
      }
    `,
    resolvers: {
      Subscription: {
        testsChanged: {
          subscribe: (0, _graphqlSubscriptions().withFilter)(() => graphql.pubsub.asyncIterator(_tester().OnTestsChanged), (payload, variables) => {
            return payload.testsChanged.id === variables.id;
          })
        }
      },
      ComponentHost: {
        getTests: async (host, {
          id
        }) => {
          const componentId = await host.resolveComponentId(id);
          const idHasVersion = _bitId().BitId.parse(id).hasVersion();
          const component = await host.get(componentId);
          if (!component) return null;
          const testsResults = await tester.getTestsResults(component, idHasVersion);
          if (!testsResults) return null;
          return testsResults;
        }
      }
    }
  };
}

//# sourceMappingURL=tester.graphql.js.map