{"version":3,"names":["Tests","constructor","components","errors","map","comp","flat"],"sources":["tester.ts"],"sourcesContent":["import { Component, ComponentID, ComponentMap } from '@teambit/component';\nimport { ExecutionContext } from '@teambit/envs';\nimport { AbstractVinyl } from '@teambit/legacy/dist/consumer/component/sources';\nimport { TestsResult } from '@teambit/tests-results';\n\nexport class Tests {\n  constructor(public components: ComponentsResults[]) {}\n  get errors(): Error[] {\n    return this.components.map((comp) => comp.errors || []).flat();\n  }\n}\n\nexport type ComponentsResults = {\n  /**\n   * component id.\n   */\n  componentId: ComponentID;\n  /**\n   * test results for the component.\n   */\n  results?: TestsResult;\n  /**\n   * aggregated errors from all files\n   */\n  errors?: Error[];\n\n  /**\n   * loading.\n   */\n  loading?: boolean;\n};\n\nexport type SpecFiles = ComponentMap<AbstractVinyl[]>;\nexport type ComponentPatternsEntry = { componentDir: string; paths: { path: string; relative: string }[] };\nexport type ComponentPatternsMap = ComponentMap<ComponentPatternsEntry>;\n\nexport interface TesterContext extends ExecutionContext {\n  /**\n   * whether the tester run for release (during bit build/tag) or not (during bit test command).\n   */\n  release: boolean;\n\n  /**\n   * list of components to test.\n   */\n  components: Component[];\n\n  /**\n   * component workspace.\n   */\n  // workspace: Workspace;\n\n  /**\n   * defines whether tester is expected to run in quiet mode.\n   */\n  quiet?: boolean;\n\n  /**\n   * list of spec files to test.\n   */\n  specFiles: SpecFiles;\n\n  /**\n   * rootPath of the component workspace or the capsule root dir (during build).\n   */\n  rootPath: string;\n\n  /**\n   * determines whether tester is expected to run in debug mode.\n   */\n  debug?: boolean;\n\n  /**\n   * is start from ui\n   */\n  ui?: boolean;\n\n  /**\n   * determines whether to start the tester in watch mode.\n   */\n  watch?: boolean;\n\n  /**\n   * whether the tester should show code coverage\n   */\n  coverage?: boolean;\n\n  /**\n   * array of patterns to test.\n   */\n  patterns: ComponentPatternsMap;\n\n  /**\n   *\n   * additional test host dependencies\n   * This can be used in cases when you want specific dependencies to be resolved from the env during testing\n   * but you don't want these dependencies as peer dependencies of the component (as they are not used during runtime)\n   * An example for this is @angular/compiler, which during running tests you want to resolve from the env, but you don't\n   * need it during component runtime.\n   */\n  additionalHostDependencies?: string[];\n}\n\n/**\n * tester interface allows extensions to implement a component tester into bit.\n */\nexport interface Tester {\n  /**\n   * display name of the tester.\n   */\n  displayName?: string;\n\n  /**\n   * icon of the tester.\n   */\n  icon?: string;\n\n  /**\n   * serialized config of the tester.\n   */\n  displayConfig?(): string;\n\n  /**\n   * path to the config in the filesystem.\n   */\n  configPath?: string;\n\n  /**\n   * id of the tester.\n   */\n  id: string;\n\n  /**\n   * on test run complete. (applies only during watch)\n   * @param callback\n   */\n  onTestRunComplete?(callback: CallbackFn): Promise<void>;\n\n  /**\n   * execute tests on all components in the given execution context.\n   */\n  test(context: TesterContext): Promise<Tests>;\n\n  /**\n   * watch tests on all components\n   */\n  watch?(context: TesterContext): Promise<Tests>;\n  /**\n   * return the tester version.\n   */\n  version(): string;\n}\nexport type CallbackFn = (testSuite: Tests) => void;\n"],"mappings":";;;;;;;;AAKO,MAAMA,KAAK,CAAC;EACjBC,WAAW,CAAQC,UAA+B,EAAE;IAAA,KAAjCA,UAA+B,GAA/BA,UAA+B;EAAG;EACrD,IAAIC,MAAM,GAAY;IACpB,OAAO,IAAI,CAACD,UAAU,CAACE,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAACF,MAAM,IAAI,EAAE,CAAC,CAACG,IAAI,EAAE;EAChE;AACF;AAAC"}