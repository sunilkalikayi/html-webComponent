"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TesterMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = _interopRequireDefault(require("lodash.compact"));
  _lodash = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = require("@teambit/envs");
  _envs = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = require("@teambit/workspace");
  _workspace = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = require("@teambit/graphql");
  _graphql = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("@teambit/builder");
  _builder = function () {
    return data;
  };
  return data;
}
function _ui() {
  const data = require("@teambit/ui");
  _ui = function () {
    return data;
  };
  return data;
}
function _lodash2() {
  const data = require("lodash");
  _lodash2 = function () {
    return data;
  };
  return data;
}
function _devFiles() {
  const data = _interopRequireDefault(require("@teambit/dev-files"));
  _devFiles = function () {
    return data;
  };
  return data;
}
function _test() {
  const data = require("./test.cmd");
  _test = function () {
    return data;
  };
  return data;
}
function _tester() {
  const data = require("./tester.aspect");
  _tester = function () {
    return data;
  };
  return data;
}
function _tester2() {
  const data = require("./tester.service");
  _tester2 = function () {
    return data;
  };
  return data;
}
function _tester3() {
  const data = require("./tester.task");
  _tester3 = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("./utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _tester4() {
  const data = require("./tester.graphql");
  _tester4 = function () {
    return data;
  };
  return data;
}
function _junitGenerator() {
  const data = require("./utils/junit-generator");
  _junitGenerator = function () {
    return data;
  };
  return data;
}
class TesterMain {
  constructor(patterns,
  /**
   * graphql extension.
   */
  graphql,
  /**
   * envs extension.
   */
  envs,
  /**
   * workspace extension.
   */
  workspace,
  /**
   * tester service.
   */
  service,
  /**
   * build task.
   */
  task, devFiles, builder) {
    this.patterns = patterns;
    this.graphql = graphql;
    this.envs = envs;
    this.workspace = workspace;
    this.service = service;
    this.task = task;
    this.devFiles = devFiles;
    this.builder = builder;
    (0, _defineProperty2().default)(this, "_testsResults", []);
  }
  async test(components, opts) {
    const options = this.getOptions(opts);
    const envsRuntime = await this.envs.createEnvironment(components);
    if (opts !== null && opts !== void 0 && opts.env) {
      return envsRuntime.runEnv(opts.env, this.service, options);
    }
    const results = await envsRuntime.run(this.service, options);
    if (opts !== null && opts !== void 0 && opts.junit) {
      await this.generateJUnit(opts === null || opts === void 0 ? void 0 : opts.junit, results);
    }
    return results;
  }
  async generateJUnit(filePath, testsResults) {
    const components = testsResults.results.map(envResult => {
      var _envResult$data;
      return (_envResult$data = envResult.data) === null || _envResult$data === void 0 ? void 0 : _envResult$data.components;
    }).flat();
    const jUnit = (0, _junitGenerator().testsResultsToJUnitFormat)((0, _lodash().default)(components));
    await _fsExtra().default.outputFile(filePath, jUnit);
  }

  /**
   * watch all components for changes and test upon each.
   */
  async watch(components, opts) {
    const options = this.getOptions(opts);
    const envsRuntime = await this.envs.createEnvironment(components);
    if (opts !== null && opts !== void 0 && opts.env) {
      return envsRuntime.runEnv(opts.env, this.service, options);
    }
    this.service.onTestRunComplete(results => {
      results.components.forEach(component => {
        this._testsResults[component.componentId.toString()] = component;
      });
    });
    return envsRuntime.run(this.service, options);
  }
  async uiWatch() {
    const components = await this.workspace.list();
    return this.watch(components, {
      watch: true,
      debug: false,
      ui: true
    });
  }
  async getTestsResults(component, idHasVersion = true) {
    const entry = component.get(_tester().TesterAspect.id);
    const isModified = !idHasVersion && (await component.isModified());
    const data = this.builder.getDataByAspect(component, _tester().TesterAspect.id);
    if ((entry || data) && !isModified) {
      return {
        testsResults: (data === null || data === void 0 ? void 0 : data.tests) || (entry === null || entry === void 0 ? void 0 : entry.data.tests),
        loading: false
      };
    }
    return this.getTestsResultsFromState(component);
  }
  getTestsResultsFromState(component) {
    const tests = this._testsResults[component.id.toString()];
    return {
      testsResults: tests === null || tests === void 0 ? void 0 : tests.results,
      loading: (tests === null || tests === void 0 ? void 0 : tests.loading) || false
    };
  }

  /**
   * Get the tests patterns from the config. (used as default patterns in case the env does not provide them via getTestsDevPatterns)
   * @returns
   */
  getPatterns() {
    return this.patterns;
  }
  getComponentDevPatterns(component) {
    const env = this.envs.calculateEnv(component).env;
    const componentPatterns = env.getTestsDevPatterns ? env.getTestsDevPatterns(component) : this.getPatterns();
    return componentPatterns;
  }
  getDevPatternToRegister() {
    return this.getComponentDevPatterns.bind(this);
  }

  /**
   * get all test files of a component.
   */
  getTestFiles(component) {
    return (0, _utils().detectTestFiles)(component, this.devFiles);
  }
  getOptions(options) {
    const defaults = {
      watch: false,
      debug: false
    };
    return (0, _lodash2().merge)(defaults, options);
  }
  static async provider([cli, envs, workspace, loggerAspect, graphql, ui, devFiles, builder], config) {
    const logger = loggerAspect.createLogger(_tester().TesterAspect.id);
    const testerService = new (_tester2().TesterService)(workspace, logger, graphql.pubsub, devFiles);
    envs.registerService(testerService);
    const tester = new TesterMain(config.patterns, graphql, envs, workspace, testerService, new (_tester3().TesterTask)(_tester().TesterAspect.id, devFiles), devFiles, builder);
    devFiles.registerDevPattern(tester.getDevPatternToRegister());
    if (workspace) {
      ui.registerOnStart(async () => {
        if (!config.watchOnStart) return undefined;
        await tester.uiWatch();
        return undefined;
      });
    }
    cli.register(new (_test().TestCmd)(tester, workspace, logger));
    graphql.register((0, _tester4().testerSchema)(tester, graphql));
    return tester;
  }
}
exports.TesterMain = TesterMain;
(0, _defineProperty2().default)(TesterMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(TesterMain, "dependencies", [_cli().CLIAspect, _envs().EnvsAspect, _workspace().WorkspaceAspect, _logger().LoggerAspect, _graphql().GraphqlAspect, _ui().UIAspect, _devFiles().default, _builder().BuilderAspect]);
(0, _defineProperty2().default)(TesterMain, "defaultConfig", {
  /**
   * default test regex for which files tester to apply on.
   */
  patterns: ['**/*.spec.+(js|ts|jsx|tsx)', '**/*.test.+(js|ts|jsx|tsx)'],
  /**
   * determine whether to watch on start.
   */
  watchOnStart: true
});
_tester().TesterAspect.addRuntime(TesterMain);

//# sourceMappingURL=tester.main.runtime.js.map