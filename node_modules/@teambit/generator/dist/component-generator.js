"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ComponentGenerator = void 0;
function _vinyl() {
  const data = _interopRequireDefault(require("vinyl"));
  _vinyl = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = _interopRequireDefault(require("@teambit/envs"));
  _envs = function () {
    return data;
  };
  return data;
}
function _camelcase() {
  const data = _interopRequireDefault(require("camelcase"));
  _camelcase = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _sources() {
  const data = require("@teambit/legacy/dist/consumer/component/sources");
  _sources = function () {
    return data;
  };
  return data;
}
function _dataToPersist() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/sources/data-to-persist"));
  _dataToPersist = function () {
    return data;
  };
  return data;
}
class ComponentGenerator {
  constructor(workspace, componentIds, options, template, envs, newComponentHelper, aspectId) {
    this.workspace = workspace;
    this.componentIds = componentIds;
    this.options = options;
    this.template = template;
    this.envs = envs;
    this.newComponentHelper = newComponentHelper;
    this.aspectId = aspectId;
  }
  async generate() {
    const dirsToDeleteIfFailed = [];
    const generateResults = await (0, _pMapSeries().default)(this.componentIds, async componentId => {
      try {
        const componentPath = this.newComponentHelper.getNewComponentPath(componentId, this.options.path);
        if (_fsExtra().default.existsSync(_path().default.join(this.workspace.path, componentPath))) {
          throw new (_bitError().BitError)(`unable to create a component at "${componentPath}", this path already exist`);
        }
        if (await this.workspace.hasName(componentId.fullName)) {
          throw new (_bitError().BitError)(`unable to create a component "${componentId.fullName}", a component with the same name already exist`);
        }
        dirsToDeleteIfFailed.push(componentPath);
        return await this.generateOneComponent(componentId, componentPath);
      } catch (err) {
        await this.deleteGeneratedComponents(dirsToDeleteIfFailed);
        throw err;
      }
    });
    await this.workspace.bitMap.write();
    return generateResults;
  }
  async deleteGeneratedComponents(dirs) {
    await Promise.all(dirs.map(async dir => {
      const absoluteDir = _path().default.join(this.workspace.path, dir);
      try {
        await _fsExtra().default.remove(absoluteDir);
      } catch (err) {
        if (err.code !== 'ENOENT') {
          // if not exist, it's fine
          throw err;
        }
      }
    }));
  }
  async generateOneComponent(componentId, componentPath) {
    var _config, _config$EnvsAspect$id;
    const name = componentId.name;
    const namePascalCase = (0, _camelcase().default)(name, {
      pascalCase: true
    });
    const nameCamelCase = (0, _camelcase().default)(name);
    const files = this.template.generateFiles({
      name,
      namePascalCase,
      nameCamelCase,
      componentId
    });
    const mainFile = files.find(file => file.isMain);
    await this.writeComponentFiles(componentPath, files);
    const addResults = await this.workspace.track({
      rootDir: componentPath,
      mainFile: mainFile === null || mainFile === void 0 ? void 0 : mainFile.relativePath,
      componentName: componentId.fullName,
      defaultScope: this.options.scope
    });
    const component = await this.workspace.get(componentId);
    const hasEnvConfiguredOriginally = this.envs.hasEnvConfigured(component);
    const envBeforeConfigChanges = this.envs.getEnv(component);
    let config = this.template.config;
    if (config && typeof config === 'function') {
      config = config({
        aspectId: this.aspectId
      });
    }
    const templateEnv = (_config = config) === null || _config === void 0 ? void 0 : (_config$EnvsAspect$id = _config[_envs().default.id]) === null || _config$EnvsAspect$id === void 0 ? void 0 : _config$EnvsAspect$id.env;
    if (config && templateEnv && hasEnvConfiguredOriginally) {
      // remove the env we got from the template.
      delete config[templateEnv];
      delete config[_envs().default.id].env;
      if (Object.keys(config[_envs().default.id]).length === 0) delete config[_envs().default.id];
      if (Object.keys(config).length === 0) config = undefined;
    }
    const configWithEnv = await this.addEnvIfProvidedByFlag(config);
    if (configWithEnv) this.workspace.bitMap.setEntireConfig(component.id, configWithEnv);
    const getEnvData = () => {
      var _config2, _config2$EnvsAspect$i;
      const envFromFlag = this.options.env; // env entered by the user when running `bit create --env`
      const envFromTemplate = (_config2 = config) === null || _config2 === void 0 ? void 0 : (_config2$EnvsAspect$i = _config2[_envs().default.id]) === null || _config2$EnvsAspect$i === void 0 ? void 0 : _config2$EnvsAspect$i.env;
      if (envFromFlag) {
        return {
          envId: envFromFlag,
          setBy: '--env flag'
        };
      }
      if (envFromTemplate) {
        return {
          envId: envFromTemplate,
          setBy: 'template'
        };
      }
      return {
        envId: envBeforeConfigChanges.id,
        setBy: hasEnvConfiguredOriginally ? 'workspace variants' : '<default>'
      };
    };
    const {
      envId,
      setBy
    } = getEnvData();
    return {
      id: componentId,
      dir: componentPath,
      files: addResults.files,
      envId,
      envSetBy: setBy
    };
  }
  async addEnvIfProvidedByFlag(config) {
    var _config3, _config3$EnvsAspect$i;
    const userEnv = this.options.env; // env entered by the user when running `bit create --env`
    const templateEnv = (_config3 = config) === null || _config3 === void 0 ? void 0 : (_config3$EnvsAspect$i = _config3[_envs().default.id]) === null || _config3$EnvsAspect$i === void 0 ? void 0 : _config3$EnvsAspect$i.env;
    if (!userEnv || userEnv === templateEnv) {
      return config;
    }
    config = config || {};
    if (templateEnv) {
      // the component template has an env and the user wants a different env.
      delete config[templateEnv];
    }
    const userEnvId = await this.workspace.resolveComponentId(userEnv);
    const userEnvIdWithPotentialVersion = await this.workspace.resolveEnvIdWithPotentialVersionForConfig(userEnvId);
    config[userEnvIdWithPotentialVersion] = {};
    config[_envs().default.id] = config[_envs().default.id] || {};
    config[_envs().default.id].env = userEnvId.toStringWithoutVersion();
    return config;
  }

  /**
   * writes the generated template files to the default directory set in the workspace config
   */
  async writeComponentFiles(componentPath, templateFiles) {
    const dataToPersist = new (_dataToPersist().default)();
    const vinylFiles = templateFiles.map(templateFile => {
      const templateFileVinyl = new (_vinyl().default)({
        base: componentPath,
        path: _path().default.join(componentPath, templateFile.relativePath),
        contents: Buffer.from(templateFile.content)
      });
      return _sources().AbstractVinyl.fromVinyl(templateFileVinyl);
    });
    const results = vinylFiles.map(v => v.path);
    dataToPersist.addManyFiles(vinylFiles);
    dataToPersist.addBasePath(this.workspace.path);
    await dataToPersist.persistAllToFS();
    return results;
  }
}
exports.ComponentGenerator = ComponentGenerator;

//# sourceMappingURL=component-generator.js.map