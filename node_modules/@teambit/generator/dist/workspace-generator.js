"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkspaceGenerator = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _bit() {
  const data = require("@teambit/bit");
  _bit = function () {
    return data;
  };
  return data;
}
function _execa() {
  const data = _interopRequireDefault(require("execa"));
  _execa = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _ui() {
  const data = _interopRequireDefault(require("@teambit/ui"));
  _ui = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = require("@teambit/workspace");
  _workspace = function () {
    return data;
  };
  return data;
}
function _forking() {
  const data = _interopRequireDefault(require("@teambit/forking"));
  _forking = function () {
    return data;
  };
  return data;
}
function _consumer() {
  const data = require("@teambit/legacy/dist/api/consumer");
  _consumer = function () {
    return data;
  };
  return data;
}
function _importer() {
  const data = _interopRequireDefault(require("@teambit/importer"));
  _importer = function () {
    return data;
  };
  return data;
}
function _compiler() {
  const data = require("@teambit/compiler");
  _compiler = function () {
    return data;
  };
  return data;
}
function _gitExecutable() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/git/git-executable"));
  _gitExecutable = function () {
    return data;
  };
  return data;
}
function _gitNotFound() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/git/exceptions/git-not-found"));
  _gitNotFound = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _install() {
  const data = require("@teambit/install");
  _install = function () {
    return data;
  };
  return data;
}
function _generator() {
  const data = require("./generator.aspect");
  _generator = function () {
    return data;
  };
  return data;
}
class WorkspaceGenerator {
  constructor(workspaceName, options, template, aspectComponent) {
    this.workspaceName = workspaceName;
    this.options = options;
    this.template = template;
    this.aspectComponent = aspectComponent;
    (0, _defineProperty2().default)(this, "workspacePath", void 0);
    (0, _defineProperty2().default)(this, "harmony", void 0);
    (0, _defineProperty2().default)(this, "workspace", void 0);
    (0, _defineProperty2().default)(this, "install", void 0);
    (0, _defineProperty2().default)(this, "importer", void 0);
    (0, _defineProperty2().default)(this, "logger", void 0);
    (0, _defineProperty2().default)(this, "forking", void 0);
    this.workspacePath = (0, _path().resolve)(this.workspaceName);
  }
  async generate() {
    if (_fsExtra().default.existsSync(this.workspacePath)) {
      throw new Error(`unable to create a workspace at "${this.workspaceName}", this path already exist`);
    }
    await _fsExtra().default.ensureDir(this.workspacePath);
    try {
      process.chdir(this.workspacePath);
      await this.initGit();
      await (0, _consumer().init)(this.workspacePath, this.options.skipGit, false, false, false, false, false, {});
      await this.writeWorkspaceFiles();
      await this.reloadBitInWorkspaceDir();
      await this.forkComponentsFromRemote();
      await this.importComponentsFromRemote();
      await this.install.install(undefined, {
        dedupe: true,
        import: false,
        copyPeerToRuntimeOnRoot: true,
        copyPeerToRuntimeOnComponents: false,
        updateExisting: false
      });
      // await this.buildUI(); // disabled for now. it takes too long
    } catch (err) {
      await _fsExtra().default.remove(this.workspacePath);
      throw err;
    }
    return this.workspacePath;
  }
  async initGit() {
    if (this.options.skipGit) return;
    const gitExecutablePath = (0, _gitExecutable().default)();
    const params = ['init'];
    try {
      await (0, _execa().default)(gitExecutablePath, params);
    } catch (err) {
      if (err.exitCodeName === 'ENOENT') {
        throw new (_gitNotFound().default)(gitExecutablePath, err);
      }
      throw err;
    }
  }
  async buildUI() {
    const uiMain = this.harmony.get(_ui().default.id);
    await uiMain.createRuntime({});
  }

  /**
   * writes the generated template files to the default directory set in the workspace config
   */
  async writeWorkspaceFiles() {
    const workspaceContext = {
      name: this.workspaceName,
      defaultScope: this.options.defaultScope,
      empty: this.options.empty,
      aspectComponent: this.aspectComponent,
      template: this.template
    };
    const templateFiles = await this.template.generateFiles(workspaceContext);
    await Promise.all(templateFiles.map(async templateFile => {
      await _fsExtra().default.outputFile((0, _path().join)(this.workspacePath, templateFile.relativePath), templateFile.content);
    }));
  }
  async reloadBitInWorkspaceDir() {
    this.harmony = await (0, _bit().loadBit)(this.workspacePath);
    this.workspace = this.harmony.get(_workspace().WorkspaceAspect.id);
    this.install = this.harmony.get(_install().InstallAspect.id);
    const loggerMain = this.harmony.get(_logger().LoggerAspect.id);
    this.logger = loggerMain.createLogger(_generator().GeneratorAspect.id);
    this.importer = this.harmony.get(_importer().default.id);
    this.forking = this.harmony.get(_forking().default.id);
  }
  async forkComponentsFromRemote() {
    var _this$template, _this$template$import, _this$template2, _this$template2$fork;
    if (this.options.empty) return;
    const componentsToFork = ((_this$template = this.template) === null || _this$template === void 0 ? void 0 : (_this$template$import = _this$template.importComponents) === null || _this$template$import === void 0 ? void 0 : _this$template$import.call(_this$template)) || ((_this$template2 = this.template) === null || _this$template2 === void 0 ? void 0 : (_this$template2$fork = _this$template2.fork) === null || _this$template2$fork === void 0 ? void 0 : _this$template2$fork.call(_this$template2)) || [];
    if (!componentsToFork.length) return;
    const componentsToForkRestructured = componentsToFork.map(({
      id,
      targetName,
      path
    }) => ({
      sourceId: id,
      targetId: targetName,
      path
    }));
    await this.forking.forkMultipleFromRemote(componentsToForkRestructured, {
      scope: this.workspace.defaultScope,
      refactor: true,
      install: false
    });
    this.workspace.clearCache();
    await this.compileComponents();
  }
  async importComponentsFromRemote() {
    var _this$template3, _this$template3$impor;
    if (this.options.empty) return;
    const componentsToImport = ((_this$template3 = this.template) === null || _this$template3 === void 0 ? void 0 : (_this$template3$impor = _this$template3.import) === null || _this$template3$impor === void 0 ? void 0 : _this$template3$impor.call(_this$template3)) || [];
    if (!componentsToImport.length) return;
    await (0, _pMapSeries().default)(componentsToImport, async componentToImport => {
      await this.importer.import({
        ids: [componentToImport.id],
        installNpmPackages: false,
        writeToPath: componentToImport.path
      }, []);
    });
    await this.workspace.bitMap.write();
    this.workspace.clearCache();
    await this.compileComponents();
  }
  async compileComponents() {
    const compiler = this.harmony.get(_compiler().CompilerAspect.id);
    await compiler.compileOnWorkspace();
  }
}
exports.WorkspaceGenerator = WorkspaceGenerator;

//# sourceMappingURL=workspace-generator.js.map