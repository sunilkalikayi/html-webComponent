"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.flat-map.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat-map.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GeneratorMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = require("@teambit/graphql");
  _graphql = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = require("@teambit/envs");
  _envs = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _community() {
  const data = require("@teambit/community");
  _community = function () {
    return data;
  };
  return data;
}
function _bit() {
  const data = require("@teambit/bit");
  _bit = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _aspectLoader() {
  const data = _interopRequireDefault(require("@teambit/aspect-loader"));
  _aspectLoader = function () {
    return data;
  };
  return data;
}
function _newComponentHelper() {
  const data = _interopRequireDefault(require("@teambit/new-component-helper"));
  _newComponentHelper = function () {
    return data;
  };
  return data;
}
function _importer() {
  const data = _interopRequireDefault(require("@teambit/importer"));
  _importer = function () {
    return data;
  };
  return data;
}
function _generator() {
  const data = require("./generator.aspect");
  _generator = function () {
    return data;
  };
  return data;
}
function _create() {
  const data = require("./create.cmd");
  _create = function () {
    return data;
  };
  return data;
}
function _templates() {
  const data = require("./templates.cmd");
  _templates = function () {
    return data;
  };
  return data;
}
function _generator2() {
  const data = require("./generator.graphql");
  _generator2 = function () {
    return data;
  };
  return data;
}
function _componentGenerator() {
  const data = require("./component-generator");
  _componentGenerator = function () {
    return data;
  };
  return data;
}
function _workspaceGenerator() {
  const data = require("./workspace-generator");
  _workspaceGenerator = function () {
    return data;
  };
  return data;
}
function _new() {
  const data = require("./new.cmd");
  _new = function () {
    return data;
  };
  return data;
}
function _componentGenerator2() {
  const data = require("./templates/component-generator");
  _componentGenerator2 = function () {
    return data;
  };
  return data;
}
function _workspaceGenerator2() {
  const data = require("./templates/workspace-generator");
  _workspaceGenerator2 = function () {
    return data;
  };
  return data;
}
function _starter() {
  const data = require("./templates/starter");
  _starter = function () {
    return data;
  };
  return data;
}
function _starter2() {
  const data = require("./starter.plugin");
  _starter2 = function () {
    return data;
  };
  return data;
}
class GeneratorMain {
  constructor(componentTemplateSlot, workspaceTemplateSlot, config, workspace, envs, aspectLoader, newComponentHelper, importer) {
    this.componentTemplateSlot = componentTemplateSlot;
    this.workspaceTemplateSlot = workspaceTemplateSlot;
    this.config = config;
    this.workspace = workspace;
    this.envs = envs;
    this.aspectLoader = aspectLoader;
    this.newComponentHelper = newComponentHelper;
    this.importer = importer;
    (0, _defineProperty2().default)(this, "aspectLoaded", false);
  }

  /**
   * register a new component template.
   */
  registerComponentTemplate(templates) {
    this.componentTemplateSlot.register(templates);
    return this;
  }

  /**
   * register a new component template.
   */
  registerWorkspaceTemplate(templates) {
    this.workspaceTemplateSlot.register(templates);
    return this;
  }

  /**
   * list all component templates registered in the workspace or workspace templates in case the
   * workspace is not available
   */
  async listTemplates() {
    const getTemplateDescriptor = ({
      id,
      template
    }) => {
      const shouldBeHidden = () => {
        if (template.hidden) return true;
        if (this.config.hideCoreTemplates && (0, _bit().isCoreAspect)(id)) return true;
        return false;
      };
      return {
        aspectId: id,
        name: template.name,
        description: template.description,
        hidden: shouldBeHidden()
      };
    };
    return this.isRunningInsideWorkspace() ? this.getAllComponentTemplatesFlattened().map(getTemplateDescriptor) : this.getAllWorkspaceTemplatesFlattened().map(getTemplateDescriptor);
  }

  /**
   * @deprecated use this.listTemplates()
   */
  async listComponentTemplates() {
    return this.listTemplates();
  }
  isRunningInsideWorkspace() {
    return Boolean(this.workspace);
  }

  /**
   * get all component templates registered by a specific aspect ID.
   */
  getComponentTemplateByAspect(aspectId) {
    return this.componentTemplateSlot.get(aspectId) || [];
  }

  /**
   * returns a specific component template.
   */
  getComponentTemplate(name, aspectId) {
    const templates = this.getAllComponentTemplatesFlattened();
    const found = templates.find(({
      id,
      template
    }) => {
      if (aspectId && id !== aspectId) return false;
      return template.name === name;
    });
    return found;
  }

  /**
   * in the case the aspect-id is given and this aspect doesn't exist locally, import it to the
   * global scope and load it from the capsule
   */
  async findTemplateInGlobalScope(aspectId, name) {
    const {
      globalScopeHarmony,
      components
    } = await this.aspectLoader.loadAspectsFromGlobalScope([aspectId]);
    const remoteGenerator = globalScopeHarmony.get(_generator().GeneratorAspect.id);
    const aspect = components[0];
    const fullAspectId = aspect.id.toString();
    const fromGlobal = await remoteGenerator.searchRegisteredWorkspaceTemplate.call(remoteGenerator, name, fullAspectId);
    return {
      workspaceTemplate: fromGlobal,
      aspect
    };
  }
  async findTemplateInOtherWorkspace(workspacePath, name, aspectId) {
    if (!aspectId) throw new (_bitError().BitError)(`to load a template from a different workspace, please provide the aspect-id using --aspect flag`);
    const harmony = await (0, _bit().loadBit)(workspacePath);
    let workspace;
    try {
      workspace = harmony.get(_workspace().default.id);
    } catch (err) {
      throw new Error(`fatal: "${workspacePath}" is not a valid Bit workspace, make sure the path is correct`);
    }
    const aspectComponentId = await workspace.resolveComponentId(aspectId);
    await workspace.loadAspects([aspectId], true);
    const aspectFullId = aspectComponentId.toString();
    const generator = harmony.get(_generator().GeneratorAspect.id);
    return generator.searchRegisteredWorkspaceTemplate(name, aspectFullId);
  }

  /**
   * returns a specific workspace template.
   */
  async getWorkspaceTemplate(name, aspectId) {
    const registeredTemplate = await this.searchRegisteredWorkspaceTemplate(name, aspectId);
    if (registeredTemplate) {
      return {
        workspaceTemplate: registeredTemplate
      };
    }
    if (!aspectId) {
      throw new (_bitError().BitError)(`template "${name}" was not found, if this is a custom-template, please use --aspect flag`);
    }
    const {
      workspaceTemplate,
      aspect
    } = await this.findTemplateInGlobalScope(aspectId, name);
    if (workspaceTemplate) {
      return {
        workspaceTemplate,
        aspect
      };
    }
    throw new (_bitError().BitError)(`template "${name}" was not found`);
  }
  async searchRegisteredWorkspaceTemplate(name, aspectId) {
    const templates = this.getAllWorkspaceTemplatesFlattened();
    const found = templates.find(({
      id,
      template
    }) => {
      if (aspectId && name) return aspectId === id && name === template.name;
      if (aspectId) return aspectId === id;
      if (name) return name === template.name;
      throw new Error(`searchRegisteredWorkspaceTemplate expects to get "name" or "aspectId"`);
    });
    return found === null || found === void 0 ? void 0 : found.template;
  }
  async generateComponentTemplate(componentNames, templateName, options) {
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    await this.loadAspects();
    const {
      namespace,
      aspect: aspectId
    } = options;
    const templateWithId = this.getComponentTemplate(templateName, aspectId);
    if (!templateWithId) throw new (_bitError().BitError)(`template "${templateName}" was not found`);
    const componentIds = componentNames.map(componentName => this.newComponentHelper.getNewComponentId(componentName, namespace, options.scope));
    const componentGenerator = new (_componentGenerator().ComponentGenerator)(this.workspace, componentIds, options, templateWithId.template, this.envs, this.newComponentHelper, templateWithId.id);
    return componentGenerator.generate();
  }
  async generateWorkspaceTemplate(workspaceName, templateName, options) {
    if (this.workspace) {
      throw new (_bitError().BitError)('Error: unable to generate a new workspace inside of an existing workspace');
    }
    const {
      aspect: aspectId,
      loadFrom
    } = options;
    let template;
    let aspectComponent;
    if (loadFrom) {
      template = await this.findTemplateInOtherWorkspace(loadFrom, templateName, aspectId);
    } else {
      const {
        workspaceTemplate,
        aspect
      } = await this.getWorkspaceTemplate(templateName, aspectId);
      template = workspaceTemplate;
      aspectComponent = aspect;
    }
    if (!template) throw new (_bitError().BitError)(`template "${templateName}" was not found`);
    const workspaceGenerator = new (_workspaceGenerator().WorkspaceGenerator)(workspaceName, options, template, aspectComponent);
    const workspacePath = await workspaceGenerator.generate();
    return {
      workspacePath,
      appName: template.appName
    };
  }
  getAllComponentTemplatesFlattened() {
    const templatesByAspects = this.componentTemplateSlot.toArray();
    return templatesByAspects.flatMap(([id, componentTemplates]) => {
      return componentTemplates.map(template => ({
        id,
        template
      }));
    });
  }
  getAllWorkspaceTemplatesFlattened() {
    const templatesByAspects = this.workspaceTemplateSlot.toArray();
    return templatesByAspects.flatMap(([id, workspaceTemplates]) => {
      return workspaceTemplates.map(template => ({
        id,
        template
      }));
    });
  }
  async loadAspects() {
    if (this.aspectLoaded) return;
    await this.workspace.loadAspects(this.config.aspects);
    this.aspectLoaded = true;
  }
  static async provider([workspace, cli, graphql, envs, aspectLoader, newComponentHelper, community, importer], config, [componentTemplateSlot, workspaceTemplateSlot]) {
    const generator = new GeneratorMain(componentTemplateSlot, workspaceTemplateSlot, config, workspace, envs, aspectLoader, newComponentHelper, importer);
    const commands = [new (_create().CreateCmd)(generator, community.getDocsDomain()), new (_templates().TemplatesCmd)(generator), new (_new().NewCmd)(generator)];
    cli.register(...commands);
    graphql.register((0, _generator2().generatorSchema)(generator));
    aspectLoader.registerPlugins([new (_starter2().StarterPlugin)(generator)]);
    generator.registerComponentTemplate([_componentGenerator2().componentGeneratorTemplate, _starter().starterTemplate, _workspaceGenerator2().workspaceGeneratorTemplate]);
    return generator;
  }
}
exports.GeneratorMain = GeneratorMain;
(0, _defineProperty2().default)(GeneratorMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(GeneratorMain, "dependencies", [_workspace().default, _cli().CLIAspect, _graphql().GraphqlAspect, _envs().EnvsAspect, _aspectLoader().default, _newComponentHelper().default, _community().CommunityAspect, _importer().default]);
(0, _defineProperty2().default)(GeneratorMain, "runtime", _cli().MainRuntime);
_generator().GeneratorAspect.addRuntime(GeneratorMain);

//# sourceMappingURL=generator.main.runtime.js.map