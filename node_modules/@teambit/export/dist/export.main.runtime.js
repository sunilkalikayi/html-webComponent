"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExportMain = void 0;
exports.isUserTryingToExportLanes = isUserTryingToExportLanes;
function _objectWithoutProperties2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
  _objectWithoutProperties2 = function () {
    return data;
  };
  return data;
}
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = _interopRequireDefault(require("@teambit/scope"));
  _scope = function () {
    return data;
  };
  return data;
}
function _ramda() {
  const data = _interopRequireDefault(require("ramda"));
  _ramda = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _analytics() {
  const data = require("@teambit/legacy/dist/analytics/analytics");
  _analytics = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _loader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/loader"));
  _loader = function () {
    return data;
  };
  return data;
}
function _loaderMessages() {
  const data = require("@teambit/legacy/dist/cli/loader/loader-messages");
  _loaderMessages = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _consumer() {
  const data = require("@teambit/legacy/dist/consumer");
  _consumer = function () {
    return data;
  };
  return data;
}
function _ejectComponents() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/eject-components"));
  _ejectComponents = function () {
    return data;
  };
  return data;
}
function _componentsList() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/components-list"));
  _componentsList = function () {
    return data;
  };
  return data;
}
function _generalError() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/error/general-error"));
  _generalError = function () {
    return data;
  };
  return data;
}
function _hooks() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/hooks"));
  _hooks = function () {
    return data;
  };
  return data;
}
function _remove() {
  const data = require("@teambit/remove");
  _remove = function () {
    return data;
  };
  return data;
}
function _links() {
  const data = require("@teambit/legacy/dist/links");
  _links = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/logger/logger"));
  _logger = function () {
    return data;
  };
  return data;
}
function _models() {
  const data = require("@teambit/legacy/dist/scope/models");
  _models = function () {
    return data;
  };
  return data;
}
function _hasWildcard() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/string/has-wildcard"));
  _hasWildcard = function () {
    return data;
  };
  return data;
}
function _scope2() {
  const data = require("@teambit/legacy/dist/scope");
  _scope2 = function () {
    return data;
  };
  return data;
}
function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));
  _workspace = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _http() {
  const data = require("@teambit/legacy/dist/scope/network/http");
  _http = function () {
    return data;
  };
  return data;
}
function _objectList() {
  const data = require("@teambit/legacy/dist/scope/objects/object-list");
  _objectList = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
function _scopeRemotes() {
  const data = require("@teambit/legacy/dist/scope/scope-remotes");
  _scopeRemotes = function () {
    return data;
  };
  return data;
}
function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");
  _dependencyResolver = function () {
    return data;
  };
  return data;
}
function _exportScopeComponents() {
  const data = require("@teambit/legacy/dist/scope/component-ops/export-scope-components");
  _exportScopeComponents = function () {
    return data;
  };
  return data;
}
function _persistFailed() {
  const data = require("@teambit/legacy/dist/scope/exceptions/persist-failed");
  _persistFailed = function () {
    return data;
  };
  return data;
}
function _traverseVersions() {
  const data = require("@teambit/legacy/dist/scope/component-ops/traverse-versions");
  _traverseVersions = function () {
    return data;
  };
  return data;
}
function _export() {
  const data = require("./export.aspect");
  _export = function () {
    return data;
  };
  return data;
}
function _exportCmd() {
  const data = require("./export-cmd");
  _exportCmd = function () {
    return data;
  };
  return data;
}
function _resumeExportCmd() {
  const data = require("./resume-export-cmd");
  _resumeExportCmd = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
const HooksManagerInstance = _hooks().default.getInstance();
class ExportMain {
  constructor(workspace, remove, depResolver) {
    this.workspace = workspace;
    this.remove = remove;
    this.depResolver = depResolver;
  }
  async export(params) {
    HooksManagerInstance.triggerHook(_constants().PRE_EXPORT_HOOK, params);
    const {
      updatedIds,
      nonExistOnBitMap,
      missingScope,
      exported,
      removedIds,
      exportedLanes
    } = await this.exportComponents(params);
    let ejectResults;
    if (params.eject) ejectResults = await ejectExportedComponents(updatedIds);
    const exportResults = {
      componentsIds: exported,
      nonExistOnBitMap,
      removedIds,
      missingScope,
      ejectResults,
      exportedLanes
    };
    HooksManagerInstance.triggerHook(_constants().POST_EXPORT_HOOK, exportResults);
    if (_scope2().Scope.onPostExport) {
      await _scope2().Scope.onPostExport(exported, exportedLanes).catch(err => {
        _logger().default.error('fatal: onPostExport encountered an error (this error does not stop the process)', err);
      });
    }
    return exportResults;
  }
  async exportObjectList(manyObjectsPerRemote, scopeRemotes, centralHubOptions) {
    const http = await _http().Http.connect(_constants().CENTRAL_BIT_HUB_URL, _constants().CENTRAL_BIT_HUB_NAME);
    if (this.shouldPushToCentralHub(manyObjectsPerRemote, scopeRemotes)) {
      const objectList = this.transformToOneObjectListWithScopeData(manyObjectsPerRemote);
      await http.pushToCentralHub(objectList, centralHubOptions);
    } else {
      await this.pushToRemotesCarefully(manyObjectsPerRemote);
    }
  }
  async exportComponents(_ref) {
    let {
        ids,
        includeNonStaged,
        originDirectly
      } = _ref,
      params = (0, _objectWithoutProperties2().default)(_ref, ["ids", "includeNonStaged", "originDirectly"]);
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    const consumer = this.workspace.consumer;
    const {
      idsToExport,
      missingScope,
      idsWithFutureScope,
      laneObject
    } = await this.getComponentsToExport(ids, includeNonStaged);
    if (_ramda().default.isEmpty(idsToExport)) {
      return {
        updatedIds: [],
        nonExistOnBitMap: [],
        removedIds: new (_bitId().BitIds)(),
        missingScope,
        exported: [],
        newIdsOnRemote: [],
        exportedLanes: []
      };
    }

    // validate lane readme component and ensure it has been snapped
    if (laneObject !== null && laneObject !== void 0 && laneObject.readmeComponent) {
      _throwForUnsnappedLaneReadme(laneObject);
    }
    const isOnMain = consumer.isOnMain();
    const {
      exported,
      updatedLocally,
      newIdsOnRemote
    } = await this.exportMany(_objectSpread(_objectSpread({}, params), {}, {
      scope: consumer.scope,
      ids: idsToExport,
      laneObject,
      originDirectly,
      idsWithFutureScope,
      isOnMain
    }));
    if (laneObject) await updateLanesAfterExport(consumer, laneObject);
    const removedIds = await this.getRemovedStagedBitIds();
    const {
      updatedIds,
      nonExistOnBitMap
    } = _updateIdsOnBitMap(consumer.bitMap, updatedLocally);
    await this.removeFromStagedConfig([...updatedIds, ...nonExistOnBitMap]);
    await linkComponents(updatedIds, consumer);
    _analytics().Analytics.setExtraData('num_components', exported.length);
    // it is important to have consumer.onDestroy() before running the eject operation, we want the
    // export and eject operations to function independently. we don't want to lose the changes to
    // .bitmap file done by the export action in case the eject action has failed.
    await consumer.onDestroy();
    return {
      updatedIds,
      nonExistOnBitMap: nonExistOnBitMap.filter(id => !removedIds.hasWithoutVersion(id)),
      removedIds,
      missingScope,
      exported,
      newIdsOnRemote,
      exportedLanes: laneObject ? [laneObject] : []
    };
  }

  /**
   * the export process uses four steps. read more about it here: https://github.com/teambit/bit/pull/3371
   */
  async exportMany({
    scope,
    ids,
    // when exporting a lane, the ids are the lane component ids
    laneObject,
    allVersions,
    originDirectly,
    idsWithFutureScope,
    resumeExportId,
    ignoreMissingArtifacts,
    isOnMain = true
  }) {
    _logger().default.debugAndAddBreadCrumb('scope.exportMany', 'ids: {ids}', {
      ids: ids.toString()
    });
    const scopeRemotes = await (0, _scopeRemotes().getScopeRemotes)(scope);
    const idsGroupedByScope = ids.toGroupByScopeName(idsWithFutureScope);

    /**
     * when a component is exported for the first time, and the lane-scope is not the same as the component-scope, it's
     * important to validate that there is no such component in the original scope. otherwise, later, it'll be impossible
     * to merge the lane because these two components don't have any snap in common.
     */
    const validateTargetScopeForLanes = async () => {
      if (!laneObject) {
        return;
      }
      const newIds = _bitId().BitIds.fromArray(ids.filter(id => !id.hasScope()));
      const newIdsGrouped = newIds.toGroupByScopeName(idsWithFutureScope);
      await (0, _pMapSeries().default)(Object.keys(newIdsGrouped), async scopeName => {
        if (scopeName === laneObject.scope) {
          // this validation is redundant if the lane-component is in the same scope as the lane-object
          return;
        }
        // by getting the remote we also validate that this scope actually exists.
        const remote = await scopeRemotes.resolve(scopeName, scope);
        const list = await remote.list();
        const listIds = _bitId().BitIds.fromArray(list.map(listItem => listItem.id));
        newIdsGrouped[scopeName].forEach(id => {
          if (listIds.hasWithoutScopeAndVersion(id)) {
            throw new Error(`unable to export a lane with a new component "${id.toString()}", which has the default-scope "${scopeName}".
  this scope already has a component with the same name. as such, it'll be impossible to merge the lane later because these two components are different`);
          }
        });
      });
    };

    /**
     * by default, when exporting a lane, it traverse from the Lane's head and therefore it may skip the main head.
     * later, if for some reason the original component was deleted in its scope, the head object will be missing.
     */
    const addMainHeadIfPossible = async (allHashes, modelComponent) => {
      const head = modelComponent.head;
      if (!head) return;
      if (allHashes.find(h => h.hash === head.hash)) return; // head is already in the list
      if (!(await scope.objects.has(head))) return; // it should not happen. but if it does, we don't want to block the export
      allHashes.push(head);
    };
    const getVersionsToExport = async (modelComponent, lane) => {
      const localTagsOrHashes = await modelComponent.getLocalTagsOrHashes(scope.objects);
      if (!allVersions && !lane) {
        return localTagsOrHashes;
      }
      let stopAt;
      if (lane && !allVersions) {
        // if lane is exported, components from other remotes may be part of this lane. we need their history.
        // because their history could already exist on the remote from previous exports, we search this id in all
        // remote-refs files of this lane-scope. while traversing the local history, stop when finding one of the remotes.
        stopAt = await scope.objects.remoteLanes.getRefsFromAllLanesOnScope(lane.scope, modelComponent.toBitId());
        if (modelComponent.laneHeadRemote) stopAt.push(modelComponent.laneHeadRemote);
      }
      const allHashes = await (0, _traverseVersions().getAllVersionHashes)({
        modelComponent,
        repo: scope.objects,
        stopAt
      });
      await addMainHeadIfPossible(allHashes, modelComponent);
      return modelComponent.switchHashesWithTagsIfExist(allHashes);
    };
    await validateTargetScopeForLanes();
    const groupedByScopeString = Object.keys(idsGroupedByScope).map(scopeName => `scope "${scopeName}": ${idsGroupedByScope[scopeName].toString()}`).join(', ');
    _logger().default.debug(`export-scope-components, export to the following scopes ${groupedByScopeString}`);
    const exportVersions = [];
    const populateExportMetadata = async modelComponent => {
      const localTagsOrHashes = await modelComponent.getLocalTagsOrHashes(scope.objects);
      const head = modelComponent.getHeadRegardlessOfLane();
      if (!head) {
        throw new Error(`unable to export ${modelComponent.id()}, head is missing`);
      }
      exportVersions.push({
        id: modelComponent.toBitId(),
        versions: localTagsOrHashes,
        head
      });
    };
    const getUpdatedObjectsToExport = async (remoteNameStr, bitIds, lane) => {
      bitIds.throwForDuplicationIgnoreVersion();
      const remote = await scopeRemotes.resolve(remoteNameStr, scope);
      const idsToChangeLocally = _bitId().BitIds.fromArray(bitIds.filter(id => !id.scope || id.scope === remoteNameStr));
      const componentsAndObjects = [];
      const objectList = new (_objectList().ObjectList)();
      const objectListPerName = {};
      const processModelComponent = async modelComponent => {
        const versionToExport = await getVersionsToExport(modelComponent, lane);
        modelComponent.clearStateData();
        const objectItems = await modelComponent.collectVersionsObjects(scope.objects, versionToExport, ignoreMissingArtifacts);
        const objectsList = await new (_objectList().ObjectList)(objectItems).toBitObjects();
        const componentAndObject = {
          component: modelComponent,
          objects: objectsList.getAll()
        };
        await this.convertToCorrectScopeHarmony(scope, componentAndObject, remoteNameStr, bitIds, idsWithFutureScope);
        await populateExportMetadata(modelComponent);
        const remoteObj = {
          url: remote.host,
          name: remote.name,
          date: Date.now().toString()
        };
        modelComponent.addScopeListItem(remoteObj);
        componentsAndObjects.push(componentAndObject);
        const componentBuffer = await modelComponent.compress();
        const componentData = {
          ref: modelComponent.hash(),
          buffer: componentBuffer,
          type: modelComponent.getType()
        };
        const objectsBuffer = await Promise.all(componentAndObject.objects.map(async obj => ({
          ref: obj.hash(),
          buffer: await obj.compress(),
          type: obj.getType()
        })));
        const allObjectsData = [componentData, ...objectsBuffer];
        objectListPerName[modelComponent.name] = new (_objectList().ObjectList)(allObjectsData);
        objectList.addIfNotExist(allObjectsData);
      };
      const modelComponents = await (0, _pMapSeries().default)(bitIds, id => scope.getModelComponent(id));
      // super important! otherwise, the processModelComponent() changes objects in memory, while the key remains the same
      scope.objects.clearCache();
      // don't use Promise.all, otherwise, it'll throw "JavaScript heap out of memory" on a large set of data
      await (0, _pMapSeries().default)(modelComponents, processModelComponent);
      if (lane) {
        lane.components.forEach(c => {
          const idWithFutureScope = idsWithFutureScope.searchWithoutScopeAndVersion(c.id);
          c.id = c.id.hasScope() ? c.id : c.id.changeScope((idWithFutureScope === null || idWithFutureScope === void 0 ? void 0 : idWithFutureScope.scope) || lane.scope);
        });
        if (lane.readmeComponent) {
          lane.readmeComponent.id = lane.readmeComponent.id.hasScope() ? lane.readmeComponent.id : lane.readmeComponent.id.changeScope(lane.scope);
        }
        const laneData = {
          ref: lane.hash(),
          buffer: await lane.compress()
        };
        objectList.addIfNotExist([laneData]);
      }
      return {
        remote,
        objectList,
        objectListPerName,
        idsToChangeLocally,
        componentsAndObjects
      };
    };
    const manyObjectsPerRemote = laneObject ? [await getUpdatedObjectsToExport(laneObject.scope, ids, laneObject)] : await (0, _pMapSeries().default)(Object.keys(idsGroupedByScope), scopeName => getUpdatedObjectsToExport(scopeName, idsGroupedByScope[scopeName], laneObject));
    const getExportMetadata = async () => {
      const exportMetadata = new (_models().ExportMetadata)({
        exportVersions
      });
      const exportMetadataObj = await exportMetadata.compress();
      const exportMetadataItem = {
        ref: exportMetadata.hash(),
        buffer: exportMetadataObj,
        type: _models().ExportMetadata.name
      };
      return exportMetadataItem;
    };
    const pushAllToCentralHub = async () => {
      const objectList = this.transformToOneObjectListWithScopeData(manyObjectsPerRemote);
      objectList.addIfNotExist([await getExportMetadata()]);
      const http = await _http().Http.connect(_constants().CENTRAL_BIT_HUB_URL, _constants().CENTRAL_BIT_HUB_NAME);
      const pushResults = await http.pushToCentralHub(objectList);
      const {
        failedScopes,
        successIds,
        errors
      } = pushResults;
      if (failedScopes.length) {
        throw new (_persistFailed().PersistFailed)(failedScopes, errors);
      }
      const exportedBitIds = successIds.map(id => _bitId().BitId.parse(id, true));
      if (manyObjectsPerRemote.length === 1) {
        // when on a lane, it's always exported to the lane. and the ids can be from different scopes, so having the
        // filter below, will remove these components from the output of bit-export at the end.
        manyObjectsPerRemote[0].exportedIds = exportedBitIds.map(id => id.toString());
      } else {
        manyObjectsPerRemote.forEach(objectPerRemote => {
          const idsPerScope = exportedBitIds.filter(id => id.scope === objectPerRemote.remote.name);
          // it's possible that idsPerScope is an empty array, in case the objects were exported already before
          objectPerRemote.exportedIds = idsPerScope.map(id => id.toString());
        });
      }
    };
    const updateLocalObjects = async lane => {
      return (0, _pMapSeries().default)(manyObjectsPerRemote, async objectsPerRemote => {
        const {
          remote,
          idsToChangeLocally,
          componentsAndObjects,
          exportedIds
        } = objectsPerRemote;
        const remoteNameStr = remote.name;
        // on Harmony, version hashes don't change, the new versions will replace the old ones.
        // on the legacy, even when the hash changed, it's fine to have the old objects laying around.
        // (could be removed in the future by some garbage collection).
        const removeComponentVersions = false;
        const refsToRemove = await Promise.all(idsToChangeLocally.map(id => scope.sources.getRefsForComponentRemoval(id, removeComponentVersions)));
        scope.objects.removeManyObjects(refsToRemove.flat());
        // @ts-ignore
        idsToChangeLocally.forEach(id => {
          var _idsWithFutureScope$s;
          scope.createSymlink(id, ((_idsWithFutureScope$s = idsWithFutureScope.searchWithoutScopeAndVersion(id)) === null || _idsWithFutureScope$s === void 0 ? void 0 : _idsWithFutureScope$s.scope) || remoteNameStr);
        });
        componentsAndObjects.forEach(componentObject => scope.sources.put(componentObject));

        // update lanes
        if (lane) {
          if (idsToChangeLocally.length) {
            // otherwise, we don't want to update scope-name of components in the lane object
            scope.objects.add(lane);
          }
          await scope.objects.remoteLanes.syncWithLaneObject(remoteNameStr, lane);
        }
        if (isOnMain && !lane) {
          // all exported from main
          const remoteLaneId = _laneId().LaneId.from(_laneId().DEFAULT_LANE, remoteNameStr);
          await scope.objects.remoteLanes.loadRemoteLane(remoteLaneId);
          await Promise.all(componentsAndObjects.map(async ({
            component
          }) => {
            await scope.objects.remoteLanes.addEntry(remoteLaneId, component.toBitId(), component.getHead());
          }));
        }
        await scope.objects.persist();
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const newIdsOnRemote = exportedIds.map(id => _bitId().BitId.parse(id, true));
        // remove version. exported component might have multiple versions exported
        const idsWithRemoteScope = newIdsOnRemote.map(id => id.changeVersion(undefined));
        const idsWithRemoteScopeUniq = _bitId().BitIds.uniqFromArray(idsWithRemoteScope);
        return {
          newIdsOnRemote,
          exported: idsWithRemoteScopeUniq,
          updatedLocally: _bitId().BitIds.fromArray(idsWithRemoteScopeUniq.filter(id => idsToChangeLocally.hasWithoutScopeAndVersion(id)))
        };
      });
    };
    if (resumeExportId) {
      const remotes = manyObjectsPerRemote.map(o => o.remote);
      await (0, _exportScopeComponents().validateRemotes)(remotes, resumeExportId);
      await (0, _exportScopeComponents().persistRemotes)(manyObjectsPerRemote, resumeExportId);
    } else if (this.shouldPushToCentralHub(manyObjectsPerRemote, scopeRemotes, originDirectly)) {
      await pushAllToCentralHub();
    } else {
      // await pushToRemotes();
      await this.pushToRemotesCarefully(manyObjectsPerRemote, resumeExportId);
    }
    _loader().default.start('updating data locally...');
    const results = await updateLocalObjects(laneObject);
    return {
      newIdsOnRemote: _ramda().default.flatten(results.map(r => r.newIdsOnRemote)),
      exported: _bitId().BitIds.uniqFromArray(_ramda().default.flatten(results.map(r => r.exported))),
      updatedLocally: _bitId().BitIds.uniqFromArray(_ramda().default.flatten(results.map(r => r.updatedLocally)))
    };
  }
  transformToOneObjectListWithScopeData(objectsPerRemote) {
    const objectList = new (_objectList().ObjectList)();
    objectsPerRemote.forEach(objPerRemote => {
      objPerRemote.objectList.addScopeName(objPerRemote.remote.name);
      objectList.mergeObjectList(objPerRemote.objectList);
    });
    return objectList;
  }
  async pushToRemotesCarefully(manyObjectsPerRemote, resumeExportId) {
    const remotes = manyObjectsPerRemote.map(o => o.remote);
    const clientId = resumeExportId || Date.now().toString();
    await this.pushRemotesPendingDir(clientId, manyObjectsPerRemote, resumeExportId);
    await (0, _exportScopeComponents().validateRemotes)(remotes, clientId, Boolean(resumeExportId));
    await (0, _exportScopeComponents().persistRemotes)(manyObjectsPerRemote, clientId);
  }
  async pushRemotesPendingDir(clientId, manyObjectsPerRemote, resumeExportId) {
    if (resumeExportId) {
      _logger().default.debug('pushRemotesPendingDir - skip as the resumeExportId was passed');
      // no need to transfer the objects, they're already on the server. also, since this clientId
      // exists already on the remote pending-dir, it'll cause a collision.
      return;
    }
    const pushOptions = {
      clientId
    };
    const pushedRemotes = [];
    await (0, _pMapSeries().default)(manyObjectsPerRemote, async objectsPerRemote => {
      const {
        remote,
        objectList
      } = objectsPerRemote;
      _loader().default.start(`transferring ${objectList.count()} objects to the remote "${remote.name}"...`);
      try {
        await remote.pushMany(objectList, pushOptions, {});
        _logger().default.debugAndAddBreadCrumb('export-scope-components.pushRemotesPendingDir', 'successfully pushed all objects to the pending-dir directory on the remote');
        pushedRemotes.push(remote);
      } catch (err) {
        _logger().default.warnAndAddBreadCrumb('exportMany', 'failed pushing objects to the remote');
        await (0, _exportScopeComponents().removePendingDirs)(pushedRemotes, clientId);
        throw err;
      }
    });
  }
  shouldPushToCentralHub(manyObjectsPerRemote, scopeRemotes, originDirectly = false) {
    if (originDirectly) return false;
    const hubRemotes = manyObjectsPerRemote.filter(m => scopeRemotes.isHub(m.remote.name));
    if (!hubRemotes.length) return false;
    if (hubRemotes.length === manyObjectsPerRemote.length) return true; // all are hub
    // @todo: maybe create a flag "no-central" to support this workflow
    throw new (_bitError().BitError)(`some of your components are configured to be exported to a local scope and some to the bit.cloud hub. this is not supported`);
  }

  /**
   * Component and dependencies id changes:
   * When exporting components with dependencies to a bare-scope, some of the dependencies may be created locally and as
   * a result their scope-name is null. Before the bare-scope gets the components, convert these scope names
   * to the bare-scope name.
   *
   * This is the Harmony version of "convertToCorrectScope". No more codemod and no more hash changes.
   */
  async convertToCorrectScopeHarmony(scope, componentsObjects, remoteScope, exportingIds, idsWithFutureScope, shouldFork = false // not in used currently, but might be needed soon
  ) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const versionsObjects = componentsObjects.objects.filter(object => object instanceof _models().Version);
    const haveVersionsChanged = await Promise.all(versionsObjects.map(async objectVersion => {
      const didDependencyChange = changeDependencyScope(objectVersion);
      changeExtensionsScope(objectVersion);
      this.depResolver.updateDepsOnLegacyExport(objectVersion, getIdWithUpdatedScope.bind(this));
      return didDependencyChange;
    }));
    const shouldChangeScope = shouldFork ? remoteScope !== componentsObjects.component.scope : !componentsObjects.component.scope;
    const hasComponentChanged = shouldChangeScope;
    if (shouldChangeScope) {
      const idWithFutureScope = idsWithFutureScope.searchWithoutScopeAndVersion(componentsObjects.component.toBitId());
      componentsObjects.component.scope = (idWithFutureScope === null || idWithFutureScope === void 0 ? void 0 : idWithFutureScope.scope) || remoteScope;
    }

    // return true if one of the versions has changed or the component itself
    return haveVersionsChanged.some(x => x) || hasComponentChanged;
    function changeDependencyScope(version) {
      let hasChanged = false;
      version.getAllDependencies().forEach(dependency => {
        const updatedScope = getIdWithUpdatedScope(dependency.id);
        if (!updatedScope.isEqual(dependency.id)) {
          hasChanged = true;
          dependency.id = updatedScope;
        }
      });
      const ids = version.flattenedDependencies;
      const needsChange = ids.some(id => id.scope !== remoteScope);
      if (needsChange) {
        version.flattenedDependencies = getBitIdsWithUpdatedScope(ids);
        hasChanged = true;
      }
      return hasChanged;
    }
    function changeExtensionsScope(version) {
      let hasChanged = false;
      version.extensions.forEach(ext => {
        if (ext.extensionId) {
          const updatedScope = getIdWithUpdatedScope(ext.extensionId);
          if (!updatedScope.isEqual(ext.extensionId)) {
            hasChanged = true;
            ext.extensionId = updatedScope;
          }
        }
      });
      return hasChanged;
    }
    function getIdWithUpdatedScope(dependencyId) {
      if (dependencyId.scope === remoteScope) {
        return dependencyId; // nothing has changed
      }
      // either, dependencyId is new, or this dependency is among the components to export (in case of fork)
      if (!dependencyId.scope || exportingIds.hasWithoutVersion(dependencyId)) {
        const depId = _models().ModelComponent.fromBitId(dependencyId);
        // todo: use 'load' for async and switch the foreach with map.
        const dependencyObject = scope.objects.loadSync(depId.hash());
        if (dependencyObject instanceof _models().Symlink) {
          return dependencyId.changeScope(dependencyObject.realScope);
        }
        const currentlyExportedDep = idsWithFutureScope.searchWithoutScopeAndVersion(dependencyId);
        if (currentlyExportedDep && currentlyExportedDep.scope) {
          // it's possible that a dependency has a different defaultScope settings.
          return dependencyId.changeScope(currentlyExportedDep.scope);
        }
        return dependencyId.changeScope(remoteScope);
      }
      return dependencyId;
    }
    function getBitIdsWithUpdatedScope(bitIds) {
      const updatedIds = bitIds.map(id => getIdWithUpdatedScope(id));
      return _bitId().BitIds.fromArray(updatedIds);
    }
  }
  async removeFromStagedConfig(ids) {
    const componentIds = await this.workspace.resolveMultipleComponentIds(ids);
    const stagedConfig = await this.workspace.scope.getStagedConfig();
    componentIds.map(compId => stagedConfig.removeComponentConfig(compId));
    await stagedConfig.write();
  }
  async getComponentsToExport(ids, includeNonStaged) {
    const consumer = this.workspace.consumer;
    const componentsList = new (_componentsList().default)(consumer);
    const idsHaveWildcard = (0, _hasWildcard().default)(ids);
    const filterNonScopeIfNeeded = async bitIds => {
      const idsWithFutureScope = await this.getIdsWithFutureScope(bitIds);
      const [idsToExport, missingScope] = _ramda().default.partition(id => {
        const idWithFutureScope = idsWithFutureScope.searchWithoutScopeAndVersion(id);
        if (!idWithFutureScope) throw new Error(`idsWithFutureScope is missing ${id.toString()}`);
        return idWithFutureScope.hasScope();
      }, bitIds);
      return {
        idsToExport: _bitId().BitIds.fromArray(idsToExport),
        missingScope,
        idsWithFutureScope
      };
    };
    if (isUserTryingToExportLanes(consumer)) {
      if (ids.length) {
        throw new (_generalError().default)(`when checked out to a lane, all its components are exported. please omit the ids`);
      }
      const {
        componentsToExport,
        laneObject
      } = await this.getLaneCompIdsToExport(consumer, includeNonStaged);
      const loaderMsg = componentsToExport.length > 1 ? _loaderMessages().BEFORE_EXPORTS : _loaderMessages().BEFORE_EXPORT;
      _loader().default.start(loaderMsg);
      const filtered = await filterNonScopeIfNeeded(componentsToExport);
      return _objectSpread(_objectSpread({}, filtered), {}, {
        laneObject
      });
    }
    if (!ids.length || idsHaveWildcard) {
      _loader().default.start(_loaderMessages().BEFORE_LOADING_COMPONENTS);
      const exportPendingComponents = includeNonStaged ? await componentsList.listNonNewComponentsIds() : await componentsList.listExportPendingComponentsIds();
      const componentsToExport = idsHaveWildcard ? _componentsList().default.filterComponentsByWildcard(exportPendingComponents, ids) : exportPendingComponents;
      const loaderMsg = componentsToExport.length > 1 ? _loaderMessages().BEFORE_EXPORTS : _loaderMessages().BEFORE_EXPORT;
      _loader().default.start(loaderMsg);
      return filterNonScopeIfNeeded(componentsToExport);
    }
    _loader().default.start(_loaderMessages().BEFORE_EXPORT); // show single export
    const parsedIds = await Promise.all(ids.map(id => getParsedId(consumer, id)));
    const statuses = await consumer.getManyComponentsStatuses(parsedIds);
    statuses.forEach(({
      id,
      status
    }) => {
      if (status.nested) {
        throw new (_generalError().default)(`unable to export "${id.toString()}", the component is not fully available. please use "bit import" first`);
      }
    });
    return filterNonScopeIfNeeded(_bitId().BitIds.fromArray(parsedIds));
  }
  async getIdsWithFutureScope(ids) {
    const idsArrayP = ids.map(async id => {
      if (id.hasScope()) return id;
      const componentId = await this.workspace.resolveComponentId(id);
      const finalScope = await this.workspace.componentDefaultScope(componentId);
      if (finalScope) {
        return id.changeScope(finalScope);
      }
      return id;
    });
    const idsArray = await Promise.all(idsArrayP);
    return _bitId().BitIds.fromArray(idsArray);
  }
  async getLaneCompIdsToExport(consumer, includeNonStaged) {
    const currentLaneId = consumer.getCurrentLaneId();
    const laneObject = await consumer.scope.loadLane(currentLaneId);
    if (!laneObject) {
      throw new Error(`fatal: unable to load the current lane object (${currentLaneId.toString()})`);
    }
    _loader().default.start(_loaderMessages().BEFORE_LOADING_COMPONENTS);
    const componentsList = new (_componentsList().default)(consumer);
    const componentsToExportWithoutRemoved = includeNonStaged ? await componentsList.listNonNewComponentsIds() : await componentsList.listExportPendingComponentsIds(laneObject);
    const removedStagedBitIds = await this.getRemovedStagedBitIds();
    const componentsToExport = _bitId().BitIds.uniqFromArray([...componentsToExportWithoutRemoved, ...removedStagedBitIds]);
    return {
      componentsToExport,
      laneObject
    };
  }
  async getRemovedStagedBitIds() {
    const removedStaged = await this.remove.getRemovedStaged();
    return _bitId().BitIds.fromArray(removedStaged.map(r => r._legacy).map(id => id.changeVersion(undefined)));
  }
  static async provider([cli, scope, workspace, remove, depResolver]) {
    const exportMain = new ExportMain(workspace, remove, depResolver);
    cli.register(new (_resumeExportCmd().ResumeExportCmd)(scope), new (_exportCmd().ExportCmd)(exportMain));
    return exportMain;
  }
}
exports.ExportMain = ExportMain;
(0, _defineProperty2().default)(ExportMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(ExportMain, "dependencies", [_cli().CLIAspect, _scope().default, _workspace().default, _remove().RemoveAspect, _dependencyResolver().DependencyResolverAspect]);
_export().ExportAspect.addRuntime(ExportMain);
function _updateIdsOnBitMap(bitMap, componentsIds) {
  const updatedIds = [];
  const nonExistOnBitMap = new (_bitId().BitIds)();
  componentsIds.forEach(componentsId => {
    const resultId = bitMap.updateComponentId(componentsId, true);
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (resultId.hasVersion()) updatedIds.push(resultId);else nonExistOnBitMap.push(resultId);
  });
  return {
    updatedIds,
    nonExistOnBitMap
  };
}
async function getParsedId(consumer, id) {
  // reason why not calling `consumer.getParsedId()` first is because a component might not be on
  // .bitmap and only in the scope. we support this case and enable to export
  const parsedId = await consumer.scope.getParsedId(id);
  if (parsedId.hasScope()) return parsedId;
  // parsing id from the scope, doesn't provide the scope-name in case it's missing, in this case
  // get the id including the scope from the consumer.
  try {
    return consumer.getParsedId(id);
  } catch (err) {
    // not in the consumer, just return the one parsed without the scope name
    return parsedId;
  }
}
async function linkComponents(ids, consumer) {
  // we don't have much of a choice here, we have to load all the exported components in order to link them
  // some of the components might be authored, some might be imported.
  // when a component has dists, we need the consumer-component object to retrieve the dists info.
  const components = await Promise.all(ids.map(id => consumer.loadComponentFromModel(id)));
  const nodeModuleLinker = new (_links().NodeModuleLinker)(components, consumer, consumer.bitMap);
  await nodeModuleLinker.link();
}
async function ejectExportedComponents(componentsIds) {
  const consumer = await (0, _consumer().loadConsumer)(undefined, true);
  let ejectResults;
  try {
    const ejectComponents = new (_ejectComponents().default)(consumer, componentsIds);
    ejectResults = await ejectComponents.eject();
  } catch (err) {
    const ejectErr = `The components ${componentsIds.map(c => c.toString()).join(', ')} were exported successfully.
    However, the eject operation has failed due to an error: ${err.msg || err}`;
    _logger().default.error(ejectErr, err);
    throw new Error(ejectErr);
  }
  // run the consumer.onDestroy() again, to write the changes done by the eject action to .bitmap
  await consumer.onDestroy();
  return ejectResults;
}
function _throwForUnsnappedLaneReadme(lane) {
  var _lane$getComponentHea;
  const readmeComponent = lane.readmeComponent;
  const isValid = (readmeComponent === null || readmeComponent === void 0 ? void 0 : readmeComponent.head) && lane.getComponent(readmeComponent.id) && ((_lane$getComponentHea = lane.getComponentHead(readmeComponent.id)) === null || _lane$getComponentHea === void 0 ? void 0 : _lane$getComponentHea.isEqual(readmeComponent === null || readmeComponent === void 0 ? void 0 : readmeComponent.head));
  if (!isValid) {
    throw new (_bitError().BitError)(`${lane === null || lane === void 0 ? void 0 : lane.name} has a readme component ${readmeComponent.id} that hasn't been snapped on the lane.
      Please run either snap -a or snap ${readmeComponent.id} to snap the component on the lane before exporting it.`);
  }
}
async function updateLanesAfterExport(consumer, lane) {
  const currentLane = consumer.getCurrentLaneId();
  const isCurrentLane = lane.name === currentLane.name;
  if (!isCurrentLane) {
    throw new Error(`updateLanesAfterExport should get called only with current lane, got ${lane.name}, current ${currentLane.name}`);
  }
  consumer.setCurrentLane(lane.toLaneId(), true);
  consumer.scope.scopeJson.removeLaneFromNew(lane.name);
  lane.isNew = false;
}
function isUserTryingToExportLanes(consumer) {
  return consumer.isOnLane();
}

//# sourceMappingURL=export.main.runtime.js.map