import { CLIMain } from '@teambit/cli';
import { ScopeMain } from '@teambit/scope';
import { BitId, BitIds } from '@teambit/legacy/dist/bit-id';
import { Consumer } from '@teambit/legacy/dist/consumer';
import { RemoveMain } from '@teambit/remove';
import { Lane } from '@teambit/legacy/dist/scope/models';
import { Scope } from '@teambit/legacy/dist/scope';
import { Workspace } from '@teambit/workspace';
import { ObjectList } from '@teambit/legacy/dist/scope/objects/object-list';
import { Remote, Remotes } from '@teambit/legacy/dist/remotes';
import { DependencyResolverMain } from '@teambit/dependency-resolver';
export declare type OnExportIdTransformer = (id: BitId) => BitId;
declare type ObjectsPerRemote = {
    remote: Remote;
    objectList: ObjectList;
    exportedIds?: string[];
};
declare type ExportParams = {
    ids: string[];
    eject: boolean;
    allVersions: boolean;
    originDirectly: boolean;
    includeNonStaged: boolean;
    resumeExportId: string | undefined;
    ignoreMissingArtifacts: boolean;
};
export declare class ExportMain {
    private workspace;
    private remove;
    private depResolver;
    constructor(workspace: Workspace, remove: RemoveMain, depResolver: DependencyResolverMain);
    export(params: ExportParams): Promise<{
        componentsIds: BitId[];
        nonExistOnBitMap: BitId[];
        removedIds: BitIds;
        missingScope: BitId[];
        ejectResults: any;
        exportedLanes: Lane[];
    }>;
    exportObjectList(manyObjectsPerRemote: ObjectsPerRemote[], scopeRemotes: Remotes, centralHubOptions?: Record<string, any>): Promise<void>;
    private exportComponents;
    /**
     * the export process uses four steps. read more about it here: https://github.com/teambit/bit/pull/3371
     */
    exportMany({ scope, ids, // when exporting a lane, the ids are the lane component ids
    laneObject, allVersions, originDirectly, idsWithFutureScope, resumeExportId, ignoreMissingArtifacts, isOnMain, }: {
        scope: Scope;
        ids: BitIds;
        laneObject?: Lane;
        allVersions: boolean;
        originDirectly?: boolean;
        idsWithFutureScope: BitIds;
        resumeExportId?: string | undefined;
        ignoreMissingArtifacts?: boolean;
        isOnMain?: boolean;
    }): Promise<{
        exported: BitIds;
        updatedLocally: BitIds;
        newIdsOnRemote: BitId[];
    }>;
    private transformToOneObjectListWithScopeData;
    private pushToRemotesCarefully;
    private pushRemotesPendingDir;
    private shouldPushToCentralHub;
    /**
     * Component and dependencies id changes:
     * When exporting components with dependencies to a bare-scope, some of the dependencies may be created locally and as
     * a result their scope-name is null. Before the bare-scope gets the components, convert these scope names
     * to the bare-scope name.
     *
     * This is the Harmony version of "convertToCorrectScope". No more codemod and no more hash changes.
     */
    private convertToCorrectScopeHarmony;
    private removeFromStagedConfig;
    private getComponentsToExport;
    private getIdsWithFutureScope;
    private getLaneCompIdsToExport;
    private getRemovedStagedBitIds;
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: import("@teambit/harmony").Aspect[];
    static provider([cli, scope, workspace, remove, depResolver]: [
        CLIMain,
        ScopeMain,
        Workspace,
        RemoveMain,
        DependencyResolverMain
    ]): Promise<ExportMain>;
}
export declare function isUserTryingToExportLanes(consumer: Consumer): boolean;
export {};
