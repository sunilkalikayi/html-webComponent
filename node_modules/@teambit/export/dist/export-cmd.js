"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExportCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _ejectTemplate() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/templates/eject-template"));
  _ejectTemplate = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _chalk() {
  const data = _interopRequireDefault(require("chalk"));
  _chalk = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
class ExportCmd {
  constructor(exportMain) {
    this.exportMain = exportMain;
    (0, _defineProperty2().default)(this, "name", 'export [component-patterns...]');
    (0, _defineProperty2().default)(this, "description", 'export components from the workspace to remote scopes');
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'component-patterns...',
      description: 'component IDs, component names, or component patterns (separated by space). Use patterns to export groups of components using a common scope or namespace. E.g., "utils/*" (wrap with double quotes)'
    }]);
    (0, _defineProperty2().default)(this, "extendedDescription", `bit export => export all staged components to their current scope, if checked out to a lane, export the lane as well
  \`bit export [id...]\` => export the given ids to their current scope
  ${(0, _constants().WILDCARD_HELP)('export remote-scope')}`);
    (0, _defineProperty2().default)(this, "alias", 'e');
    (0, _defineProperty2().default)(this, "helpUrl", 'components/exporting-components');
    (0, _defineProperty2().default)(this, "options", [['e', 'eject', 'replace the exported components with their corresponding packages (to use these components without further maintaining them)'], ['a', 'all', 'export all components, including non-staged (useful when components in the remote scope are corrupted or missing)'], ['', 'all-versions', 'export not only staged versions but all of them (useful when versions in the remote scope are corrupted or missing)'], ['', 'origin-directly', 'EXPERIMENTAL. avoid export to the central hub, instead, export directly to the original scopes. not recommended!'], ['', 'resume <string>', 'in case the previous export failed and suggested to resume with an export-id, enter the id'], ['', 'ignore-missing-artifacts', "EXPERIMENTAL. don't throw an error when artifact files are missing. not recommended, unless you're sure the artifacts are in the remote"], ['j', 'json', 'show output in json format']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "group", 'collaborate');
    (0, _defineProperty2().default)(this, "remoteOp", true);
  }
  async report([ids = []], {
    eject = false,
    all = false,
    allVersions = false,
    originDirectly = false,
    ignoreMissingArtifacts = false,
    resume
  }) {
    const {
      componentsIds,
      nonExistOnBitMap,
      removedIds,
      missingScope,
      exportedLanes,
      ejectResults
    } = await this.exportMain.export({
      ids,
      eject,
      includeNonStaged: all || allVersions,
      allVersions: allVersions || all,
      originDirectly,
      resumeExportId: resume,
      ignoreMissingArtifacts
    });
    if ((0, _lodash().isEmpty)(componentsIds) && (0, _lodash().isEmpty)(nonExistOnBitMap) && (0, _lodash().isEmpty)(missingScope)) {
      return _chalk().default.yellow('nothing to export');
    }
    const exportOutput = () => {
      if ((0, _lodash().isEmpty)(componentsIds)) return '';
      const lanesOutput = exportedLanes.length ? ` from lane ${_chalk().default.bold(exportedLanes[0].name)}` : '';
      return _chalk().default.green(`exported the following ${componentsIds.length} component(s)${lanesOutput}:\n${_chalk().default.bold(componentsIds.join('\n'))}`);
    };
    const nonExistOnBitMapOutput = () => {
      // if includeDependencies is true, the nonExistOnBitMap might be the dependencies
      if ((0, _lodash().isEmpty)(nonExistOnBitMap)) return '';
      const idsStr = nonExistOnBitMap.map(id => id.toString()).join(', ');
      return _chalk().default.yellow(`${idsStr}\nexported successfully. bit did not update the workspace as the component files are not tracked. this might happen when a component was tracked in a different git branch. to fix it check if they where tracked in a different git branch, checkout to that branch and resync by running 'bit import'. or stay on your branch and track the components again using 'bit add'.\n`);
    };
    const removedOutput = () => {
      if (!removedIds.length) return '';
      const title = _chalk().default.bold(`\n\nthe following component(s) have been marked as removed on the remote\n`);
      const idsStr = removedIds.join('\n');
      return title + idsStr;
    };
    const missingScopeOutput = () => {
      if ((0, _lodash().isEmpty)(missingScope)) return '';
      const idsStr = missingScope.map(id => id.toString()).join(', ');
      return _chalk().default.yellow(`the following component(s) were not exported: ${_chalk().default.bold(idsStr)}.\nplease specify <remote> to export them, or set a "defaultScope" in your workspace config\n\n`);
    };
    const ejectOutput = () => {
      if (!ejectResults) return '';
      const output = (0, _ejectTemplate().default)(ejectResults);
      return `\n${output}`;
    };
    return nonExistOnBitMapOutput() + missingScopeOutput() + exportOutput() + ejectOutput() + removedOutput();
  }
  async json([ids = []], {
    eject = false,
    all = false,
    allVersions = false,
    originDirectly = false,
    ignoreMissingArtifacts = false,
    resume
  }) {
    const results = await this.exportMain.export({
      ids,
      eject,
      includeNonStaged: all || allVersions,
      allVersions: allVersions || all,
      originDirectly,
      resumeExportId: resume,
      ignoreMissingArtifacts
    });
    return results;
  }
}
exports.ExportCmd = ExportCmd;

//# sourceMappingURL=export-cmd.js.map