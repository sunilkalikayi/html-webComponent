import { Component, ComponentID, Snap, State } from '@teambit/component';
import { Logger } from '@teambit/logger';
import ConsumerComponent from '@teambit/legacy/dist/consumer/component';
import type { ScopeMain } from './scope.main.runtime';
export declare class ScopeComponentLoader {
    private scope;
    private logger;
    private componentsCache;
    private importedComponentsCache;
    constructor(scope: ScopeMain, logger: Logger);
    get(id: ComponentID, importIfMissing?: boolean): Promise<Component | undefined>;
    getFromConsumerComponent(consumerComponent: ConsumerComponent): Promise<Component>;
    /**
     * get a component from a remote without importing it
     */
    getRemoteComponent(id: ComponentID): Promise<Component>;
    /**
     * get components from a remote without importing it
     */
    getManyRemoteComponents(ids: ComponentID[]): Promise<Component[]>;
    getState(id: ComponentID, hash: string): Promise<State>;
    getSnap(id: ComponentID, hash: string): Promise<Snap>;
    clearCache(): void;
    /**
     * make sure that not only the id-str match, but also the legacy-id.
     * this is needed because the ComponentID.toString() is the same whether or not the legacy-id has
     * scope-name, as it includes the defaultScope if the scope is empty.
     * as a result, when out-of-sync is happening and the id is changed to include scope-name in the
     * legacy-id, the component is the cache has the old id.
     */
    private getFromCache;
    private getTagMap;
    private getHeadSnap;
    private createSnapFromVersion;
    private createStateFromVersion;
}
