"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StagedConfig = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _componentId() {
  const data = require("@teambit/component-id");
  _componentId = function () {
    return data;
  };
  return data;
}
function _laneId() {
  const data = require("@teambit/lane-id");
  _laneId = function () {
    return data;
  };
  return data;
}
const STAGED_CONFIG_DIR = 'staged-config';
class StagedConfig {
  constructor(filePath, componentsConfig) {
    this.filePath = filePath;
    this.componentsConfig = componentsConfig;
    (0, _defineProperty2().default)(this, "hasChanged", false);
  }
  static async load(scopePath, laneId) {
    const lanePath = laneId ? _path().default.join(laneId.scope, laneId.name) : _laneId().DEFAULT_LANE;
    const filePath = _path().default.join(scopePath, STAGED_CONFIG_DIR, `${lanePath}.json`);
    let componentsConfig = [];
    try {
      const fileContent = await _fsExtra().default.readJson(filePath);
      componentsConfig = fileContent.map(item => ({
        id: _componentId().ComponentID.fromObject(item.id),
        config: item.config
      }));
    } catch (err) {
      if (err.code === 'ENOENT') {
        componentsConfig = [];
      } else {
        throw err;
      }
    }
    return new StagedConfig(filePath, componentsConfig);
  }
  toObject() {
    return this.componentsConfig.map(({
      id,
      config
    }) => ({
      id: id.toObject(),
      config
    }));
  }
  async write() {
    if (!this.hasChanged) return;
    await _fsExtra().default.outputFile(this.filePath, JSON.stringify(this.toObject(), null, 2));
  }
  getConfigPerId(id) {
    var _this$componentsConfi;
    return (_this$componentsConfi = this.componentsConfig.find(c => c.id.isEqual(id, {
      ignoreVersion: true
    }))) === null || _this$componentsConfi === void 0 ? void 0 : _this$componentsConfi.config;
  }
  getAll() {
    return this.componentsConfig;
  }
  addComponentConfig(id, config) {
    const exists = this.componentsConfig.find(c => c.id.isEqual(id, {
      ignoreVersion: true
    }));
    if (exists) {
      exists.config = config;
    } else {
      this.componentsConfig.push({
        id,
        config
      });
    }
    this.hasChanged = true;
  }
  removeComponentConfig(id) {
    this.componentsConfig = this.componentsConfig.filter(c => !c.id.isEqual(id, {
      ignoreVersion: true
    }));
    this.hasChanged = true;
  }
}
exports.StagedConfig = StagedConfig;

//# sourceMappingURL=staged-config.js.map