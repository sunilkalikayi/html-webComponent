"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FetchRoute = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _express() {
  const data = require("@teambit/express");
  _express = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = require("@teambit/legacy/dist/api/scope");
  _scope = function () {
    return data;
  };
  return data;
}
function _objectList() {
  const data = require("@teambit/legacy/dist/scope/objects/object-list");
  _objectList = function () {
    return data;
  };
  return data;
}
function _util() {
  const data = require("util");
  _util = function () {
    return data;
  };
  return data;
}
function _stream() {
  const data = require("stream");
  _stream = function () {
    return data;
  };
  return data;
}
class FetchRoute {
  constructor(scope, logger) {
    this.scope = scope;
    this.logger = logger;
    (0, _defineProperty2().default)(this, "route", '/scope/fetch');
    (0, _defineProperty2().default)(this, "method", 'post');
    (0, _defineProperty2().default)(this, "verb", _express().Verb.READ);
    (0, _defineProperty2().default)(this, "middlewares", [async (req, res) => {
      req.setTimeout(this.scope.config.httpTimeOut);
      const preFetchHookP = this.scope.preFetchObjects.values().map(fn => fn({
        ids: req.body.ids,
        fetchOptions: req.body.fetchOptions
      }, {
        headers: req.headers
      }));
      Promise.all(preFetchHookP).catch(err => {
        this.logger.error('fatal: onPreFetchObjects encountered an error (this error does not stop the process)', err);
      });
      const readable = await (0, _scope().fetch)(this.scope.path, req.body.ids, req.body.fetchOptions);
      const pack = _objectList().ObjectList.fromObjectStreamToTar(readable, this.scope.name);
      const pipelinePromise = (0, _util().promisify)(_stream().pipeline);
      try {
        await pipelinePromise(pack, res);
        this.logger.info('fetch.router, the response has been sent successfully to the client', req.headers);
      } catch (err) {
        if (req.aborted) {
          this.logger.warn('FetchRoute, the client aborted the request', err);
        } else {
          this.logger.error(`FetchRoute encountered an error during the pipeline streaming, this should never happen.
  make sure the error is caught in fromObjectStreamToTar and it streamed using the name "ERROR"`, err);
        }
      }
    }]);
  }
}
exports.FetchRoute = FetchRoute;

//# sourceMappingURL=fetch.route.js.map