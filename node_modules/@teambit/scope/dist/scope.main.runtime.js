"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.flat-map.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat-map.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.string.trim.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScopeMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));
  _pMapSeries = function () {
    return data;
  };
  return data;
}
function _semver() {
  const data = _interopRequireDefault(require("semver"));
  _semver = function () {
    return data;
  };
  return data;
}
function _multimatch() {
  const data = _interopRequireDefault(require("multimatch"));
  _multimatch = function () {
    return data;
  };
  return data;
}
function _builder() {
  const data = require("@teambit/builder");
  _builder = function () {
    return data;
  };
  return data;
}
function _fsExtra() {
  const data = require("fs-extra");
  _fsExtra = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _aspectLoader() {
  const data = require("@teambit/aspect-loader");
  _aspectLoader = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = require("@teambit/graphql");
  _graphql = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _isolator() {
  const data = require("@teambit/isolator");
  _isolator = function () {
    return data;
  };
  return data;
}
function _logger() {
  const data = require("@teambit/logger");
  _logger = function () {
    return data;
  };
  return data;
}
function _express() {
  const data = require("@teambit/express");
  _express = function () {
    return data;
  };
  return data;
}
function _ui() {
  const data = require("@teambit/ui");
  _ui = function () {
    return data;
  };
  return data;
}
function _harmonyModules() {
  const data = require("@teambit/harmony.modules.requireable-component");
  _harmonyModules = function () {
    return data;
  };
  return data;
}
function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");
  _legacyBitId = function () {
    return data;
  };
  return data;
}
function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");
  _bitId = function () {
    return data;
  };
  return data;
}
function _objects() {
  const data = require("@teambit/legacy/dist/scope/objects");
  _objects = function () {
    return data;
  };
  return data;
}
function _scopeLoader() {
  const data = require("@teambit/legacy/dist/scope/scope-loader");
  _scopeLoader = function () {
    return data;
  };
  return data;
}
function _constants() {
  const data = require("@teambit/legacy/dist/constants");
  _constants = function () {
    return data;
  };
  return data;
}
function _actions() {
  const data = require("@teambit/legacy/dist/scope/actions");
  _actions = function () {
    return data;
  };
  return data;
}
function _scopeRemotes() {
  const data = require("@teambit/legacy/dist/scope/scope-remotes");
  _scopeRemotes = function () {
    return data;
  };
  return data;
}
function _workspaceModules() {
  const data = require("@teambit/workspace.modules.match-pattern");
  _workspaceModules = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = require("@teambit/legacy/dist/scope");
  _scope = function () {
    return data;
  };
  return data;
}
function _objectList() {
  const data = require("@teambit/legacy/dist/scope/objects/object-list");
  _objectList = function () {
    return data;
  };
  return data;
}
function _http() {
  const data = require("@teambit/legacy/dist/scope/network/http/http");
  _http = function () {
    return data;
  };
  return data;
}
function _componentsGraph() {
  const data = require("@teambit/legacy/dist/scope/graph/components-graph");
  _componentsGraph = function () {
    return data;
  };
  return data;
}
function _scope2() {
  const data = require("@teambit/legacy/dist/api/scope");
  _scope2 = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _exportScopeComponents() {
  const data = require("@teambit/legacy/dist/scope/component-ops/export-scope-components");
  _exportScopeComponents = function () {
    return data;
  };
  return data;
}
function _config() {
  const data = require("@teambit/legacy/dist/consumer/config");
  _config = function () {
    return data;
  };
  return data;
}
function _envs() {
  const data = _interopRequireDefault(require("@teambit/envs"));
  _envs = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _scope3() {
  const data = require("./scope.aspect");
  _scope3 = function () {
    return data;
  };
  return data;
}
function _scope4() {
  const data = require("./scope.graphql");
  _scope4 = function () {
    return data;
  };
  return data;
}
function _scope5() {
  const data = require("./scope.ui-root");
  _scope5 = function () {
    return data;
  };
  return data;
}
function _routes() {
  const data = require("./routes");
  _routes = function () {
    return data;
  };
  return data;
}
function _scopeComponentLoader() {
  const data = require("./scope-component-loader");
  _scopeComponentLoader = function () {
    return data;
  };
  return data;
}
function _scopeCmd() {
  const data = require("./scope-cmd");
  _scopeCmd = function () {
    return data;
  };
  return data;
}
function _stagedConfig() {
  const data = require("./staged-config");
  _stagedConfig = function () {
    return data;
  };
  return data;
}
function _noIdMatchPattern() {
  const data = require("./exceptions/no-id-match-pattern");
  _noIdMatchPattern = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
class ScopeMain {
  constructor(
  /**
   * private reference to the instance of Harmony.
   */
  harmony,
  /**
   * legacy scope
   */
  legacyScope,
  /**
   * component extension.
   */
  componentExtension,
  /**
   * slot registry for subscribing to build
   */

  config, postPutSlot, postDeleteSlot, postExportSlot, postObjectsPersist, preFetchObjects, isolator, aspectLoader, logger, envs) {
    this.harmony = harmony;
    this.legacyScope = legacyScope;
    this.componentExtension = componentExtension;
    this.config = config;
    this.postPutSlot = postPutSlot;
    this.postDeleteSlot = postDeleteSlot;
    this.postExportSlot = postExportSlot;
    this.postObjectsPersist = postObjectsPersist;
    this.preFetchObjects = preFetchObjects;
    this.isolator = isolator;
    this.aspectLoader = aspectLoader;
    this.logger = logger;
    this.envs = envs;
    (0, _defineProperty2().default)(this, "componentLoader", void 0);
    (0, _defineProperty2().default)(this, "localAspects", []);
    this.componentLoader = new (_scopeComponentLoader().ScopeComponentLoader)(this, this.logger);
  }

  /**
   * name of the scope
   */
  get name() {
    return this.legacyScope.name;
  }
  get icon() {
    return this.config.icon;
  }
  get backgroundIconColor() {
    return this.config.backgroundIconColor;
  }
  get description() {
    return this.config.description;
  }
  get path() {
    return this.legacyScope.path;
  }
  get isLegacy() {
    return this.legacyScope.isLegacy;
  }

  // We need to reload the aspects with their new version since:
  // during get many by legacy, we go load component which in turn go to getEnv
  // get env validates that the env written on the component is really exist by checking the envs slot registry
  // when we load here, it's env version in the aspect list already has the new version in case the env itself is being tagged
  // so we are search for the env in the registry with the new version number
  // but since the env only registered during the on load of the bit process (before the tag) it's version in the registry is only the old one
  // once we reload them we will have it registered with the new version as well
  async reloadAspectsWithNewVersion(components) {
    const host = this.componentExtension.getHost();

    // Return only aspects that defined on components but not in the root config file (workspace.jsonc/scope.jsonc)
    const getUserAspectsIdsWithoutRootIds = () => {
      const allUserAspectIds = this.aspectLoader.getUserAspects();
      const rootIds = Object.keys(this.harmony.config.toObject());
      const diffIds = (0, _lodash().difference)(allUserAspectIds, rootIds);
      return diffIds;
    };

    // Based on the list of components to be tagged return those who are loaded to harmony with their used version
    const getAspectsByPreviouslyUsedVersion = async () => {
      const harmonyIds = getUserAspectsIdsWithoutRootIds();
      const aspectsIds = [];
      const aspectsP = components.map(async component => {
        const newId = await host.resolveComponentId(component.id);
        if (component.previouslyUsedVersion && component.version && component.previouslyUsedVersion !== component.version) {
          const newIdWithPreviouslyUsedVersion = newId.changeVersion(component.previouslyUsedVersion);
          if (harmonyIds.includes(newIdWithPreviouslyUsedVersion.toString())) {
            aspectsIds.push(newId.toString());
          }
        }
      });
      await Promise.all(aspectsP);
      return aspectsIds;
    };
    const idsToLoad = await getAspectsByPreviouslyUsedVersion();
    await host.loadAspects(idsToLoad, false, 'scope.reloadAspectsWithNewVersion');
  }
  getManyByLegacy(components) {
    return (0, _pMapSeries().default)(components, async component => this.getFromConsumerComponent(component));
  }
  clearCache() {
    this.logger.debug('clearing the components and the legacy cache');
    this.componentLoader.clearCache();
    this.legacyScope.objects.clearCache();
  }
  builderDataMapToLegacyOnTagResults(builderDataComponentMap) {
    const builderDataToLegacyExtension = (component, builderData) => {
      var _component$state$aspe;
      const existingBuilder = (_component$state$aspe = component.state.aspects.get(_builder().BuilderAspect.id)) === null || _component$state$aspe === void 0 ? void 0 : _component$state$aspe.legacy;
      const builderExtension = existingBuilder || new (_config().ExtensionDataEntry)(undefined, undefined, _builder().BuilderAspect.id);
      builderExtension.data = builderData;
      return builderExtension;
    };
    return builderDataComponentMap.toArray().map(([component, builderData]) => ({
      id: component.id._legacy,
      builderData: builderDataToLegacyExtension(component, builderData)
    }));
  }

  /**
   * register to the post-export slot.
   */
  onPostPut(postPutFn) {
    this.postPutSlot.register(postPutFn);
    return this;
  }

  /**
   * register to the post-delete slot.
   */
  onPostDelete(postDeleteFn) {
    this.postDeleteSlot.register(postDeleteFn);
    return this;
  }

  /**
   * register to the post-export slot.
   */
  registerOnPostExport(postExportFn) {
    this.postExportSlot.register(postExportFn);
    return this;
  }
  registerOnPreFetchObjects(preFetchObjectsFn) {
    this.preFetchObjects.register(preFetchObjectsFn);
    return this;
  }
  registerOnPostObjectsPersist(postObjectsPersistFn) {
    this.postObjectsPersist.register(postObjectsPersistFn);
    return this;
  }

  /**
   * Will fetch a list of components into the current scope.
   * This will only fetch the object and won't write the files to the actual FS
   *
   * @param {ComponentsIds} ids list of ids to fetch
   */
  fetch(ids) {} // eslint-disable-line @typescript-eslint/no-unused-vars

  /**
   * This function will get a component and sealed it's current state into the scope
   *
   * @param {Component[]} components A list of components to seal with specific persist options (such as message and version number)
   * @param {PersistOptions} persistGeneralOptions General persistence options such as verbose
   */
  persist(components, options) {} // eslint-disable-line @typescript-eslint/no-unused-vars

  async delete({
    ids,
    force,
    lanes
  }, headers) {
    const authData = (0, _http().getAuthDataFromHeader)(headers === null || headers === void 0 ? void 0 : headers.authorization);
    const result = await (0, _scope2().remove)({
      path: this.path,
      ids,
      force,
      lanes
    });
    const fns = this.postDeleteSlot.values();
    const metadata = {
      auth: authData,
      headers
    };
    const componentIds = lanes ? [] : ids.map(id => _component().ComponentID.fromString(id));
    await (0, _pMapSeries().default)(fns, async fn => {
      try {
        await fn({
          ids: componentIds
        }, metadata);
      } catch (err) {
        this.logger.error('failed to run delete slot', err);
      }
    });
    return result;
  }
  async toObjectList(types) {
    const objects = await this.legacyScope.objects.list(types);
    return _objectList().ObjectList.fromBitObjects(objects);
  }

  // TODO: temporary compiler workaround - discuss this with david.
  toJs(str) {
    if (str.endsWith('.ts')) return str.replace('.ts', '.js');
    return str;
  }
  parseLocalAspect(localAspects) {
    const dirPaths = localAspects.map(localAspect => (0, _path().resolve)(localAspect.replace('file://', '')));
    const nonExistsDirPaths = dirPaths.filter(path => !(0, _fsExtra().existsSync)(path));
    nonExistsDirPaths.forEach(path => this.logger.warn(`no such file or directory: ${path}`));
    const existsDirPaths = dirPaths.filter(path => (0, _fsExtra().existsSync)(path));
    return existsDirPaths;
  }
  findRuntime(dirPath, runtime) {
    const files = (0, _fsExtra().readdirSync)((0, _path().join)(dirPath, 'dist'));
    return files.find(path => path.includes(`${runtime}.runtime.js`));
  }
  async loadAspectFromPath(localAspects) {
    const dirPaths = this.parseLocalAspect(localAspects);
    const manifests = dirPaths.map(dirPath => {
      const scopeRuntime = this.findRuntime(dirPath, 'scope');
      if (scopeRuntime) {
        // eslint-disable-next-line global-require, import/no-dynamic-require
        const module = require((0, _path().join)(dirPath, 'dist', scopeRuntime));
        return module.default || module;
      }
      // eslint-disable-next-line global-require, import/no-dynamic-require
      const module = require(dirPath);
      return module.default || module;
    });
    await this.aspectLoader.loadExtensionsByManifests(manifests, true);
  }
  async loadAspects(ids, throwOnError = false, neededFor) {
    var _grouped$envs, _grouped$other;
    // generate a random callId to be able to identify the call from the logs
    const callId = Math.floor(Math.random() * 1000);
    const loggerPrefix = `[${callId}] loadAspects,`;
    this.logger.info(`${loggerPrefix} loading ${ids.length} aspects.
ids: ${ids.join(', ')}
needed-for: ${neededFor || '<unknown>'}`);
    const grouped = await this.groupAspectIdsByEnvOfTheList(ids);
    this.logger.info(`${loggerPrefix} getManifestsAndLoadAspects for grouped.envs, total ${((_grouped$envs = grouped.envs) === null || _grouped$envs === void 0 ? void 0 : _grouped$envs.length) || 0}`);
    const envsManifestsIds = await this.getManifestsAndLoadAspects(grouped.envs, throwOnError);
    this.logger.info(`${loggerPrefix} getManifestsAndLoadAspects for grouped.other, total ${((_grouped$other = grouped.other) === null || _grouped$other === void 0 ? void 0 : _grouped$other.length) || 0}`);
    const otherManifestsIds = await this.getManifestsAndLoadAspects(grouped.other, throwOnError);
    this.logger.debug(`${loggerPrefix} finish loading aspects`);
    return envsManifestsIds.concat(otherManifestsIds);
  }

  /**
   * This function get's a list of aspect ids and return them grouped by whether any of them is the env of other from the list
   * @param ids
   */
  async groupAspectIdsByEnvOfTheList(ids) {
    const components = await this.getNonLoadedAspects(ids);
    const envsIds = (0, _lodash().uniq)(components.map(component => this.envs.getEnvId(component)).filter(envId => !this.aspectLoader.isCoreEnv(envId)));
    const grouped = (0, _lodash().groupBy)(ids, id => {
      if (envsIds.includes(id)) return 'envs';
      return 'other';
    });
    return grouped;
  }
  async getManifestsAndLoadAspects(ids = [], throwOnError = false) {
    const {
      manifests: scopeManifests,
      potentialPluginsIds
    } = await this.getManifestsGraphRecursively(ids, [], throwOnError);
    await this.aspectLoader.loadExtensionsByManifests(scopeManifests);
    const {
      manifests: scopePluginsManifests
    } = await this.getManifestsGraphRecursively(potentialPluginsIds, [], throwOnError);
    await this.aspectLoader.loadExtensionsByManifests(scopePluginsManifests);
    const allManifests = scopeManifests.concat(scopePluginsManifests);
    return (0, _lodash().compact)(allManifests.map(manifest => manifest.id));
  }
  async getManifestsGraphRecursively(ids, visited = [], throwOnError = false, opts = {}) {
    ids = (0, _lodash().uniq)(ids);
    this.logger.debug(`getManifestsGraphRecursively, ids:\n${ids.join('\n')}`);
    const nonVisitedId = ids.filter(id => !visited.includes(id));
    if (!nonVisitedId.length) {
      return {
        manifests: [],
        potentialPluginsIds: []
      };
    }
    const components = await this.getNonLoadedAspects(nonVisitedId);
    // Adding all the envs ids to the array to support case when one (or more) of the aspects has custom aspect env
    const customEnvsIds = components.map(component => this.envs.getEnvId(component)).filter(envId => !this.aspectLoader.isCoreEnv(envId));
    // In case there is custom env we need to load it right away, otherwise we will fail during the require aspects
    await this.getManifestsAndLoadAspects(customEnvsIds);
    visited.push(...nonVisitedId);
    const manifests = await this.requireAspects(components, throwOnError, opts);
    const potentialPluginsIds = (0, _lodash().compact)(manifests.map((manifest, index) => {
      if (this.aspectLoader.isValidAspect(manifest)) return undefined;
      // return index;
      return components[index].id.toString();
    }));
    const depsToLoad = [];
    await (0, _pMapSeries().default)(manifests, async manifest => {
      depsToLoad.push(...(manifest.dependencies || []));
      // @ts-ignore
      (manifest._runtimes || []).forEach(runtime => {
        depsToLoad.push(...(runtime.dependencies || []));
      });
      const depIds = depsToLoad.map(d => d.id).filter(id => id);
      this.logger.debug(`getManifestsGraphRecursively, id: ${manifest.id || '<unknown>'}, found ${depIds.length}: ${depIds.join(', ')}`);
      const {
        manifests: loaded
      } = await this.getManifestsGraphRecursively(depIds, visited, throwOnError);
      manifests.push(...loaded);
    });
    return {
      manifests,
      potentialPluginsIds
    };
  }
  async getNonLoadedAspects(ids) {
    const notLoadedIds = ids.filter(id => !this.aspectLoader.isAspectLoaded(id));
    if (!notLoadedIds.length) return [];
    const coreAspectsStringIds = this.aspectLoader.getCoreAspectIds();
    const idsWithoutCore = (0, _lodash().difference)(ids, coreAspectsStringIds);
    const aspectIds = idsWithoutCore.filter(id => !id.startsWith('file://'));
    // TODO: use diff instead of filter twice
    const localAspects = ids.filter(id => id.startsWith('file://'));
    this.localAspects = this.localAspects.concat(localAspects);
    // load local aspects for debugging purposes.
    await this.loadAspectFromPath(localAspects);
    const componentIds = await this.resolveMultipleComponentIds(aspectIds);
    if (!componentIds || !componentIds.length) return [];
    const components = await this.import(componentIds, {
      reFetchUnBuiltVersion: false
    });
    return components;
  }
  async resolveLocalAspects(ids, runtime) {
    const dirs = this.parseLocalAspect(ids);
    return dirs.map(dir => {
      const runtimeManifest = runtime ? this.findRuntime(dir, runtime) : undefined;
      return new (_aspectLoader().AspectDefinition)(dir, runtimeManifest ? (0, _path().join)(dir, 'dist', runtimeManifest) : null, undefined, undefined, true);
    });
  }
  async getResolvedAspects(components, opts) {
    var _opts$skipIfExists;
    if (!components || !components.length) return [];
    const network = await this.isolator.isolateComponents(components.map(c => c.id),
    // includeFromNestedHosts - to support case when you are in a workspace, trying to load aspect defined in the workspace.jsonc but not part of the workspace
    {
      baseDir: this.getAspectCapsulePath(),
      skipIfExists: (_opts$skipIfExists = opts === null || opts === void 0 ? void 0 : opts.skipIfExists) !== null && _opts$skipIfExists !== void 0 ? _opts$skipIfExists : true,
      seedersOnly: true,
      includeFromNestedHosts: true,
      installOptions: {
        copyPeerToRuntimeOnRoot: true,
        packageManagerConfigRootDir: opts === null || opts === void 0 ? void 0 : opts.packageManagerConfigRootDir,
        useNesting: true,
        copyPeerToRuntimeOnComponents: true,
        installPeersFromEnvs: true
      }
    }, this.legacyScope);
    const capsules = network.seedersCapsules;
    return capsules.map(capsule => {
      return new (_harmonyModules().RequireableComponent)(capsule.component, async () => {
        // eslint-disable-next-line global-require, import/no-dynamic-require
        const plugins = this.aspectLoader.getPlugins(capsule.component, capsule.path);
        if (plugins.has()) {
          await this.compileIfNoDist(capsule, capsule.component);
          return plugins.load(_cli().MainRuntime.name);
        }
        // eslint-disable-next-line global-require, import/no-dynamic-require
        const aspect = require(capsule.path);
        const scopeRuntime = await this.aspectLoader.getRuntimePath(capsule.component, capsule.path, 'scope');
        const mainRuntime = await this.aspectLoader.getRuntimePath(capsule.component, capsule.path, _cli().MainRuntime.name);
        const runtimePath = scopeRuntime || mainRuntime;
        // eslint-disable-next-line global-require, import/no-dynamic-require
        if (runtimePath) require(runtimePath);
        // eslint-disable-next-line global-require, import/no-dynamic-require
        return aspect;
      }, capsule);
    });
  }
  async compileIfNoDist(capsule, component) {
    const env = this.envs.getEnv(component);
    const compiler = env.env.getCompiler();
    const distDir = (compiler === null || compiler === void 0 ? void 0 : compiler.distDir) || _constants().DEFAULT_DIST_DIRNAME;
    const distExists = (0, _fsExtra().existsSync)((0, _path().join)(capsule.path, distDir));
    if (distExists) return;
    const compiledCode = component.filesystem.files.flatMap(file => {
      if (!compiler.isFileSupported(file.path)) {
        return [{
          outputText: file.contents.toString('utf8'),
          outputPath: file.path
        }];
      }
      if (compiler.transpileFile) {
        return compiler.transpileFile(file.contents.toString('utf8'), {
          filePath: file.path,
          componentDir: capsule.path
        });
      }
      return [];
    });
    await Promise.all((0, _lodash().compact)(compiledCode).map(compiledFile => {
      const path = compiler.getDistPathBySrcPath(compiledFile.outputPath);
      return capsule === null || capsule === void 0 ? void 0 : capsule.outputFile(path, compiledFile.outputText);
    }));
  }
  async tryCompile(requirableAspect) {
    if (requirableAspect.capsule) return this.compileIfNoDist(requirableAspect.capsule, requirableAspect.component);
    return undefined;
  }
  async requireAspects(components, throwOnError = false, opts = {}) {
    const requireableExtensions = await this.getResolvedAspects(components, opts);
    if (!requireableExtensions) {
      return [];
    }
    let error;
    let erroredId = '';
    const requireWithCatch = async requireableAspects => {
      error = undefined;
      try {
        const manifests = await (0, _pMapSeries().default)(requireableAspects, async requireableExtension => {
          try {
            return await this.aspectLoader.doRequire(requireableExtension);
          } catch (err) {
            erroredId = requireableExtension.component.id.toString();
            if (err.code === 'MODULE_NOT_FOUND') {
              try {
                await this.tryCompile(requireableExtension);
                return await this.aspectLoader.doRequire(requireableExtension);
              } catch (newErr) {
                error = newErr;
                throw newErr;
              }
            }
            error = err;
            throw err;
          }
        });
        return manifests;
      } catch (err) {
        return null;
      }
    };
    const manifests = await requireWithCatch(requireableExtensions);
    if (!error) {
      return (0, _lodash().compact)(manifests);
    }
    if (error.code === 'MODULE_NOT_FOUND') {
      this.logger.warn(`failed loading aspects from capsules due to MODULE_NOT_FOUND error, re-creating the capsules and trying again`);
      const resolvedAspectsAgain = await this.getResolvedAspects(components, _objectSpread(_objectSpread({}, opts), {}, {
        skipIfExists: false
      }));
      const manifestAgain = await requireWithCatch(resolvedAspectsAgain);
      if (!error) {
        return (0, _lodash().compact)(manifestAgain);
      }
    }
    this.aspectLoader.handleExtensionLoadingError(error, erroredId, throwOnError);
    return [];
  }
  getAspectCapsulePath() {
    return `${this.path}-aspects`;
  }
  async resolveUserAspects(runtimeName, userAspectsIds) {
    if (!userAspectsIds || !userAspectsIds.length) return [];
    const components = await this.getMany(userAspectsIds);
    const network = await this.isolator.isolateComponents(userAspectsIds, {
      baseDir: this.getAspectCapsulePath(),
      skipIfExists: true,
      // for some reason this needs to be false, otherwise tagging components in some workspaces
      // result in error during Preview task:
      // "No matching version found for <some-component-on-the-workspace>"
      seedersOnly: true,
      includeFromNestedHosts: true,
      installOptions: {
        copyPeerToRuntimeOnRoot: true,
        useNesting: true,
        copyPeerToRuntimeOnComponents: true,
        installPeersFromEnvs: true
      },
      host: this
    }, this.legacyScope);
    const capsules = network.seedersCapsules;
    const aspectDefs = await this.aspectLoader.resolveAspects(components, async component => {
      const capsule = capsules.getCapsule(component.id);
      if (!capsule) throw new Error(`failed loading aspect: ${component.id.toString()}`);
      const localPath = capsule.path;
      const runtimePath = runtimeName ? await this.aspectLoader.getRuntimePath(component, localPath, runtimeName) : null;
      this.logger.debug(`scope resolveUserAspects, resolving id: ${component.id.toString()}, localPath: ${localPath}, runtimePath: ${runtimePath}`);
      return {
        id: capsule.component.id,
        aspectPath: localPath,
        runtimePath
      };
    });
    return aspectDefs;
  }
  async resolveAspects(runtimeName, componentIds, opts) {
    const originalStringIds = componentIds === null || componentIds === void 0 ? void 0 : componentIds.map(id => id.toString());
    this.logger.debug(`scope resolveAspects, runtimeName: ${runtimeName}, componentIds: ${originalStringIds}`);
    const defaultOpts = {
      excludeCore: false,
      requestedOnly: false
    };
    const mergedOpts = _objectSpread(_objectSpread({}, defaultOpts), opts);
    const coreAspectsIds = this.aspectLoader.getCoreAspectIds();
    let userAspectsIds;
    let requestedCoreStringIds;
    if (componentIds && componentIds.length) {
      var _groupedByIsCore$true;
      const groupedByIsCore = (0, _lodash().groupBy)(componentIds, id => coreAspectsIds.includes(id.toString()));
      userAspectsIds = groupedByIsCore.false || [];
      requestedCoreStringIds = ((_groupedByIsCore$true = groupedByIsCore.true) === null || _groupedByIsCore$true === void 0 ? void 0 : _groupedByIsCore$true.map(id => id.toStringWithoutVersion())) || [];
    } else {
      userAspectsIds = await this.resolveMultipleComponentIds(this.aspectLoader.getUserAspects());
    }
    const withoutLocalAspects = userAspectsIds.filter(aspectId => {
      return !this.localAspects.find(localAspect => {
        return localAspect.includes(aspectId.fullName.replace('/', '.'));
      });
    });
    const userAspectsDefs = await this.resolveUserAspects(runtimeName, withoutLocalAspects);
    const localResolved = await this.resolveLocalAspects(this.localAspects, runtimeName);
    const coreAspectsDefs = await this.aspectLoader.getCoreAspectDefs(runtimeName);
    const allDefs = userAspectsDefs.concat(coreAspectsDefs).concat(localResolved);
    let afterExclusion = allDefs;
    if (mergedOpts.excludeCore) {
      const userAspectsIdsWithoutVersion = userAspectsIds.map(aspectId => aspectId.toStringWithoutVersion());
      const userAspectsIdsWithoutVersionAndCoreRequested = userAspectsIdsWithoutVersion.concat(requestedCoreStringIds);
      afterExclusion = allDefs.filter(def => {
        const id = _component().ComponentID.fromString(def.getId || '');
        const isTarget = userAspectsIdsWithoutVersionAndCoreRequested.includes(id.toStringWithoutVersion());
        // If it's core, but requested explicitly, keep it
        if (isTarget) return true;
        const isCore = coreAspectsDefs.find(coreId => def.getId === coreId.getId);
        return !isCore;
      });
    }
    const uniqDefs = (0, _lodash().uniqBy)(afterExclusion, def => `${def.aspectPath}-${def.runtimePath}`);
    let defs = uniqDefs;
    if (runtimeName) {
      defs = defs.filter(def => def.runtimePath);
    }
    if (componentIds && componentIds.length && mergedOpts.requestedOnly) {
      const componentIdsString = componentIds.map(id => id.toString());
      defs = defs.filter(def => {
        var _def$component;
        return def.id && componentIdsString.includes(def.id) || def.component && componentIdsString.includes((_def$component = def.component) === null || _def$component === void 0 ? void 0 : _def$component.id.toString());
      });
    }
    return defs;
  }
  async getLegacyGraph(ids) {
    if (!ids || ids.length < 1) ids = (await this.list()).map(comp => comp.id) || [];
    const legacyIds = ids.map(id => {
      let bitId = id._legacy;
      // The resolve bitId in scope will remove the scope name in case it's the same as the scope
      // We restore it back to use it correctly in the legacy code.
      if (!bitId.hasScope()) {
        var _this$legacyScope;
        bitId = bitId.changeScope((_this$legacyScope = this.legacyScope) === null || _this$legacyScope === void 0 ? void 0 : _this$legacyScope.name);
      }
      return bitId;
    });
    const legacyGraph = await (0, _componentsGraph().buildOneGraphForComponentsUsingScope)(legacyIds, this.legacyScope);
    return legacyGraph;
  }

  /**
   * import components into the scope.
   */
  async import(ids, {
    useCache = true,
    throwIfNotExist = false,
    reFetchUnBuiltVersion = true,
    lane
  } = {}) {
    const legacyIds = ids.map(id => {
      const legacyId = id._legacy;
      if (legacyId.scope === this.name) return legacyId.changeScope(null);
      return legacyId;
    });
    const withoutOwnScopeAndLocals = legacyIds.filter(id => {
      return id.scope !== this.name && id.hasScope();
    });
    const lanes = lane ? [lane] : undefined;
    await this.legacyScope.import(_bitId().BitIds.fromArray(withoutOwnScopeAndLocals), useCache, reFetchUnBuiltVersion, lanes);
    return this.getMany(ids, throwIfNotExist);
  }
  async get(id) {
    return this.componentLoader.get(id);
  }
  async getFromConsumerComponent(consumerComponent) {
    return this.componentLoader.getFromConsumerComponent(consumerComponent);
  }

  /**
   * get a component from a remote without importing it
   */
  async getRemoteComponent(id) {
    return this.componentLoader.getRemoteComponent(id);
  }

  /**
   * get a component from a remote without importing it
   */
  async getManyRemoteComponents(ids) {
    return this.componentLoader.getManyRemoteComponents(ids);
  }

  /**
   * list all components in the scope.
   */
  async list(filter, includeCache = false, includeFromLanes = false) {
    const patternsWithScope = (filter === null || filter === void 0 ? void 0 : filter.namespaces) && (filter === null || filter === void 0 ? void 0 : filter.namespaces.map(pattern => `**/${pattern || '**'}`)) || undefined;
    const componentsIds = await this.listIds(includeCache, includeFromLanes, patternsWithScope);
    return this.getMany(filter && filter.limit ? (0, _lodash().slice)(componentsIds, filter.offset, filter.offset + filter.limit) : componentsIds);
  }

  /**
   * for now, list of invalid components are mostly useful for the workspace.
   * in the future, this can return components that failed to load in the scope due to objects file
   * corruption or similar issues.
   */
  async listInvalid() {
    return [];
  }

  /**
   * get ids of all scope components.
   * @param includeCache whether or not include components that their scope-name is different than the current scope-name
   */
  async listIds(includeCache = false, includeFromLanes = false, patterns) {
    const allModelComponents = await this.legacyScope.list();
    const filterByCacheAndLanes = modelComponent => {
      const cacheFilter = includeCache ? true : this.exists(modelComponent);
      const lanesFilter = includeFromLanes ? true : modelComponent.hasHead();
      return cacheFilter && lanesFilter;
    };
    const modelComponentsToList = allModelComponents.filter(filterByCacheAndLanes);
    let ids = modelComponentsToList.map(component => _component().ComponentID.fromLegacy(component.toBitIdWithLatestVersion(), component.scope || this.name));
    if (patterns && patterns.length > 0) {
      ids = ids.filter(id => patterns === null || patterns === void 0 ? void 0 : patterns.some(pattern => (0, _workspaceModules().isMatchNamespacePatternItem)(id.toStringWithoutVersion(), pattern).match));
    }
    this.logger.debug(`scope listIds: total ${ids.length} components after filter scope`);
    return ids;
  }

  /**
   * Check if a specific id exist in the scope
   * @param componentId
   */
  async hasId(componentId, includeCache = false) {
    if (!includeCache && componentId.scope !== this.name) return false;
    const opts = {
      includeOrphaned: true,
      includeVersion: true
    };
    return this.legacyScope.hasId(componentId._legacy, opts);
  }
  async hasIdNested(componentId, includeCache = false) {
    return this.hasId(componentId, includeCache);
  }

  /**
   * determine whether a component exists in the scope.
   */
  exists(modelComponent) {
    return modelComponent.scope === this.name;
  }
  async getMany(ids, throwIfNotExist = false) {
    const idsWithoutEmpty = (0, _lodash().compact)(ids);
    const componentsP = (0, _pMapSeries().default)(idsWithoutEmpty, async id => {
      return throwIfNotExist ? this.getOrThrow(id) : this.get(id);
    });
    const components = await componentsP;
    return (0, _lodash().compact)(components);
  }

  /**
   * load components from a scope and load their aspects
   */
  async loadMany(ids) {
    const components = await (0, _pMapSeries().default)(ids, id => this.load(id));
    return (0, _lodash().compact)(components);
  }

  /**
   * get a component and throw an exception if not found.
   * @param id component id
   */
  async getOrThrow(id) {
    const component = await this.get(id);
    if (!component) throw new (_exceptions().ComponentNotFound)(id);
    return component;
  }

  /**
   * returns a specific state of a component.
   * @param id component ID.
   * @param hash state hash.
   */
  async getState(id, hash) {
    return this.componentLoader.getState(id, hash);
  }
  async getSnap(id, hash) {
    return this.componentLoader.getSnap(id, hash);
  }
  async getLogs(id, shortHash = false, startsFrom) {
    return this.legacyScope.loadComponentLogs(id._legacy, shortHash, startsFrom);
  }
  async getStagedConfig() {
    const currentLaneId = this.legacyScope.currentLaneId;
    return _stagedConfig().StagedConfig.load(this.path, currentLaneId);
  }

  /**
   * resolve a component ID.
   * @param id component ID.
   */
  async resolveComponentId(id) {
    const idStr = id.toString();
    const component = await this.legacyScope.loadModelComponentByIdStr(idStr);
    const getIdToCheck = () => {
      if (component) return idStr; // component exists in the scope with the scope-name.
      if (idStr.startsWith(`${this.name}/`)) {
        // component with the full name doesn't exist in the scope, it might be locally tagged
        return idStr.replace(`${this.name}/`, '');
      }
      return idStr;
    };
    const IdToCheck = getIdToCheck();
    const legacyId = id instanceof _legacyBitId().BitId ? id : await this.legacyScope.getParsedId(IdToCheck);
    if (!legacyId.scope) return _component().ComponentID.fromLegacy(legacyId, this.name);
    return _component().ComponentID.fromLegacy(legacyId);
  }
  async resolveMultipleComponentIds(ids) {
    return Promise.all(ids.map(async id => this.resolveComponentId(id)));
  }

  /**
   * @deprecated use `this.idsByPattern` instead for consistency, which supports also negation and list of patterns.
   */
  async byPattern(patterns, scope = '**') {
    const patternsWithScope = patterns.map(pattern => `${scope}/${pattern || '**'}`);
    const ids = await this.listIds(true, false, patternsWithScope);
    const components = await this.getMany(ids);
    return components;
  }

  /**
   * get component-ids matching the given pattern. a pattern can have multiple patterns separated by a comma.
   * it uses multimatch (https://www.npmjs.com/package/multimatch) package for the matching algorithm, which supports
   * (among others) negate character "!" to exclude ids. See the package page for more supported characters.
   */
  async idsByPattern(pattern, throwForNoMatch = true) {
    if (!pattern.includes('*') && !pattern.includes(',')) {
      // if it's not a pattern but just id, resolve it without multimatch to support specifying id without scope-name
      const id = await this.resolveComponentId(pattern);
      const exists = await this.hasId(id, true);
      if (exists) return [id];
      if (throwForNoMatch) throw new (_bitError().BitError)(`unable to find "${pattern}" in the scope`);
      return [];
    }
    const ids = await this.listIds(true);
    return this.filterIdsFromPoolIdsByPattern(pattern, ids, throwForNoMatch);
  }

  // todo: move this to somewhere else (where?)
  filterIdsFromPoolIdsByPattern(pattern, ids, throwForNoMatch = true) {
    const patterns = pattern.split(',').map(p => p.trim());
    if (patterns.every(p => p.startsWith('!'))) {
      // otherwise it'll never match anything. don't use ".push()". it must be the first item in the array.
      patterns.unshift('**');
    }
    // check also as legacyId.toString, as it doesn't have the defaultScope
    const idsToCheck = id => [id.toStringWithoutVersion(), id._legacy.toStringWithoutVersion()];
    const idsFiltered = ids.filter(id => (0, _multimatch().default)(idsToCheck(id), patterns).length);
    if (throwForNoMatch && !idsFiltered.length) {
      throw new (_noIdMatchPattern().NoIdMatchPattern)(pattern);
    }
    return idsFiltered;
  }
  async getExactVersionBySemverRange(id, range) {
    var _semver$maxSatisfying;
    const modelComponent = await this.legacyScope.getModelComponent(id._legacy);
    const versions = modelComponent.listVersions();
    return (_semver$maxSatisfying = _semver().default.maxSatisfying(versions, range, {
      includePrerelease: true
    })) === null || _semver$maxSatisfying === void 0 ? void 0 : _semver$maxSatisfying.toString();
  }
  async resumeExport(exportId, remotes) {
    return (0, _exportScopeComponents().resumeExport)(this.legacyScope, exportId, remotes);
  }
  async resolveId(id) {
    const legacyId = await this.legacyScope.getParsedId(id);
    return _component().ComponentID.fromLegacy(legacyId);
  }

  // TODO: add new API for this
  async _legacyRemotes() {
    return (0, _scopeRemotes().getScopeRemotes)(this.legacyScope);
  }

  /**
   * list all component ids from a remote-scope
   */
  async listRemoteScope(scopeName) {
    const remotes = await this._legacyRemotes();
    const remote = await remotes.resolve(scopeName, this.legacyScope);
    const results = await remote.list();
    return results.map(({
      id
    }) => _component().ComponentID.fromLegacy(id));
  }

  /**
   * get a component and load its aspect
   */
  async load(id) {
    const component = await this.get(id);
    if (!component) return undefined;
    const aspectIds = component.state.aspects.ids;
    // load components from type aspects as aspects.
    if (this.aspectLoader.isAspectComponent(component)) {
      aspectIds.push(component.id.toString());
    }
    await this.loadAspects(aspectIds, true, id.toString());
    return component;
  }
  async loadComponentsAspect(component) {
    const aspectIds = component.state.aspects.ids;
    await this.loadAspects(aspectIds, true, component.id.toString());
  }
  async isModified() {
    return false;
  }
  async write() {
    // no-op (it's relevant for the workspace only)
  }

  /**
   * declare the slots of scope extension.
   */

  static async provider([componentExt, ui, graphql, cli, isolator, aspectLoader, express, loggerMain, envs], config, [postPutSlot, postDeleteSlot, postExportSlot, postObjectsPersistSlot, preFetchObjectsSlot], harmony) {
    const bitConfig = harmony.config.get('teambit.harmony/bit');
    const legacyScope = await (0, _scopeLoader().loadScopeIfExist)(bitConfig === null || bitConfig === void 0 ? void 0 : bitConfig.cwd);
    if (!legacyScope) {
      return undefined;
    }
    const logger = loggerMain.createLogger(_scope3().ScopeAspect.id);
    const scope = new ScopeMain(harmony, legacyScope, componentExt, config, postPutSlot, postDeleteSlot, postExportSlot, postObjectsPersistSlot, preFetchObjectsSlot, isolator, aspectLoader, logger, envs);
    cli.registerOnStart(async hasWorkspace => {
      if (hasWorkspace) return;
      await scope.loadAspects(aspectLoader.getNotLoadedConfiguredExtensions(), undefined, 'scope.cli.registerOnStart');
    });
    cli.register(new (_scopeCmd().ScopeCmd)());
    const onPutHook = async (ids, lanes, authData) => {
      logger.debug(`onPutHook, started. (${ids.length} components)`);
      scope.componentLoader.clearCache();
      const componentIds = await scope.resolveMultipleComponentIds(ids);
      const fns = postPutSlot.values();
      const data = {
        ids: componentIds,
        lanes
      };
      const metadata = {
        auth: authData
      };
      await Promise.all(fns.map(async fn => fn(data, metadata)));
      logger.debug(`onPutHook, completed. (${ids.length} components)`);
    };
    const getAuthData = () => {
      const token = _http().Http.getToken();
      return token ? {
        type: _http().DEFAULT_AUTH_TYPE,
        credentials: token
      } : undefined;
    };
    const onPostExportHook = async (ids, lanes) => {
      logger.debug(`onPostExportHook, started. (${ids.length} components)`);
      const componentIds = await scope.resolveMultipleComponentIds(ids);
      const fns = postExportSlot.values();
      const data = {
        ids: componentIds,
        lanes
      };
      const metadata = {
        auth: getAuthData()
      };
      await Promise.all(fns.map(async fn => fn(data, metadata)));
      logger.debug(`onPostExportHook, completed. (${ids.length} components)`);
    };
    const onPostObjectsPersistHook = async () => {
      logger.debug(`onPostObjectsPersistHook, started`);
      const fns = postObjectsPersistSlot.values();
      const metadata = {
        auth: getAuthData()
      };
      await Promise.all(fns.map(async fn => fn(undefined, metadata)));
      logger.debug(`onPostObjectsPersistHook, completed`);
    };
    _actions().ExportPersist.onPutHook = onPutHook;
    _actions().PostSign.onPutHook = onPutHook;
    _scope().Scope.onPostExport = onPostExportHook;
    _objects().Repository.onPostObjectsPersist = onPostObjectsPersistHook;
    express.register([new (_routes().PutRoute)(scope, postPutSlot), new (_routes().FetchRoute)(scope, logger), new (_routes().ActionRoute)(scope), new (_routes().DeleteRoute)(scope)]);
    // @ts-ignore - @ran to implement the missing functions and remove it
    ui.registerUiRoot(new (_scope5().ScopeUIRoot)(scope));
    graphql.register((0, _scope4().scopeSchema)(scope));
    componentExt.registerHost(scope);
    return scope;
  }
}
exports.ScopeMain = ScopeMain;
(0, _defineProperty2().default)(ScopeMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(ScopeMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(ScopeMain, "dependencies", [_component().ComponentAspect, _ui().UIAspect, _graphql().GraphqlAspect, _cli().CLIAspect, _isolator().IsolatorAspect, _aspectLoader().AspectLoaderAspect, _express().ExpressAspect, _logger().LoggerAspect, _envs().default]);
(0, _defineProperty2().default)(ScopeMain, "defaultConfig", {
  httpTimeOut: 600000
});
_scope3().ScopeAspect.addRuntime(ScopeMain);

//# sourceMappingURL=scope.main.runtime.js.map