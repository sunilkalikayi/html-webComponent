"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scopeSchema = scopeSchema;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("@teambit/component");
  _component = function () {
    return data;
  };
  return data;
}
function _graphqlTag() {
  const data = _interopRequireDefault(require("graphql-tag"));
  _graphqlTag = function () {
    return data;
  };
  return data;
}
function _scope() {
  const data = require("@teambit/legacy/dist/api/scope");
  _scope = function () {
    return data;
  };
  return data;
}
function _scopeList() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/api/scope/lib/scope-list"));
  _scopeList = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function scopeSchema(scopeMain) {
  return {
    typeDefs: (0, _graphqlTag().default)`
      type Scope {
        # name of the scope.
        name: String

        # description of the scope.
        description: String

        # icon of the scope.
        icon: String

        # background color of the icon.
        backgroundIconColor: String

        # path of the scope.
        path: String

        # list of components contained in the scope.
        components(offset: Int, limit: Int, includeCache: Boolean, namespaces: [String!]): [Component]

        # get a specific component.
        get(id: String!): Component

        # get serialized legacy component. deprecated. PLEASE DO NOT USE THIS API.
        _getLegacy(id: String!): String

        # get logs.
        getLogs(id: String!): [Log]

        # get many components by ID.
        getMany(ids: [String]!): [Component]

        # get serialized legacy component ids with versions. deprecated. PLEASE DO NOT USE THIS API.
        _legacyLatestVersions(ids: [String]!): [String]

        # get serialized list component of components. deprecated. PLEASE DO NOT USE THIS API.
        _legacyList(namespaces: String): [LegacyMeta] @deprecated(reason: "Use the component query on Scope")
      }

      type Log {
        message: String
        username: String
        email: String
        date: String
        hash: String!
        tag: String
      }

      type LegacyMeta {
        id: String
        deprecated: Boolean
      }

      type Query {
        scope: Scope
      }
    `,
    resolvers: {
      Scope: {
        name: scope => {
          return scope.name;
        },
        description: scope => {
          return scope.description;
        },
        icon: scope => {
          return scope.icon;
        },
        backgroundIconColor: scope => {
          return scope.backgroundIconColor;
        },
        components: (scope, props) => {
          if (!props) return scope.list();
          return scope.list(_objectSpread({}, props), props.includeCache);
        },
        get: async (scope, {
          id
        }) => {
          return scope.get(_component().ComponentID.fromString(id));
        },
        _getLegacy: async (scope, {
          id
        }) => {
          const resolvedId = await scope.resolveId(id);
          const component = await scope.get(resolvedId);
          if (!component) return null;
          return component.state._consumer.toString();
        },
        _legacyLatestVersions: async (scope, {
          ids
        }) => {
          return (0, _scope().latestVersions)(scope.path, ids);
        },
        _legacyList: async (scope, {
          namespaces
        }) => {
          const listData = await (0, _scopeList().default)(scope.path, namespaces);
          listData.forEach(data => {
            data.id = data.id.toString();
          });
          return listData;
        },
        getLogs: async (scope, {
          id
        }) => {
          return scope.getLogs(_component().ComponentID.fromString(id));
        },
        getMany: async (scope, {
          ids
        }) => {
          return scope.getMany(ids.map(str => _component().ComponentID.fromString(str)));
        }
        // delete: async (scope: ScopeMain, props: {  }) => {

        // }
      },

      Query: {
        scope: () => scopeMain
      }
    }
  };
}

//# sourceMappingURL=scope.graphql.js.map