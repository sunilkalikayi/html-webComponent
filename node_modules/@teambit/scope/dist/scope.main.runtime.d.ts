import type { AspectLoaderMain } from '@teambit/aspect-loader';
import { RawBuilderData } from '@teambit/builder';
import { AspectDefinition } from '@teambit/aspect-loader';
import { CLIMain } from '@teambit/cli';
import type { ComponentMain, ComponentMap, ResolveAspectsOptions } from '@teambit/component';
import { Component, ComponentFactory, ComponentID, Snap, State } from '@teambit/component';
import type { GraphqlMain } from '@teambit/graphql';
import { Harmony, SlotRegistry, ExtensionManifest, Aspect } from '@teambit/harmony';
import { IsolatorMain } from '@teambit/isolator';
import { LoggerMain, Logger } from '@teambit/logger';
import { ExpressMain } from '@teambit/express';
import type { UiMain } from '@teambit/ui';
import { RequireableComponent } from '@teambit/harmony.modules.requireable-component';
import { BitId } from '@teambit/legacy-bit-id';
import { BitIds as ComponentsIds } from '@teambit/legacy/dist/bit-id';
import { ModelComponent, Lane } from '@teambit/legacy/dist/scope/models';
import LegacyScope, { LegacyOnTagResult } from '@teambit/legacy/dist/scope/scope';
import { ComponentLog } from '@teambit/legacy/dist/scope/models/model-component';
import { PersistOptions } from '@teambit/legacy/dist/scope/types';
import LegacyGraph from '@teambit/legacy/dist/scope/graph/graph';
import { Remotes } from '@teambit/legacy/dist/remotes';
import { Types } from '@teambit/legacy/dist/scope/object-registrar';
import { FETCH_OPTIONS } from '@teambit/legacy/dist/api/scope/lib/fetch';
import { ObjectList } from '@teambit/legacy/dist/scope/objects/object-list';
import { AuthData } from '@teambit/legacy/dist/scope/network/http/http';
import ConsumerComponent from '@teambit/legacy/dist/consumer/component';
import { EnvsMain } from '@teambit/envs';
import { ScopeComponentLoader } from './scope-component-loader';
import { StagedConfig } from './staged-config';
declare type ManifestOrAspect = ExtensionManifest | Aspect;
declare type RemoteEventMetadata = {
    auth?: AuthData;
    headers?: {};
};
declare type RemoteEvent<Data> = (data: Data, metadata: RemoteEventMetadata, errors?: Array<string | Error>) => Promise<void>;
declare type OnPostPutData = {
    ids: ComponentID[];
    lanes: Lane[];
};
declare type OnPostDeleteData = {
    ids: ComponentID[];
};
declare type OnPreFetchObjectData = {
    ids: string[];
    fetchOptions: FETCH_OPTIONS;
};
declare type OnPostPut = RemoteEvent<OnPostPutData>;
declare type OnPostExport = RemoteEvent<OnPostPutData>;
declare type OnPostDelete = RemoteEvent<OnPostDeleteData>;
declare type OnPostObjectsPersist = RemoteEvent<undefined>;
declare type OnPreFetchObjects = RemoteEvent<OnPreFetchObjectData>;
export declare type OnPostPutSlot = SlotRegistry<OnPostPut>;
export declare type OnPostDeleteSlot = SlotRegistry<OnPostDelete>;
export declare type OnPostExportSlot = SlotRegistry<OnPostExport>;
export declare type OnPostObjectsPersistSlot = SlotRegistry<OnPostObjectsPersist>;
export declare type OnPreFetchObjectsSlot = SlotRegistry<OnPreFetchObjects>;
export declare type ScopeConfig = {
    httpTimeOut: number;
    description?: string;
    icon?: string;
    backgroundIconColor?: string;
};
export declare class ScopeMain implements ComponentFactory {
    /**
     * private reference to the instance of Harmony.
     */
    private harmony;
    /**
     * legacy scope
     */
    readonly legacyScope: LegacyScope;
    /**
     * component extension.
     */
    readonly componentExtension: ComponentMain;
    /**
     * slot registry for subscribing to build
     */
    readonly config: ScopeConfig;
    private postPutSlot;
    private postDeleteSlot;
    private postExportSlot;
    private postObjectsPersist;
    preFetchObjects: OnPreFetchObjectsSlot;
    private isolator;
    private aspectLoader;
    private logger;
    private envs;
    componentLoader: ScopeComponentLoader;
    constructor(
    /**
     * private reference to the instance of Harmony.
     */
    harmony: Harmony, 
    /**
     * legacy scope
     */
    legacyScope: LegacyScope, 
    /**
     * component extension.
     */
    componentExtension: ComponentMain, 
    /**
     * slot registry for subscribing to build
     */
    config: ScopeConfig, postPutSlot: OnPostPutSlot, postDeleteSlot: OnPostDeleteSlot, postExportSlot: OnPostExportSlot, postObjectsPersist: OnPostObjectsPersistSlot, preFetchObjects: OnPreFetchObjectsSlot, isolator: IsolatorMain, aspectLoader: AspectLoaderMain, logger: Logger, envs: EnvsMain);
    /**
     * name of the scope
     */
    get name(): string;
    get icon(): string | undefined;
    get backgroundIconColor(): string | undefined;
    get description(): string | undefined;
    get path(): string;
    get isLegacy(): boolean;
    reloadAspectsWithNewVersion(components: ConsumerComponent[]): Promise<void>;
    getManyByLegacy(components: ConsumerComponent[]): Promise<Component[]>;
    clearCache(): void;
    builderDataMapToLegacyOnTagResults(builderDataComponentMap: ComponentMap<RawBuilderData>): LegacyOnTagResult[];
    /**
     * register to the post-export slot.
     */
    onPostPut(postPutFn: OnPostPut): this;
    /**
     * register to the post-delete slot.
     */
    onPostDelete(postDeleteFn: OnPostDelete): this;
    /**
     * register to the post-export slot.
     */
    registerOnPostExport(postExportFn: OnPostExport): this;
    registerOnPreFetchObjects(preFetchObjectsFn: OnPreFetchObjects): this;
    registerOnPostObjectsPersist(postObjectsPersistFn: OnPostObjectsPersist): this;
    /**
     * Will fetch a list of components into the current scope.
     * This will only fetch the object and won't write the files to the actual FS
     *
     * @param {ComponentsIds} ids list of ids to fetch
     */
    fetch(ids: ComponentsIds): void;
    /**
     * This function will get a component and sealed it's current state into the scope
     *
     * @param {Component[]} components A list of components to seal with specific persist options (such as message and version number)
     * @param {PersistOptions} persistGeneralOptions General persistence options such as verbose
     */
    persist(components: Component[], options: PersistOptions): void;
    delete({ ids, force, lanes }: {
        ids: string[];
        force: boolean;
        lanes: boolean;
    }, headers?: Record<string, any>): Promise<import("@teambit/legacy/dist/scope/removed-components").RemovedObjectSerialized>;
    toObjectList(types: Types): Promise<ObjectList>;
    private toJs;
    private parseLocalAspect;
    private findRuntime;
    private loadAspectFromPath;
    private localAspects;
    loadAspects(ids: string[], throwOnError?: boolean, neededFor?: string): Promise<string[]>;
    /**
     * This function get's a list of aspect ids and return them grouped by whether any of them is the env of other from the list
     * @param ids
     */
    groupAspectIdsByEnvOfTheList(ids: string[]): Promise<{
        envs?: string[];
        other?: string[];
    }>;
    private getManifestsAndLoadAspects;
    getManifestsGraphRecursively(ids: string[], visited?: string[], throwOnError?: boolean, opts?: {
        packageManagerConfigRootDir?: string;
    }): Promise<{
        manifests: ManifestOrAspect[];
        potentialPluginsIds: string[];
    }>;
    private getNonLoadedAspects;
    private resolveLocalAspects;
    getResolvedAspects(components: Component[], opts?: {
        skipIfExists?: boolean;
        packageManagerConfigRootDir?: string;
    }): Promise<RequireableComponent[]>;
    private compileIfNoDist;
    private tryCompile;
    requireAspects(components: Component[], throwOnError?: boolean, opts?: {
        packageManagerConfigRootDir?: string;
    }): Promise<Array<ExtensionManifest | Aspect>>;
    getAspectCapsulePath(): string;
    private resolveUserAspects;
    resolveAspects(runtimeName?: string, componentIds?: ComponentID[], opts?: ResolveAspectsOptions): Promise<AspectDefinition[]>;
    getLegacyGraph(ids?: ComponentID[]): Promise<LegacyGraph>;
    /**
     * import components into the scope.
     */
    import(ids: ComponentID[], { useCache, throwIfNotExist, reFetchUnBuiltVersion, lane, }?: {
        /**
         * if the component exists locally, don't go to the server to search for updates.
         */
        useCache?: boolean;
        throwIfNotExist?: boolean;
        /**
         * if the Version objects exists locally, but its `buildStatus` is Pending or Failed, reach the remote to find
         * whether the version was already built there.
         */
        reFetchUnBuiltVersion?: boolean;
        /**
         * if the component is on a lane, provide the lane object. the component will be fetched from the lane-scope and
         * not from the component-scope.
         */
        lane?: Lane;
    }): Promise<Component[]>;
    get(id: ComponentID): Promise<Component | undefined>;
    getFromConsumerComponent(consumerComponent: ConsumerComponent): Promise<Component>;
    /**
     * get a component from a remote without importing it
     */
    getRemoteComponent(id: ComponentID): Promise<Component>;
    /**
     * get a component from a remote without importing it
     */
    getManyRemoteComponents(ids: ComponentID[]): Promise<Component[]>;
    /**
     * list all components in the scope.
     */
    list(filter?: {
        offset: number;
        limit: number;
        namespaces?: string[];
    }, includeCache?: boolean, includeFromLanes?: boolean): Promise<Component[]>;
    /**
     * for now, list of invalid components are mostly useful for the workspace.
     * in the future, this can return components that failed to load in the scope due to objects file
     * corruption or similar issues.
     */
    listInvalid(): Promise<never[]>;
    /**
     * get ids of all scope components.
     * @param includeCache whether or not include components that their scope-name is different than the current scope-name
     */
    listIds(includeCache?: boolean, includeFromLanes?: boolean, patterns?: string[]): Promise<ComponentID[]>;
    /**
     * Check if a specific id exist in the scope
     * @param componentId
     */
    hasId(componentId: ComponentID, includeCache?: boolean): Promise<boolean>;
    hasIdNested(componentId: ComponentID, includeCache?: boolean): Promise<boolean>;
    /**
     * determine whether a component exists in the scope.
     */
    exists(modelComponent: ModelComponent): boolean;
    getMany(ids: ComponentID[], throwIfNotExist?: boolean): Promise<Component[]>;
    /**
     * load components from a scope and load their aspects
     */
    loadMany(ids: ComponentID[]): Promise<Component[]>;
    /**
     * get a component and throw an exception if not found.
     * @param id component id
     */
    getOrThrow(id: ComponentID): Promise<Component>;
    /**
     * returns a specific state of a component.
     * @param id component ID.
     * @param hash state hash.
     */
    getState(id: ComponentID, hash: string): Promise<State>;
    getSnap(id: ComponentID, hash: string): Promise<Snap>;
    getLogs(id: ComponentID, shortHash?: boolean, startsFrom?: string): Promise<ComponentLog[]>;
    getStagedConfig(): Promise<StagedConfig>;
    /**
     * resolve a component ID.
     * @param id component ID.
     */
    resolveComponentId(id: string | ComponentID | BitId): Promise<ComponentID>;
    resolveMultipleComponentIds(ids: Array<string | ComponentID | BitId>): Promise<ComponentID[]>;
    /**
     * @deprecated use `this.idsByPattern` instead for consistency, which supports also negation and list of patterns.
     */
    byPattern(patterns: string[], scope?: string): Promise<Component[]>;
    /**
     * get component-ids matching the given pattern. a pattern can have multiple patterns separated by a comma.
     * it uses multimatch (https://www.npmjs.com/package/multimatch) package for the matching algorithm, which supports
     * (among others) negate character "!" to exclude ids. See the package page for more supported characters.
     */
    idsByPattern(pattern: string, throwForNoMatch?: boolean): Promise<ComponentID[]>;
    filterIdsFromPoolIdsByPattern(pattern: string, ids: ComponentID[], throwForNoMatch?: boolean): ComponentID[];
    getExactVersionBySemverRange(id: ComponentID, range: string): Promise<string | undefined>;
    resumeExport(exportId: string, remotes: string[]): Promise<string[]>;
    resolveId(id: string): Promise<ComponentID>;
    _legacyRemotes(): Promise<Remotes>;
    /**
     * list all component ids from a remote-scope
     */
    listRemoteScope(scopeName: string): Promise<ComponentID[]>;
    /**
     * get a component and load its aspect
     */
    load(id: ComponentID): Promise<Component | undefined>;
    loadComponentsAspect(component: Component): Promise<void>;
    isModified(): Promise<boolean>;
    write(): Promise<void>;
    /**
     * declare the slots of scope extension.
     */
    static slots: (((registerFn: () => string) => SlotRegistry<OnPostPut>) | ((registerFn: () => string) => SlotRegistry<OnPostObjectsPersist>) | ((registerFn: () => string) => SlotRegistry<OnPreFetchObjects>))[];
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: Aspect[];
    static defaultConfig: ScopeConfig;
    static provider([componentExt, ui, graphql, cli, isolator, aspectLoader, express, loggerMain, envs]: [
        ComponentMain,
        UiMain,
        GraphqlMain,
        CLIMain,
        IsolatorMain,
        AspectLoaderMain,
        ExpressMain,
        LoggerMain,
        EnvsMain
    ], config: ScopeConfig, [postPutSlot, postDeleteSlot, postExportSlot, postObjectsPersistSlot, preFetchObjectsSlot]: [
        OnPostPutSlot,
        OnPostDeleteSlot,
        OnPostExportSlot,
        OnPostObjectsPersistSlot,
        OnPreFetchObjectsSlot
    ], harmony: Harmony): Promise<ScopeMain | undefined>;
}
export {};
