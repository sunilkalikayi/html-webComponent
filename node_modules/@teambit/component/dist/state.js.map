{"version":3,"names":["State","constructor","config","_aspects","filesystem","dependencies","_consumer","mainFile","file","files","find","componentFile","relative","MainFileNotFound","ComponentID","fromLegacy","id","hash","issues","IssuesList","isModified","_isModified","aspects"],"sources":["state.ts"],"sourcesContent":["import { IssuesList } from '@teambit/component-issues';\nimport { ComponentID } from '@teambit/component-id';\nimport ComponentFS from './component-fs';\nimport Config from './config';\nimport { AspectList } from './aspect-list';\nimport { MainFileNotFound } from './exceptions';\n\nexport class State {\n  constructor(\n    /**\n     * component configuration which is later generated to a component `package.json` and `bit.json`.\n     * @deprecated please use `aspects` instead.\n     */\n    readonly config: Config,\n\n    /**\n     * list of aspects configured on the component.\n     */\n    private _aspects: AspectList,\n\n    /**\n     * in-memory representation of the component current filesystem.\n     */\n    readonly filesystem: ComponentFS,\n\n    /**\n     * dependency graph of the component current. ideally package dependencies would be also placed here.\n     */\n    // readonly dependencies: Dependencies\n    readonly dependencies,\n\n    /**\n     * instance of legacy consumer component.\n     */\n    readonly _consumer: any\n  ) {}\n\n  /**\n   * get the main file of the component.\n   */\n  get mainFile() {\n    const file = this.filesystem.files.find((componentFile) => {\n      return componentFile.relative === this._consumer.mainFile;\n    });\n\n    if (!file) throw new MainFileNotFound(ComponentID.fromLegacy(this._consumer.id), this._consumer.mainFile);\n\n    return file;\n  }\n\n  /**\n   * calculate the hash of this state\n   */\n  get hash() {\n    return '';\n  }\n\n  get issues(): IssuesList {\n    return (this._consumer.issues ||= new IssuesList());\n  }\n\n  /**\n   * @deprecated please use `component.isModified`.\n   * the way it's implemented here is unreliable and will only work if in the legacy the \"isModified\" was calculated.\n   */\n  get isModified(): boolean {\n    return this._consumer._isModified;\n  }\n\n  get aspects(): AspectList {\n    return this._aspects;\n  }\n\n  set aspects(aspects: AspectList) {\n    this._aspects = aspects;\n  }\n\n  // static fromLegacy(consumerComponent: ConsumerComponent) {\n  //   return new State(\n  //     new Config(consumerComponent.mainFile, consumerComponent.extensions),\n  //     consumerComponent.version || 'new',\n  //     ComponentFS.fromVinyls(consumerComponent.files),\n  //     Store.fromArray([]),\n  //     consumerComponent.dependencies,\n  //     consumerComponent\n  //   );\n  // }\n}\n"],"mappings":";;;;;;AAAA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAIA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAEO,MAAMA,KAAK,CAAC;EACjBC,WAAW;EACT;AACJ;AACA;AACA;EACaC,MAAc;EAEvB;AACJ;AACA;EACYC,QAAoB;EAE5B;AACJ;AACA;EACaC,UAAuB;EAEhC;AACJ;AACA;EACI;EACSC,YAAY;EAErB;AACJ;AACA;EACaC,SAAc,EACvB;IAAA,KAtBSJ,MAAc,GAAdA,MAAc;IAAA,KAKfC,QAAoB,GAApBA,QAAoB;IAAA,KAKnBC,UAAuB,GAAvBA,UAAuB;IAAA,KAMvBC,YAAY,GAAZA,YAAY;IAAA,KAKZC,SAAc,GAAdA,SAAc;EACtB;;EAEH;AACF;AACA;EACE,IAAIC,QAAQ,GAAG;IACb,MAAMC,IAAI,GAAG,IAAI,CAACJ,UAAU,CAACK,KAAK,CAACC,IAAI,CAAEC,aAAa,IAAK;MACzD,OAAOA,aAAa,CAACC,QAAQ,KAAK,IAAI,CAACN,SAAS,CAACC,QAAQ;IAC3D,CAAC,CAAC;IAEF,IAAI,CAACC,IAAI,EAAE,MAAM,KAAIK,8BAAgB,EAACC,0BAAW,CAACC,UAAU,CAAC,IAAI,CAACT,SAAS,CAACU,EAAE,CAAC,EAAE,IAAI,CAACV,SAAS,CAACC,QAAQ,CAAC;IAEzG,OAAOC,IAAI;EACb;;EAEA;AACF;AACA;EACE,IAAIS,IAAI,GAAG;IACT,OAAO,EAAE;EACX;EAEA,IAAIC,MAAM,GAAe;IAAA;IACvB,OAAQ,uBAAI,CAACZ,SAAS,EAACY,MAAM,KAArB,gBAAeA,MAAM,GAAK,KAAIC,6BAAU,GAAE;EACpD;;EAEA;AACF;AACA;AACA;EACE,IAAIC,UAAU,GAAY;IACxB,OAAO,IAAI,CAACd,SAAS,CAACe,WAAW;EACnC;EAEA,IAAIC,OAAO,GAAe;IACxB,OAAO,IAAI,CAACnB,QAAQ;EACtB;EAEA,IAAImB,OAAO,CAACA,OAAmB,EAAE;IAC/B,IAAI,CAACnB,QAAQ,GAAGmB,OAAO;EACzB;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACF;AAAC"}