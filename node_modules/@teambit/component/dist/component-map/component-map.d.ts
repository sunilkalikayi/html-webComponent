import { ComponentID } from '@teambit/component-id';
import { Component } from '../component';
/**
 * allows to index components -> values.
 */
export declare class ComponentMap<T> {
    readonly hashMap: Map<string, [Component, T]>;
    constructor(hashMap: Map<string, [Component, T]>);
    /**
     * @deprecated please use `get` instead
     */
    byComponent(component: Component): [Component, T] | undefined;
    get components(): Component[];
    /**
     * get a value for a component.
     */
    get(component: Component): [Component, T] | undefined;
    /**
     * get a value by the component-id
     */
    getValueByComponentId(componentId: ComponentID): T | null;
    /**
     * returns an array.
     */
    toArray(): [Component, T][];
    /**
     * map entries and return a new component map.
     */
    map<NewType>(predicate: (value: T, component: Component) => NewType): ComponentMap<NewType>;
    /**
     * similar to Array.forEach, but here you get both, the value and the component.
     */
    forEach(predicate: (value: T, component: Component) => void): void;
    /**
     * flatten values of all components into a single array.
     */
    flattenValue(): T[];
    /**
     * filter all components with empty values and return a new map.
     */
    filter(predicate: (value: T) => boolean): ComponentMap<T>;
    /**
     * get all component ids.
     */
    keys(): IterableIterator<string>;
    static create<U>(rawMap: [Component, U][]): ComponentMap<U>;
    /**
     * create a component map from components and a value predicate.
     * @param components components to zip into the map.
     * @param predicate predicate for returning desired value.
     */
    static as<U>(components: Component[], predicate: (component: Component) => U): ComponentMap<U>;
}
