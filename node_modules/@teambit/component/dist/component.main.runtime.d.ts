import { CLIMain } from '@teambit/cli';
import { ExpressMain, Route } from '@teambit/express';
import { GraphqlMain } from '@teambit/graphql';
import { SlotRegistry } from '@teambit/harmony';
import { ComponentID } from '@teambit/component-id';
import { ExtensionDataList } from '@teambit/legacy/dist/consumer/config';
import { ComponentFactory } from './component-factory';
import { AspectList } from './aspect-list';
import { AspectEntry } from './aspect-entry';
import { ShowFragment } from './show';
import { RegisteredComponentRoute } from '.';
export declare type ComponentHostSlot = SlotRegistry<ComponentFactory>;
export declare type ShowFragmentSlot = SlotRegistry<ShowFragment[]>;
export declare class ComponentMain {
    /**
     * slot for component hosts to register.
     */
    private hostSlot;
    /**
     * Express Extension
     */
    private express;
    private showFragmentSlot;
    constructor(
    /**
     * slot for component hosts to register.
     */
    hostSlot: ComponentHostSlot, 
    /**
     * Express Extension
     */
    express: ExpressMain, showFragmentSlot: ShowFragmentSlot);
    /**
     * register a new component host.
     */
    registerHost(host: ComponentFactory): this;
    /**
     * important! avoid using this method.
     * seems like this method was written to work around a very specific case when the ComponentID of the aspects are
     * not available. in case of new components, to get the ComponentID, the workspace-aspect is needed to get the
     * default-scope. when this method is called from the scope, there is no way to get the real component-id.
     * instead, this method asks for the "scope", which when called by the scope-aspect is the current scope-name.
     * it may or may not be the real scope-name of the aspect.
     * to fix this possibly incorrect scope-name, the `workspace.resolveScopeAspectListIds()` checks whether the
     * scope-name is the same as scope.name, and if so, resolve it to the correct scope-name.
     */
    createAspectListFromLegacy(legacyExtensionDataList: ExtensionDataList, scope?: string): AspectList;
    createAspectListFromEntries(entries: AspectEntry[]): AspectList;
    registerRoute(routes: RegisteredComponentRoute[]): this;
    /**
     * set the prior host.
     */
    setHostPriority(id: string): this;
    /**
     * get component host by extension ID.
     */
    getHost(id?: string): ComponentFactory;
    getRoute(id: ComponentID, routeName: string): string;
    /**
     * get the prior host.
     */
    private getPriorHost;
    getShowFragments(): ShowFragment[];
    isHost(name: string): boolean;
    /**
     * register a show fragment to display further information in the `bit show` command.
     */
    registerShowFragments(showFragments: ShowFragment[]): this;
    private _priorHost;
    static slots: (((registerFn: () => string) => SlotRegistry<Route[]>) | ((registerFn: () => string) => SlotRegistry<ComponentFactory>) | ((registerFn: () => string) => SlotRegistry<ShowFragment[]>))[];
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: import("@teambit/harmony").Aspect[];
    static provider([graphql, express, cli]: [GraphqlMain, ExpressMain, CLIMain], config: any, [hostSlot, showFragmentSlot]: [ComponentHostSlot, ShowFragmentSlot]): Promise<ComponentMain>;
}
