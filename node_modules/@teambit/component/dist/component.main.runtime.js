"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ComponentMain = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _cli() {
  const data = require("@teambit/cli");
  _cli = function () {
    return data;
  };
  return data;
}
function _express() {
  const data = require("@teambit/express");
  _express = function () {
    return data;
  };
  return data;
}
function _graphql() {
  const data = require("@teambit/graphql");
  _graphql = function () {
    return data;
  };
  return data;
}
function _harmony() {
  const data = require("@teambit/harmony");
  _harmony = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _component() {
  const data = require("./component.aspect");
  _component = function () {
    return data;
  };
  return data;
}
function _component2() {
  const data = require("./component.graphql");
  _component2 = function () {
    return data;
  };
  return data;
}
function _component3() {
  const data = require("./component.route");
  _component3 = function () {
    return data;
  };
  return data;
}
function _aspectList() {
  const data = require("./aspect-list");
  _aspectList = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _show() {
  const data = require("./show");
  _show = function () {
    return data;
  };
  return data;
}
class ComponentMain {
  constructor(
  /**
   * slot for component hosts to register.
   */
  hostSlot,
  /**
   * Express Extension
   */
  express, showFragmentSlot) {
    this.hostSlot = hostSlot;
    this.express = express;
    this.showFragmentSlot = showFragmentSlot;
    (0, _defineProperty2().default)(this, "_priorHost", void 0);
  }

  /**
   * register a new component host.
   */
  registerHost(host) {
    this.hostSlot.register(host);
    return this;
  }

  /**
   * important! avoid using this method.
   * seems like this method was written to work around a very specific case when the ComponentID of the aspects are
   * not available. in case of new components, to get the ComponentID, the workspace-aspect is needed to get the
   * default-scope. when this method is called from the scope, there is no way to get the real component-id.
   * instead, this method asks for the "scope", which when called by the scope-aspect is the current scope-name.
   * it may or may not be the real scope-name of the aspect.
   * to fix this possibly incorrect scope-name, the `workspace.resolveScopeAspectListIds()` checks whether the
   * scope-name is the same as scope.name, and if so, resolve it to the correct scope-name.
   */
  createAspectListFromLegacy(legacyExtensionDataList, scope) {
    return _aspectList().AspectList.fromLegacyExtensions(legacyExtensionDataList, scope);
  }
  createAspectListFromEntries(entries) {
    return new (_aspectList().AspectList)(entries);
  }
  registerRoute(routes) {
    const routeEntries = routes.map(route => {
      return new (_component3().ComponentRoute)(route, this);
    });
    const flattenRoutes = (0, _lodash().flatten)(routeEntries);
    this.express.register(flattenRoutes);
    return this;
  }

  /**
   * set the prior host.
   */
  setHostPriority(id) {
    const host = this.hostSlot.get(id);
    if (!host) {
      throw new (_exceptions().HostNotFound)(id);
    }
    this._priorHost = host;
    return this;
  }

  /**
   * get component host by extension ID.
   */
  getHost(id) {
    if (id) {
      const host = this.hostSlot.get(id);
      if (!host) throw new (_exceptions().HostNotFound)(id);
      return host;
    }
    return this.getPriorHost();
  }
  getRoute(id, routeName) {
    return `/api/${id.toString()}/~aspect/${routeName}`;
  }

  /**
   * get the prior host.
   */
  getPriorHost() {
    if (this._priorHost) return this._priorHost;
    const hosts = this.hostSlot.values();
    const priorityHost = hosts.find(host => host.priority);
    return priorityHost || hosts[0];
  }
  getShowFragments() {
    const fragments = (0, _lodash().orderBy)((0, _lodash().flatten)(this.showFragmentSlot.values()), ['weight', ['asc']]);
    return fragments;
  }
  isHost(name) {
    return !!this.hostSlot.get(name);
  }

  /**
   * register a show fragment to display further information in the `bit show` command.
   */
  registerShowFragments(showFragments) {
    this.showFragmentSlot.register(showFragments);
    return this;
  }
  static async provider([graphql, express, cli], config, [hostSlot, showFragmentSlot]) {
    const componentExtension = new ComponentMain(hostSlot, express, showFragmentSlot);
    cli.register(new (_show().ShowCmd)(componentExtension));
    componentExtension.registerShowFragments([new (_show().NameFragment)(), new (_show().MainFileFragment)(), new (_show().IDFragment)(), new (_show().ScopeFragment)(), new (_show().FilesFragment)(), new (_show().ExtensionsFragment)()]);
    graphql.register((0, _component2().componentSchema)(componentExtension));
    return componentExtension;
  }
}
exports.ComponentMain = ComponentMain;
(0, _defineProperty2().default)(ComponentMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(ComponentMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(ComponentMain, "dependencies", [_graphql().GraphqlAspect, _express().ExpressAspect, _cli().CLIAspect]);
_component().ComponentAspect.addRuntime(ComponentMain);

//# sourceMappingURL=component.main.runtime.js.map