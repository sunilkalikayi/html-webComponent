"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.State = void 0;
function _componentIssues() {
  const data = require("@teambit/component-issues");
  _componentIssues = function () {
    return data;
  };
  return data;
}
function _componentId() {
  const data = require("@teambit/component-id");
  _componentId = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
class State {
  constructor(
  /**
   * component configuration which is later generated to a component `package.json` and `bit.json`.
   * @deprecated please use `aspects` instead.
   */
  config,
  /**
   * list of aspects configured on the component.
   */
  _aspects,
  /**
   * in-memory representation of the component current filesystem.
   */
  filesystem,
  /**
   * dependency graph of the component current. ideally package dependencies would be also placed here.
   */
  // readonly dependencies: Dependencies
  dependencies,
  /**
   * instance of legacy consumer component.
   */
  _consumer) {
    this.config = config;
    this._aspects = _aspects;
    this.filesystem = filesystem;
    this.dependencies = dependencies;
    this._consumer = _consumer;
  }

  /**
   * get the main file of the component.
   */
  get mainFile() {
    const file = this.filesystem.files.find(componentFile => {
      return componentFile.relative === this._consumer.mainFile;
    });
    if (!file) throw new (_exceptions().MainFileNotFound)(_componentId().ComponentID.fromLegacy(this._consumer.id), this._consumer.mainFile);
    return file;
  }

  /**
   * calculate the hash of this state
   */
  get hash() {
    return '';
  }
  get issues() {
    var _this$_consumer;
    return (_this$_consumer = this._consumer).issues || (_this$_consumer.issues = new (_componentIssues().IssuesList)());
  }

  /**
   * @deprecated please use `component.isModified`.
   * the way it's implemented here is unreliable and will only work if in the legacy the "isModified" was calculated.
   */
  get isModified() {
    return this._consumer._isModified;
  }
  get aspects() {
    return this._aspects;
  }
  set aspects(aspects) {
    this._aspects = aspects;
  }

  // static fromLegacy(consumerComponent: ConsumerComponent) {
  //   return new State(
  //     new Config(consumerComponent.mainFile, consumerComponent.extensions),
  //     consumerComponent.version || 'new',
  //     ComponentFS.fromVinyls(consumerComponent.files),
  //     Store.fromArray([]),
  //     consumerComponent.dependencies,
  //     consumerComponent
  //   );
  // }
}
exports.State = State;

//# sourceMappingURL=state.js.map