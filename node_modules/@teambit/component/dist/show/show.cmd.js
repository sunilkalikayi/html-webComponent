"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShowCmd = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _cliTable() {
  const data = require("@teambit/cli-table");
  _cliTable = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/bit-map/exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");
  _legacyBitId = function () {
    return data;
  };
  return data;
}
function _showCmd() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/commands/public-cmds/show-cmd"));
  _showCmd = function () {
    return data;
  };
  return data;
}
// import { Logger } from '@teambit/logger';
// import chalk from 'chalk';

class ShowCmd {
  constructor(component) {
    this.component = component;
    (0, _defineProperty2().default)(this, "name", 'show <component-name>');
    (0, _defineProperty2().default)(this, "description", "display the component's essential information");
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "group", 'info');
    (0, _defineProperty2().default)(this, "arguments", [{
      name: 'component-name',
      description: 'component name or component id'
    }]);
    (0, _defineProperty2().default)(this, "options", [['j', 'json', 'return the component data in a json format'], ['l', 'legacy', 'use the legacy bit show.'], ['r', 'remote', 'show a remote component'], ['c', 'compare', 'compare current file system component to the latest tagged component [default=latest]. only works in legacy.']]);
  }
  async getComponent(idStr, remote) {
    if (remote) {
      const bitId = _legacyBitId().BitId.parse(idStr, true); // user used --remote so we know it has a scope
      const host = this.component.getHost('teambit.scope/scope');
      const id = await host.resolveComponentId(bitId);
      if (!host.getRemoteComponent) {
        throw new Error('Component Host does not implement getRemoteComponent()');
      }
      const component = await host.getRemoteComponent(id);
      return component;
    }
    const host = this.component.getHost();
    const id = await host.resolveComponentId(idStr);
    const component = await host.get(id);
    if (!component) throw new (_exceptions().MissingBitMapComponent)(idStr);
    return component;
  }
  async useLegacy(id, json = false, remote = false, compare = false) {
    const legacyShow = new (_showCmd().default)();
    const showData = await legacyShow.action([id], {
      json,
      versions: undefined,
      remote,
      compare
    });
    return legacyShow.report(showData);
  }
  async report([idStr], {
    legacy,
    remote,
    compare
  }) {
    if (legacy) return this.useLegacy(idStr, false, remote, compare);
    const component = await this.getComponent(idStr, remote);
    const fragments = this.component.getShowFragments();
    const rows = await Promise.all(fragments.map(async fragment => {
      const row = await fragment.renderRow(component);
      if (!row.content) return null;
      return [row.title, row.content];
    }));
    const table = new (_cliTable().CLITable)([], (0, _lodash().compact)(rows));
    return table.render();
  }
  async json([idStr], {
    remote,
    legacy
  }) {
    if (legacy) return JSON.parse(await this.useLegacy(idStr, true, remote));
    const component = await this.getComponent(idStr, remote);
    const fragments = this.component.getShowFragments();
    const rows = await Promise.all(fragments.map(async fragment => {
      return fragment.json ? fragment.json(component) : undefined;
    }));
    return rows.filter(row => !!row);
  }
}
exports.ShowCmd = ShowCmd;

//# sourceMappingURL=show.cmd.js.map