"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.array.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Component = Component;
function _react() {
  const data = _interopRequireWildcard(require("react"));
  _react = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = _interopRequireDefault(require("lodash.flatten"));
  _lodash = function () {
    return data;
  };
  return data;
}
function _uiFoundationUiReactRouter() {
  const data = require("@teambit/ui-foundation.ui.react-router.slot-router");
  _uiFoundationUiReactRouter = function () {
    return data;
  };
  return data;
}
function _lodash2() {
  const data = require("lodash");
  _lodash2 = function () {
    return data;
  };
  return data;
}
function _componentModule() {
  const data = _interopRequireDefault(require("./component.module.scss"));
  _componentModule = function () {
    return data;
  };
  return data;
}
function _context() {
  const data = require("./context");
  _context = function () {
    return data;
  };
  return data;
}
function _useComponent() {
  const data = require("./use-component");
  _useComponent = function () {
    return data;
  };
  return data;
}
function _useComponentFromLocation() {
  const data = require("./use-component-from-location");
  _useComponentFromLocation = function () {
    return data;
  };
  return data;
}
function _() {
  const data = require("..");
  _ = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function getComponentIdStr(componentIdStr) {
  if ((0, _lodash2().isFunction)(componentIdStr)) return componentIdStr();
  return componentIdStr;
}

/**
 * main UI component of the Component extension.
 */
function Component({
  routeSlot,
  containerSlot,
  host,
  onComponentChange,
  componentIdStr,
  useComponent,
  path,
  useComponentFilters
}) {
  const idFromLocation = (0, _useComponentFromLocation().useIdFromLocation)();
  const _componentIdStr = getComponentIdStr(componentIdStr);
  const componentId = _componentIdStr ? _().ComponentID.fromString(_componentIdStr) : undefined;
  const resolvedComponentIdStr = path || idFromLocation;
  const useComponentOptions = {
    logFilters: useComponentFilters === null || useComponentFilters === void 0 ? void 0 : useComponentFilters(),
    customUseComponent: useComponent
  };
  const {
    component,
    componentDescriptor,
    error
  } = (0, _useComponent().useComponent)(host, (componentId === null || componentId === void 0 ? void 0 : componentId.toString()) || idFromLocation, useComponentOptions);
  // trigger onComponentChange when component changes
  (0, _react().useEffect)(() => onComponentChange === null || onComponentChange === void 0 ? void 0 : onComponentChange(component), [component]);
  // cleanup when unmounting component
  (0, _react().useEffect)(() => () => onComponentChange === null || onComponentChange === void 0 ? void 0 : onComponentChange(undefined), []);
  const pageItems = (0, _react().useMemo)(() => (0, _lodash().default)(containerSlot === null || containerSlot === void 0 ? void 0 : containerSlot.values()), [containerSlot]);
  const before = (0, _react().useMemo)(() => pageItems.filter(x => x.type === 'before').map(x => x.content), [pageItems]);
  const after = (0, _react().useMemo)(() => pageItems.filter(x => x.type === 'after').map(x => x.content), [pageItems]);
  if (error) return error.renderError();
  if (!component) return /*#__PURE__*/_react().default.createElement("div", null);
  return /*#__PURE__*/_react().default.createElement(_context().ComponentDescriptorProvider, {
    componentDescriptor: componentDescriptor
  }, /*#__PURE__*/_react().default.createElement(_context().ComponentProvider, {
    component: component
  }, before, /*#__PURE__*/_react().default.createElement("div", {
    className: _componentModule().default.container
  }, routeSlot && /*#__PURE__*/_react().default.createElement(_uiFoundationUiReactRouter().SlotRouter, {
    parentPath: `${resolvedComponentIdStr}/*`,
    slot: routeSlot
  })), after));
}

//# sourceMappingURL=component.js.map