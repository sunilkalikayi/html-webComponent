"use strict";

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AspectList = void 0;
function _extensionData() {
  const data = require("@teambit/legacy/dist/consumer/config/extension-data");
  _extensionData = function () {
    return data;
  };
  return data;
}
function _componentId() {
  const data = require("@teambit/component-id");
  _componentId = function () {
    return data;
  };
  return data;
}
function _aspectEntry() {
  const data = require("./aspect-entry");
  _aspectEntry = function () {
    return data;
  };
  return data;
}
/**
 * list of aspects, each may have data and artifacts saved per component.
 */
class AspectList {
  constructor(entries) {
    this.entries = entries;
  }
  addEntry(aspectId, data = {}) {
    const extensionDataEntry = new (_extensionData().ExtensionDataEntry)(undefined, aspectId._legacy, undefined, {}, data);
    const entry = new (_aspectEntry().AspectEntry)(aspectId, extensionDataEntry);
    this.entries.push(entry);
    return entry;
  }

  /**
   * transform an aspect list into a new one without the given aspect ids
   */
  withoutEntries(aspectIds) {
    const entries = this.entries.filter(entry => !aspectIds.includes(entry.legacy.stringId));
    return new AspectList(entries);
  }

  /**
   * get all ids as strings from the aspect list.
   */
  get ids() {
    const list = this.entries.map(entry => entry.id.toString());
    return list;
  }

  /**
   * get an aspect from the list using a serialized ID.
   */
  get(id) {
    return this.entries.find(entry => {
      return entry.legacy.stringId === id || entry.id.toStringWithoutVersion() === id;
    });
  }

  /**
   * find aspect by component ID.
   */
  find(id, ignoreVersion = false) {
    return this.entries.find(aspectEntry => {
      return id.isEqual(aspectEntry.id, {
        ignoreVersion
      });
    });
  }

  /**
   * transform an aspect list into a new one.
   */
  map(predicate) {
    const entries = this.entries.map(predicate);
    return new AspectList(entries);
  }

  /**
   * transform an aspect list into a new one.
   */
  async pmap(predicate) {
    const entriesP = this.entries.map(predicate);
    const entries = await Promise.all(entriesP);
    return new AspectList(entries);
  }
  toConfigObject() {
    const res = {};
    this.entries.forEach(entry => {
      if (entry.config) {
        res[entry.id.toString()] = (0, _extensionData().removeInternalConfigFields)(entry.config);
      }
    });
    return res;
  }
  serialize() {
    const serializedEntries = this.entries.map(entry => entry.serialize());
    return serializedEntries;
  }
  filter(ids) {
    if (!(ids !== null && ids !== void 0 && ids.length)) return new AspectList(this.entries);
    const entries = this.entries.filter(aspectEntry => {
      return ids === null || ids === void 0 ? void 0 : ids.includes(aspectEntry.id.toStringWithoutVersion());
    });
    return new AspectList(entries);
  }
  toLegacy() {
    const legacyEntries = this.entries.map(entry => entry.legacy);
    return _extensionData().ExtensionDataList.fromArray(legacyEntries);
  }
  stringIds() {
    const ids = this.entries.map(entry => entry.id.toString());
    return ids;
  }
  clone() {
    return new AspectList(this.entries.map(entry => entry.clone()));
  }
  static fromLegacyExtensions(legacyDataList, scope) {
    const newEntries = legacyDataList.map(entry => {
      return new (_aspectEntry().AspectEntry)(getAspectId(entry, scope), entry);
    });
    return new AspectList(newEntries);
  }
}
exports.AspectList = AspectList;
function getAspectId(entry, scope) {
  if (!entry.extensionId && entry.name) return _componentId().ComponentID.fromString(entry.name);
  if (entry.extensionId) return _componentId().ComponentID.fromLegacy(entry.extensionId, scope);
  throw new Error('aspect cannot be loaded without setting an ID');
}

//# sourceMappingURL=aspect-list.js.map