import { AnyFS } from '@teambit/any-fs';
import { SemVer } from 'semver';
import { ComponentID } from '@teambit/component-id';
import { BuildStatus } from '@teambit/legacy/dist/constants';
import { ComponentFactory } from './component-factory';
import ComponentFS from './component-fs';
import ComponentConfig from './config';
import { Snap } from './snap';
import { State } from './state';
import { TagMap } from './tag-map';
import { Tag } from './tag';
import { IComponent, RawComponentMetadata } from './component-interface';
declare type SnapsIterableOpts = {
    firstParentOnly?: boolean;
    stopFn?: (snap: Snap) => Promise<boolean>;
};
export declare type InvalidComponent = {
    id: ComponentID;
    err: Error;
};
/**
 * in-memory representation of a component.
 */
export declare class Component implements IComponent {
    /**
     * component ID represented by the `ComponentId` type.
     */
    readonly id: ComponentID;
    /**
     * head version of the component. can be `null` for new components.
     */
    readonly head: Snap | null;
    /**
     * state of the component.
     */
    private _state;
    /**
     * tags of the component.
     */
    readonly tags: TagMap;
    /**
     * the component factory
     */
    private factory;
    constructor(
    /**
     * component ID represented by the `ComponentId` type.
     */
    id: ComponentID, 
    /**
     * head version of the component. can be `null` for new components.
     */
    head: Snap | null, 
    /**
     * state of the component.
     */
    _state: State, 
    /**
     * tags of the component.
     */
    tags: TagMap, 
    /**
     * the component factory
     */
    factory: ComponentFactory);
    get mainFile(): import("@teambit/legacy/dist/consumer/component/sources").AbstractVinyl;
    get state(): State;
    set state(state: State);
    /**
     * component configuration which is later generated to a component `package.json` and `bit.json`.
     */
    get config(): ComponentConfig;
    /**
     * in-memory representation of the component current filesystem.
     */
    get filesystem(): ComponentFS;
    /**
     * build status of the component
     */
    get buildStatus(): BuildStatus;
    get headTag(): Tag | undefined;
    get latest(): string | undefined;
    /**
     * get aspect data from current state.
     */
    get(id: string): RawComponentMetadata | undefined;
    getLogs(filter?: {
        type?: string;
        offset?: number;
        limit?: number;
        head?: string;
        sort?: string;
    }): Promise<import("@teambit/legacy/scopes/component/legacy-component-log").LegacyComponentLog[]>;
    stringify(): string;
    /**
     * record component changes in the `Scope`.
     */
    /**
     * display name of the component.
     */
    get displayName(): string;
    /**
     * tag a component `Snap` with a semantic version. we follow SemVer specs as defined [here](https://semver.org/)).
     */
    tag(version: SemVer): void;
    /**
     * determines whether this component is modified in the workspace.
     */
    isModified(): Promise<boolean>;
    /**
     * is component isOutdated
     */
    isOutdated(): boolean;
    /**
     * determines whether this component is new.
     */
    isNew(): Promise<boolean>;
    loadState(snapId: string): Promise<State>;
    loadSnap(snapId?: string): Promise<Snap>;
    /**
     * Get iterable which iterate over snap parents lazily
     * @param snapId
     * @param options
     */
    snapsIterable(snapId?: string, options?: SnapsIterableOpts): AsyncIterable<Snap>;
    /**
     * traverse recursively from the provided snap (or head) upwards until it finds a tag
     * @param snapToStartFrom
     */
    getClosestTag(snapToStartFrom?: string): Promise<Tag | undefined>;
    /**
     * checkout the component to a different version in its working tree.
     */
    checkout(version: SemVer): void;
    /**
     * examine difference between two components.
     */
    /**
     * merge two different components
     */
    /**
     * write a component to a given file system.
     * @param path root path to write the component
     * @param fs instance of any fs to use.
     */
    write(path: string, fs?: AnyFS): void;
    /**
     *
     * Check if 2 components are equal
     * @param {Component} component
     * @returns {boolean}
     * @memberof Component
     */
    equals(component: Component): boolean;
}
export {};
