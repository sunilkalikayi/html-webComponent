"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.componentSchema = componentSchema;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _stripAnsi() {
  const data = _interopRequireDefault(require("strip-ansi"));
  _stripAnsi = function () {
    return data;
  };
  return data;
}
function _graphqlTag() {
  const data = _interopRequireDefault(require("graphql-tag"));
  _graphqlTag = function () {
    return data;
  };
  return data;
}
function _graphqlTypeJson() {
  const data = require("graphql-type-json");
  _graphqlTypeJson = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@teambit/legacy/dist/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function componentSchema(componentExtension) {
  return {
    typeDefs: (0, _graphqlTag().default)`
      scalar JSON
      scalar JSONObject

      type ComponentID {
        name: String!
        version: String
        scope: String
      }

      type Tag {
        # semver assigned to the tag.
        version: String!

        # tag hash.
        hash: String!
      }

      type Snap {
        # hash of the snapshot.
        hash: String!

        # time of the snapshot.
        timestamp: String!

        # parents of the snap
        parents: [String]!

        # snapper
        author: Author!

        # snapshot message
        message: String
      }

      type LogEntry {
        message: String!
        username: String
        parents: [String]!
        email: String
        date: String
        hash: String!
        tag: String
        id: String!
      }

      type Author {
        # display name of the snapper.
        displayName: String!

        # author of the snapper.
        email: String!
      }

      type Component {
        # id of the component.
        id: ComponentID!

        # head snap of the component.
        head: Snap

        # head tag of the component.
        headTag: Tag

        # list of all relative component paths.
        fs: [String]

        # relative path to the main file of the component
        mainFile: String

        # return specific file contents by relative file path.
        getFile(path: String): String

        # latest version of the component.
        latest: String

        # display name of the component
        displayName: String!

        # component buildStatus
        buildStatus: String

        # list of component releases.
        tags: [Tag]!

        """
        component logs
        """
        logs(
          """
          type of logs to show (tag or snap)
          """
          type: String
          offset: Int
          limit: Int
          """
          head to start traversing logs from
          """
          head: String
          sort: String
          """
          start traversing logs from the fetched component's head
          """
          takeHeadFromComponent: Boolean
        ): [LogEntry]!

        aspects(include: [String]): [Aspect]
      }

      type Aspect {
        id: String!
        icon: String
        config: JSONObject
        data: JSONObject
      }

      type InvalidComponent {
        id: ComponentID!
        errorName: String!
        errorMessage: String!
      }

      type ComponentHost {
        id: ID!
        name: String!

        # load a component.
        get(id: String!, withState: Boolean): Component

        # list components
        list(offset: Int, limit: Int): [Component]!

        # list invalid components and their errors
        listInvalid: [InvalidComponent]!

        # get component logs(snaps) by component id
        snaps(id: String!): [LogEntry]! @deprecated(reason: "Use the logs field on Component")
      }

      type Query {
        getHost(id: String): ComponentHost
      }
    `,
    resolvers: {
      JSONObject: _graphqlTypeJson().GraphQLJSONObject,
      Component: {
        id: component => component.id.toObject(),
        displayName: component => component.displayName,
        fs: component => {
          return component.state.filesystem.files.map(file => file.relative);
        },
        getFile: (component, {
          path
        }) => {
          const maybeFile = component.state.filesystem.files.find(file => (0, _utils().pathNormalizeToLinux)(file.relative) === path);
          if (!maybeFile) return undefined;
          return maybeFile.contents.toString('utf-8');
        },
        mainFile: component => {
          return component.state._consumer.mainFile;
        },
        headTag: component => {
          var _component$headTag;
          return (_component$headTag = component.headTag) === null || _component$headTag === void 0 ? void 0 : _component$headTag.toObject();
        },
        latest: component => component.latest,
        tags: component => {
          // graphql doesn't support map types
          return component.tags.toArray().map(tag => tag.toObject());
        },
        aspects: (component, {
          include
        }) => {
          return component.state.aspects.filter(include).serialize();
        },
        logs: async (component, filter) => {
          let head = filter === null || filter === void 0 ? void 0 : filter.head;
          if (!head && filter !== null && filter !== void 0 && filter.takeHeadFromComponent) {
            head = component.id.version;
          }
          const finalFilter = _objectSpread(_objectSpread({}, filter), {
            head
          });
          return (await component.getLogs(finalFilter)).map(log => _objectSpread(_objectSpread({}, log), {}, {
            id: log.hash
          }));
        }
      },
      ComponentHost: {
        get: async (host, {
          id
        }) => {
          try {
            const componentId = await host.resolveComponentId(id);
            const component = await host.get(componentId);
            return component;
          } catch (error) {
            return null;
          }
        },
        snaps: async (host, {
          id
        }) => {
          const componentId = await host.resolveComponentId(id);
          // return (await host.getLogs(componentId)).map(log => ({...log, id: log.hash}))
          return host.getLogs(componentId);
        },
        list: async (host, filter) => {
          return host.list(filter);
        },
        listInvalid: async host => {
          const invalidComps = await host.listInvalid();
          return invalidComps.map(({
            id,
            err
          }) => ({
            id,
            errorName: err.name,
            errorMessage: err.message ? (0, _stripAnsi().default)(err.message) : err.name
          }));
        },
        id: async host => {
          return host.name;
        },
        name: async host => {
          return host.name;
        }
      },
      Query: {
        getHost: (componentExt, {
          id
        }) => {
          return componentExtension.getHost(id);
        }
      }
    }
  };
}

//# sourceMappingURL=component.graphql.js.map