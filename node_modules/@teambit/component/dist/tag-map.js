"use strict";

require("core-js/modules/es.array.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TagMap = void 0;
function _semverHelper() {
  const data = require("@teambit/legacy/dist/utils/semver-helper");
  _semverHelper = function () {
    return data;
  };
  return data;
}
function _semver() {
  const data = require("semver");
  _semver = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
class TagMap extends Map {
  /**
   * get snap by hash.
   */
  byHash(hash) {
    const tag = Array.from(this.values()).find(currTag => currTag.hash === hash);
    return tag;
  }

  /**
   * e.g.
   * {
   *   alpha: '1.0.0-alpha.5',
   *   dev: '2.2.4-dev.37
   * }
   */
  getPreReleaseLatestTags() {
    const preReleaseTagsWithAllVersions = this.toArray().reduce((acc, current) => {
      var _preReleases$;
      const preReleases = current.version.prerelease;
      if (!preReleases.length) return acc;
      if (preReleases.length !== 2) {
        // it could be length 1, e.g. 1.0.0-0, we ignore it.
        // it could also be length > 2, e.g. 1.0.0-dev.1.alpha.1, we don't support it for now.
        return acc;
      }
      if (typeof preReleases[0] !== 'string') return acc;
      (acc[_preReleases$ = preReleases[0]] || (acc[_preReleases$] = [])).push(current.version.raw);
      return acc;
    }, {});
    return Object.keys(preReleaseTagsWithAllVersions).reduce((acc, current) => {
      acc[current] = (0, _semver().maxSatisfying)(preReleaseTagsWithAllVersions[current], '*', {
        includePrerelease: true
      });
      return acc;
    }, {});
  }

  /**
   * Get a map that map snap hash to tag
   */
  getHashMap() {
    const res = new Map();
    this.forEach(tag => {
      res.set(tag.hash, tag);
    });
    return res;
  }

  /**
   * get the latest semver from the tag map.
   */
  getLatest() {
    const versions = this.toArray().map(tag => tag.version.raw);
    if (this.isEmpty()) throw new (_exceptions().CouldNotFindLatest)(versions);
    return (0, _semverHelper().getLatestVersion)(versions);
  }
  isEmpty() {
    return this.size === 0;
  }

  /**
   * get an array of all tags.
   */
  toArray() {
    return Array.from(this.values());
  }
  byVersion(version) {
    const versions = this.toArray().map(tag => tag);
    return versions.find(tag => tag.version.raw === version);
  }
  static fromArray(tags) {
    const tuples = tags.map(tag => [tag.version, tag]);
    return new TagMap(tuples);
  }
  static empty() {
    return new TagMap();
  }
}
exports.TagMap = TagMap;

//# sourceMappingURL=tag-map.js.map