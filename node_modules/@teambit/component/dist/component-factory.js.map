{"version":3,"names":[],"sources":["component-factory.ts"],"sourcesContent":["import { BitId } from '@teambit/legacy-bit-id';\nimport LegacyGraph from '@teambit/legacy/dist/scope/graph/graph';\nimport ConsumerComponent from '@teambit/legacy/dist/consumer/component';\nimport type { ComponentLog } from '@teambit/legacy/dist/scope/models/model-component';\nimport type { AspectDefinition } from '@teambit/aspect-loader';\nimport { ComponentID } from '@teambit/component-id';\nimport { Component, InvalidComponent } from './component';\nimport { State } from './state';\nimport { Snap } from './snap';\n\nexport type ResolveAspectsOptions = {\n  /**\n   * Do not return results for the core aspects\n   */\n  excludeCore?: boolean;\n  /**\n   * Only return results for the provided list of ids\n   */\n  requestedOnly?: boolean;\n};\n\nexport interface ComponentFactory {\n  /**\n   * name of the component host.\n   */\n  name: string;\n\n  /**\n   * path to the component host.\n   */\n  path: string;\n\n  isLegacy: boolean;\n\n  /**\n   * resolve a `string` component ID to an instance of a ComponentID.\n   */\n  resolveComponentId(id: string | ComponentID | BitId): Promise<ComponentID>;\n\n  /**\n   * resolve multiple `string` component ID to an instance of a ComponentID.\n   */\n  resolveMultipleComponentIds(ids: (string | ComponentID | BitId)[]): Promise<ComponentID[]>;\n\n  /**\n   * returns a component by ID.\n   */\n  get(id: ComponentID): Promise<Component | undefined>;\n\n  /**\n   * returns many components by ids.\n   */\n  getMany(ids: ComponentID[]): Promise<Component[]>;\n\n  /**\n   * returns many components by their legacy representation.\n   */\n  getManyByLegacy(components: ConsumerComponent[]): Promise<Component[]>;\n\n  /**\n   * get a component from a remote without importing it\n   */\n  getRemoteComponent?: (id: ComponentID) => Promise<Component>;\n\n  getLegacyGraph(ids?: ComponentID[], shouldThrowOnMissingDep?: boolean): Promise<LegacyGraph>;\n\n  getLogs(id: ComponentID, shortHash?: boolean, startsFrom?: string): Promise<ComponentLog[]>;\n\n  /**\n   * returns a specific state of a component by hash or semver.\n   */\n  getState(id: ComponentID, snapId: string): Promise<State>;\n\n  /**\n   * returns a specific snap of a component by hash.\n   */\n  getSnap(id: ComponentID, snapId: string): Promise<Snap>;\n\n  /**\n   * load aspects.\n   * returns the loaded aspect ids including the loaded versions.\n   */\n  loadAspects: (ids: string[], throwOnError?: boolean, neededFor?: string) => Promise<string[]>;\n\n  /**\n   * Resolve dirs for aspects\n   */\n  resolveAspects: (\n    runtimeName?: string,\n    componentIds?: ComponentID[],\n    opts?: ResolveAspectsOptions\n  ) => Promise<AspectDefinition[]>;\n\n  /**\n   * list all components in the host.\n   */\n  list(filter?: { offset: number; limit: number }): Promise<Component[]>;\n\n  /**\n   * list invalid components, such as components with missing files on the fs.\n   */\n  listInvalid(): Promise<InvalidComponent[]>;\n\n  listIds(): Promise<ComponentID[]>;\n\n  /**\n   * get component-ids matching the given pattern. a pattern can have multiple patterns separated by a comma.\n   * it uses multimatch (https://www.npmjs.com/package/multimatch) package for the matching algorithm, which supports\n   * (among others) negate character \"!\" to exclude ids. See the package page for more supported characters.\n   */\n  idsByPattern(pattern: string, throwForNoMatch?: boolean): Promise<ComponentID[]>;\n\n  hasId(componentId: ComponentID): Promise<boolean>;\n\n  /**\n   * Check if the host has the id, if no, search for the id in inner host (for example, workspace will search in the scope)\n   * @param componentId\n   */\n  hasIdNested(componentId: ComponentID, includeCache?: boolean): Promise<boolean>;\n\n  /**\n   * whether a component is not the same as its head.\n   * for a new component, it'll return \"true\" as it has no head yet.\n   * this is relevant for component from the workspace, where it can be locally changed. on the scope it's always false\n   */\n  isModified(component: Component): Promise<boolean>;\n\n  /**\n   * write the component to the filesystem when applicable (no-op for scope).\n   * to change the component-path, specify the \"rootPath\", which should be a relative path inside the workspace.\n   */\n  write(component: Component, rootPath?: string): Promise<void>;\n\n  /**\n   * determine whether host should be the prior one in case multiple hosts persist.\n   */\n  priority?: boolean;\n}\n"],"mappings":""}