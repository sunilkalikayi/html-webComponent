"use strict";

require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.async-iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.sort.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.exec.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Component = void 0;
function _toolboxString() {
  const data = require("@teambit/toolbox.string.capitalize");
  _toolboxString = function () {
    return data;
  };
  return data;
}
function _bitError() {
  const data = require("@teambit/bit-error");
  _bitError = function () {
    return data;
  };
  return data;
}
function _lodash() {
  const data = require("lodash");
  _lodash = function () {
    return data;
  };
  return data;
}
function _tagMap() {
  const data = require("./tag-map");
  _tagMap = function () {
    return data;
  };
  return data;
}
function _exceptions() {
  const data = require("./exceptions");
  _exceptions = function () {
    return data;
  };
  return data;
}
function _asyncIterator(iterable) { var method, async, sync, retry = 2; for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = "@@asyncIterator", sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function (s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function (value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }
/**
 * in-memory representation of a component.
 */
class Component {
  constructor(
  /**
   * component ID represented by the `ComponentId` type.
   */
  id,
  /**
   * head version of the component. can be `null` for new components.
   */
  head = null,
  /**
   * state of the component.
   */
  _state,
  /**
   * tags of the component.
   */
  tags = new (_tagMap().TagMap)(),
  /**
   * the component factory
   */
  factory) {
    this.id = id;
    this.head = head;
    this._state = _state;
    this.tags = tags;
    this.factory = factory;
  }
  get mainFile() {
    return this.state.mainFile;
  }
  get state() {
    return this._state;
  }
  set state(state) {
    this._state = state;
  }

  /**
   * component configuration which is later generated to a component `package.json` and `bit.json`.
   */
  get config() {
    return this.state.config;
  }

  /**
   * in-memory representation of the component current filesystem.
   */
  get filesystem() {
    return this.state.filesystem;
  }

  /**
   * build status of the component
   */
  get buildStatus() {
    return this._state._consumer.buildStatus;
  }
  get headTag() {
    if (!this.head) return undefined;
    return this.tags.byHash(this.head.hash);
  }
  get latest() {
    if (!this.head) return undefined;
    try {
      return this.tags.getLatest();
    } catch (err) {
      if (err instanceof _exceptions().CouldNotFindLatest) {
        return this.head.hash;
      }
      throw err;
    }
  }

  /**
   * get aspect data from current state.
   */
  get(id) {
    var _this$state$aspects$g;
    return (_this$state$aspects$g = this.state.aspects.get(id)) === null || _this$state$aspects$g === void 0 ? void 0 : _this$state$aspects$g.serialize();
  }
  async getLogs(filter) {
    const allLogs = await this.factory.getLogs(this.id, false, filter === null || filter === void 0 ? void 0 : filter.head);
    if (!filter) return allLogs;
    const {
      type,
      limit,
      offset,
      sort
    } = filter;
    const typeFilter = snap => {
      if (type === 'tag') return snap.tag;
      if (type === 'snap') return !snap.tag;
      return true;
    };
    let filteredLogs = type && allLogs.filter(typeFilter) || allLogs;
    if (sort !== 'asc') filteredLogs = filteredLogs.reverse();
    if (limit) {
      filteredLogs = (0, _lodash().slice)(filteredLogs, offset, limit + (offset || 0));
    }
    return filteredLogs;
  }
  stringify() {
    return JSON.stringify({
      id: this.id,
      head: this.head
    });
  }

  /**
   * record component changes in the `Scope`.
   */
  // snap(author: Author, message = '') {
  // if (!this.isModified()) throw new NothingToSnap();
  // const snap = new Snap(this, author, message);

  // return new Component(this.id, snap, snap.state);
  // }

  /**
   * display name of the component.
   */
  get displayName() {
    const tokens = this.id.name.split('-').map(token => (0, _toolboxString().capitalize)(token));
    return tokens.join(' ');
  }

  /**
   * tag a component `Snap` with a semantic version. we follow SemVer specs as defined [here](https://semver.org/)).
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  tag(version) {
    // const snap = this.snap();
    // const tag = new Tag(version, snap);
    // this.tags.set(tag);
  }

  /**
   * determines whether this component is modified in the workspace.
   */
  isModified() {
    return this.factory.isModified(this);
  }

  /**
   * is component isOutdated
   */
  isOutdated() {
    var _this$head;
    if (!this.latest) return false;
    const latestTag = this.tags.byVersion(this.latest);
    if (!latestTag) return false;
    if (((_this$head = this.head) === null || _this$head === void 0 ? void 0 : _this$head.hash) !== (latestTag === null || latestTag === void 0 ? void 0 : latestTag.hash)) return true;
    return false;
  }

  /**
   * determines whether this component is new.
   */
  isNew() {
    return Promise.resolve(this.head === null);
  }

  // TODO: @david after snap we need to make sure to refactor here.
  loadState(snapId) {
    return this.factory.getState(this.id, snapId);
  }
  loadSnap(snapId) {
    var _this$head2;
    const snapToGet = snapId || ((_this$head2 = this.head) === null || _this$head2 === void 0 ? void 0 : _this$head2.hash);
    if (!snapToGet) {
      throw new (_bitError().BitError)('could not load snap for new components');
    }
    return this.factory.getSnap(this.id, snapToGet);
  }

  /**
   * Get iterable which iterate over snap parents lazily
   * @param snapId
   * @param options
   */
  snapsIterable(snapId, options = {}) {
    var _this$head3;
    const snapToStart = snapId || ((_this$head3 = this.head) === null || _this$head3 === void 0 ? void 0 : _this$head3.hash);
    let nextSnaps = [snapToStart];
    let done;
    if (!snapToStart) {
      done = true;
    }
    const iterator = {
      next: async () => {
        if (done) {
          return {
            value: undefined,
            done
          };
        }
        const currSnapId = nextSnaps.shift();
        const snap = await this.loadSnap(currSnapId);
        if (snap.parents && snap.parents.length) {
          if (options.firstParentOnly) {
            nextSnaps.push(snap.parents[0]);
          } else {
            nextSnaps = nextSnaps.concat(snap.parents);
          }
        }
        if (!nextSnaps.length) {
          done = true;
        } else if (options.stopFn) {
          done = await options.stopFn(snap);
        }
        return {
          value: snap,
          done: undefined
        };
      }
    };
    return {
      [Symbol.asyncIterator]: () => iterator
    };
  }

  /**
   * traverse recursively from the provided snap (or head) upwards until it finds a tag
   * @param snapToStartFrom
   */
  async getClosestTag(snapToStartFrom) {
    const tagsHashMap = this.tags.getHashMap();
    const stopFn = async snap => {
      if (tagsHashMap.has(snap.hash)) {
        return true;
      }
      return false;
    };
    const iterable = this.snapsIterable(snapToStartFrom, {
      firstParentOnly: true,
      stopFn
    });
    const snaps = [];
    var _iteratorAbruptCompletion = false;
    var _didIteratorError = false;
    var _iteratorError;
    try {
      for (var _iterator = _asyncIterator(iterable), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {
        const snap = _step.value;
        snaps.push(snap);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (_iteratorAbruptCompletion && _iterator.return != null) {
          await _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    if (snaps.length) {
      const hashOfLastSnap = snaps[snaps.length - 1].hash;
      return tagsHashMap.get(hashOfLastSnap);
    }
    return undefined;
  }

  /**
   * checkout the component to a different version in its working tree.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  checkout(version) {}

  /**
   * examine difference between two components.
   */
  // diff(other: Component): Difference {}

  /**
   * merge two different components
   */
  // merge(other: Component): Component {}

  /**
   * write a component to a given file system.
   * @param path root path to write the component
   * @param fs instance of any fs to use.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  write(path, fs) {}

  /**
   *
   * Check if 2 components are equal
   * @param {Component} component
   * @returns {boolean}
   * @memberof Component
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  equals(component) {
    return component.id.toString() === this.id.toString();
  }
}
exports.Component = Component;

//# sourceMappingURL=component.js.map