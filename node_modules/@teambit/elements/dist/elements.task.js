"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
require("core-js/modules/es.promise.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ElementTask = void 0;
function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  _defineProperty2 = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = require("path");
  _path = function () {
    return data;
  };
  return data;
}
function _compiler() {
  const data = require("@teambit/compiler");
  _compiler = function () {
    return data;
  };
  return data;
}
function _computeTargets() {
  const data = require("./compute-targets");
  _computeTargets = function () {
    return data;
  };
  return data;
}
function _computeResults() {
  const data = require("./compute-results");
  _computeResults = function () {
    return data;
  };
  return data;
}
function _() {
  const data = require(".");
  _ = function () {
    return data;
  };
  return data;
}
class ElementTask {
  constructor(
  /**
   * elements extension.
   */
  elements, storageResolver) {
    this.elements = elements;
    this.storageResolver = storageResolver;
    (0, _defineProperty2().default)(this, "aspectId", _().ElementsAspect.id);
    (0, _defineProperty2().default)(this, "name", 'GenerateElementBundle');
    (0, _defineProperty2().default)(this, "location", 'end');
    (0, _defineProperty2().default)(this, "dependencies", [_compiler().CompilerAspect.id]);
  }
  async execute(context) {
    const url = `/elements/${context.envRuntime.id}`;
    const outDirName = this.elements.getElementsDirName();
    const elementsWrapperFn = context.env.getElementsWrapper.bind(context.env);
    const targets = await (0, _computeTargets().computeTargets)(context, elementsWrapperFn, outDirName);
    const bundlerContext = Object.assign(context, {
      targets,
      entry: [],
      publicPath: this.getElementsDir(context),
      rootPath: url
    });
    const bundler = await context.env.getElementsBundler(bundlerContext, []);
    const bundlerResults = await bundler.run();
    return (0, _computeResults().computeResults)(bundlerContext, bundlerResults, outDirName, this.storageResolver);
  }
  getElementsDir(context) {
    const outputPath = (0, _path().resolve)(`${context.id}/public`);
    return outputPath;
  }
}
exports.ElementTask = ElementTask;

//# sourceMappingURL=elements.task.js.map